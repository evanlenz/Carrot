xquery version "1.0" encoding "UTF-8";

(: This file was generated on Mon Jan  9, 2012 21:53 by REx v5.10 which is Copyright (c) 1979-2011 by Gunther Rademacher <grd@gmx.net> :)
(: REx command line: Carrot.ebnf -xquery -tree :)

(:~
 : The parser that was generated for the Carrot grammar.
 :)
module namespace p="Carrot";

(: EDL: Manually added to make this work in MarkLogic Server :)
declare default function namespace "http://www.w3.org/2005/xpath-functions";

(:~
 : The codepoint to charclass mapping for 7 bit codepoints.
 :)
declare variable $p:MAP0 as xs:integer+ :=
(
  64, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7,
  8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,
  29, 26, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 31, 30, 30, 30, 30, 30, 30, 32, 6, 33, 34, 30, 35, 36, 37,
  38, 39, 40, 41, 42, 43, 44, 30, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 30, 60, 61, 62, 6, 6
);

(:~
 : The codepoint to charclass mapping for codepoints below the surrogate block.
 :)
declare variable $p:MAP1 as xs:integer+ :=
(
  216, 291, 323, 383, 415, 908, 351, 815, 815, 447, 479, 511, 543, 575, 621, 882, 589, 681, 815, 815, 815, 815, 815,
  815, 815, 815, 815, 815, 815, 815, 713, 745, 821, 649, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815,
  815, 815, 777, 809, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815,
  815, 815, 815, 815, 815, 815, 815, 815, 815, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 259, 815,
  815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 853, 940, 949, 941, 941, 957, 965, 973, 979, 987, 1259, 1010, 1027, 1045,
  1053, 1061, 1069, 1267, 1267, 1267, 1267, 1267, 1267, 1425, 1267, 1259, 1259, 1260, 1259, 1259, 1259, 1260, 1259,
  1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259,
  1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1261, 1267, 1267, 1267, 1267, 1267, 1267,
  1267, 1267, 1267, 1267, 1267, 1259, 1259, 1259, 1259, 1259, 1259, 1347, 1260, 1258, 1257, 1259, 1259, 1259, 1259,
  1259, 1260, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1263, 1083, 1259, 1259, 1259, 1259, 1188, 1086, 1259,
  1259, 1259, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259,
  1259, 1266, 1267, 1085, 1265, 1267, 1393, 1267, 1267, 1267, 1267, 1267, 1258, 1259, 1259, 1264, 1125, 1313, 1392,
  1267, 1387, 1393, 1125, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1349, 1259, 1260, 1136, 1387, 1302, 1201,
  1387, 1393, 1387, 1387, 1387, 1387, 1387, 1387, 1387, 1387, 1389, 1267, 1267, 1267, 1393, 1267, 1267, 1267, 1372,
  1236, 1259, 1259, 1256, 1259, 1259, 1259, 1259, 1260, 1260, 1412, 1257, 1259, 1263, 1267, 1258, 1094, 1259, 1259,
  1259, 1259, 1259, 1259, 1259, 1259, 1258, 1094, 1259, 1259, 1259, 1259, 1103, 1267, 1259, 1259, 1259, 1259, 1259,
  1259, 1116, 1034, 1259, 1259, 1259, 1117, 1261, 1265, 1438, 1259, 1259, 1259, 1259, 1259, 1259, 1154, 1387, 1389,
  1202, 1259, 1172, 1387, 1267, 1267, 1438, 1116, 1348, 1259, 1259, 1257, 1186, 1197, 1163, 1175, 1425, 1212, 1172,
  1387, 1265, 1267, 1223, 1246, 1348, 1259, 1259, 1257, 1402, 1197, 1178, 1175, 1267, 1234, 1426, 1387, 1244, 1267,
  1438, 1235, 1256, 1259, 1259, 1257, 1254, 1154, 1277, 1108, 1267, 1267, 994, 1387, 1267, 1267, 1438, 1116, 1348, 1259,
  1259, 1257, 1345, 1154, 1203, 1175, 1426, 1212, 1037, 1387, 1267, 1267, 1002, 1015, 1290, 1286, 1189, 1015, 1127,
  1037, 1204, 1201, 1425, 1267, 1425, 1387, 1267, 1267, 1438, 1094, 1257, 1259, 1259, 1257, 1095, 1037, 1278, 1201,
  1427, 1267, 1037, 1387, 1267, 1267, 1002, 1094, 1257, 1259, 1259, 1257, 1095, 1037, 1278, 1201, 1427, 1269, 1037,
  1387, 1267, 1267, 1002, 1094, 1257, 1259, 1259, 1257, 1259, 1037, 1164, 1201, 1425, 1267, 1037, 1387, 1267, 1267,
  1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1259,
  1259, 1259, 1259, 1261, 1267, 1259, 1259, 1259, 1259, 1260, 1267, 1258, 1259, 1259, 1259, 1259, 1260, 1298, 1392,
  1310, 1388, 1387, 1393, 1267, 1267, 1267, 1267, 1215, 1322, 1084, 1258, 1332, 1342, 1298, 1146, 1357, 1389, 1387,
  1393, 1267, 1267, 1267, 1267, 1269, 1019, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1264, 1267,
  1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1254, 1401, 1264, 1267, 1267,
  1267, 1267, 1410, 1266, 1410, 1188, 1081, 1334, 1187, 1214, 1267, 1267, 1267, 1267, 1269, 1267, 1324, 1268, 1288,
  1264, 1267, 1267, 1267, 1267, 1421, 1266, 1423, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259,
  1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1263, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259,
  1259, 1265, 1259, 1259, 1261, 1261, 1259, 1259, 1259, 1259, 1261, 1261, 1259, 1413, 1259, 1259, 1259, 1261, 1259,
  1259, 1259, 1259, 1259, 1259, 1094, 1128, 1226, 1262, 1117, 1263, 1259, 1262, 1226, 1262, 1075, 1267, 1267, 1267,
  1258, 1314, 1162, 1267, 1258, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1262, 999, 1258, 1259, 1259, 1259,
  1259, 1259, 1259, 1259, 1259, 1259, 1259, 1435, 1083, 1259, 1259, 1259, 1259, 1262, 1267, 1267, 1267, 1267, 1267,
  1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267,
  1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1387, 1390, 1370, 1267, 1267, 1267, 1259, 1259, 1259, 1259, 1259,
  1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1263, 1267, 1267, 1267,
  1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1393, 1387, 1393, 1380, 1362, 1259, 1258, 1259, 1259, 1259, 1265,
  1386, 1387, 1278, 1391, 1277, 1386, 1387, 1389, 1386, 1370, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1258,
  1259, 1259, 1259, 1260, 1423, 1258, 1259, 1259, 1259, 1260, 1267, 1386, 1387, 1160, 1387, 1387, 1142, 1367, 1267,
  1259, 1259, 1259, 1264, 1264, 1267, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
  11, 12, 13, 14, 15, 16, 17, 17, 17, 17, 17, 17, 17, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 26, 30, 6, 6,
  6, 6, 6, 63, 63, 6, 6, 63, 63, 6, 30, 30, 30, 30, 30, 30, 30, 31, 30, 30, 30, 6, 6, 6, 30, 30, 6, 6, 30, 6, 30, 30,
  30, 32, 6, 33, 34, 30, 6, 6, 30, 30, 6, 6, 6, 6, 63, 63, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 30, 45, 46, 47, 48,
  49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 30, 60, 61, 62, 6, 6, 6, 6, 6, 63, 6, 30, 6, 6, 6, 6, 6, 30, 30, 30, 30,
  30, 30, 30, 30, 30, 30, 30, 6, 30, 30, 30, 30, 30, 6, 63, 63, 63, 63, 6, 63, 63, 63, 6, 6, 30, 30, 30, 30, 30, 6, 6,
  30, 30, 63, 30, 30, 30, 30, 30, 30, 30, 6, 30, 6, 30, 30, 30, 30, 6, 30, 63, 63, 6, 63, 63, 63, 6, 63, 63, 30, 6, 6,
  30, 30, 6, 6, 63, 30, 63, 63, 6, 63, 63, 63, 63, 63, 6, 6, 63, 63, 30, 30, 63, 63, 6, 6, 63, 63, 63, 6, 6, 6, 6, 63,
  30, 6, 30, 6, 6, 6, 30, 30, 6, 6, 6, 30, 30, 6, 6, 63, 6, 63, 63, 63, 63, 6, 6, 6, 63, 63, 6, 6, 6, 6, 30, 30, 6, 30,
  6, 6, 30, 6, 6, 63, 6, 6, 30, 30, 30, 6, 30, 30, 6, 30, 30, 30, 30, 6, 30, 6, 30, 30, 63, 63, 30, 30, 30, 6, 6, 6, 6,
  30, 30, 6, 30, 30, 6, 30, 30, 30, 30, 30, 30, 30, 30, 6, 6, 6, 6, 6, 6, 6, 6, 30, 6, 63, 63, 63, 63, 63, 63, 6, 63,
  63, 6, 30, 30, 6, 30, 6, 30, 30, 30, 30, 6, 6, 30, 63, 30, 30, 63, 63, 63, 63, 63, 30, 30, 63, 30, 30, 30, 30, 30, 30,
  63, 63, 63, 63, 63, 63, 30, 6, 30, 6, 6, 30, 6, 6, 30, 30, 6, 30, 30, 30, 6, 30, 6, 30, 6, 30, 6, 6, 30, 30, 6, 30,
  30, 6, 6, 30, 30, 30, 30, 30, 6, 30, 30, 30, 30, 30, 6, 63, 6, 6, 6, 6, 63, 63, 6, 63, 6, 6, 6, 6, 6, 6, 30, 63, 6, 6,
  6, 6, 6, 63, 6, 63, 63, 63, 63, 63, 63, 63, 63, 6, 6, 6, 6, 6, 6, 6, 30, 6, 30, 30, 6, 30, 30, 6, 6, 6, 6, 6, 30, 6,
  30, 6, 30, 6, 30, 6, 6, 6, 30, 6, 6, 6, 6, 6, 6, 6, 63, 63, 6, 30, 30, 30, 6, 63, 63, 63, 6, 30, 30, 30
);

(:~
 : The codepoint to charclass mapping for codepoints above the surrogate block.
 :)
declare variable $p:MAP2 as xs:integer+ :=
(
  57344, 65536, 65533, 1114111, 6, 6
);

(:~
 : The token-set-id to DFA-initial-state mapping.
 :)
declare variable $p:INITIAL as xs:integer+ :=
(
  6145, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 2069, 4117, 22, 23, 24, 25, 26, 27, 28, 29,
  30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58,
  59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87,
  88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113,
  114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136,
  137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151
);

(:~
 : The DFA transition table.
 :)
declare variable $p:TRANSITION as xs:integer+ :=
(
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 12961, 8320, 8378, 8375, 8375, 8356, 8372, 8400, 8394,
  8329, 8416, 13340, 22764, 10702, 13724, 10760, 22966, 8815, 22967, 9433, 14240, 8441, 14655, 8992, 8492, 8508, 8598,
  8577, 9174, 8592, 8614, 9456, 21097, 14722, 8630, 8646, 8662, 21106, 12809, 22967, 8824, 8702, 8749, 8713, 14586,
  10760, 8773, 8864, 9501, 9556, 9487, 8833, 8801, 9210, 8849, 8880, 8896, 9574, 8912, 9566, 9299, 8980, 9008, 9035,
  9088, 12383, 9109, 21085, 9545, 9159, 9201, 9226, 9268, 9284, 9348, 9364, 9392, 12783, 9421, 9449, 8757, 8754, 9472,
  9530, 9093, 9590, 9604, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 8336, 10760, 12288, 10760, 10760, 15143,
  17133, 17145, 10760, 12954, 9641, 13340, 22764, 13713, 13724, 10760, 22966, 8815, 22967, 8942, 14240, 8441, 14655,
  8992, 8492, 8508, 8598, 8577, 9174, 8592, 8614, 9456, 21097, 14722, 8630, 8646, 8662, 21106, 12809, 22967, 8824, 8702,
  8749, 8713, 14586, 10760, 8773, 8864, 9501, 9556, 9487, 8833, 8801, 9210, 8849, 8880, 8896, 9574, 8912, 9566, 9299,
  8980, 9008, 9035, 9088, 12383, 9109, 21085, 9545, 9159, 9201, 9226, 9268, 9284, 9348, 9364, 9392, 12783, 9421, 9449,
  8757, 8754, 9472, 9530, 9093, 9590, 9604, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 9706, 9660, 18434, 10760,
  10760, 9683, 19881, 10760, 13844, 9699, 9722, 13340, 9828, 10702, 13724, 10760, 22966, 8815, 22967, 9433, 9741, 8441,
  14655, 8992, 8492, 8508, 8598, 8577, 9174, 8592, 8614, 9456, 21097, 14722, 8630, 8646, 8662, 21106, 12809, 22967,
  8824, 8702, 8749, 8713, 14586, 10760, 8773, 8864, 9501, 9556, 9487, 8833, 8801, 9210, 8849, 8880, 8896, 9574, 8912,
  9566, 9299, 8980, 9008, 9035, 9088, 12383, 9109, 21085, 9545, 9159, 9201, 9226, 9268, 9284, 9348, 9364, 9392, 12783,
  9421, 9449, 8757, 8754, 9472, 9530, 9093, 9590, 9604, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 9769, 10760,
  12288, 10760, 10760, 15143, 10760, 10760, 9804, 19482, 9641, 9855, 9816, 10702, 13724, 10760, 22966, 8815, 22967,
  9433, 9891, 9919, 14655, 8992, 8492, 8508, 8598, 8577, 9174, 8592, 8614, 9456, 21097, 14722, 8630, 8646, 8662, 21106,
  12809, 22967, 8824, 8702, 8749, 8713, 14586, 10760, 8773, 8864, 9501, 9556, 9487, 8833, 8801, 9210, 8849, 8880, 8896,
  9574, 8912, 9566, 9299, 8980, 9008, 9035, 9088, 12383, 9109, 21085, 9545, 9159, 9201, 9226, 9268, 9284, 9348, 9364,
  9392, 12783, 9421, 9449, 8757, 8754, 9472, 9530, 9093, 9590, 9604, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  9935, 8723, 12288, 9960, 8723, 12239, 10760, 12228, 9944, 9981, 9641, 13340, 22764, 10702, 13724, 10760, 22966, 8815,
  22967, 9433, 14240, 8441, 14655, 8992, 8492, 8508, 8598, 8577, 9174, 8592, 8614, 9456, 21097, 14722, 8630, 8646, 8662,
  21106, 12809, 22967, 8824, 8702, 8749, 8713, 14586, 10760, 8773, 8864, 9501, 9556, 9487, 8833, 8801, 9210, 8849, 8880,
  8896, 9574, 8912, 9566, 9299, 8980, 9008, 9035, 9088, 12383, 9109, 21085, 9545, 9159, 9201, 9226, 9268, 9284, 9348,
  9364, 9392, 12783, 9421, 9449, 8757, 8754, 9472, 9530, 9093, 9590, 9604, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 8336, 10760, 12288, 10760, 10760, 15143, 10760, 10760, 10760, 18924, 9641, 13340, 22764, 10702, 13724, 10760,
  22966, 8815, 22967, 9433, 14240, 8441, 14655, 8992, 8492, 8508, 8598, 8577, 9174, 8592, 8614, 9456, 21097, 14722,
  8630, 8646, 8662, 21106, 12809, 22967, 8824, 8702, 8749, 8713, 14586, 10760, 8773, 8864, 9501, 9556, 9487, 8833, 8801,
  9210, 8849, 8880, 8896, 9574, 8912, 9566, 9299, 8980, 9008, 9035, 9088, 12383, 9109, 21085, 9545, 9159, 9201, 9226,
  9268, 9284, 9348, 9364, 9392, 12783, 9421, 9449, 8757, 8754, 9472, 9530, 9093, 9590, 9604, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 8336, 10760, 12288, 10760, 10760, 19666, 10760, 10760, 10760, 18924, 10004, 13340, 10385, 10702,
  13724, 10760, 22966, 8815, 22967, 9433, 14240, 8441, 14655, 8992, 8492, 8508, 8598, 8577, 9174, 8592, 8614, 9456,
  21097, 14722, 8630, 8646, 8662, 21106, 12809, 22967, 8824, 8702, 8749, 8713, 14586, 10760, 8773, 8864, 9501, 9556,
  9487, 8833, 8801, 9210, 8849, 8880, 8896, 9574, 8912, 9566, 9299, 8980, 9008, 9035, 9088, 12383, 9109, 21085, 9545,
  9159, 9201, 9226, 9268, 9284, 9348, 9364, 9392, 12783, 9421, 9449, 8757, 8754, 9472, 9530, 9093, 9590, 9604, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 9988, 10023, 17762, 10760, 10760, 10046, 19774, 10760, 12887, 10062, 10098,
  13340, 22827, 10702, 13724, 10760, 22966, 8815, 22967, 9433, 9124, 8441, 14655, 8992, 8492, 8508, 8598, 8577, 9174,
  8592, 8614, 9456, 21097, 14722, 8630, 8646, 8662, 21106, 12809, 22967, 8824, 8702, 8749, 8713, 14586, 10760, 8773,
  8864, 9501, 9556, 9487, 8833, 8801, 9210, 8849, 8880, 8896, 9574, 8912, 9566, 9299, 8980, 9008, 9035, 9088, 12383,
  9109, 21085, 9545, 9159, 9201, 9226, 9268, 9284, 9348, 9364, 9392, 12783, 9421, 9449, 8757, 8754, 9472, 9530, 9093,
  9590, 9604, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10117, 16587, 10162, 16598, 10159, 10140, 10156, 10178,
  10215, 10230, 9641, 10257, 22764, 10702, 13724, 10760, 22966, 8815, 22967, 9433, 19422, 8441, 14655, 8992, 8492, 8508,
  8598, 8577, 9174, 8592, 8614, 9456, 21097, 14722, 8630, 8646, 8662, 21106, 12809, 22967, 8824, 8702, 8749, 8713,
  14586, 10760, 8773, 8864, 9501, 9556, 9487, 8833, 8801, 9210, 8849, 8880, 8896, 9574, 8912, 9566, 9299, 8980, 9008,
  9035, 9088, 12383, 9109, 21085, 9545, 9159, 9201, 9226, 9268, 9284, 9348, 9364, 9392, 12783, 9421, 9449, 8757, 8754,
  9472, 9530, 9093, 9590, 9604, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 8336, 18399, 12288, 10292, 21040,
  10330, 10357, 10346, 8733, 10373, 9641, 10409, 22764, 10702, 13724, 10760, 22966, 8815, 22967, 9433, 14050, 8441,
  14655, 8992, 8492, 8508, 8598, 8577, 9174, 8592, 8614, 9456, 21097, 14722, 8630, 8646, 8662, 21106, 12809, 22967,
  8824, 8702, 8749, 8713, 14586, 10760, 8773, 8864, 9501, 9556, 9487, 8833, 8801, 9210, 8849, 8880, 8896, 9574, 8912,
  9566, 9299, 8980, 9008, 9035, 9088, 12383, 9109, 21085, 9545, 9159, 9201, 9226, 9268, 9284, 9348, 9364, 9392, 12783,
  9421, 9449, 8757, 8754, 9472, 9530, 9093, 9590, 9604, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 8336, 10760,
  12288, 10760, 10760, 15143, 10314, 10458, 10498, 10511, 9641, 13340, 22764, 10702, 13724, 10760, 22966, 8815, 22967,
  9433, 14240, 8441, 14655, 8992, 8492, 8508, 8598, 8577, 9174, 8927, 8614, 9456, 21097, 14722, 8630, 8646, 8662, 21106,
  12809, 22967, 8824, 8702, 8749, 8713, 14586, 10760, 8773, 8864, 9501, 9556, 9487, 8833, 8801, 9210, 8849, 8880, 8896,
  9574, 8912, 9566, 9299, 8980, 9008, 9035, 9088, 12383, 9109, 21085, 9545, 9159, 9201, 9226, 9268, 9284, 9348, 9364,
  9392, 12783, 9421, 9449, 8757, 8754, 9472, 9530, 9093, 9590, 9604, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  8336, 10760, 12288, 10760, 10760, 15143, 12450, 10538, 12401, 12459, 9641, 13340, 22764, 10702, 13724, 10760, 22966,
  8815, 22967, 9433, 14240, 10574, 14655, 8992, 8492, 8508, 8598, 8577, 9174, 8592, 8614, 9456, 21097, 14722, 8630,
  8646, 8662, 21106, 12809, 22967, 8824, 8702, 8749, 8713, 14586, 10760, 8773, 8864, 9501, 9556, 9487, 8833, 8801, 9210,
  8849, 8880, 8896, 9574, 8912, 9566, 9299, 8980, 9008, 9035, 9088, 12383, 9109, 21085, 9545, 9159, 9201, 9226, 9268,
  9284, 9348, 9364, 9392, 12783, 9421, 9449, 8757, 8754, 9472, 9530, 9093, 9590, 9604, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 8336, 20080, 12288, 11207, 19541, 10605, 10632, 10621, 10760, 10648, 9641, 13340, 22764, 10702,
  13724, 10760, 22966, 8815, 22967, 9433, 14240, 8441, 14655, 8992, 8492, 8508, 8598, 8577, 9174, 8592, 8614, 9456,
  21097, 14722, 8630, 8646, 8662, 21106, 12809, 22967, 8824, 8702, 8749, 8713, 14586, 10760, 8773, 8864, 9501, 9556,
  9487, 8833, 8801, 9210, 8849, 8880, 8896, 9574, 8912, 9566, 9299, 8980, 9008, 9035, 9088, 12383, 9109, 21085, 9545,
  9159, 9201, 9226, 9268, 9284, 9348, 9364, 9392, 12783, 9421, 9449, 8757, 8754, 9472, 9530, 9093, 9590, 9604, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10694, 10760, 12288, 10760, 10760, 15143, 16228, 10718, 22361, 16237, 10757,
  14252, 13836, 11138, 13669, 10760, 20636, 16983, 13453, 13939, 10101, 19685, 19888, 10809, 13670, 9725, 20637, 20637,
  10904, 13433, 13453, 13453, 10777, 10760, 10760, 10804, 13669, 15206, 20637, 20637, 21318, 13453, 13453, 18711, 10760,
  10760, 10807, 14279, 20637, 20637, 18302, 13453, 13453, 10829, 10761, 10810, 15207, 20637, 18506, 17793, 13998, 10551,
  14187, 20637, 18062, 13453, 10826, 8561, 20637, 18782, 13997, 20682, 10845, 10864, 14361, 10925, 18303, 10941, 16129,
  10957, 15009, 18514, 22241, 22686, 22158, 17416, 13252, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 8336, 10760,
  12288, 10760, 12879, 10973, 10760, 10760, 18720, 10989, 10757, 9136, 20760, 11138, 13669, 10760, 20636, 16983, 13453,
  18567, 10101, 10760, 10761, 10809, 13670, 9725, 20637, 20637, 10904, 13433, 13453, 13453, 12506, 10760, 10760, 15879,
  13669, 15206, 20637, 20637, 21318, 13453, 13453, 18711, 10760, 10760, 10807, 14279, 20637, 20637, 18302, 13453, 13453,
  10829, 10761, 10810, 15207, 20637, 18302, 13453, 13998, 11137, 14187, 20637, 18302, 13453, 15968, 8561, 20637, 18782,
  13997, 20682, 20635, 18782, 14361, 11016, 18303, 17881, 18303, 18774, 15009, 15006, 18784, 22686, 22158, 17416, 13252,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 8336, 9784, 12288, 10760, 10760, 22471, 10760, 11039, 9788, 11068,
  9641, 13340, 10304, 13050, 13724, 10760, 22966, 8815, 22967, 9433, 14240, 8441, 14655, 8992, 8492, 8508, 8598, 8577,
  9174, 8592, 8614, 9456, 21097, 14722, 8630, 8646, 8662, 21106, 12809, 22967, 8824, 8702, 8749, 8713, 14586, 10760,
  8773, 8864, 9501, 9556, 9487, 8833, 8801, 9210, 8849, 8880, 8896, 9574, 8912, 9566, 9299, 8980, 9008, 9035, 9088,
  12383, 9109, 21085, 9545, 9159, 9201, 9226, 9268, 9284, 9348, 9364, 9392, 12783, 9421, 9449, 8757, 8754, 9472, 9530,
  9093, 9590, 9604, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 8336, 10760, 12288, 10760, 13381, 11095, 10760,
  10760, 13389, 11111, 10757, 19275, 19116, 11138, 13669, 10760, 20636, 16983, 13453, 15037, 10101, 9143, 11134, 10809,
  13670, 9725, 20637, 20637, 10904, 13433, 13453, 13453, 18658, 10760, 11154, 15879, 13669, 15206, 20637, 20637, 21318,
  13453, 13453, 15565, 11179, 9312, 10807, 14279, 20637, 20637, 18302, 13453, 13453, 22351, 13263, 10810, 15207, 20637,
  18302, 13453, 13998, 11137, 14187, 20637, 18302, 13453, 15968, 8561, 20637, 18782, 13997, 20682, 20635, 18782, 14361,
  11016, 18303, 17881, 18303, 18774, 15009, 15006, 18784, 22686, 22158, 17416, 13252, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 8336, 8340, 21885, 10007, 12744, 10589, 10760, 11197, 10760, 15121, 11223, 13886, 22764, 10702, 13724,
  10760, 11532, 11390, 11361, 11827, 13873, 8441, 14655, 8992, 8492, 11247, 11586, 11297, 11261, 11312, 11506, 11281,
  22403, 14722, 8630, 8646, 8662, 13535, 11936, 11533, 11272, 11873, 11359, 11884, 14586, 10760, 8773, 12107, 11377,
  11578, 11858, 11786, 11406, 11678, 8849, 8880, 11475, 11564, 11491, 11799, 11434, 8980, 11522, 11549, 11602, 11420,
  11623, 22391, 11925, 11654, 11669, 9226, 11694, 11710, 11741, 11757, 11773, 11725, 11815, 11327, 11343, 11340, 11843,
  11910, 11607, 11952, 11968, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 8336, 17834, 12288, 21849, 21848, 11052,
  12006, 11995, 21847, 12022, 9641, 13340, 22764, 10702, 13724, 10760, 22966, 8815, 22967, 9433, 14240, 8441, 14655,
  8992, 8492, 8508, 8598, 8577, 9174, 8592, 8614, 9456, 21097, 14722, 12049, 8646, 8662, 21106, 12809, 22967, 8824,
  8702, 8749, 9019, 12065, 19088, 8773, 8864, 9501, 9556, 9487, 8833, 8801, 9185, 12092, 8880, 8896, 9574, 8912, 9566,
  9299, 8980, 9008, 9035, 9088, 12383, 9109, 21085, 9545, 9159, 9201, 9226, 9268, 9284, 9348, 9364, 9392, 12783, 9421,
  9449, 8757, 8754, 9472, 9530, 9093, 9590, 9604, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 8336, 10760, 12288,
  10760, 10760, 21124, 11447, 11459, 11163, 12123, 9641, 13340, 22764, 10702, 15457, 10760, 22966, 8815, 22967, 9405,
  14240, 8441, 14655, 8992, 8492, 8508, 8598, 8577, 9174, 8592, 8614, 9456, 21097, 14722, 8630, 8646, 8662, 21106,
  12809, 22967, 8824, 8702, 8749, 8713, 14586, 10760, 8773, 8864, 9501, 9556, 9487, 8833, 8801, 9210, 8849, 8880, 8896,
  9574, 8912, 9566, 9299, 8980, 9008, 9035, 9088, 12383, 9109, 21085, 9545, 9159, 9201, 9226, 9268, 9284, 9348, 9364,
  9392, 12783, 9421, 9449, 8757, 8754, 9472, 9530, 9093, 9590, 9604, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  12150, 10760, 12621, 10760, 12613, 15143, 12160, 12176, 10760, 12217, 12255, 13340, 22764, 10702, 8785, 10760, 22966,
  8815, 22967, 8522, 14240, 8441, 14655, 8992, 8492, 8508, 8598, 8577, 9174, 8592, 8614, 9456, 21097, 14722, 8630, 8646,
  8662, 21106, 12809, 22967, 8824, 8702, 8749, 8713, 14586, 10760, 8773, 8864, 9501, 9556, 9487, 8833, 8801, 9210, 8849,
  8880, 8896, 9574, 8912, 9566, 9299, 8980, 9008, 9035, 9088, 12383, 9109, 21085, 9545, 9159, 9201, 9226, 9268, 9284,
  9348, 9364, 9392, 12783, 9421, 9449, 8757, 8754, 9472, 9530, 9093, 9590, 9604, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 18931, 12280, 12288, 10760, 10760, 15143, 12189, 12201, 12284, 12304, 12352, 13340, 22764, 10702, 13061,
  10760, 22966, 8815, 22967, 9514, 14240, 8441, 14655, 8992, 8492, 8508, 8598, 8577, 9174, 8592, 8614, 9456, 21097,
  14722, 8630, 8646, 8662, 21106, 12809, 22967, 8824, 8702, 8749, 8713, 14586, 10760, 8773, 8864, 9501, 9556, 9487,
  8833, 8801, 9210, 8849, 8880, 8896, 9574, 8912, 9566, 9299, 8980, 9008, 9035, 9088, 12383, 9109, 21085, 9545, 9159,
  9201, 9226, 9268, 9284, 9348, 9364, 9392, 12783, 9421, 12373, 8757, 8754, 9472, 9530, 9093, 9590, 9604, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 19022, 12399, 12288, 10199, 10760, 15143, 9644, 12417, 10760, 19015, 9641, 13340,
  22764, 15446, 13724, 10760, 22966, 8815, 22967, 9050, 14240, 8441, 14655, 8992, 8492, 8508, 8598, 8577, 9174, 8592,
  8614, 9456, 21097, 14722, 8630, 8646, 8662, 21106, 12809, 22967, 8824, 8702, 8749, 8713, 14586, 10760, 8773, 8864,
  9501, 9556, 9487, 8833, 8801, 9210, 8849, 8880, 8896, 9574, 8912, 9566, 9299, 8980, 9008, 9035, 9088, 12383, 9109,
  21085, 9545, 9159, 9201, 9226, 9268, 9284, 9348, 9364, 9392, 12783, 9421, 9449, 8757, 8754, 9472, 9530, 9093, 9590,
  9604, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 8336, 10760, 12288, 10760, 10760, 15143, 10760, 10760, 22529,
  12439, 9641, 13340, 22764, 10702, 13724, 10760, 22966, 8815, 22967, 9433, 14240, 8441, 14655, 8992, 8492, 8508, 8598,
  8577, 9174, 8592, 8614, 9456, 21097, 14722, 8630, 8646, 8662, 21106, 12809, 22967, 8824, 8702, 8749, 8713, 14586,
  10760, 8773, 8864, 9501, 9556, 9487, 8833, 8801, 9210, 8849, 8880, 8896, 9574, 8912, 9566, 9299, 8980, 9008, 9035,
  9088, 12383, 9109, 21085, 9545, 9159, 9201, 9226, 9268, 9284, 9348, 9364, 9392, 12783, 9421, 9449, 8757, 8754, 9472,
  9530, 9093, 9590, 9604, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10996, 10760, 13207, 10759, 11000, 15143,
  18392, 16353, 18473, 16217, 10757, 14252, 13836, 11138, 13669, 10760, 20636, 16983, 13453, 13939, 10788, 10760, 10761,
  10809, 13670, 9725, 20637, 20637, 10904, 12475, 13453, 13453, 12506, 10760, 10073, 15879, 13669, 15206, 20637, 20637,
  21318, 13453, 13453, 15500, 22359, 22281, 10807, 14279, 20637, 20637, 18302, 13453, 13453, 22351, 11079, 10810, 15207,
  20637, 18302, 13453, 13998, 11137, 14187, 20637, 18302, 13453, 15968, 12494, 20637, 18782, 13997, 20682, 20635, 18782,
  14361, 11016, 18303, 17881, 18303, 18774, 15009, 15006, 18784, 22686, 22158, 17416, 13252, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10996, 10760, 13207, 10759, 11000, 15143, 18392, 16353, 18473, 16217, 10757, 14252, 13836, 11138,
  13669, 10760, 20636, 16983, 13453, 13939, 10788, 10760, 10761, 10809, 13670, 9725, 20637, 20637, 10904, 12475, 13453,
  13453, 12506, 10760, 10073, 15879, 13669, 15206, 20637, 20637, 21318, 13453, 13453, 15500, 22359, 22281, 10807, 14279,
  20637, 20637, 18302, 13453, 13453, 22351, 13263, 10810, 15207, 20637, 18302, 13453, 13998, 11137, 14187, 20637, 18302,
  13453, 15968, 8561, 20637, 18782, 13997, 20682, 20635, 18782, 14361, 11016, 18303, 17881, 18303, 18774, 15009, 15006,
  18784, 22686, 22158, 17416, 13252, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10996, 10760, 13207, 10759, 11000,
  15143, 18392, 16353, 18473, 16217, 10757, 14252, 13836, 11138, 13669, 10760, 20636, 16983, 13453, 13939, 10788, 10760,
  10761, 10809, 13670, 9725, 20637, 20637, 10904, 12475, 13453, 13453, 12506, 10760, 10073, 12533, 13669, 15206, 20637,
  20637, 21318, 13453, 13453, 15500, 22359, 22281, 10807, 14279, 20637, 20637, 18302, 13453, 13453, 22351, 13263, 10810,
  15207, 20637, 18302, 13453, 13998, 11137, 14187, 20637, 18302, 13453, 15968, 8561, 20637, 18782, 13997, 20682, 20635,
  18782, 14361, 11016, 18303, 17881, 18303, 18774, 15009, 15006, 18784, 22686, 22158, 17416, 13252, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10996, 10760, 13207, 10759, 11000, 15143, 18392, 16353, 18473, 16217, 10757, 14252, 13836,
  11138, 13669, 10760, 20636, 16983, 13453, 13939, 10788, 10760, 10761, 10809, 13670, 9725, 20637, 20637, 10904, 12475,
  13453, 13453, 12506, 10760, 10073, 15879, 13669, 15206, 20637, 20637, 21318, 13453, 13453, 15500, 22359, 22281, 12554,
  14279, 20637, 20637, 18302, 13453, 13453, 22351, 13263, 10810, 15207, 20637, 18302, 13453, 13998, 11137, 14187, 20637,
  18302, 13453, 15968, 8561, 20637, 18782, 13997, 20682, 20635, 18782, 14361, 11016, 18303, 17881, 18303, 18774, 15009,
  15006, 18784, 22686, 22158, 17416, 13252, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10996, 10760, 13207, 10759,
  11000, 15143, 18392, 16353, 18473, 16217, 10757, 14252, 20966, 11138, 13669, 10760, 20636, 16983, 13453, 13939, 10788,
  9965, 10761, 10809, 13670, 9725, 20637, 20637, 10904, 12475, 13453, 13453, 12506, 10760, 10073, 15879, 13669, 15206,
  20637, 20637, 21318, 13453, 13453, 15500, 22359, 22281, 10807, 14279, 20637, 20637, 18302, 13453, 13453, 22351, 13263,
  10810, 15207, 20637, 18302, 13453, 13998, 11137, 14187, 20637, 18302, 13453, 15968, 8561, 20637, 18782, 13997, 20682,
  20635, 18782, 14361, 11016, 18303, 17881, 18303, 18774, 15009, 15006, 18784, 22686, 22158, 17416, 13252, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10996, 10760, 13207, 10759, 11000, 15143, 18392, 16353, 18473, 16217, 10757, 14252,
  13836, 11138, 13669, 10760, 20636, 16983, 13453, 13939, 10788, 10760, 10761, 10809, 13670, 9725, 20637, 20637, 10904,
  12475, 13453, 13453, 12506, 10760, 10760, 15879, 13669, 15206, 20637, 20637, 21318, 13453, 13453, 18711, 10760, 10760,
  10807, 14279, 20637, 20637, 18302, 13453, 13453, 10829, 10761, 10810, 15207, 20637, 18302, 13453, 13998, 11137, 14187,
  20637, 18302, 13453, 15968, 8561, 20637, 18782, 13997, 20682, 20635, 18782, 14361, 11016, 18303, 17881, 18303, 18774,
  15009, 15006, 18784, 22686, 22158, 17416, 13252, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10996, 10760, 13207,
  10759, 11000, 15143, 18392, 16353, 18473, 16217, 10757, 14252, 13836, 11138, 13669, 10760, 20636, 16983, 13453, 13939,
  10788, 10760, 10761, 10809, 13670, 9725, 20637, 20637, 10904, 12475, 13453, 13453, 12506, 10760, 10760, 15879, 13669,
  15206, 20637, 20637, 21318, 13453, 13453, 18711, 10760, 10760, 10807, 14279, 20637, 20637, 18302, 13453, 13453, 10829,
  10761, 10810, 15207, 20637, 18302, 13453, 13998, 10124, 14187, 20637, 18302, 13453, 15968, 8561, 20637, 18782, 13997,
  20682, 20635, 18782, 14361, 11016, 18303, 17881, 18303, 18774, 15009, 15006, 18784, 22686, 22158, 17416, 13252, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 8336, 10760, 12288, 10760, 10760, 11979, 10760, 12573, 10760, 12602, 9641,
  13340, 22764, 10702, 13724, 10760, 22966, 8815, 22967, 9433, 14240, 8441, 10030, 8992, 8492, 8508, 8598, 8577, 9174,
  8592, 8614, 9456, 21097, 14722, 8630, 8646, 8662, 21106, 12809, 22967, 8824, 8702, 8749, 8713, 14586, 10760, 8773,
  8864, 9501, 9556, 9487, 8833, 8801, 9210, 8849, 8880, 8896, 9574, 8912, 9566, 9299, 8980, 9008, 9035, 9088, 12383,
  9109, 21085, 9545, 9159, 9201, 12637, 9268, 9284, 9348, 9364, 9392, 12783, 9421, 9449, 8757, 8754, 9472, 9530, 9093,
  9590, 9604, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 8336, 10760, 12676, 10760, 10760, 12586, 12717, 12706,
  10760, 12733, 9641, 13340, 22764, 10702, 13724, 10760, 22966, 8815, 22967, 9433, 14240, 8441, 14655, 8992, 8492, 8508,
  8598, 8577, 9174, 8592, 8614, 9456, 21097, 14722, 8630, 8646, 8662, 21106, 12809, 22967, 8824, 8702, 8749, 8713,
  14586, 10760, 8773, 8864, 9501, 9556, 9487, 8833, 8801, 9210, 8849, 8880, 8896, 9574, 8912, 9566, 9299, 8980, 9008,
  9035, 9088, 12383, 9109, 21085, 9545, 9159, 9201, 9226, 9268, 9284, 9348, 12771, 9392, 22945, 9421, 12799, 8757, 8754,
  9472, 9530, 9093, 9590, 9604, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 8336, 10760, 12288, 10760, 10760,
  15143, 10760, 8422, 8425, 12825, 9641, 13340, 22764, 10702, 13724, 10760, 22966, 8815, 22967, 9433, 14240, 8441,
  14655, 8992, 8492, 8508, 8598, 8577, 9174, 8592, 8614, 9456, 21097, 14722, 8630, 8646, 8662, 21106, 12809, 22967,
  8824, 8702, 8749, 8713, 14586, 10760, 8773, 8864, 9501, 9556, 9487, 8833, 8801, 9210, 8849, 8880, 8896, 9574, 8912,
  9566, 9299, 8980, 9008, 9035, 9088, 12383, 9109, 21085, 9545, 9159, 9201, 9226, 9268, 9284, 9348, 9364, 9392, 12783,
  9421, 9449, 8757, 8754, 9472, 9530, 9093, 9590, 9604, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 8336, 10760,
  12288, 10760, 10760, 12852, 10760, 10760, 19124, 12868, 9641, 13340, 13113, 10702, 13724, 10760, 22966, 8815, 22967,
  9433, 14240, 8441, 22771, 8992, 8492, 8508, 8598, 8577, 9174, 8592, 8614, 9456, 21097, 14722, 8630, 8646, 8662, 21106,
  12809, 22967, 8824, 8702, 8749, 8713, 14586, 10760, 8773, 8864, 9501, 9556, 9487, 8833, 8801, 9210, 8849, 8880, 8896,
  9574, 8912, 9566, 9299, 8980, 9008, 9035, 9088, 12383, 9109, 21085, 9545, 9159, 9201, 9226, 9268, 9284, 9348, 9364,
  9392, 12783, 9421, 9449, 8757, 8754, 9472, 9530, 9093, 9590, 9604, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10996, 10760, 12903, 12660, 12939, 11638, 12977, 12991, 13007, 13020, 13036, 13077, 13101, 18038, 13283, 14257, 13137,
  13189, 13223, 13299, 13328, 21002, 10761, 10809, 13370, 9725, 20637, 10848, 15237, 12475, 13453, 17718, 12506, 17660,
  10073, 13273, 10442, 13405, 20637, 18296, 21318, 13452, 19922, 15500, 22359, 13470, 13510, 14937, 13551, 20637, 14700,
  13587, 13453, 15686, 10423, 10810, 15207, 14317, 15732, 13453, 13626, 11137, 14187, 20637, 18302, 13453, 15968, 8561,
  20028, 16809, 22081, 20682, 20635, 18782, 14361, 11016, 18303, 17881, 18303, 18774, 15009, 15006, 18784, 22686, 22158,
  17416, 13252, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10996, 10760, 12319, 10759, 13642, 15143, 18392, 16353,
  18473, 16217, 10757, 14252, 13836, 11138, 13669, 10760, 20636, 16983, 13453, 13939, 10788, 10760, 10761, 10809, 13670,
  9725, 20637, 20637, 10904, 12475, 13453, 13453, 12506, 11181, 10073, 15879, 13523, 15206, 20637, 19186, 21318, 13453,
  18630, 15500, 22359, 22281, 10807, 14279, 20637, 20637, 18302, 13453, 13453, 22351, 13263, 13666, 9064, 20637, 13686,
  13453, 13998, 11137, 14187, 20637, 18302, 13453, 15968, 8561, 20637, 18782, 13997, 20682, 20635, 18782, 14361, 11016,
  18303, 17881, 18303, 18774, 17726, 13740, 18784, 22686, 22158, 17416, 13252, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 11118, 10760, 13207, 10759, 8677, 8686, 13779, 13795, 13811, 13825, 10757, 9753, 13836, 11138, 13669, 10760,
  20636, 18144, 17289, 13860, 10788, 10760, 21750, 13902, 13670, 17105, 17581, 20637, 21668, 13927, 13955, 13453, 12506,
  10760, 10241, 10558, 13669, 17382, 20638, 20637, 13972, 13995, 14014, 15500, 22359, 14037, 10807, 14279, 20637, 20637,
  18302, 13453, 13453, 22351, 13263, 10810, 15207, 20637, 18302, 13453, 13998, 11137, 14066, 20186, 18302, 21989, 14098,
  21248, 14970, 18782, 14092, 20682, 20635, 21982, 20058, 11016, 18303, 17881, 18303, 18774, 20803, 10892, 18784, 22686,
  22158, 17859, 13252, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10996, 10760, 13207, 10759, 12652, 12134, 14114,
  14126, 14142, 14155, 10757, 14252, 13836, 11138, 14182, 21640, 14203, 16972, 14482, 14227, 17359, 10760, 12357, 10809,
  14273, 21913, 20637, 13166, 18871, 14295, 14299, 13453, 12506, 10760, 10073, 15879, 13669, 15206, 20637, 20637, 21318,
  13453, 13453, 15500, 22359, 22281, 10807, 14279, 14315, 16509, 20034, 13453, 13453, 14333, 12755, 10810, 14907, 19380,
  15765, 13453, 14359, 20124, 14377, 14402, 18302, 14435, 15968, 8561, 20637, 18782, 13997, 20682, 14386, 18782, 15289,
  11016, 18303, 17881, 18303, 10879, 14464, 15006, 18784, 22686, 22158, 17416, 13252, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10996, 10760, 17458, 10759, 11894, 18197, 14506, 14518, 14534, 14547, 10757, 14574, 20966, 14622, 14671,
  14716, 14738, 21942, 14769, 19409, 12517, 8536, 13085, 10809, 22646, 16833, 20193, 9072, 14785, 14821, 21325, 14837,
  14868, 14895, 10522, 9625, 14930, 14953, 14986, 22230, 15025, 15053, 15093, 15109, 15694, 15159, 15175, 15199, 14694,
  15223, 15258, 15282, 15305, 15329, 15355, 22324, 17550, 21167, 22153, 15381, 15432, 11137, 15473, 19372, 18302, 15489,
  18588, 17332, 15516, 15554, 15581, 15621, 20635, 15645, 16392, 11016, 20879, 15655, 16560, 15671, 15928, 19604, 15710,
  22686, 15748, 17416, 13252, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10996, 10760, 13207, 10759, 11000, 12033,
  15781, 15793, 15809, 15822, 15858, 14252, 13836, 11138, 13669, 10760, 20636, 18133, 20888, 20616, 10788, 18430, 9875,
  15898, 13670, 9725, 18265, 20637, 10904, 15918, 13453, 13453, 12506, 10760, 10073, 15879, 13669, 15206, 20637, 15944,
  21318, 13453, 21515, 15396, 22359, 22281, 10807, 14279, 20637, 20637, 18302, 13453, 13453, 14852, 13263, 22059, 15207,
  19347, 18302, 13453, 15963, 11137, 14187, 20637, 18302, 13453, 15968, 8561, 20637, 18782, 13997, 20682, 20635, 18782,
  14361, 11016, 18303, 17881, 18303, 18774, 15009, 15006, 18784, 17905, 18463, 18539, 13252, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10996, 10760, 13207, 10759, 20574, 15143, 15987, 15999, 16015, 16028, 10757, 14252, 14166, 11138,
  13669, 10760, 20636, 16983, 13453, 13939, 19263, 18214, 10761, 10809, 13670, 9725, 20637, 20637, 10904, 12475, 13453,
  13453, 12506, 10760, 10760, 15879, 13669, 15206, 20637, 20637, 21318, 13453, 13453, 18711, 10760, 10760, 10807, 14279,
  20637, 20637, 18302, 13453, 13453, 10829, 10761, 10810, 15207, 20637, 18302, 13453, 13998, 11137, 14187, 20637, 18302,
  13453, 15968, 8561, 20637, 18782, 13997, 10731, 16055, 14473, 16094, 16116, 22199, 16156, 18303, 18774, 15009, 15006,
  18784, 22686, 22667, 16205, 13252, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10996, 10760, 13207, 10759, 11000,
  15143, 18392, 16353, 18473, 16217, 10757, 16253, 13836, 15873, 12538, 10760, 16274, 16294, 16321, 16340, 10788, 14597,
  10761, 10809, 13670, 9725, 20637, 20637, 18686, 12475, 13453, 16387, 12506, 10760, 10760, 15879, 13669, 15206, 20637,
  20637, 21318, 13453, 13453, 18711, 10760, 10760, 10807, 14279, 20637, 20637, 18302, 13453, 13453, 10829, 10761, 10810,
  15207, 20637, 18302, 13453, 13998, 11137, 14187, 20637, 18302, 13453, 15968, 8561, 20637, 18782, 13997, 20682, 20635,
  18782, 14361, 11016, 18744, 19455, 18303, 18774, 15009, 15006, 18784, 22686, 22158, 17416, 13252, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10996, 10760, 16417, 13650, 16408, 15143, 16433, 16447, 16463, 16477, 10757, 14252, 13836,
  22574, 13669, 14649, 16504, 16961, 16525, 13939, 10788, 10760, 10761, 18234, 13911, 8956, 16545, 20637, 16614, 16636,
  16660, 16529, 12506, 21825, 10760, 15879, 19076, 15206, 20637, 16681, 21318, 13453, 16189, 16706, 10760, 10760, 10807,
  14279, 20637, 21477, 21723, 13453, 13453, 10829, 10761, 10810, 15207, 20637, 18302, 13453, 13998, 16731, 16769, 13152,
  19624, 22036, 16825, 16849, 21717, 14753, 20435, 20682, 20635, 18782, 14361, 11016, 18303, 17881, 18303, 13238, 16877,
  15006, 18784, 16920, 22158, 17416, 17010, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10996, 10760, 13207, 10759,
  11000, 15143, 18392, 16353, 18897, 16217, 10757, 14252, 13836, 11138, 13669, 10760, 20636, 16983, 13453, 13939, 10788,
  10760, 10761, 10809, 13670, 9725, 20637, 20637, 10904, 12475, 13453, 13453, 12506, 10760, 10760, 15879, 13669, 15206,
  20637, 20637, 21318, 13453, 13453, 18711, 10760, 10760, 10807, 14279, 20637, 20637, 18302, 13453, 13453, 10829, 10761,
  10810, 15207, 20637, 18302, 13453, 13998, 11137, 14187, 20637, 18302, 13453, 15968, 8561, 20637, 18782, 13997, 20682,
  20635, 18782, 14361, 11016, 18303, 17881, 18303, 18774, 15009, 15006, 18784, 22686, 22158, 17416, 13252, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10996, 10760, 13207, 10759, 18010, 17037, 17053, 17065, 17081, 17094, 17121, 9903,
  14166, 16039, 17496, 17669, 16365, 18122, 17161, 16574, 19263, 8476, 10761, 17182, 13670, 9725, 17202, 15242, 17230,
  17253, 17287, 17305, 17348, 19297, 10760, 10433, 13669, 8964, 15759, 20637, 21418, 17800, 13453, 18711, 10760, 10271,
  10807, 17375, 20637, 17398, 18302, 13453, 17432, 15971, 17474, 17493, 21392, 20637, 18302, 17512, 13998, 17477, 15629,
  20637, 16620, 13453, 15313, 8561, 20637, 18782, 13997, 17532, 20635, 16181, 22554, 11016, 18303, 17881, 18303, 18774,
  15009, 15538, 17592, 20515, 18480, 17566, 13252, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10996, 10760, 13207,
  10759, 11000, 15143, 17608, 17620, 17636, 17649, 10757, 14252, 15833, 16488, 15902, 16715, 15724, 18089, 17685, 20561,
  9252, 10760, 20729, 10809, 13670, 9725, 20637, 18269, 19617, 17709, 13453, 21605, 17742, 19046, 17758, 15879, 13669,
  15206, 20637, 16278, 17778, 17816, 13453, 18711, 10760, 17832, 10807, 14279, 14963, 20637, 17850, 17875, 13979, 10829,
  10761, 10810, 15207, 20637, 18302, 13453, 13998, 11137, 14187, 20637, 18302, 13453, 15968, 8561, 20637, 18782, 13997,
  20682, 20635, 18782, 14361, 11016, 18303, 22303, 20418, 17897, 15009, 15006, 18784, 22686, 22158, 17416, 13252, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10996, 10760, 20314, 12917, 11000, 15143, 17921, 17933, 17949, 17962, 17997,
  14252, 13836, 20974, 18026, 20340, 18054, 18078, 18160, 18184, 10788, 18213, 10761, 10809, 13670, 9725, 20637, 20637,
  10904, 12475, 13453, 13453, 12506, 9869, 10760, 15879, 13669, 15206, 20637, 20637, 21318, 13453, 13453, 18711, 10760,
  22917, 18230, 18250, 20637, 18285, 16371, 13453, 18319, 18340, 18379, 18415, 18450, 18496, 18530, 18555, 18583, 11137,
  14187, 18604, 13566, 18626, 21292, 18646, 18674, 20148, 18702, 12690, 18736, 18760, 18800, 11016, 18827, 17881, 18303,
  19591, 18843, 18859, 18784, 22686, 18887, 17416, 18913, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10996, 10760,
  12836, 10759, 15408, 18947, 18963, 18975, 18991, 19004, 10757, 14252, 19038, 19062, 19104, 22800, 19140, 13763, 19156,
  17319, 10788, 10760, 10761, 10809, 13670, 9725, 20637, 20637, 19172, 12475, 13453, 19207, 12506, 10760, 17981, 15879,
  16753, 15206, 21676, 14412, 21318, 17516, 13453, 19249, 19291, 15132, 10807, 14279, 19191, 20637, 18302, 19706, 13453,
  10829, 10761, 10810, 15207, 20637, 18302, 13453, 13998, 11137, 20377, 20637, 14805, 13453, 15968, 19313, 19341, 13610,
  13997, 20682, 20635, 18782, 14361, 19363, 14419, 17881, 19396, 13602, 19438, 15006, 18784, 22686, 22158, 17416, 19471,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10996, 10760, 13207, 10759, 11000, 15143, 18392, 19233, 19498, 19511,
  10757, 14252, 13836, 11138, 13669, 10760, 20636, 16983, 13453, 13939, 10788, 10760, 19557, 16746, 13670, 9725, 16690,
  20637, 20176, 19577, 21284, 17166, 19640, 10760, 19656, 15879, 13669, 15206, 20637, 20637, 21318, 13453, 13453, 16140,
  19682, 17973, 10678, 17542, 18610, 20637, 18302, 22011, 13453, 16100, 10761, 10810, 15207, 20637, 18302, 13453, 13998,
  11137, 14187, 20637, 18302, 13453, 15968, 8561, 20637, 18782, 13997, 20682, 20635, 18782, 14361, 11016, 18303, 17881,
  18303, 18774, 15009, 15006, 18784, 22686, 22158, 17416, 13252, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10996,
  10760, 13207, 10759, 11000, 15143, 18392, 16353, 18473, 16217, 10757, 14252, 14558, 20733, 17186, 15842, 20833, 16950,
  19701, 19722, 19751, 22898, 10761, 10809, 13670, 9725, 20637, 20637, 10904, 12475, 13453, 13453, 12506, 10760, 10760,
  15879, 13669, 15206, 20637, 20637, 21318, 13453, 13453, 18711, 10760, 10760, 10807, 14279, 20637, 20637, 18302, 13453,
  13453, 10829, 10761, 10810, 15207, 20637, 18302, 13453, 13998, 11137, 14187, 20637, 18302, 13453, 15968, 8561, 20637,
  18782, 13997, 20682, 20635, 19797, 14361, 11016, 18303, 17881, 18303, 18774, 15009, 15006, 18784, 22686, 22158, 17416,
  13252, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10996, 10760, 12336, 12333, 15339, 19813, 19829, 19841, 19857,
  19870, 19904, 19763, 13836, 10669, 14637, 12923, 11023, 16305, 16665, 19220, 10788, 9667, 9615, 15183, 13670, 9725,
  10909, 16886, 14799, 12475, 19920, 19938, 12506, 10760, 10760, 19956, 19961, 15206, 20870, 16904, 21444, 20427, 13453,
  19977, 10659, 10760, 15882, 10741, 15947, 20002, 18302, 16324, 20050, 20074, 10761, 10810, 14683, 20637, 18302, 20096,
  13998, 11137, 14187, 22489, 18302, 13453, 20116, 10482, 20637, 19447, 13997, 20682, 20635, 18782, 14361, 11016, 18303,
  21189, 21274, 20140, 14490, 20164, 18784, 22686, 20209, 17416, 13252, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10996, 10760, 13207, 15416, 14343, 20246, 20262, 20274, 20290, 20303, 20330, 14252, 20356, 11231, 20372, 20393, 20409,
  13752, 20451, 14448, 8455, 10760, 17021, 20476, 13670, 15077, 20506, 20531, 21585, 20548, 17262, 13453, 12506, 18363,
  10760, 15879, 13669, 15206, 20637, 20637, 21318, 13453, 13453, 18711, 18811, 16258, 10807, 20590, 20637, 20220, 14914,
  13453, 21613, 20662, 22721, 20490, 20632, 21972, 17407, 20100, 20654, 20678, 14187, 20637, 21595, 20698, 15968, 8561,
  20637, 18782, 13997, 20714, 21352, 18782, 20749, 11016, 18303, 17881, 20784, 18774, 20896, 20800, 20819, 20855, 22158,
  17416, 13252, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10996, 10760, 20768, 13203, 11000, 15143, 20912, 20926,
  20942, 20955, 10757, 8467, 21032, 14606, 20990, 21018, 14076, 13419, 21056, 17445, 14879, 21122, 8550, 12557, 21140,
  9839, 20637, 21156, 16068, 21183, 17271, 21205, 16861, 10760, 10192, 15365, 21225, 21264, 21308, 20532, 20604, 21541,
  12478, 18711, 22593, 10760, 10807, 21341, 20637, 13173, 18302, 13453, 19940, 10829, 10471, 21368, 21408, 21434, 20839,
  18168, 13998, 21460, 14187, 21476, 21493, 21509, 21071, 8561, 20230, 21531, 21557, 21757, 21573, 15001, 21629, 21656,
  16078, 21692, 18303, 18774, 15009, 15266, 16784, 16935, 22158, 17416, 21739, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10996, 10760, 13207, 10759, 11000, 15143, 21773, 21785, 21801, 21814, 10757, 21841, 13836, 11138, 13669, 10760,
  20636, 16983, 13453, 13939, 10788, 10760, 21237, 10809, 13670, 9725, 20637, 20637, 20017, 12475, 13453, 13956, 21865,
  21881, 9325, 15879, 21901, 15206, 21929, 21958, 21318, 22005, 22027, 18711, 10276, 10760, 22052, 14279, 21706, 20637,
  18302, 22075, 13453, 10829, 10761, 10810, 15207, 20637, 18302, 13453, 13436, 11137, 14187, 20637, 22097, 13453, 15968,
  8561, 20637, 18782, 13997, 20682, 20635, 18782, 14361, 11016, 15531, 22139, 18303, 18774, 15009, 15006, 22174, 22686,
  13571, 22215, 13252, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10996, 10760, 13207, 10759, 11000, 15143, 18392,
  19735, 22257, 22270, 10757, 14252, 13836, 11138, 13669, 10760, 16798, 18100, 22297, 22110, 10788, 10760, 10761, 22319,
  13670, 21383, 16170, 20637, 10904, 22340, 13453, 13453, 12506, 10760, 10760, 15879, 22377, 15206, 16895, 20637, 21318,
  18324, 13453, 18711, 10760, 10760, 10807, 14279, 20637, 20637, 18302, 13453, 13453, 10829, 10761, 10810, 15207, 20637,
  18302, 13453, 13998, 11137, 14187, 20637, 18302, 13453, 15968, 8561, 20637, 18782, 13997, 20682, 20635, 18782, 14361,
  11016, 18303, 17881, 18303, 18774, 15009, 15006, 18784, 22686, 22158, 17416, 13252, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10996, 10760, 13207, 10759, 11000, 12076, 22419, 22431, 22447, 22460, 10757, 14252, 13836, 11138, 13669,
  10760, 20636, 16983, 13453, 13939, 10788, 10760, 10761, 10809, 13670, 9725, 20637, 20637, 10904, 12475, 13453, 13453,
  12506, 10760, 10760, 15879, 13669, 15206, 20637, 20637, 21318, 13453, 13453, 18711, 10760, 10760, 10807, 14279, 20637,
  20637, 18302, 13453, 13453, 10829, 10761, 10810, 15207, 22487, 17237, 14021, 20460, 11137, 14187, 20637, 18302, 13453,
  15968, 8561, 20637, 18782, 13997, 20682, 20635, 18782, 14361, 11016, 18303, 17881, 18303, 18774, 15009, 15006, 18784,
  22686, 22158, 17416, 13252, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10996, 10760, 13207, 10759, 11000, 15143,
  18392, 22123, 22505, 22518, 10757, 14252, 13836, 19561, 13669, 19986, 22188, 18111, 22545, 13700, 10788, 13121, 22570,
  10809, 13670, 9725, 20637, 20637, 17214, 12475, 13453, 16644, 19325, 10760, 22590, 15879, 13669, 15206, 20637, 20637,
  21318, 13453, 13453, 18711, 10760, 10760, 10807, 14279, 20637, 20637, 18302, 13453, 13453, 10829, 10761, 10810, 15207,
  20637, 18302, 13453, 13998, 11137, 14187, 20637, 18302, 13453, 15968, 8561, 20637, 18782, 13997, 20682, 20635, 18782,
  14361, 11016, 18303, 17881, 18303, 18774, 15009, 15006, 18784, 22686, 22158, 17416, 13252, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10996, 10760, 13207, 10759, 11000, 15143, 18392, 16353, 18473, 16217, 22609, 14252, 13836, 11138,
  13669, 10760, 20636, 16994, 13454, 13939, 10788, 10760, 10761, 10809, 13670, 9725, 20637, 20637, 10904, 12475, 13453,
  13453, 9241, 10760, 10760, 15879, 13669, 15206, 20637, 20637, 21318, 13453, 13453, 15068, 10760, 19781, 22636, 14279,
  14211, 20637, 22662, 17693, 13453, 10829, 10761, 10810, 15207, 20637, 22683, 13453, 21209, 11137, 14187, 20637, 18302,
  13453, 15968, 8561, 20637, 18782, 13997, 20682, 20635, 18782, 14361, 11016, 18303, 17881, 18303, 18774, 15009, 15006,
  18784, 22686, 22158, 17416, 13252, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 8336, 10760, 10393, 18354, 22702,
  22737, 15595, 12264, 22712, 22753, 9641, 13340, 13494, 10702, 13724, 10760, 22966, 8815, 22967, 9433, 14240, 8441,
  14655, 8992, 8492, 8508, 8598, 8577, 9174, 8592, 8614, 9456, 21097, 14722, 8630, 8646, 8662, 21106, 12809, 22967,
  8824, 8702, 8749, 8713, 14586, 10760, 8773, 8864, 9501, 9556, 9487, 8833, 8801, 9210, 8849, 8880, 8896, 9574, 8912,
  9566, 9299, 8980, 9008, 9035, 9088, 12383, 9109, 21085, 9545, 9159, 9201, 9226, 9268, 9284, 9348, 9364, 9392, 12783,
  9421, 9449, 8757, 8754, 9472, 9530, 9093, 9590, 9604, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 8336, 10760,
  12288, 19533, 9332, 22620, 10082, 22787, 9331, 22816, 9641, 13340, 22764, 10702, 13724, 10760, 22966, 8815, 22967,
  9433, 14240, 8441, 14655, 8992, 8492, 8508, 8598, 8577, 9174, 8592, 8614, 9456, 21097, 14722, 8630, 8646, 8662, 21106,
  12809, 22967, 8824, 8702, 8749, 8713, 14586, 10760, 8773, 8864, 9501, 9556, 9487, 8833, 8801, 9210, 8849, 8880, 8896,
  9574, 8912, 9566, 9299, 8980, 9008, 9035, 9088, 12383, 9109, 21085, 9545, 9159, 9201, 9226, 9268, 9284, 9348, 9364,
  9392, 12783, 9421, 9449, 8757, 8754, 9472, 9530, 9093, 9590, 9604, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  8336, 10760, 13354, 10760, 10760, 13312, 22854, 22843, 10760, 22870, 9641, 13340, 22881, 10702, 13724, 10760, 22966,
  8815, 22967, 9433, 14240, 8441, 14655, 8992, 8492, 8508, 8598, 8577, 9174, 8592, 8614, 9456, 21097, 14722, 8630, 8646,
  8662, 21106, 12809, 22967, 8824, 8702, 8749, 8713, 14586, 10760, 8773, 8864, 9501, 9556, 9487, 8833, 8801, 9210, 8849,
  8880, 8896, 9574, 8912, 9566, 9299, 8980, 9008, 9035, 9088, 12383, 9109, 21085, 9545, 9159, 9201, 9226, 9268, 9284,
  9348, 9364, 9392, 12783, 9421, 9449, 8757, 8754, 9472, 9530, 9093, 9590, 9604, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 8336, 10760, 12288, 10760, 10760, 15143, 10760, 10760, 10760, 19522, 10757, 14252, 13836, 11138, 13669,
  10760, 20636, 16983, 13453, 13939, 10101, 10760, 10761, 10809, 13670, 9725, 20637, 20637, 10904, 13433, 13453, 13453,
  12506, 10760, 10760, 15879, 13669, 15206, 20637, 20637, 21318, 13453, 13453, 18711, 10760, 10760, 10807, 14279, 20637,
  20637, 18302, 13453, 13453, 10829, 10761, 10810, 15207, 20637, 18302, 13453, 13998, 11137, 14187, 20637, 18302, 13453,
  15968, 8561, 20637, 18782, 13997, 20682, 20635, 18782, 14361, 11016, 18303, 17881, 18303, 18774, 15009, 15006, 18784,
  22686, 22158, 17416, 13252, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 15605, 10760, 22897, 15605, 10760,
  10760, 15600, 10760, 10760, 22914, 12423, 13347, 10702, 13724, 10760, 22966, 8815, 22967, 9433, 13483, 8441, 14655,
  8992, 8492, 8508, 8598, 8577, 9174, 8592, 8614, 9456, 21097, 14722, 8630, 8646, 8662, 21106, 12809, 22967, 8824, 8702,
  8749, 8713, 14586, 10760, 8773, 8864, 9501, 9556, 9487, 8833, 8801, 9210, 8849, 8880, 8896, 9574, 8912, 9566, 9299,
  8980, 9008, 9035, 9088, 12383, 9109, 21085, 9545, 9159, 9201, 9226, 9268, 9284, 9348, 22933, 9392, 9376, 9421, 22961,
  8757, 8754, 9472, 9530, 9093, 9590, 9604, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760,
  10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 10760, 30884, 30884, 0, 0, 32934,
  32934, 30884, 30884, 32934, 32934, 32934, 32934, 32934, 32934, 32934, 32934, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 168, 169, 0, 32934, 32934, 0, 32934, 32934, 32934, 32934, 32934, 26624, 28672, 32934, 32934, 32934, 32934,
  32934, 24576, 32934, 32934, 0, 32934, 32934, 32934, 32934, 32934, 32934, 32934, 32934, 32934, 32934, 32934, 32934,
  32934, 32934, 32934, 32934, 179, 32934, 32934, 0, 32934, 0, 30884, 32934, 32934, 32934, 32934, 32934, 32934, 0, 32934,
  32934, 32934, 32934, 32934, 32934, 32934, 32934, 32934, 0, 30884, 161, 162, 563200, 30884, 0, 32934, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 141312, 0, 0, 0, 141312, 141312, 0, 0, 677888, 0, 0, 0, 534528, 0, 0, 0, 0, 0, 0, 534528, 0, 0,
  0, 0, 528, 0, 0, 529, 0, 0, 0, 0, 0, 0, 179, 179, 179, 0, 0, 0, 339, 0, 0, 0, 0, 0, 0, 0, 0, 0, 541, 0, 0, 0, 0, 0,
  549, 786432, 561152, 794624, 806912, 561152, 561152, 561152, 849920, 561152, 561152, 561152, 733184, 749568, 753664,
  772096, 780288, 786432, 794624, 849920, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 763904, 563200, 563200, 563200, 563200, 0, 0,
  563200, 563200, 563200, 563200, 563200, 0, 563200, 118784, 0, 0, 0, 0, 537, 0, 0, 539, 0, 0, 0, 0, 0, 351, 0, 0, 0, 0,
  556, 0, 0, 0, 0, 561, 0, 0, 0, 0, 0, 220, 220, 220, 220, 220, 220, 220, 220, 0, 0, 0, 163, 563200, 772096, 780288,
  786432, 563200, 794624, 806912, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 849920, 563200, 0, 0, 563200,
  563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 733184, 563200, 563200, 563200,
  749568, 753664, 563200, 563200, 563200, 563200, 749568, 753664, 563200, 759808, 563200, 563200, 772096, 563200,
  780288, 786432, 563200, 794624, 563200, 806912, 0, 536576, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 745472, 784384, 0,
  0, 0, 671744, 671744, 561152, 561152, 561152, 561152, 561152, 716800, 561152, 561152, 561152, 745472, 561152, 561152,
  561152, 784384, 788480, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 716800, 0, 788480, 0, 0, 0, 160, 0, 0,
  0, 0, 163, 0, 0, 0, 0, 193, 0, 0, 193, 26624, 28672, 193, 0, 0, 0, 0, 24576, 563200, 563200, 716800, 563200, 563200,
  563200, 563200, 563200, 563200, 563200, 745472, 563200, 563200, 563200, 563200, 563200, 0, 0, 563200, 563200, 688128,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 65536, 0, 0, 0, 0, 0, 0, 0, 0, 0, 75776, 0, 0, 75776, 0, 0, 0, 784384, 788480, 563200,
  563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 0, 563200,
  563200, 563200, 563200, 563200, 563200, 563200, 0, 0, 561152, 688128, 690176, 561152, 561152, 561152, 724992, 561152,
  561152, 757760, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 55296,
  118784, 126976, 0, 774144, 563200, 800768, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 835584, 837632,
  563200, 845824, 563200, 563200, 563200, 563200, 0, 0, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200,
  563200, 0, 563200, 671744, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 724992, 563200, 563200, 563200,
  563200, 757760, 563200, 563200, 563200, 0, 0, 782336, 0, 0, 0, 0, 0, 0, 0, 727040, 0, 0, 868352, 0, 561152, 561152,
  561152, 561152, 561152, 757760, 0, 0, 0, 0, 0, 0, 690176, 563200, 563200, 688128, 561152, 561152, 561152, 561152,
  727040, 561152, 561152, 561152, 808960, 561152, 561152, 561152, 851968, 858112, 868352, 858112, 0, 0, 0, 851968, 0,
  563200, 563200, 563200, 694272, 563200, 563200, 563200, 563200, 563200, 727040, 735232, 868352, 563200, 563200,
  563200, 563200, 563200, 727040, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 694272, 563200, 0, 51200,
  563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 733184, 563200, 563200,
  563200, 563200, 0, 515, 563200, 563200, 563200, 563200, 563200, 0, 563200, 515, 0, 0, 0, 0, 590, 0, 592, 0, 0, 0, 0,
  0, 0, 0, 163, 163, 163, 163, 770, 771, 772, 163, 163, 163, 825344, 0, 0, 0, 0, 0, 0, 841728, 839680, 0, 0, 0, 561152,
  561152, 561152, 561152, 561152, 561152, 561152, 733184, 561152, 561152, 749568, 753664, 561152, 561152, 772096,
  780288, 561152, 737280, 561152, 561152, 825344, 561152, 839680, 737280, 0, 0, 0, 563200, 563200, 563200, 563200,
  563200, 0, 0, 563200, 563200, 688128, 161, 0, 0, 0, 161, 0, 563200, 563200, 563200, 737280, 563200, 761856, 563200,
  563200, 790528, 563200, 815104, 563200, 825344, 563200, 839680, 563200, 563200, 563200, 563200, 0, 120832, 563200,
  563200, 563200, 563200, 563200, 0, 563200, 120832, 0, 0, 0, 0, 1003, 163, 163, 1006, 163, 163, 163, 163, 163, 163,
  163, 163, 624, 163, 163, 163, 163, 163, 163, 630, 563200, 870400, 563200, 563200, 563200, 563200, 563200, 563200,
  563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 669696, 563200, 563200, 563200, 563200, 825344,
  563200, 563200, 839680, 563200, 563200, 563200, 870400, 0, 0, 0, 0, 708608, 0, 722944, 0, 0, 0, 162, 0, 673792,
  686080, 0, 763904, 0, 802816, 0, 0, 0, 179, 179, 179, 0, 0, 0, 0, 0, 0, 0, 0, 343, 0, 0, 0, 0, 0, 0, 350, 546, 0,
  698368, 563200, 722944, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 698368, 706560,
  708608, 563200, 563200, 563200, 563200, 0, 563200, 563200, 563200, 563200, 563200, 759808, 563200, 563200, 563200,
  563200, 563200, 0, 0, 161, 0, 162, 0, 0, 808960, 0, 0, 0, 563200, 722944, 563200, 563200, 563200, 563200, 811008,
  563200, 563200, 563200, 563200, 563200, 563200, 563200, 0, 0, 0, 0, 0, 0, 0, 808960, 0, 0, 0, 0, 0, 751616, 0, 0, 0,
  0, 0, 561152, 692224, 561152, 561152, 768000, 561152, 561152, 0, 0, 0, 163, 252193, 289, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  528, 0, 0, 0, 0, 530, 0, 0, 0, 0, 179, 179, 768000, 692224, 667648, 563200, 692224, 563200, 563200, 563200, 718848,
  563200, 768000, 563200, 563200, 563200, 563200, 862208, 563200, 718848, 563200, 563200, 563200, 563200, 563200,
  667648, 563200, 563200, 692224, 563200, 563200, 563200, 718848, 563200, 563200, 563200, 563200, 563200, 563200,
  851968, 563200, 858112, 563200, 563200, 868352, 563200, 0, 0, 0, 0, 0, 726, 873, 0, 0, 0, 0, 0, 733, 0, 0, 0, 0, 0,
  731, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 352256, 0, 0, 0, 0, 563200, 768000, 563200, 563200, 563200, 563200, 563200,
  563200, 563200, 563200, 862208, 792576, 827392, 0, 696320, 675840, 0, 1202, 675840, 696320, 561152, 770048, 827392,
  770048, 563200, 675840, 696320, 563200, 563200, 741376, 770048, 817152, 563200, 827392, 563200, 563200, 563200,
  860160, 0, 714752, 0, 714752, 563200, 710656, 827392, 860160, 679936, 563200, 563200, 563200, 563200, 563200, 563200,
  563200, 675840, 679936, 696320, 563200, 563200, 563200, 563200, 0, 0, 563200, 563200, 563200, 563200, 563200, 0,
  563200, 116736, 0, 0, 714752, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 856064, 563200, 710656, 714752,
  563200, 563200, 563200, 563200, 0, 0, 563200, 563200, 563200, 563200, 563200, 0, 563200, 0, 0, 0, 563200, 563200,
  563200, 856064, 0, 1202, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 849920,
  563200, 563200, 563200, 563200, 563200, 563200, 720896, 563200, 563200, 563200, 563200, 563200, 563200, 720896,
  563200, 563200, 563200, 563200, 563200, 563200, 833536, 563200, 563200, 563200, 563200, 774144, 800768, 563200,
  563200, 845824, 563200, 563200, 563200, 563200, 688128, 690176, 563200, 563200, 563200, 563200, 563200, 563200,
  724992, 563200, 563200, 563200, 563200, 757760, 563200, 563200, 563200, 563200, 0, 0, 563200, 563200, 563200, 563200,
  563200, 0, 563200, 0, 90112, 0, 563200, 563200, 563200, 729088, 563200, 563200, 833536, 563200, 563200, 729088,
  563200, 563200, 563200, 563200, 833536, 563200, 563200, 563200, 706560, 708608, 563200, 563200, 563200, 563200,
  563200, 811008, 563200, 563200, 563200, 563200, 563200, 563200, 835584, 837632, 563200, 563200, 563200, 563200,
  563200, 563200, 563200, 563200, 727040, 735232, 563200, 563200, 563200, 563200, 563200, 563200, 808960, 563200,
  563200, 563200, 563200, 563200, 851968, 858112, 563200, 563200, 831488, 669696, 563200, 563200, 563200, 563200,
  831488, 563200, 743424, 819200, 563200, 563200, 743424, 819200, 563200, 712704, 563200, 563200, 563200, 563200,
  563200, 563200, 563200, 823296, 823296, 0, 0, 0, 0, 0, 0, 0, 0, 560, 0, 0, 0, 0, 0, 0, 220, 739, 740, 220, 220, 220,
  220, 745, 220, 747, 220, 161, 162, 563200, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 131072, 0, 0, 57344, 0, 0,
  161, 57344, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 543, 0, 0, 0, 0, 0, 0, 161, 0, 0, 0, 0, 0, 57547, 28672, 0, 0, 0, 0, 0,
  24576, 161, 161, 161, 0, 161, 0, 161, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 161, 161, 0, 0, 14657, 162, 563200, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 163, 163, 161, 0, 0, 0, 0, 673792, 686080, 0, 763904, 0, 802816, 0, 0, 0, 179,
  179, 179, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 345, 6145, 0, 569498, 4, 156, 0, 0, 0, 0, 0, 0, 0, 0, 0, 156, 0, 0, 0, 165, 0,
  0, 0, 165, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96458, 0, 96458, 0, 0, 309, 0, 0, 0, 0, 309, 0, 0, 0, 309, 0, 0, 0, 0, 0, 0,
  532480, 200, 0, 0, 0, 355, 0, 0, 0, 0, 0, 0, 532480, 200, 0, 0, 20480, 0, 0, 0, 0, 0, 0, 0, 0, 594, 594, 0, 0, 0, 594,
  163, 163, 0, 0, 179, 179, 179, 0, 71680, 0, 0, 0, 0, 0, 0, 532480, 0, 0, 0, 0, 715, 716, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 536, 0, 0, 220, 0, 520, 524, 0, 0, 673792, 686080, 0, 763904, 0, 802816, 0, 0, 0, 179, 179, 179, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 344, 0, 0, 0, 677888, 0, 0, 0, 534528, 0, 0, 0, 0, 0, 0, 534528, 0, 547, 6145, 0, 3, 4, 0, 65536, 0, 0, 0,
  0, 0, 0, 0, 65536, 0, 0, 0, 65536, 0, 65536, 0, 0, 0, 65536, 65536, 0, 65536, 65536, 65536, 65536, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 351, 0, 0, 65536, 65536, 65536, 0, 65536, 0, 65536, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 162,
  162, 0, 0, 322, 323, 563200, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 169, 0, 0, 0, 67584, 0, 0, 162, 67584, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 564, 0, 806912, 0, 561152, 0, 0, 162, 0, 0, 0, 0, 0, 26624, 67791, 0, 0, 0, 0, 0, 24576, 162,
  162, 162, 0, 162, 0, 162, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 733, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 352256, 352256,
  352256, 352256, 352256, 352256, 161, 14660, 563200, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 179, 179, 6145, 0, 3, 4,
  0, 0, 157, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1076, 220, 220, 220, 220, 167, 167, 0, 167, 167, 167, 167, 167, 26624,
  28672, 167, 167, 167, 167, 69799, 24576, 167, 167, 0, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167,
  167, 167, 167, 180, 167, 167, 167, 167, 167, 167, 0, 69799, 69799, 167, 69799, 69799, 69799, 69799, 69799, 167, 0, 0,
  0, 0, 730, 0, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 131072, 0, 0, 0, 0, 0, 167, 0, 0, 167, 167, 167, 167, 167, 167,
  69632, 69799, 167, 167, 69799, 69815, 69815, 69815, 69799, 69815, 69799, 69799, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0,
  733, 0, 0, 0, 0, 0, 736, 0, 0, 0, 567631, 567631, 179, 0, 0, 0, 0, 0, 0, 0, 0, 532480, 0, 0, 0, 0, 872, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 865, 0, 0, 0, 75776, 0, 0, 0, 0, 0, 0, 0, 75776, 75776, 75776, 0, 0, 0, 0, 0, 0, 532480, 200,
  0, 98304, 0, 0, 0, 0, 0, 0, 0, 0, 0, 77824, 77824, 77824, 77824, 77824, 77824, 77824, 0, 0, 0, 75776, 0, 75776, 75776,
  0, 26624, 28672, 0, 0, 75776, 0, 75776, 24576, 75776, 75776, 75776, 75776, 0, 75776, 75776, 75776, 75776, 75776,
  75776, 75776, 75776, 0, 0, 0, 75776, 75776, 75776, 75776, 75776, 75776, 75776, 75776, 75776, 75776, 75776, 75776, 0,
  0, 75776, 75776, 75776, 75776, 6145, 0, 0, 4, 59392, 0, 0, 0, 0, 0, 0, 532480, 352, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  348160, 0, 179, 0, 348160, 0, 0, 179, 179, 102400, 0, 0, 0, 0, 0, 0, 0, 0, 532480, 0, 0, 0, 0, 982, 0, 0, 0, 873, 0,
  0, 0, 0, 0, 0, 220, 220, 220, 742, 220, 220, 220, 220, 220, 220, 220, 220, 220, 755, 220, 220, 0, 0, 0, 0, 77824,
  77824, 79872, 77824, 0, 79872, 77824, 77824, 77824, 77824, 77824, 77824, 77824, 0, 0, 0, 0, 0, 983, 984, 0, 0, 0, 0,
  0, 0, 0, 0, 220, 220, 220, 220, 220, 220, 220, 220, 0, 0, 0, 1155, 51488, 0, 0, 0, 0, 0, 51488, 0, 0, 77824, 0, 0,
  51488, 51488, 51488, 51488, 77824, 51488, 77824, 51488, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 733, 0, 0, 0, 0, 735,
  0, 0, 81920, 81920, 83968, 81920, 0, 83968, 81920, 81920, 81920, 81920, 81920, 81920, 81920, 0, 0, 0, 0, 0, 1072, 0,
  0, 0, 0, 0, 0, 220, 220, 220, 220, 220, 744, 220, 220, 220, 220, 220, 0, 0, 677888, 0, 0, 0, 534528, 0, 0, 0, 0, 0, 0,
  534528, 545, 0, 0, 0, 169, 0, 0, 0, 0, 26624, 28672, 0, 0, 168, 0, 168, 24576, 0, 0, 0, 86016, 86016, 86016, 0, 86016,
  26624, 28672, 86016, 0, 0, 86016, 0, 24576, 86016, 86016, 86016, 86016, 0, 86016, 86016, 86016, 86016, 86016, 86016,
  86016, 86016, 0, 0, 0, 86016, 0, 86016, 86016, 86016, 86016, 86016, 86016, 86016, 86016, 86016, 0, 0, 0, 86016, 0,
  86016, 86016, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 861, 862, 0, 0, 0, 0, 0, 0, 0, 0, 366, 0, 0, 220, 220, 220, 220,
  220, 220, 220, 220, 886, 220, 220, 220, 220, 220, 152, 0, 3, 4, 0, 0, 0, 158, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 561152,
  561152, 561152, 561152, 561152, 88064, 88064, 88064, 88064, 0, 88064, 88064, 88064, 88064, 88064, 88064, 88064, 88064,
  0, 0, 0, 0, 0, 1200, 0, 0, 1203, 220, 220, 220, 220, 220, 220, 0, 0, 0, 898, 0, 0, 0, 0, 163, 163, 163, 161, 162, 163,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 220, 0, 0, 563, 163, 289, 289, 0, 0, 0, 0, 0, 0, 0, 0, 0, 528, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 179, 179, 0, 0, 112640, 0, 0, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220,
  220, 220, 220, 0, 289, 289, 1131, 289, 289, 289, 289, 289, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1209, 163, 163, 163,
  163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 629, 163, 163, 163, 1220, 163, 163, 163, 163, 163, 1226, 289, 289,
  289, 289, 289, 289, 1232, 289, 289, 289, 289, 0, 1202, 163, 163, 163, 163, 1294, 163, 163, 163, 163, 289, 289, 289,
  1321, 289, 289, 289, 289, 289, 0, 163, 163, 163, 163, 0, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 615,
  163, 163, 163, 163, 0, 1202, 220, 220, 220, 220, 220, 0, 163, 163, 163, 163, 163, 1250, 163, 1251, 289, 1263, 289,
  1264, 289, 289, 289, 289, 289, 289, 0, 0, 1202, 220, 163, 1272, 1286, 289, 289, 289, 0, 1202, 1290, 163, 163, 163,
  163, 163, 163, 163, 163, 1299, 0, 0, 198, 0, 0, 0, 0, 0, 26624, 28672, 0, 0, 0, 0, 0, 24576, 92476, 92476, 92476, 0,
  92476, 0, 92476, 6145, 41113, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 163, 0, 0, 0, 0, 0, 0, 0, 0, 1202, 220, 220, 220, 220,
  220, 0, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 439, 441, 163, 163, 448, 0, 96458, 0, 96458, 0, 0, 96458,
  96458, 96458, 96458, 96458, 96458, 96458, 0, 0, 0, 0, 0, 108544, 108544, 0, 26624, 28672, 0, 0, 108544, 0, 108544,
  24576, 96458, 96458, 96458, 96458, 96458, 96458, 0, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 873, 0, 0, 0, 0, 0, 988,
  220, 0, 0, 199, 0, 0, 0, 0, 0, 26624, 28672, 0, 0, 0, 0, 0, 24576, 199, 199, 199, 0, 199, 0, 199, 6145, 41113, 3, 4,
  0, 0, 0, 0, 0, 0, 0, 160, 163, 0, 0, 0, 0, 0, 552, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 220, 220, 220, 220, 220, 546,
  546, 726, 0, 0, 0, 0, 552, 733, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 110902, 0, 0, 0, 110902, 110902, 705, 858, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 725, 0, 0, 169, 0, 0, 169, 0, 168, 0, 168, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86016, 0, 0,
  86016, 86016, 0, 0, 161, 162, 563525, 0, 0, 0, 73728, 104448, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 359, 220, 369, 220, 220,
  220, 786432, 794624, 849920, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 763904, 563525, 563525, 563525, 563525, 0, 563525, 563525,
  563525, 563525, 563525, 760133, 563525, 563525, 563525, 563525, 563525, 563525, 0, 563667, 672211, 563667, 563667,
  563667, 563667, 563667, 563667, 563667, 563667, 563667, 850387, 563667, 563667, 563667, 563667, 563667, 563667,
  563525, 772421, 780613, 786757, 563525, 794949, 807237, 563525, 563525, 563525, 563525, 563525, 563525, 563525,
  850245, 563525, 0, 0, 563667, 563667, 563667, 563667, 563667, 563667, 563667, 563667, 563667, 563667, 563667, 733651,
  563667, 563667, 563667, 856531, 0, 1202, 563525, 563525, 563525, 563525, 563525, 563525, 563525, 563525, 563525,
  563667, 563667, 563667, 563667, 563667, 563667, 563667, 563667, 563667, 0, 563525, 563525, 563525, 563525, 563525,
  563525, 563525, 784851, 788947, 563667, 563667, 563667, 563667, 563667, 563667, 563667, 563667, 563667, 563667,
  563667, 563667, 563667, 563667, 563667, 563667, 690501, 563525, 563525, 563525, 563525, 563525, 563525, 725317,
  563525, 563525, 563525, 563525, 758085, 563525, 563525, 563525, 563525, 0, 0, 563525, 563525, 563525, 563525, 563525,
  563525, 563525, 563525, 563525, 466, 774611, 563667, 801235, 563667, 563667, 563667, 563667, 563667, 563667, 563667,
  836051, 838099, 563667, 846291, 563667, 563667, 563667, 563667, 563667, 563667, 737747, 563667, 762323, 563667,
  563667, 790995, 563667, 815571, 563667, 563667, 563667, 563667, 563667, 563667, 852435, 563667, 858579, 563667,
  563667, 868819, 563667, 0, 0, 0, 0, 0, 110830, 0, 110830, 110830, 110830, 110830, 110830, 110830, 110830, 110830,
  110830, 0, 110830, 110830, 110830, 110830, 110830, 110830, 110830, 110830, 0, 0, 0, 0, 0, 0, 851968, 0, 563525,
  563525, 563525, 694597, 563525, 563525, 563525, 563525, 563525, 727365, 735557, 868677, 563525, 563525, 563525,
  563525, 563525, 727365, 563525, 563525, 563525, 563667, 563667, 563667, 563667, 694739, 563667, 563667, 750035,
  754131, 563667, 760275, 563667, 563667, 772563, 563667, 780755, 786899, 563667, 795091, 563667, 807379, 561152,
  737280, 561152, 561152, 825344, 561152, 839680, 737280, 0, 0, 0, 563525, 563525, 563525, 563525, 563525, 563525,
  563525, 563525, 563525, 563525, 563525, 563525, 563525, 563525, 563525, 563525, 563525, 563525, 563525, 737605,
  563525, 762181, 563525, 563525, 790853, 563525, 815429, 563525, 825669, 563525, 840005, 563525, 563525, 563525,
  563525, 563525, 563525, 809285, 563525, 563525, 563525, 563525, 563525, 852293, 858437, 563525, 563525, 563525,
  563525, 563525, 563525, 835909, 837957, 563525, 563525, 563525, 563525, 563525, 563525, 563525, 563525, 733509,
  563525, 563525, 563525, 749893, 753989, 563525, 563525, 563525, 870725, 563525, 563525, 563525, 563525, 563525,
  563525, 563525, 563525, 563667, 563667, 563667, 563667, 563667, 563667, 670021, 563525, 563525, 563525, 563525,
  825811, 563667, 563667, 840147, 563667, 563667, 563667, 870867, 0, 0, 0, 0, 708608, 0, 722944, 0, 0, 0, 170, 0, 0, 0,
  0, 26624, 28672, 208, 0, 0, 0, 0, 24576, 698693, 563525, 723269, 563525, 563525, 563525, 563525, 563667, 563667,
  563667, 563667, 563667, 698835, 707027, 709075, 563667, 723411, 563667, 563667, 563667, 563667, 811475, 563667,
  563667, 563667, 563667, 563667, 563667, 563667, 0, 0, 0, 0, 0, 0, 0, 808960, 0, 0, 0, 768000, 692224, 667973, 563525,
  692549, 563525, 563525, 563525, 719173, 563525, 768325, 563525, 563525, 563525, 563525, 862533, 563525, 719173,
  563525, 563525, 563525, 563525, 563525, 668115, 563667, 563667, 692691, 563667, 563667, 563667, 719315, 563667,
  741843, 770515, 817619, 563667, 827859, 563667, 563667, 563667, 860627, 0, 714752, 1202, 714752, 563525, 710981,
  563667, 768467, 563667, 563667, 563667, 563667, 563667, 563667, 563667, 563667, 862675, 792576, 827392, 0, 696320,
  675840, 0, 1202, 675840, 696320, 561152, 770048, 827392, 770048, 563525, 676165, 696645, 563525, 563525, 741701,
  770373, 817477, 827717, 860485, 680261, 563525, 563525, 563525, 563525, 563525, 563525, 563667, 676307, 680403,
  696787, 563667, 563667, 563667, 563667, 563667, 563667, 563667, 725459, 563667, 563667, 563667, 563667, 758227,
  563667, 563667, 563667, 563667, 563667, 563667, 727507, 735699, 563667, 563667, 563667, 563667, 563667, 563667,
  809427, 563667, 715077, 563525, 563525, 563525, 563525, 563525, 563525, 563525, 856389, 563667, 711123, 715219,
  563667, 563667, 563667, 563667, 0, 0, 563525, 563525, 563525, 563667, 563667, 0, 563667, 0, 0, 0, 721221, 563525,
  563525, 563525, 563525, 563667, 563667, 721363, 563667, 563667, 563667, 563667, 563667, 563667, 833536, 563525,
  563525, 563525, 563525, 774469, 801093, 563525, 563525, 846149, 563525, 563667, 563667, 563667, 688595, 690643,
  563667, 563667, 717267, 563667, 563667, 563667, 563667, 563667, 563667, 563667, 745939, 563667, 563667, 563667,
  563667, 563667, 0, 0, 563525, 563667, 688128, 0, 0, 0, 0, 0, 0, 0, 0, 163, 0, 0, 0, 191, 0, 0, 0, 563525, 563525,
  563525, 729413, 563525, 563525, 833861, 563667, 563667, 729555, 563667, 563667, 563667, 563667, 834003, 563525,
  563525, 563525, 706885, 708933, 563525, 563525, 563525, 563525, 563525, 811333, 563525, 563525, 563525, 563525,
  563525, 563525, 745797, 563525, 563525, 563525, 563525, 784709, 788805, 563525, 563525, 563525, 831813, 670163,
  563667, 563667, 563667, 563667, 831955, 563525, 743749, 819525, 563525, 563667, 743891, 819667, 563667, 713029,
  563525, 713171, 563667, 563525, 563667, 563525, 563667, 563525, 563667, 823621, 823763, 0, 0, 0, 0, 0, 0, 0, 0, 26624,
  28672, 0, 0, 137216, 0, 137216, 24576, 108544, 108544, 108544, 108544, 0, 108544, 108544, 108544, 108544, 108544,
  108544, 108544, 108544, 0, 0, 0, 108544, 0, 108544, 108544, 108544, 108544, 108544, 108544, 108544, 108544, 108544, 0,
  0, 0, 108544, 108544, 108544, 108544, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 26624, 28672, 0, 210, 0, 210, 0, 24576,
  0, 536576, 0, 0, 0, 0, 0, 34816, 0, 0, 0, 18432, 0, 0, 0, 745472, 162, 0, 0, 0, 162, 0, 724992, 0, 0, 0, 847872, 0, 0,
  0, 0, 0, 0, 0, 0, 26624, 28672, 0, 212, 0, 212, 0, 24576, 0, 0, 782336, 0, 0, 0, 0, 0, 200, 0, 727040, 0, 0, 868352,
  0, 561152, 561152, 561152, 561152, 561152, 757760, 0, 0, 0, 0, 0, 0, 690176, 563525, 563525, 688453, 110902, 110902,
  110902, 110830, 110902, 110830, 110910, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 26624, 28672, 209, 0, 0, 0, 0, 24576,
  6145, 0, 3, 4, 0, 0, 0, 0, 122880, 0, 0, 0, 0, 0, 0, 122880, 0, 122880, 122880, 122880, 122880, 122880, 122880,
  122880, 122880, 122880, 122880, 122880, 122880, 122880, 0, 122880, 122880, 122880, 122880, 122880, 122880, 122880,
  122880, 0, 0, 0, 0, 0, 125167, 0, 125167, 125167, 125167, 125167, 125167, 125167, 125167, 125167, 125167, 0, 125167,
  125167, 125167, 125167, 125167, 125167, 125167, 125167, 0, 0, 0, 0, 0, 0, 122880, 0, 122880, 122880, 6145, 0, 3, 4, 0,
  0, 0, 0, 0, 0, 0, 0, 65536, 0, 0, 0, 0, 65536, 0, 0, 0, 0, 0, 26624, 28672, 0, 0, 0, 0, 0, 24576, 161, 162, 563200, 0,
  0, 0, 0, 0, 106496, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 348160, 348160, 348160, 0, 0, 0, 124928, 0, 0, 124928, 0, 0, 0,
  124928, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 179, 0, 0, 0, 0, 0, 125167, 0, 125167, 125167, 6145, 0, 3, 0, 0, 0, 0,
  133120, 0, 0, 0, 171, 0, 0, 0, 0, 0, 0, 0, 0, 0, 179, 163, 0, 177, 0, 0, 0, 0, 0, 0, 0, 0, 0, 177, 0, 0, 0, 179, 163,
  0, 161, 162, 563200, 0, 100352, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 531, 565, 566, 563200, 563200, 563200, 856064,
  0, 49152, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 737280, 563200, 761856,
  563200, 563200, 790528, 563200, 815104, 563200, 563200, 0, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 81920, 0,
  0, 131072, 0, 0, 131072, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 532480, 0, 0, 135168, 135168, 135168, 0, 135168, 0,
  135168, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 81920, 81920, 81920, 81920, 81920, 81920, 81920, 81920, 6145, 0, 3, 4,
  0, 0, 0, 0, 0, 163, 51847, 528, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 846, 289, 289, 0, 0,
  0, 1144, 220, 220, 220, 220, 220, 220, 220, 220, 0, 0, 0, 163, 289, 289, 0, 0, 0, 0, 0, 0, 0, 0, 0, 528, 0, 0, 0, 0,
  0, 0, 0, 0, 533, 179, 179, 0, 0, 0, 738, 0, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 395, 0, 0, 0, 0, 0,
  879, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 579, 220, 580, 0, 0, 0, 137216, 0, 0,
  137216, 137216, 137216, 137216, 137216, 137216, 137216, 0, 0, 0, 0, 0, 139264, 0, 0, 26624, 28672, 0, 0, 0, 0, 0,
  24576, 0, 0, 0, 137216, 0, 137216, 0, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 122880, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 179, 0, 0, 0, 0, 751616, 0, 0, 0, 0, 1202, 561152, 692224, 561152, 561152, 768000, 561152, 561152, 0, 0, 0, 186, 0,
  0, 0, 0, 163, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 170, 170, 0, 139264, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 179, 0, 0,
  0, 0, 1199, 0, 1201, 0, 220, 220, 1204, 1205, 220, 220, 220, 0, 139264, 139264, 139264, 139264, 0, 139264, 139264,
  139264, 139264, 139264, 139264, 139264, 139264, 0, 0, 0, 139264, 0, 139264, 139264, 139264, 139264, 139264, 139264,
  139264, 139264, 139264, 0, 0, 0, 139264, 0, 139264, 139264, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 169, 0, 0, 169, 0, 0,
  0, 0, 0, 0, 0, 0, 873, 0, 0, 986, 0, 0, 0, 989, 0, 1245, 675840, 696320, 561152, 770048, 827392, 770048, 563200,
  675840, 696320, 563200, 563200, 741376, 770048, 817152, 563200, 827392, 563200, 563200, 563200, 860160, 0, 714752,
  1202, 714752, 563200, 710656, 563200, 563200, 563200, 856064, 0, 1270, 563200, 563200, 563200, 563200, 563200, 563200,
  563200, 563200, 563200, 563200, 745472, 563200, 563200, 563200, 563200, 784384, 788480, 563200, 563200, 563200,
  141312, 141312, 141312, 0, 141312, 0, 141312, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 175, 176, 0, 0, 0, 0, 179, 163, 0,
  0, 0, 200, 0, 0, 0, 0, 0, 26624, 28672, 0, 0, 0, 0, 0, 24576, 200, 200, 200, 0, 200, 0, 200, 6145, 0, 3, 4, 0, 0, 0,
  0, 0, 0, 0, 189, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 162, 0, 0, 0, 162, 162, 0, 0, 170, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 179,
  163, 0, 0, 0, 0, 174, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 411, 0, 0, 0, 170, 185, 0, 0, 0, 0, 0, 0, 163, 0, 0, 0, 0,
  0, 194, 0, 0, 0, 237, 0, 237, 237, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 30884, 30884, 208, 219, 221, 221, 221,
  219, 221, 219, 219, 219, 219, 219, 219, 219, 219, 219, 256, 219, 258, 256, 219, 219, 219, 219, 219, 221, 219, 258,
  279, 279, 290, 279, 279, 279, 279, 279, 290, 279, 279, 279, 279, 279, 290, 290, 290, 290, 279, 290, 279, 290, 6145,
  41113, 3, 4, 0, 0, 0, 0, 320, 161, 162, 163, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 330, 0, 0, 0, 0, 114688, 0, 0, 0, 0, 0, 0,
  561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 0, 0, 129024, 0, 0, 0,
  179, 179, 179, 0, 0, 338, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 562, 0, 0, 0, 0, 220, 0, 0, 347, 0, 0, 0, 0, 200, 0, 0, 0,
  356, 0, 0, 0, 0, 0, 0, 532480, 16737, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 542, 0, 0, 0, 0, 0, 0, 163, 417, 163, 163, 163,
  163, 163, 163, 163, 163, 163, 440, 163, 443, 163, 163, 163, 163, 1096, 163, 163, 163, 163, 163, 163, 1100, 163, 1101,
  163, 163, 163, 163, 621, 163, 622, 163, 163, 163, 163, 163, 163, 163, 163, 163, 925, 163, 163, 163, 163, 163, 163,
  163, 450, 163, 163, 347, 338, 163, 417, 163, 163, 163, 163, 440, 443, 163, 0, 0, 182, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 179, 163, 0, 289, 289, 471, 289, 289, 289, 289, 289, 289, 289, 289, 289, 497, 289, 500, 289, 289, 289, 289, 0,
  1202, 163, 163, 1292, 1293, 163, 163, 1296, 1297, 163, 289, 289, 163, 289, 163, 289, 163, 289, 163, 289, 0, 0, 0, 0,
  0, 0, 0, 0, 873, 0, 0, 0, 0, 0, 0, 220, 220, 220, 220, 743, 220, 220, 220, 220, 220, 220, 220, 220, 390, 220, 220,
  220, 0, 0, 0, 0, 289, 510, 289, 289, 0, 0, 417, 163, 163, 289, 289, 0, 471, 0, 0, 0, 0, 0, 354304, 0, 0, 206, 206, 0,
  0, 0, 0, 0, 206, 0, 521, 525, 0, 528, 0, 0, 0, 0, 0, 0, 0, 0, 0, 179, 179, 179, 0, 0, 0, 0, 0, 0, 0, 0, 532480, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 354304, 179, 0, 0, 220, 220, 220, 220, 220, 220, 585, 220, 220, 220, 220, 0, 0, 0, 0, 0,
  0, 0, 190, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 199, 0, 0, 0, 199, 199, 0, 0, 0, 763, 0, 0, 163, 163, 163, 163, 163, 163,
  163, 773, 163, 163, 163, 163, 401, 453, 454, 163, 163, 163, 460, 163, 163, 446, 163, 0, 0, 289, 289, 289, 289, 289,
  289, 289, 289, 289, 289, 289, 289, 289, 0, 1066, 0, 820, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289,
  289, 289, 289, 289, 508, 0, 0, 870, 0, 0, 0, 873, 0, 0, 0, 0, 0, 733, 0, 0, 0, 0, 0, 673792, 686080, 0, 763904, 0,
  802816, 0, 0, 0, 0, 0, 0, 532480, 200, 0, 0, 0, 0, 350208, 0, 0, 0, 0, 0, 220, 220, 881, 882, 220, 220, 220, 220, 220,
  220, 887, 220, 220, 220, 220, 220, 220, 220, 220, 754, 220, 220, 220, 0, 0, 0, 0, 0, 0, 563525, 672069, 563525,
  563525, 563525, 563525, 563525, 563525, 563525, 717125, 904, 163, 906, 907, 163, 163, 163, 163, 163, 163, 163, 163,
  163, 163, 916, 163, 163, 163, 163, 1106, 163, 163, 163, 163, 163, 289, 289, 289, 289, 289, 289, 163, 163, 163, 163,
  1371, 944, 289, 946, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 956, 289, 289, 289, 289, 0, 1202, 163,
  1291, 163, 163, 163, 163, 163, 163, 163, 289, 289, 289, 289, 1180, 289, 289, 289, 289, 289, 289, 289, 289, 1059, 289,
  289, 289, 289, 289, 1063, 289, 289, 0, 0, 1067, 0, 0, 171, 0, 0, 0, 0, 0, 163, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 173, 990, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 0, 0, 0, 0, 0, 163, 163, 1027, 163,
  163, 163, 163, 163, 163, 163, 289, 289, 1037, 1038, 289, 289, 289, 289, 0, 0, 163, 427, 163, 289, 289, 0, 289, 0, 0,
  0, 0, 364, 0, 0, 0, 0, 0, 0, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152,
  561152, 0, 0, 0, 0, 1316, 163, 289, 289, 289, 289, 1322, 1323, 289, 1325, 289, 0, 163, 163, 163, 163, 0, 0, 416, 163,
  163, 163, 434, 163, 163, 163, 163, 0, 0, 163, 455, 456, 163, 163, 461, 163, 445, 447, 0, 214, 214, 222, 222, 222, 214,
  222, 214, 214, 214, 214, 214, 214, 214, 254, 254, 255, 255, 214, 255, 259, 214, 255, 255, 255, 255, 255, 222, 255,
  259, 280, 280, 291, 280, 280, 280, 280, 280, 291, 280, 280, 280, 311, 280, 291, 291, 317, 317, 317, 280, 317, 280,
  317, 6145, 41113, 3, 4, 0, 0, 0, 0, 0, 0, 0, 200, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 161, 0, 0, 0, 161, 161, 289, 289, 289,
  289, 513, 0, 163, 163, 163, 289, 289, 0, 289, 0, 0, 0, 0, 0, 673792, 686080, 0, 763904, 0, 802816, 0, 0, 0, 0, 567632,
  73728, 567632, 0, 73728, 0, 0, 0, 0, 0, 0, 532480, 0, 0, 567, 220, 220, 220, 220, 220, 220, 220, 575, 220, 220, 220,
  220, 220, 220, 220, 220, 220, 587, 220, 0, 0, 0, 0, 0, 163, 51847, 528, 648, 650, 289, 289, 289, 289, 656, 289, 660,
  289, 289, 289, 289, 0, 0, 163, 163, 163, 289, 289, 0, 289, 0, 0, 0, 665, 289, 289, 289, 289, 289, 289, 289, 289, 289,
  289, 289, 289, 289, 289, 289, 693, 163, 163, 807, 163, 163, 163, 51847, 289, 289, 289, 289, 289, 289, 289, 289, 289,
  965, 289, 289, 289, 289, 289, 289, 289, 821, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 0,
  0, 0, 289, 289, 289, 289, 289, 838, 839, 289, 289, 289, 289, 289, 289, 289, 289, 289, 1048, 289, 289, 289, 289, 289,
  289, 0, 0, 0, 871, 0, 0, 873, 0, 0, 0, 0, 0, 733, 0, 0, 0, 0, 0, 673792, 686080, 0, 763904, 0, 802816, 0, 0, 0, 179,
  0, 220, 220, 1082, 220, 220, 220, 220, 0, 0, 1086, 0, 163, 163, 163, 163, 163, 430, 163, 436, 163, 163, 163, 163, 163,
  446, 163, 289, 289, 289, 289, 289, 1187, 289, 289, 289, 289, 289, 289, 289, 289, 0, 0, 1137, 0, 0, 0, 0, 0, 215, 215,
  223, 223, 223, 215, 223, 215, 215, 246, 246, 246, 246, 246, 246, 246, 260, 246, 246, 246, 246, 246, 246, 223, 246,
  260, 281, 281, 292, 281, 281, 281, 281, 281, 292, 281, 281, 281, 260, 281, 292, 292, 292, 292, 281, 292, 281, 292,
  6145, 41113, 3, 4, 0, 0, 0, 0, 0, 0, 0, 200, 0, 0, 0, 357, 0, 0, 0, 0, 220, 220, 381, 220, 220, 220, 220, 220, 220,
  220, 220, 220, 0, 0, 0, 0, 163, 163, 163, 163, 163, 405, 163, 163, 163, 163, 163, 163, 431, 163, 163, 163, 163, 163,
  163, 163, 163, 911, 912, 163, 163, 163, 163, 163, 163, 289, 289, 289, 289, 514, 0, 163, 163, 163, 231909, 289, 0, 289,
  0, 0, 0, 0, 0, 673792, 686080, 0, 763904, 0, 802816, 0, 0, 0, 179, 179, 179, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  412, 413, 0, 220, 581, 220, 582, 220, 220, 220, 220, 220, 220, 220, 0, 0, 0, 0, 0, 0, 0, 0, 163, 163, 163, 163, 51847,
  528, 649, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 674, 289, 675, 676, 163, 905, 163, 163, 163,
  163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 1025, 289, 970, 971, 289, 289, 0, 0, 856, 0, 858, 0, 0, 0,
  0, 0, 0, 0, 0, 163, 0, 0, 0, 192, 0, 0, 0, 1055, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 0, 0, 0,
  0, 0, 1081, 220, 220, 220, 220, 220, 220, 0, 0, 0, 0, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163,
  1218, 163, 163, 1094, 163, 163, 163, 163, 163, 163, 163, 1099, 163, 163, 163, 163, 163, 163, 795, 163, 163, 163, 163,
  163, 163, 163, 163, 163, 1258, 289, 289, 289, 289, 289, 289, 289, 289, 1120, 289, 289, 289, 289, 289, 289, 289, 289,
  289, 1127, 289, 289, 289, 289, 0, 0, 163, 163, 163, 489, 289, 0, 289, 0, 0, 519, 289, 1301, 289, 289, 289, 289, 289,
  289, 0, 163, 163, 163, 163, 163, 163, 163, 289, 1227, 289, 289, 289, 289, 289, 289, 289, 485, 289, 289, 289, 289, 289,
  289, 289, 289, 0, 163, 1310, 163, 163, 163, 163, 163, 216, 216, 224, 224, 224, 240, 224, 240, 240, 240, 240, 250, 250,
  250, 250, 250, 261, 250, 250, 250, 250, 250, 250, 224, 250, 261, 282, 282, 293, 282, 282, 282, 282, 282, 293, 282,
  282, 282, 312, 282, 293, 293, 293, 293, 282, 293, 282, 293, 6145, 41113, 3, 4, 0, 0, 0, 0, 0, 0, 0, 200, 0, 0, 0, 358,
  0, 0, 0, 0, 333, 0, 179, 179, 179, 0, 0, 0, 0, 340, 0, 342, 0, 0, 0, 0, 0, 0, 724992, 0, 0, 0, 847872, 0, 0, 0, 0, 0,
  0, 0, 0, 540, 0, 0, 0, 0, 0, 0, 0, 0, 0, 349, 0, 220, 220, 220, 220, 220, 360, 0, 362, 0, 0, 0, 365, 0, 0, 0, 0, 220,
  220, 220, 372, 220, 220, 220, 220, 220, 220, 388, 220, 220, 393, 220, 220, 0, 0, 0, 0, 0, 404, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 806912, 0, 561152, 220, 379, 220, 384, 220, 387, 220, 389, 220, 220, 220, 220, 0, 0, 0, 0, 0, 163, 163,
  163, 163, 163, 1008, 163, 163, 163, 163, 163, 909, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 289, 289, 289,
  289, 942, 289, 397, 0, 400, 402, 0, 365, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 778240, 0, 0, 0, 163, 163, 420, 163,
  163, 429, 163, 435, 163, 438, 163, 163, 442, 444, 163, 163, 163, 163, 1172, 163, 163, 289, 289, 289, 289, 289, 289,
  289, 289, 1182, 289, 289, 289, 474, 289, 289, 483, 289, 491, 289, 494, 289, 289, 499, 502, 505, 163, 163, 634, 163, 0,
  163, 163, 163, 639, 163, 163, 641, 163, 624, 163, 163, 163, 163, 543, 163, 163, 163, 163, 163, 163, 163, 163, 163,
  163, 163, 1112, 289, 289, 289, 289, 289, 163, 51847, 528, 289, 289, 289, 289, 289, 289, 289, 289, 289, 661, 289, 289,
  664, 289, 678, 289, 289, 289, 289, 289, 289, 289, 289, 687, 289, 289, 289, 692, 289, 289, 289, 289, 289, 0, 0, 856, 0,
  858, 0, 0, 0, 0, 0, 978, 0, 695, 0, 163, 289, 289, 698, 0, 0, 0, 0, 0, 0, 0, 0, 528, 0, 0, 0, 0, 0, 0, 0, 532, 0, 179,
  179, 711, 712, 713, 0, 0, 0, 0, 0, 0, 0, 0, 722, 0, 0, 0, 0, 0, 163, 1005, 163, 163, 163, 163, 163, 163, 163, 163,
  163, 938, 939, 289, 289, 289, 289, 289, 220, 220, 750, 220, 220, 751, 220, 220, 220, 220, 220, 220, 0, 0, 0, 0, 899,
  0, 901, 901, 163, 163, 163, 760, 761, 0, 0, 698, 698, 766, 163, 767, 768, 163, 163, 163, 163, 163, 163, 910, 163, 163,
  163, 163, 163, 163, 163, 163, 163, 1164, 163, 163, 163, 163, 163, 163, 163, 776, 163, 163, 779, 163, 163, 163, 163,
  163, 784, 163, 163, 786, 787, 163, 163, 163, 163, 1223, 163, 163, 289, 289, 289, 289, 289, 289, 289, 289, 289, 0, 163,
  163, 163, 163, 163, 163, 163, 163, 806, 163, 808, 163, 810, 51847, 811, 289, 812, 289, 814, 289, 289, 289, 289, 0, 0,
  163, 163, 163, 289, 289, 350, 289, 0, 0, 0, 289, 289, 289, 289, 289, 824, 289, 289, 827, 289, 289, 289, 289, 289, 832,
  289, 289, 289, 289, 289, 0, 0, 178339, 178465, 0, 0, 0, 0, 0, 0, 0, 0, 0, 595, 0, 597, 598, 595, 163, 163, 289, 289,
  835, 836, 837, 289, 289, 289, 289, 842, 289, 844, 289, 289, 289, 848, 289, 289, 289, 289, 853, 0, 0, 163, 289, 0, 0,
  856, 0, 0, 0, 0, 0, 168, 0, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 874, 0, 549, 0, 0, 0, 0, 0, 0, 0, 0, 26624, 28672,
  0, 0, 0, 0, 0, 24576, 868, 0, 0, 0, 0, 0, 873, 0, 0, 0, 0, 0, 733, 0, 0, 877, 878, 0, 220, 220, 220, 220, 220, 884,
  220, 220, 220, 220, 220, 220, 220, 220, 220, 576, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 895, 0, 0, 0, 0,
  0, 0, 0, 0, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 921, 163, 163, 163, 163, 163, 163,
  163, 163, 163, 929, 163, 163, 163, 163, 544, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 627, 163, 163,
  163, 163, 932, 163, 934, 163, 163, 163, 936, 163, 163, 163, 289, 289, 289, 289, 289, 289, 289, 289, 289, 1327, 163,
  163, 163, 163, 289, 945, 289, 289, 948, 289, 950, 289, 289, 289, 289, 289, 289, 289, 289, 289, 1242, 289, 0, 0, 0, 0,
  0, 289, 289, 289, 289, 289, 961, 962, 289, 289, 289, 289, 289, 289, 289, 289, 289, 0, 1136, 0, 0, 0, 0, 0, 0, 289,
  289, 289, 972, 289, 0, 0, 856, 0, 858, 0, 0, 0, 0, 0, 0, 0, 0, 163, 177, 0, 0, 0, 177, 0, 0, 0, 980, 0, 0, 0, 0, 0,
  985, 873, 0, 0, 0, 0, 0, 0, 220, 220, 741, 220, 220, 220, 220, 220, 746, 220, 220, 289, 289, 289, 289, 1044, 289, 289,
  289, 289, 289, 289, 289, 289, 1052, 1053, 289, 289, 289, 289, 289, 0, 855, 163, 289, 0, 0, 856, 0, 0, 0, 0, 0, 175,
  176, 0, 163, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 184, 0, 0, 289, 289, 289, 289, 289, 1060, 289, 289, 289, 1062, 289,
  289, 289, 1065, 0, 0, 0, 0, 120832, 0, 0, 0, 0, 0, 0, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152,
  561152, 561152, 561152, 561152, 0, 116736, 0, 0, 220, 220, 220, 1083, 220, 220, 220, 0, 1085, 0, 0, 163, 163, 163,
  163, 1092, 1118, 289, 289, 289, 289, 289, 289, 289, 289, 289, 1126, 289, 289, 289, 289, 289, 0, 0, 163, 289, 0, 0,
  856, 0, 0, 0, 0, 163, 1157, 163, 163, 163, 163, 163, 163, 1163, 163, 163, 163, 1166, 1167, 1168, 163, 163, 163, 163,
  1253, 163, 163, 163, 163, 289, 289, 289, 289, 289, 289, 289, 289, 289, 0, 163, 163, 1330, 1331, 163, 163, 163, 1171,
  163, 1174, 163, 289, 289, 289, 1179, 289, 289, 289, 289, 289, 0, 0, 163, 289, 0, 699, 856, 0, 0, 0, 0, 289, 289, 1184,
  289, 1186, 289, 289, 289, 289, 1190, 1192, 289, 1194, 1195, 0, 0, 0, 0, 348160, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  53248, 0, 0, 0, 0, 0, 0, 0, 1196, 0, 0, 0, 0, 0, 0, 0, 220, 220, 220, 220, 220, 220, 220, 0, 0, 0, 1087, 163, 163,
  1090, 163, 163, 1219, 163, 163, 163, 163, 163, 163, 289, 289, 1228, 289, 289, 289, 289, 289, 289, 289, 1267, 289, 289,
  0, 0, 1202, 220, 163, 163, 289, 289, 289, 289, 1289, 1202, 163, 163, 163, 163, 163, 163, 163, 163, 1298, 289, 289,
  289, 289, 289, 0, 975, 856, 0, 858, 0, 0, 0, 0, 0, 0, 0, 0, 0, 863, 0, 0, 0, 0, 163, 1332, 163, 163, 163, 1336, 289,
  289, 1338, 289, 289, 289, 289, 289, 0, 163, 163, 163, 424, 163, 163, 432, 163, 163, 163, 163, 163, 163, 163, 163,
  1033, 163, 289, 289, 289, 289, 289, 289, 1357, 163, 163, 163, 1361, 289, 1363, 289, 289, 289, 1367, 163, 163, 163,
  163, 163, 780, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 289, 1036, 289, 289, 289, 289, 210, 210, 225, 225,
  225, 210, 225, 210, 210, 210, 210, 210, 210, 210, 210, 210, 262, 210, 210, 210, 210, 210, 210, 225, 210, 262, 262,
  262, 294, 262, 262, 262, 262, 262, 294, 262, 262, 262, 262, 262, 294, 294, 294, 294, 262, 294, 262, 294, 6145, 41113,
  3, 4, 0, 0, 0, 0, 0, 0, 0, 200, 354, 0, 0, 0, 0, 0, 0, 0, 0, 0, 396, 0, 0, 0, 0, 0, 0, 161, 162, 163, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 331, 0, 0, 0, 363, 0, 0, 0, 0, 0, 0, 0, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 888,
  889, 890, 220, 220, 220, 570, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 0, 0, 0, 354, 163, 51847,
  528, 289, 289, 289, 289, 289, 289, 657, 289, 289, 289, 289, 289, 289, 289, 1307, 0, 163, 163, 163, 163, 1313, 163,
  163, 163, 163, 791, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 915, 163, 917, 289, 289, 289,
  1058, 289, 289, 289, 289, 289, 289, 289, 289, 289, 0, 0, 0, 0, 0, 0, 0, 0, 0, 329728, 0, 0, 0, 226, 226, 226, 241,
  226, 241, 241, 241, 241, 241, 241, 241, 241, 241, 263, 241, 241, 241, 241, 241, 241, 226, 241, 263, 263, 263, 295,
  263, 263, 263, 263, 263, 295, 263, 263, 263, 263, 263, 295, 295, 295, 295, 263, 295, 263, 295, 6145, 41113, 3, 4, 0,
  0, 0, 0, 0, 0, 0, 328, 0, 0, 0, 220, 220, 220, 220, 374, 0, 0, 163, 1210, 163, 163, 163, 163, 163, 1214, 163, 163,
  1216, 163, 163, 163, 163, 0, 636, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 1255, 163, 163, 289, 289, 289,
  289, 1259, 289, 289, 1234, 289, 289, 1236, 289, 289, 289, 289, 289, 289, 289, 0, 0, 0, 0, 0, 0, 976, 0, 0, 0, 0, 1244,
  1202, 220, 220, 1246, 220, 220, 0, 163, 163, 163, 163, 1249, 163, 163, 163, 163, 163, 1277, 163, 163, 163, 289, 1281,
  289, 289, 289, 289, 289, 0, 0, 163, 289, 0, 0, 0, 703, 0, 0, 0, 289, 289, 289, 289, 1265, 289, 289, 289, 289, 289, 0,
  0, 1202, 220, 163, 163, 163, 163, 608, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 1224, 163, 289, 289,
  289, 289, 289, 289, 289, 289, 289, 841, 289, 289, 289, 289, 289, 289, 289, 163, 289, 289, 1373, 1374, 289, 289, 163,
  163, 163, 163, 289, 289, 289, 289, 163, 289, 163, 289, 6145, 41113, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 88064, 88064, 88064,
  88064, 88064, 88064, 88064, 88064, 0, 41113, 3, 4, 0, 0, 319, 0, 0, 0, 334, 179, 179, 179, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 556, 0, 0, 0, 163, 418, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 801, 163, 803,
  163, 163, 163, 451, 163, 0, 0, 163, 418, 163, 163, 163, 163, 163, 163, 163, 0, 0, 163, 163, 163, 163, 163, 163, 462,
  163, 448, 0, 289, 289, 472, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 955, 289, 957, 289, 289,
  511, 289, 0, 0, 418, 163, 163, 289, 289, 0, 472, 0, 0, 0, 0, 163, 0, 0, 0, 0, 0, 0, 220, 0, 163, 163, 163, 423, 163,
  163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 289, 940, 289, 289, 289, 289, 289, 289, 289, 289, 682, 289, 289,
  289, 289, 289, 289, 289, 289, 289, 289, 289, 0, 0, 1243, 0, 0, 0, 173, 0, 0, 0, 0, 0, 0, 163, 0, 0, 0, 0, 0, 173, 0,
  0, 0, 0, 0, 0, 0, 179, 163, 0, 0, 0, 227, 227, 227, 242, 227, 242, 242, 247, 247, 251, 252, 252, 252, 252, 257, 252,
  264, 257, 252, 252, 252, 252, 252, 227, 252, 264, 283, 283, 296, 283, 283, 283, 283, 283, 296, 283, 283, 283, 264,
  283, 296, 314, 296, 296, 296, 283, 296, 283, 296, 6145, 41113, 3, 4, 0, 0, 0, 0, 0, 0, 0, 354, 0, 0, 0, 220, 220, 220,
  220, 375, 0, 163, 163, 421, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 927, 928, 163, 163, 163, 289,
  289, 289, 475, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 689, 289, 289, 289, 163, 603, 163, 163,
  163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 616, 163, 163, 163, 163, 1276, 163, 163, 163, 163, 289, 289, 289,
  289, 1283, 289, 289, 289, 289, 0, 0, 163, 457, 163, 289, 289, 0, 289, 0, 0, 0, 0, 167, 167, 0, 0, 167, 167, 69799,
  167, 167, 167, 167, 167, 69799, 69799, 69799, 183, 167, 167, 167, 167, 167, 167, 167, 631, 163, 163, 163, 0, 163, 163,
  163, 163, 163, 163, 163, 163, 163, 163, 163, 289, 289, 289, 1115, 289, 289, 163, 51847, 528, 289, 289, 289, 289, 653,
  289, 289, 289, 289, 289, 289, 289, 289, 686, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 668, 289, 289,
  289, 289, 289, 289, 289, 289, 289, 289, 289, 496, 498, 289, 289, 507, 163, 790, 163, 163, 163, 163, 163, 163, 797,
  163, 163, 163, 163, 163, 163, 163, 611, 163, 163, 163, 163, 163, 163, 163, 617, 289, 289, 851, 289, 289, 0, 0, 163,
  289, 0, 0, 0, 0, 0, 0, 0, 0, 0, 354, 0, 0, 0, 0, 0, 0, 0, 1068, 0, 0, 0, 0, 1073, 0, 0, 1074, 0, 0, 1077, 220, 1079,
  220, 220, 220, 220, 220, 220, 574, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 756, 220, 0, 0, 0, 759, 220, 220,
  220, 220, 220, 1084, 220, 0, 0, 0, 0, 163, 1089, 163, 1091, 163, 163, 163, 163, 1335, 289, 289, 289, 289, 289, 289,
  289, 289, 1343, 0, 163, 163, 163, 426, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 1173, 163, 289, 289,
  289, 289, 289, 289, 289, 289, 1181, 289, 1130, 289, 289, 1132, 289, 289, 289, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 596, 0, 0,
  0, 163, 163, 0, 0, 1143, 0, 220, 220, 220, 220, 1148, 220, 220, 220, 0, 0, 0, 163, 289, 289, 0, 0, 0, 703, 0, 0, 0,
  709, 0, 528, 289, 289, 289, 1303, 1304, 1305, 1306, 289, 0, 163, 163, 163, 163, 163, 163, 163, 623, 163, 163, 163,
  163, 163, 163, 163, 163, 781, 163, 163, 163, 163, 163, 163, 163, 163, 796, 163, 798, 163, 800, 163, 163, 163, 163,
  163, 1346, 1347, 163, 163, 163, 163, 289, 289, 289, 1352, 1353, 289, 289, 289, 163, 163, 163, 163, 1348, 1349, 163,
  289, 289, 289, 289, 289, 1354, 1355, 289, 163, 163, 163, 452, 0, 0, 163, 163, 163, 425, 163, 163, 163, 163, 163, 0, 0,
  163, 163, 421, 163, 163, 163, 163, 163, 163, 0, 0, 163, 163, 163, 163, 431, 163, 163, 163, 163, 0, 0, 163, 163, 163,
  163, 163, 163, 163, 163, 163, 0, 0, 163, 163, 163, 163, 163, 163, 163, 163, 465, 0, 163, 289, 289, 1382, 1383, 163,
  289, 163, 289, 163, 289, 0, 0, 0, 0, 0, 0, 0, 559, 0, 0, 0, 0, 559, 0, 0, 220, 195, 0, 0, 0, 0, 0, 0, 0, 26624, 28672,
  0, 211, 0, 211, 0, 24576, 211, 211, 228, 228, 228, 243, 228, 243, 243, 243, 243, 243, 243, 243, 243, 243, 265, 243,
  243, 243, 243, 243, 243, 228, 277, 265, 265, 265, 297, 265, 265, 265, 265, 265, 297, 265, 265, 265, 265, 265, 297,
  297, 297, 297, 265, 297, 265, 297, 6145, 41113, 3, 4, 0, 0, 0, 0, 0, 0, 0, 593, 0, 0, 0, 0, 0, 0, 599, 601, 161, 162,
  163, 0, 0, 0, 0, 0, 0, 0, 0, 328, 0, 0, 0, 0, 0, 237, 0, 237, 237, 237, 237, 237, 237, 237, 237, 237, 0, 237, 237,
  237, 237, 237, 237, 237, 237, 0, 0, 0, 289, 289, 289, 289, 477, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289,
  688, 289, 289, 289, 289, 220, 220, 569, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 0, 0, 0, 396,
  163, 163, 604, 163, 163, 163, 163, 163, 163, 163, 163, 614, 163, 163, 163, 163, 0, 163, 163, 163, 163, 163, 163, 163,
  163, 163, 163, 645, 163, 633, 163, 163, 0, 163, 604, 163, 163, 163, 163, 163, 163, 163, 163, 163, 1034, 289, 289, 289,
  289, 289, 289, 163, 51847, 528, 289, 289, 289, 289, 289, 654, 289, 289, 289, 289, 289, 289, 289, 670, 289, 289, 289,
  289, 289, 289, 289, 289, 671, 289, 289, 673, 289, 289, 289, 289, 289, 289, 666, 289, 289, 289, 289, 289, 289, 289,
  289, 289, 289, 289, 289, 289, 289, 501, 289, 289, 289, 289, 289, 289, 683, 289, 289, 289, 289, 289, 289, 289, 691,
  289, 289, 289, 289, 0, 0, 516, 163, 447, 289, 289, 0, 518, 0, 0, 0, 0, 220, 1146, 220, 220, 220, 1149, 220, 1151, 0,
  1153, 1154, 163, 0, 0, 0, 604, 289, 654, 0, 0, 0, 0, 0, 0, 0, 0, 0, 528, 0, 0, 0, 0, 0, 0, 531, 0, 0, 179, 179, 220,
  892, 220, 220, 220, 0, 0, 0, 0, 0, 0, 0, 0, 163, 163, 163, 163, 163, 163, 163, 163, 774, 163, 918, 163, 163, 163, 163,
  163, 163, 163, 924, 163, 163, 163, 163, 163, 163, 163, 1032, 163, 163, 289, 289, 289, 289, 289, 289, 163, 163, 163,
  163, 289, 289, 289, 289, 163, 289, 958, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 966, 289, 289, 289, 289, 0,
  0, 163, 163, 163, 490, 289, 0, 289, 0, 0, 0, 0, 172, 0, 0, 0, 0, 0, 0, 0, 0, 179, 163, 0, 979, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 220, 1078, 220, 220, 220, 220, 992, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 0,
  0, 0, 328, 289, 289, 1042, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 830, 289, 289, 289, 0, 0,
  0, 1198, 0, 0, 0, 0, 220, 220, 220, 220, 220, 220, 220, 0, 0, 897, 0, 0, 0, 0, 0, 163, 163, 163, 163, 163, 163, 163,
  163, 1011, 163, 163, 163, 289, 1372, 289, 289, 289, 289, 163, 163, 163, 163, 289, 289, 289, 289, 163, 163, 163, 605,
  163, 609, 163, 163, 163, 163, 613, 163, 163, 163, 163, 163, 289, 289, 289, 289, 1339, 1340, 289, 289, 289, 0, 1344, 0,
  0, 229, 229, 229, 0, 229, 0, 0, 248, 248, 248, 248, 248, 248, 248, 266, 248, 248, 248, 248, 248, 248, 229, 248, 266,
  266, 266, 298, 266, 266, 266, 266, 266, 298, 266, 266, 266, 266, 266, 298, 298, 298, 298, 266, 298, 266, 298, 6145,
  41113, 3, 4, 0, 0, 0, 0, 0, 0, 0, 718, 719, 0, 0, 0, 0, 0, 0, 0, 0, 0, 328, 0, 0, 0, 0, 0, 0, 289, 289, 289, 289, 478,
  289, 289, 487, 289, 289, 289, 289, 289, 289, 289, 289, 951, 952, 289, 289, 289, 289, 289, 289, 163, 51847, 528, 289,
  289, 289, 289, 289, 655, 289, 289, 289, 289, 289, 289, 289, 685, 289, 289, 289, 289, 289, 289, 289, 289, 0, 163, 163,
  1311, 1312, 163, 163, 163, 0, 0, 0, 637, 289, 655, 0, 0, 701, 0, 0, 0, 707, 0, 0, 528, 0, 0, 0, 728, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 179, 162, 162, 805, 163, 163, 163, 163, 163, 51847, 289, 289, 289, 289, 289, 289, 289, 818, 289,
  289, 289, 289, 289, 289, 1046, 289, 289, 289, 289, 289, 289, 289, 289, 289, 828, 289, 289, 289, 289, 289, 289, 289,
  289, 289, 289, 823, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 833, 0, 869, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 108544, 163, 933, 163, 163, 163, 163, 163, 937, 163, 163, 289, 289, 289, 289, 289, 289, 163, 163, 163, 1377,
  289, 289, 289, 1379, 163, 289, 289, 289, 289, 289, 949, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 0, 0, 1202,
  220, 163, 163, 289, 289, 1288, 289, 0, 1202, 163, 163, 163, 163, 163, 163, 163, 163, 163, 289, 289, 289, 289, 289,
  289, 289, 289, 1356, 0, 0, 230, 230, 230, 244, 230, 244, 244, 244, 244, 244, 244, 244, 244, 244, 267, 244, 244, 244,
  244, 244, 244, 230, 244, 267, 284, 284, 299, 284, 284, 284, 284, 284, 299, 284, 284, 284, 267, 284, 299, 299, 299,
  299, 284, 299, 284, 299, 6145, 41113, 3, 4, 0, 0, 0, 0, 0, 0, 0, 730, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 734, 0, 357, 0, 0,
  0, 161, 162, 163, 0, 0, 0, 0, 0, 0, 0, 0, 0, 329, 0, 0, 0, 0, 188, 0, 0, 0, 163, 0, 0, 0, 0, 0, 0, 188, 220, 220, 382,
  220, 220, 220, 220, 220, 220, 220, 394, 220, 0, 0, 0, 0, 0, 320, 0, 0, 0, 338, 0, 220, 220, 370, 220, 220, 414, 415,
  163, 163, 163, 163, 163, 433, 163, 163, 163, 163, 163, 163, 163, 163, 1110, 163, 289, 289, 289, 289, 289, 289, 449,
  163, 163, 163, 0, 0, 415, 163, 163, 163, 433, 163, 163, 163, 163, 0, 0, 163, 163, 163, 458, 432, 163, 163, 163, 163,
  0, 0, 163, 163, 163, 426, 163, 163, 163, 163, 163, 0, 0, 163, 163, 163, 427, 163, 163, 163, 163, 163, 0, 0, 163, 163,
  163, 457, 163, 163, 163, 163, 163, 0, 0, 163, 163, 163, 163, 459, 163, 163, 163, 163, 0, 0, 163, 163, 163, 163, 163,
  163, 163, 463, 163, 0, 289, 468, 289, 289, 289, 289, 289, 488, 289, 289, 289, 289, 289, 289, 289, 289, 1047, 289,
  1049, 289, 289, 289, 289, 1054, 509, 289, 289, 289, 0, 0, 163, 163, 163, 488, 289, 0, 289, 0, 0, 0, 0, 201, 0, 0, 201,
  26624, 28672, 201, 0, 0, 0, 0, 24576, 534, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 549, 0, 0, 880, 220, 220, 220,
  220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 577, 220, 220, 220, 220, 220, 220, 894, 220, 0, 896, 0, 0, 0, 0, 0,
  0, 163, 903, 163, 163, 163, 606, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 628, 163, 163, 163, 163,
  163, 920, 163, 163, 163, 163, 163, 163, 163, 926, 163, 163, 163, 163, 163, 794, 163, 163, 163, 163, 163, 163, 163,
  163, 163, 163, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 960, 289, 289, 289, 289, 289, 289, 289, 289,
  289, 289, 289, 829, 289, 289, 289, 289, 969, 289, 289, 289, 289, 0, 0, 0, 0, 0, 0, 0, 0, 977, 0, 0, 0, 0, 348160, 0,
  348160, 0, 348160, 0, 0, 0, 0, 0, 0, 0, 0, 0, 720, 0, 0, 0, 0, 0, 0, 0, 0, 0, 981, 0, 0, 0, 0, 0, 0, 0, 0, 987, 0, 0,
  220, 220, 220, 0, 220, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 75776, 0, 0, 0, 0, 220, 220, 220, 993, 220, 220, 995, 220,
  220, 997, 220, 220, 220, 220, 220, 0, 0, 0, 536, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 179, 161, 161, 0, 0, 1002, 0,
  0, 163, 163, 163, 163, 163, 163, 163, 1010, 163, 163, 163, 163, 163, 1362, 289, 289, 289, 289, 289, 163, 163, 163,
  163, 163, 289, 163, 163, 163, 163, 163, 289, 289, 289, 289, 289, 289, 163, 1368, 163, 163, 163, 163, 163, 163, 1015,
  163, 163, 163, 163, 163, 1021, 163, 163, 163, 163, 163, 163, 1031, 163, 163, 163, 289, 289, 289, 289, 289, 289, 289,
  289, 289, 0, 163, 1329, 163, 163, 163, 163, 163, 1028, 163, 1030, 163, 163, 163, 163, 289, 289, 289, 289, 289, 289,
  1376, 163, 163, 163, 1378, 289, 289, 289, 163, 1040, 289, 289, 1043, 289, 1045, 289, 289, 289, 289, 289, 1050, 289,
  289, 289, 289, 0, 0, 163, 163, 163, 289, 289, 94208, 289, 0, 0, 0, 289, 289, 1057, 289, 289, 289, 289, 289, 289, 289,
  289, 289, 289, 0, 0, 0, 1138, 0, 0, 0, 1140, 163, 163, 1095, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163,
  163, 163, 913, 163, 163, 163, 163, 163, 289, 289, 289, 1121, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289,
  289, 845, 289, 289, 289, 0, 1142, 0, 0, 1145, 220, 220, 220, 220, 220, 220, 220, 0, 0, 0, 163, 289, 289, 0, 699, 0, 0,
  0, 705, 0, 0, 0, 528, 1156, 163, 163, 163, 163, 163, 163, 1162, 163, 163, 163, 1165, 163, 163, 163, 163, 0, 163, 163,
  163, 163, 163, 163, 163, 163, 163, 644, 163, 289, 289, 289, 1185, 289, 289, 289, 1188, 289, 289, 289, 289, 289, 289,
  0, 0, 163, 289, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 92358, 0, 0, 0, 92476, 92476, 0, 0, 163, 163, 163, 1211, 1212, 1213,
  163, 163, 163, 163, 163, 163, 163, 163, 1257, 289, 289, 289, 289, 289, 289, 289, 163, 163, 163, 1222, 163, 163, 163,
  289, 289, 289, 289, 1229, 1230, 1231, 289, 289, 289, 289, 0, 1202, 163, 163, 163, 163, 163, 163, 163, 163, 163, 289,
  289, 289, 289, 289, 289, 289, 289, 289, 0, 163, 289, 289, 289, 289, 1237, 289, 289, 289, 289, 289, 289, 0, 0, 0, 0, 0,
  0, 0, 860, 0, 0, 0, 0, 864, 0, 0, 0, 163, 163, 163, 1252, 163, 163, 163, 163, 163, 289, 289, 289, 289, 289, 289, 1261,
  289, 289, 1302, 289, 289, 289, 289, 289, 1308, 163, 163, 163, 163, 163, 163, 1315, 163, 1317, 289, 289, 289, 289, 289,
  289, 1324, 289, 1326, 0, 163, 163, 163, 163, 0, 163, 163, 163, 163, 163, 163, 163, 642, 163, 163, 163, 163, 1358,
  1359, 163, 163, 289, 289, 1364, 1365, 289, 289, 163, 163, 163, 163, 163, 289, 163, 163, 163, 163, 163, 289, 315, 289,
  289, 163, 289, 289, 163, 289, 163, 289, 1386, 1387, 163, 289, 0, 0, 0, 0, 0, 0, 0, 6145, 0, 3, 4, 0, 0, 0, 0, 0,
  124928, 0, 0, 0, 0, 0, 0, 0, 176, 0, 0, 0, 0, 0, 0, 26624, 28672, 0, 176, 0, 176, 0, 24576, 217, 217, 231, 231, 231,
  217, 231, 217, 217, 217, 217, 217, 217, 217, 217, 217, 268, 217, 217, 217, 217, 217, 217, 231, 217, 268, 268, 268,
  300, 268, 268, 268, 268, 268, 300, 268, 268, 268, 268, 268, 300, 300, 300, 300, 268, 300, 268, 300, 6145, 41113, 3, 4,
  0, 0, 0, 0, 0, 0, 0, 6145, 0, 3, 571547, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 0, 0, 346, 0, 0, 0, 0, 0, 0, 200, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 721, 0, 0, 0, 0, 0, 0, 361, 0, 0, 0, 346, 0, 0, 0, 0, 0, 220, 220, 371, 220, 220, 220, 220, 220,
  220, 220, 753, 220, 220, 220, 220, 0, 0, 0, 0, 0, 200, 0, 0, 0, 200, 0, 0, 34816, 0, 0, 0, 378, 220, 220, 220, 386,
  220, 220, 220, 220, 392, 220, 220, 0, 0, 0, 0, 0, 350, 199, 200, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 200, 0, 0, 0, 200, 200,
  0, 163, 419, 422, 163, 428, 163, 163, 163, 437, 163, 163, 163, 163, 445, 447, 289, 289, 473, 476, 289, 482, 289, 289,
  289, 493, 495, 289, 289, 289, 503, 506, 632, 163, 163, 163, 0, 163, 163, 163, 163, 163, 163, 163, 163, 643, 163, 163,
  163, 163, 793, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 914, 163, 163, 163, 163, 289, 679, 289, 289,
  289, 289, 289, 289, 289, 289, 289, 289, 690, 289, 289, 289, 289, 0, 0, 163, 163, 448, 289, 289, 0, 289, 0, 0, 0, 0,
  269, 0, 0, 0, 0, 0, 0, 220, 0, 269, 285, 285, 849, 289, 289, 289, 289, 0, 0, 163, 289, 0, 0, 0, 0, 857, 0, 522, 526,
  0, 528, 0, 0, 0, 0, 0, 0, 0, 0, 0, 179, 179, 179, 0, 0, 0, 0, 0, 0, 0, 343, 190, 0, 0, 0, 0, 0, 859, 0, 526, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 723, 0, 0, 0, 1141, 0, 0, 0, 220, 220, 1147, 220, 220, 220, 220, 220, 0, 0, 0, 163, 289,
  289, 0, 700, 0, 0, 0, 706, 0, 0, 0, 528, 163, 163, 1158, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163,
  163, 1022, 163, 163, 163, 163, 163, 0, 1202, 220, 220, 220, 220, 220, 0, 1247, 163, 163, 163, 163, 163, 163, 163,
  1098, 163, 163, 163, 163, 163, 163, 163, 163, 1020, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 1275, 163, 163,
  163, 163, 163, 289, 289, 289, 1282, 289, 289, 289, 289, 0, 0, 163, 163, 464, 289, 517, 0, 289, 0, 0, 0, 0, 0, 673792,
  686080, 0, 763904, 0, 802816, 0, 0, 0, 567631, 179, 1300, 289, 289, 289, 289, 289, 289, 289, 0, 163, 163, 163, 163,
  163, 163, 163, 1176, 289, 289, 289, 289, 289, 289, 289, 289, 1268, 289, 0, 0, 1202, 220, 163, 163, 163, 289, 289, 163,
  289, 1384, 1385, 163, 289, 163, 289, 0, 0, 0, 0, 0, 0, 0, 6145, 0, 569498, 4, 0, 71680, 0, 0, 0, 301, 285, 285, 285,
  285, 285, 301, 285, 285, 285, 285, 285, 301, 301, 301, 301, 285, 301, 285, 301, 6145, 41113, 3, 4, 0, 0, 0, 0, 0, 0,
  0, 6145, 41113, 3, 4, 0, 0, 0, 0, 0, 0, 0, 352256, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86016, 0, 0, 86016, 0, 0, 0, 551, 0,
  555, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 220, 220, 220, 220, 377, 646, 51847, 528, 289, 289, 289, 289, 289, 289, 289,
  289, 289, 289, 663, 289, 289, 289, 289, 0, 1202, 163, 163, 163, 163, 163, 1295, 163, 163, 163, 289, 289, 1320, 289,
  289, 289, 289, 289, 289, 0, 1328, 163, 163, 163, 163, 0, 163, 637, 163, 163, 163, 163, 163, 163, 163, 163, 163, 1111,
  289, 1113, 289, 289, 1116, 289, 0, 0, 0, 696, 289, 697, 0, 0, 702, 0, 0, 0, 708, 0, 0, 528, 0, 0, 0, 729, 0, 0, 0, 0,
  0, 556, 0, 0, 0, 0, 0, 0, 0, 0, 204, 204, 0, 0, 0, 0, 0, 204, 0, 0, 709, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  545, 0, 289, 289, 289, 289, 479, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 954, 289, 289, 289, 289, 289,
  289, 289, 512, 0, 0, 163, 425, 163, 289, 289, 0, 289, 0, 0, 0, 0, 274, 0, 0, 0, 0, 0, 0, 220, 0, 274, 274, 274, 0,
  523, 527, 0, 528, 0, 0, 0, 0, 0, 0, 0, 0, 0, 179, 179, 179, 0, 0, 0, 0, 0, 341, 0, 0, 0, 0, 0, 0, 162, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 875, 0, 0, 0, 0, 163, 163, 1221, 163, 163, 163, 163, 289, 289, 289, 289, 289, 289, 289, 289, 1233,
  0, 177, 0, 0, 177, 0, 0, 177, 26624, 28672, 177, 177, 0, 177, 0, 24576, 177, 177, 232, 232, 232, 177, 232, 177, 177,
  177, 177, 177, 177, 177, 177, 177, 270, 177, 177, 177, 177, 177, 177, 232, 177, 270, 270, 270, 302, 270, 270, 270,
  270, 270, 302, 270, 270, 270, 270, 270, 302, 302, 302, 302, 270, 302, 270, 302, 6145, 41113, 3, 4, 0, 0, 0, 0, 0, 0,
  161, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 563, 0, 0, 0, 220, 161, 162, 163, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 332, 289,
  667, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 847, 289, 677, 289, 289, 289, 289, 289,
  289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 967, 289, 0, 737, 0, 0, 0, 220, 220, 220, 220, 220, 220, 220, 220,
  220, 220, 220, 757, 0, 0, 0, 0, 289, 850, 289, 852, 289, 854, 0, 163, 289, 0, 0, 0, 0, 0, 0, 0, 0, 0, 408, 0, 0, 0, 0,
  0, 0, 163, 919, 163, 163, 922, 163, 163, 163, 163, 163, 163, 163, 163, 163, 930, 163, 163, 163, 635, 0, 163, 163, 163,
  163, 163, 163, 163, 163, 163, 163, 163, 1159, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 289, 289, 289, 289,
  289, 943, 289, 289, 289, 959, 289, 289, 289, 963, 289, 289, 289, 289, 289, 289, 289, 289, 1241, 289, 289, 0, 0, 0, 0,
  0, 289, 289, 289, 289, 973, 974, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86016, 0, 0, 0, 289, 1041, 289, 289, 289, 289,
  289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 1051, 289, 289, 289, 289, 289, 289, 289, 289, 1133, 289, 289, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 1075, 0, 220, 220, 220, 220, 289, 1287, 289, 289, 0, 1202, 163, 163, 163, 163, 163, 163, 163,
  163, 163, 289, 1177, 289, 289, 289, 289, 289, 289, 289, 163, 163, 289, 1319, 289, 289, 289, 289, 289, 289, 289, 0,
  163, 163, 163, 163, 0, 163, 163, 163, 163, 640, 163, 163, 163, 163, 163, 163, 1097, 163, 163, 163, 163, 163, 163, 163,
  163, 163, 612, 163, 163, 163, 163, 163, 163, 163, 163, 163, 1360, 163, 289, 289, 289, 289, 1366, 289, 163, 163, 163,
  163, 163, 923, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 1161, 163, 163, 163, 163, 163, 163, 163, 163, 1169,
  196, 197, 0, 0, 0, 0, 0, 0, 26624, 28672, 0, 197, 0, 197, 0, 24576, 218, 218, 233, 233, 233, 218, 233, 218, 218, 218,
  218, 218, 218, 218, 218, 218, 271, 218, 218, 218, 218, 218, 218, 233, 278, 271, 286, 286, 303, 286, 286, 286, 286,
  286, 303, 286, 286, 286, 271, 286, 303, 303, 303, 303, 286, 303, 286, 303, 6145, 41113, 3, 4, 0, 0, 0, 0, 0, 0, 174,
  0, 0, 0, 0, 0, 0, 179, 163, 0, 161, 162, 163, 0, 0, 0, 0, 0, 0, 326, 0, 0, 0, 0, 0, 0, 0, 0, 407, 0, 409, 410, 0, 0,
  0, 367, 0, 326, 0, 0, 0, 0, 0, 200, 0, 0, 0, 0, 0, 0, 0, 359, 220, 220, 383, 220, 220, 220, 220, 220, 220, 220, 220,
  220, 0, 0, 0, 0, 1088, 163, 163, 163, 163, 0, 399, 0, 0, 0, 0, 399, 0, 0, 0, 399, 399, 0, 0, 0, 359, 399, 416, 163,
  163, 163, 163, 163, 434, 163, 163, 163, 163, 163, 163, 163, 163, 1279, 163, 289, 289, 289, 289, 289, 289, 289, 826,
  289, 289, 289, 289, 289, 289, 289, 289, 1189, 289, 289, 289, 289, 289, 0, 0, 289, 469, 289, 289, 289, 289, 289, 489,
  289, 289, 289, 289, 289, 289, 289, 289, 1061, 289, 289, 289, 289, 289, 0, 0, 0, 220, 568, 220, 571, 220, 573, 220,
  220, 220, 220, 220, 220, 220, 578, 220, 220, 220, 220, 220, 220, 220, 996, 220, 220, 220, 220, 220, 220, 220, 0, 602,
  163, 163, 607, 163, 163, 610, 163, 163, 163, 163, 163, 163, 163, 163, 163, 1350, 289, 289, 289, 289, 289, 289, 289,
  163, 618, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 804, 163, 51847, 528, 289, 289,
  289, 652, 289, 289, 658, 289, 289, 662, 289, 289, 289, 289, 0, 0, 163, 424, 163, 487, 289, 0, 289, 0, 0, 0, 0, 187, 0,
  0, 0, 163, 0, 0, 0, 0, 0, 0, 187, 891, 220, 220, 220, 220, 0, 0, 0, 0, 0, 0, 0, 0, 902, 163, 163, 163, 163, 809, 163,
  51847, 289, 289, 289, 289, 815, 289, 289, 289, 289, 0, 0, 163, 163, 163, 486, 289, 0, 289, 0, 0, 0, 0, 1001, 0, 0, 0,
  163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 788, 289, 1056, 289, 289, 289, 289,
  289, 289, 289, 289, 289, 289, 289, 0, 0, 0, 703, 0, 709, 0, 0, 0, 0, 0, 0, 0, 0, 1070, 0, 0, 0, 0, 0, 0, 0, 0, 220,
  220, 220, 220, 220, 220, 220, 0, 289, 289, 289, 289, 289, 1123, 289, 289, 289, 289, 289, 289, 289, 289, 289, 1129, 0,
  1197, 0, 0, 0, 0, 0, 0, 220, 220, 220, 220, 220, 220, 1207, 0, 0, 0, 554, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 220, 220,
  220, 220, 376, 289, 289, 289, 289, 289, 1238, 289, 289, 289, 289, 289, 0, 0, 0, 0, 0, 0, 350, 200, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 178, 0, 0, 179, 163, 0, 163, 1273, 1274, 163, 163, 163, 163, 163, 163, 289, 289, 289, 289, 289, 1284,
  1285, 163, 163, 1318, 289, 289, 289, 289, 289, 289, 289, 289, 0, 163, 163, 163, 163, 163, 1314, 163, 163, 163, 1333,
  163, 163, 289, 289, 289, 289, 289, 289, 1341, 289, 289, 0, 163, 163, 163, 425, 163, 163, 163, 163, 163, 163, 163, 163,
  163, 163, 163, 1035, 289, 289, 289, 289, 1039, 1345, 163, 163, 163, 163, 163, 163, 289, 1351, 289, 289, 289, 289, 289,
  289, 163, 163, 163, 778, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 1256, 163, 289, 289, 289, 289,
  289, 289, 289, 486, 289, 289, 289, 289, 289, 289, 289, 289, 0, 1309, 163, 163, 163, 163, 163, 163, 0, 0, 234, 234,
  234, 0, 234, 245, 245, 245, 245, 245, 245, 253, 253, 253, 245, 253, 272, 245, 253, 253, 253, 253, 253, 234, 253, 272,
  287, 287, 304, 287, 287, 287, 287, 287, 304, 287, 287, 287, 313, 287, 304, 304, 304, 304, 287, 304, 287, 304, 6145,
  41113, 3, 4, 0, 0, 0, 0, 0, 0, 351, 200, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 367, 220, 368, 220, 220, 220, 220, 380, 220,
  385, 220, 220, 220, 220, 391, 220, 220, 220, 0, 0, 0, 0, 0, 538, 0, 0, 0, 0, 0, 0, 544, 0, 0, 548, 398, 0, 401, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 339, 0, 348, 349, 0, 0, 200, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 75776, 75776, 75776, 0, 0, 0,
  289, 470, 289, 289, 289, 289, 484, 490, 492, 289, 289, 289, 289, 289, 504, 289, 289, 289, 289, 289, 289, 1134, 289, 0,
  0, 0, 0, 0, 1139, 0, 0, 0, 0, 561152, 561152, 561152, 708608, 561152, 561152, 561152, 561152, 0, 0, 0, 563200, 563200,
  563200, 0, 0, 0, 0, 0, 0, 0, 0, 0, 563200, 671744, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 716800, 0,
  535, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 110805, 220, 220, 220, 220, 583, 584, 220, 220, 220, 220, 220, 0, 0,
  0, 0, 561, 619, 163, 620, 163, 163, 163, 163, 163, 163, 625, 626, 163, 163, 163, 163, 163, 1017, 1018, 163, 163, 163,
  163, 1023, 163, 163, 1024, 163, 163, 51847, 528, 289, 289, 651, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 0,
  0, 1202, 220, 1271, 163, 289, 289, 680, 681, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 1064, 0, 0,
  0, 220, 749, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 0, 0, 0, 0, 0, 557, 0, 0, 0, 0, 0, 0, 0, 0, 0, 220,
  220, 220, 220, 220, 220, 1150, 220, 1152, 0, 0, 163, 0, 0, 762, 0, 764, 765, 163, 163, 163, 769, 163, 163, 163, 163,
  163, 163, 1278, 163, 163, 1280, 289, 289, 289, 289, 289, 289, 669, 289, 289, 289, 289, 289, 289, 289, 289, 289, 1135,
  0, 0, 0, 0, 0, 0, 0, 163, 163, 777, 163, 163, 163, 163, 163, 163, 783, 163, 163, 163, 163, 163, 163, 51847, 289, 289,
  289, 289, 289, 289, 289, 289, 289, 672, 289, 289, 289, 289, 289, 289, 220, 220, 893, 220, 220, 0, 0, 0, 0, 0, 900, 0,
  0, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 1217, 163, 163, 220, 991, 220, 220, 220, 994, 220, 220, 220,
  220, 220, 220, 220, 220, 220, 0, 0, 0, 589, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 163, 163, 163, 163, 163, 163, 1009, 163,
  163, 163, 163, 1000, 0, 0, 0, 0, 1004, 163, 163, 163, 1007, 163, 163, 163, 163, 163, 163, 51847, 289, 289, 289, 289,
  289, 816, 817, 289, 819, 1012, 163, 1014, 163, 163, 163, 163, 1019, 163, 163, 163, 163, 163, 163, 163, 163, 51847,
  289, 289, 289, 813, 289, 289, 289, 289, 289, 0, 0, 1069, 0, 1071, 0, 0, 0, 0, 0, 0, 0, 220, 220, 220, 1080, 1093, 163,
  163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 931, 1103, 163, 163, 1105, 163, 1107, 163, 163,
  163, 163, 289, 289, 289, 289, 289, 1117, 289, 1119, 289, 289, 1122, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289,
  289, 843, 289, 289, 289, 289, 289, 163, 1170, 163, 163, 163, 163, 1175, 289, 289, 1178, 289, 289, 289, 289, 289, 289,
  825, 289, 289, 289, 289, 289, 289, 831, 289, 289, 1183, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 1193, 289,
  289, 61440, 63488, 0, 0, 163, 163, 163, 163, 163, 163, 163, 163, 163, 1215, 163, 163, 163, 163, 0, 163, 163, 163, 610,
  163, 163, 163, 163, 163, 163, 163, 1108, 1109, 163, 163, 289, 289, 289, 289, 289, 289, 684, 289, 289, 289, 289, 289,
  289, 289, 289, 289, 964, 289, 289, 289, 289, 289, 289, 968, 289, 289, 1235, 289, 289, 289, 1239, 289, 289, 289, 289,
  0, 0, 0, 0, 0, 0, 405, 0, 0, 0, 405, 405, 0, 0, 0, 0, 0, 1202, 220, 220, 220, 220, 220, 0, 163, 163, 163, 1248, 163,
  163, 163, 163, 0, 163, 163, 638, 163, 163, 163, 163, 163, 163, 163, 163, 782, 163, 163, 163, 163, 163, 163, 163, 289,
  289, 289, 289, 289, 289, 1266, 289, 289, 289, 0, 0, 1202, 220, 163, 163, 163, 163, 908, 163, 163, 163, 163, 163, 163,
  163, 163, 163, 163, 163, 1160, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 289, 289, 941, 289, 289, 289, 1380,
  289, 1381, 163, 289, 163, 289, 163, 289, 163, 289, 0, 0, 0, 0, 0, 0, 558, 0, 0, 0, 0, 0, 0, 0, 0, 220, 220, 220, 220,
  220, 1206, 220, 1208, 0, 0, 235, 235, 235, 0, 235, 0, 0, 0, 249, 249, 249, 249, 249, 249, 273, 249, 249, 249, 249,
  249, 249, 235, 249, 273, 273, 273, 305, 273, 273, 273, 273, 273, 305, 273, 273, 273, 273, 273, 305, 305, 305, 305,
  273, 305, 273, 305, 6145, 41113, 3, 4, 0, 0, 0, 0, 0, 0, 717, 0, 0, 0, 0, 0, 0, 0, 724, 0, 0, 0, 179, 179, 179, 337,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 108544, 0, 0, 0, 0, 0, 694, 0, 0, 163, 289, 289, 0, 0, 0, 0, 704, 0, 0, 0, 710,
  528, 0, 0, 0, 714, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 181, 0, 0, 220, 220, 220, 220, 220, 220, 752, 220, 220, 220,
  220, 220, 0, 0, 0, 0, 0, 591, 0, 0, 0, 0, 0, 0, 0, 0, 600, 163, 775, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163,
  163, 785, 163, 163, 163, 163, 400, 0, 163, 163, 420, 163, 163, 438, 163, 444, 464, 0, 789, 163, 163, 163, 163, 163,
  163, 163, 163, 163, 163, 163, 163, 802, 163, 163, 163, 163, 1016, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163,
  163, 1225, 289, 289, 289, 289, 289, 289, 289, 289, 289, 1125, 289, 289, 289, 289, 289, 289, 289, 289, 289, 822, 289,
  289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 953, 289, 289, 289, 289, 289, 289, 834, 289, 289, 289, 289,
  289, 840, 289, 289, 289, 289, 289, 289, 289, 289, 1124, 289, 289, 289, 289, 289, 289, 1128, 289, 0, 0, 220, 220, 220,
  220, 883, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 998, 220, 220, 220, 220, 0, 289, 289, 289, 947, 289, 289,
  289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 1191, 289, 289, 289, 0, 0, 163, 163, 1104, 163, 163, 163, 163, 163,
  163, 163, 289, 289, 1114, 289, 289, 289, 289, 0, 0, 163, 426, 163, 289, 289, 0, 289, 0, 0, 0, 0, 276, 0, 0, 0, 0, 0,
  0, 220, 0, 276, 276, 276, 1262, 289, 289, 289, 289, 289, 289, 289, 289, 289, 0, 0, 1202, 220, 163, 163, 163, 163,
  1029, 163, 163, 163, 163, 163, 289, 289, 289, 289, 289, 289, 163, 163, 163, 163, 163, 163, 163, 163, 1334, 163, 289,
  289, 289, 289, 289, 289, 289, 1342, 289, 0, 163, 163, 163, 427, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163,
  1254, 163, 163, 163, 289, 289, 289, 289, 289, 1260, 289, 163, 289, 289, 289, 289, 1375, 289, 163, 163, 163, 163, 289,
  289, 289, 289, 163, 163, 163, 792, 163, 163, 163, 163, 163, 163, 799, 163, 163, 163, 163, 163, 289, 1337, 289, 289,
  289, 289, 289, 289, 289, 0, 163, 306, 274, 274, 274, 274, 274, 306, 274, 274, 274, 274, 274, 306, 306, 306, 306, 274,
  306, 274, 306, 6145, 41113, 3, 4, 0, 0, 0, 0, 0, 0, 873, 0, 0, 0, 0, 0, 733, 0, 0, 0, 289, 289, 289, 289, 480, 289,
  289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 1269, 0, 1202, 220, 163, 163, 220, 220, 220, 220, 572, 220, 220,
  220, 220, 220, 220, 220, 220, 220, 220, 220, 999, 220, 220, 220, 0, 163, 51847, 528, 289, 289, 289, 289, 289, 289,
  289, 659, 289, 289, 289, 289, 289, 0, 0, 856, 0, 858, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 88064, 748, 220,
  220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 0, 758, 0, 0, 0, 0, 561152, 561152, 561152, 708608, 561152, 561152,
  561152, 561152, 0, 0, 0, 563525, 563667, 563667, 0, 0, 0, 0, 0, 0, 0, 0, 0, 563200, 212, 212, 236, 236, 236, 212, 236,
  212, 212, 212, 212, 212, 212, 212, 212, 212, 275, 212, 212, 212, 212, 212, 212, 236, 212, 275, 275, 275, 307, 275,
  275, 275, 275, 275, 307, 275, 275, 275, 275, 275, 307, 307, 307, 307, 275, 307, 275, 307, 6145, 41113, 3, 4, 0, 0, 0,
  0, 0, 0, 96458, 0, 26624, 28672, 0, 0, 96458, 0, 96458, 24576, 163, 1013, 163, 163, 163, 163, 163, 163, 163, 163, 163,
  163, 163, 163, 163, 163, 163, 1102, 308, 276, 276, 276, 276, 276, 308, 276, 276, 276, 276, 276, 308, 308, 308, 308,
  276, 308, 276, 308, 6145, 41113, 3, 4, 0, 0, 0, 0, 0, 0, 135168, 0, 0, 0, 0, 0, 135168, 135168, 135168, 135168, 289,
  289, 289, 289, 481, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 289, 1240, 289, 289, 289, 0, 0, 0, 0, 0, 0, 0,
  553, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 220, 220, 220, 373, 220, 0, 0, 727, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  866, 867, 161, 162, 163, 0, 0, 0, 0, 0, 0, 0, 327, 0, 0, 0, 0, 0, 0, 352256, 0, 26624, 28672, 0, 0, 352256, 0, 352256,
  24576, 0, 0, 220, 220, 220, 220, 220, 220, 220, 885, 220, 220, 220, 220, 220, 220, 220, 220, 586, 220, 588, 0, 0, 0,
  0, 0, 163, 163, 163, 935, 163, 163, 163, 163, 163, 163, 289, 289, 289, 289, 289, 289, 163, 163, 1369, 1370, 163, 163,
  1026, 163, 163, 163, 163, 163, 163, 163, 163, 289, 289, 289, 289, 289, 289, 289, 289, 163, 348160, 0, 348160, 0, 0,
  348160, 348160, 0, 0, 348160, 0, 0, 0, 0, 0, 348160, 0, 0, 348160, 0, 0, 0, 0, 0, 0, 0, 0, 0, 730, 0, 0, 0, 0, 0, 220,
  348160, 0, 0, 0, 0, 0, 0, 348160, 348365, 348365, 0, 0, 0, 0, 0, 348365, 0, 348160, 0, 348160, 0, 348160, 0, 6145, 0,
  3, 4, 0, 0, 0, 0, 0, 0, 532480, 200, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 806912, 0, 561152, 352256, 352256, 352256,
  352256, 0, 352256, 352256, 352256, 352256, 352256, 352256, 352256, 352256, 0, 0, 0, 0, 403, 0, 0, 406, 0, 0, 0, 0,
  403, 346, 346, 0, 0, 0, 0, 352256, 0, 352256, 352256, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 532480, 200, 0, 0, 0, 0, 0, 0,
  22528, 0, 354304, 354304, 354304, 354304, 0, 354304, 354304, 354304, 354304, 354304, 354304, 354304, 354304, 0, 0, 0,
  354304, 0, 354304, 354304, 354304, 354304, 354304, 354304, 354304, 354304, 354304, 0, 0, 354304, 354304, 0, 354304,
  354304, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 532480, 200, 0, 0, 0, 0, 0, 356352, 0, 0, 53248, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 550, 0, 0, 563200, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 876, 0, 0, 0, 675840, 696320, 561152,
  770048, 827392, 770048, 563200, 675840, 696320, 563200, 563200, 741376, 770048, 817152, 563200, 827392, 563200,
  563200, 563200, 860160, 0, 714752, 1270, 714752, 563200, 710656, 563200, 563200, 563200, 856064, 0, 0, 563200, 563200,
  563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200
);

(:~
 : The DFA-state to expected-token-set mapping.
 :)
declare variable $p:EXPECTED as xs:integer+ :=
(
  33, 64, 80, 96, 112, 128, 144, 158, 168, 168, 170, 312, 186, 202, 218, 249, 265, 281, 297, 328, 48, 344, 360, 376,
  233, 392, 408, 424, 455, 439, 486, 470, 502, 511, 515, 524, 522, 518, 528, 532, 535, 539, 543, 552, 565, 625, 1189,
  615, 863, 546, 1138, 1332, 900, 915, 864, 1074, 800, 1145, 1150, 827, 1156, 1160, 1165, 1251, 691, 683, 579, 558, 562,
  1299, 569, 594, 638, 1171, 692, 692, 690, 578, 579, 579, 584, 863, 588, 592, 595, 1543, 692, 692, 599, 579, 579, 605,
  608, 1141, 614, 1192, 692, 692, 1196, 579, 579, 619, 1553, 637, 1194, 692, 1196, 579, 601, 1500, 643, 692, 1196, 579,
  650, 657, 692, 674, 580, 1501, 1544, 674, 676, 661, 663, 668, 663, 672, 680, 1198, 664, 646, 687, 696, 700, 710, 714,
  717, 721, 728, 732, 736, 740, 724, 744, 748, 752, 807, 863, 934, 863, 863, 863, 863, 757, 863, 863, 1290, 863, 863,
  863, 863, 863, 863, 1097, 863, 863, 1097, 863, 863, 863, 863, 863, 863, 863, 863, 863, 863, 863, 863, 863, 863, 863,
  863, 766, 1233, 1386, 811, 1492, 1116, 818, 863, 856, 831, 863, 610, 995, 862, 863, 1021, 1391, 952, 841, 845, 850,
  854, 863, 1336, 860, 863, 1531, 863, 868, 1128, 863, 875, 863, 1335, 879, 863, 863, 888, 894, 940, 906, 1040, 912,
  863, 1577, 932, 1244, 1040, 922, 863, 574, 1350, 1355, 1361, 1329, 863, 1340, 1344, 554, 1258, 1166, 1349, 1354, 1161,
  1329, 930, 1243, 1182, 938, 1280, 944, 653, 948, 957, 961, 965, 971, 975, 1081, 979, 989, 1267, 1269, 1270, 993, 863,
  863, 1551, 863, 999, 1003, 1007, 1011, 1015, 1019, 1226, 1292, 1025, 1031, 1038, 1044, 1048, 622, 1287, 548, 1227,
  1312, 1057, 706, 1064, 1068, 837, 1072, 1305, 1345, 1078, 863, 1372, 1566, 1498, 1085, 1090, 1096, 1101, 953, 1115,
  918, 1105, 863, 703, 772, 776, 780, 784, 788, 1034, 814, 792, 1060, 798, 1521, 804, 1106, 1315, 824, 1110, 1086, 1092,
  884, 1530, 1114, 1321, 1120, 863, 1125, 1528, 1132, 1519, 1490, 1517, 882, 1170, 631, 1152, 1175, 633, 1179, 1186,
  628, 1436, 863, 863, 863, 1202, 1027, 1206, 1210, 1214, 1218, 1221, 1225, 1586, 890, 1344, 1584, 1231, 1237, 1248,
  1255, 1264, 1405, 1587, 1402, 1407, 1121, 1274, 1278, 863, 1284, 1296, 863, 1260, 1303, 1356, 1309, 863, 863, 1325,
  1134, 1360, 1365, 863, 1369, 572, 902, 1379, 1343, 1385, 1383, 572, 871, 982, 1051, 1433, 1390, 1395, 950, 1053, 1443,
  1399, 1411, 1415, 1419, 1423, 1430, 1440, 1447, 1451, 1426, 1455, 1459, 639, 863, 863, 1463, 985, 1467, 1471, 1475,
  1479, 1483, 863, 846, 863, 1487, 863, 926, 846, 863, 1374, 863, 1514, 863, 1506, 1536, 863, 863, 760, 863, 1525, 1240,
  1496, 863, 897, 1575, 925, 863, 1318, 863, 1505, 863, 1510, 863, 863, 897, 834, 863, 1560, 1540, 908, 863, 863, 1573,
  863, 1570, 863, 1563, 907, 1581, 794, 907, 1146, 967, 863, 863, 1535, 1540, 863, 760, 821, 1375, 1548, 863, 1557,
  1540, 753, 762, 863, 768, 863, 863, 863, 863, 863, 863, 863, 1591, 1592, 2302, 1772, 1597, 1614, 1611, 1625, 1627,
  1628, 1640, 1627, 1636, 1626, 1627, 1627, 1627, 1632, 1642, 1627, 1646, 1648, 2154, 2157, 1797, 1797, 1796, 1652,
  2160, 1656, 1660, 1664, 1668, 1670, 1672, 1593, 1772, 1600, 1772, 1772, 2419, 1772, 1730, 1770, 1772, 1772, 1619,
  1689, 1694, 1703, 1707, 1697, 1758, 2049, 1772, 2753, 2539, 1772, 1676, 2665, 1717, 2296, 1939, 2721, 1772, 1772,
  2710, 2714, 2530, 1694, 1694, 1694, 1694, 1764, 2129, 1724, 1758, 1729, 2662, 2664, 1734, 1718, 2296, 2784, 2785,
  2785, 2785, 2785, 1772, 2527, 2529, 1694, 1694, 1694, 1765, 1694, 1739, 1725, 1758, 1760, 1772, 1772, 1698, 2103,
  2807, 2785, 2785, 2785, 2465, 1694, 1755, 1759, 1772, 1617, 2322, 1772, 1682, 2392, 2467, 1772, 2469, 2467, 1787,
  1772, 1606, 1772, 2466, 2785, 2785, 2785, 2786, 1772, 1772, 2785, 2786, 2046, 2527, 1705, 1694, 2552, 1694, 1694,
  1766, 1772, 1699, 1772, 2221, 2296, 2785, 2785, 2046, 2807, 2786, 2527, 2527, 2551, 1694, 1801, 1694, 1694, 1696,
  2548, 1694, 1793, 2527, 1705, 1694, 1694, 1695, 1772, 1694, 1694, 2526, 2527, 2525, 2527, 2528, 2527, 2551, 2552,
  2527, 2526, 2527, 2527, 2527, 2527, 2551, 2552, 1705, 2552, 1742, 1805, 1744, 1772, 1735, 1971, 1772, 1750, 1713,
  2429, 1809, 2056, 2478, 2269, 2281, 2284, 1813, 1818, 1818, 1817, 1988, 1822, 1831, 2287, 1818, 1891, 1895, 1899,
  1990, 1985, 2275, 2272, 1845, 1856, 1834, 1837, 1860, 1864, 1866, 1870, 1883, 1887, 1788, 2278, 1903, 1781, 1950,
  1951, 1909, 1772, 1772, 1973, 1917, 1772, 1772, 1772, 1750, 1938, 1602, 1949, 1772, 1750, 2798, 1772, 1772, 1772,
  1955, 1773, 1772, 1772, 1778, 1772, 1963, 1977, 1982, 1965, 1994, 2862, 2003, 2005, 2009, 2013, 2017, 2021, 2022,
  2030, 2030, 2029, 2026, 2034, 2037, 2041, 1772, 2671, 1772, 1772, 1788, 1777, 2061, 2068, 1772, 1772, 1841, 1772,
  1978, 2064, 2073, 1772, 1771, 1772, 2105, 2771, 1770, 2187, 1962, 1772, 1772, 2411, 2293, 1685, 2087, 1772, 1775,
  1772, 1772, 1777, 1772, 1719, 1772, 1772, 2170, 2619, 2093, 2099, 1772, 1777, 1772, 1772, 1777, 2447, 2499, 1943,
  2056, 2117, 1687, 2260, 1772, 1772, 1772, 1776, 1848, 1772, 2618, 2139, 2203, 2128, 1772, 1772, 1849, 1772, 2143,
  2196, 2115, 1772, 1772, 1772, 1772, 1720, 2774, 1772, 1966, 1772, 1777, 2738, 2145, 2174, 2191, 2204, 1767, 2222,
  2193, 2205, 1772, 1787, 1772, 1772, 2495, 2505, 1772, 2775, 1963, 1772, 2042, 2778, 2054, 2652, 2212, 1772, 1789,
  2799, 1772, 1851, 1772, 1772, 2442, 2740, 2197, 1772, 1772, 1772, 1777, 2290, 2177, 2194, 2206, 1772, 1852, 2451,
  1772, 1879, 1923, 2506, 2177, 2195, 2207, 1772, 1919, 2799, 1772, 1772, 2775, 2647, 2651, 2211, 1772, 1772, 1927,
  1772, 2226, 2206, 1772, 1772, 1957, 2201, 2247, 1939, 2217, 2233, 2241, 2104, 1772, 1772, 1964, 1772, 1772, 1772,
  1773, 1772, 2649, 2246, 2541, 2242, 1772, 2251, 2540, 2111, 2302, 1772, 1772, 1997, 1783, 2257, 2266, 2306, 2540,
  2301, 1772, 1772, 2311, 2312, 1772, 2077, 1772, 1929, 2042, 1772, 1943, 1945, 2804, 2075, 2305, 2540, 2078, 2330,
  2316, 1772, 1772, 2109, 2095, 1876, 2320, 1772, 1873, 2326, 1783, 1996, 2334, 2341, 2344, 2358, 2362, 2364, 2347,
  2363, 2350, 2353, 2353, 2354, 2368, 2353, 2353, 1772, 1772, 2124, 1771, 2328, 1772, 1783, 1772, 1911, 1772, 2512,
  1772, 2372, 1772, 1955, 1772, 2187, 2377, 2401, 1772, 1772, 2134, 1772, 2386, 2069, 2253, 2380, 2390, 2396, 2400,
  1772, 1963, 1772, 1772, 2751, 1939, 1782, 1772, 2513, 1772, 2054, 1967, 2295, 2458, 1772, 1772, 2435, 2458, 1941,
  2439, 2856, 2455, 2303, 1772, 1772, 2169, 2534, 2497, 2501, 2431, 2303, 2076, 1772, 2540, 2514, 1772, 1772, 1751,
  2180, 2179, 1767, 1772, 1940, 2483, 1772, 2482, 1772, 1772, 1772, 2044, 1750, 1923, 2506, 1767, 2489, 1772, 1772,
  1772, 2082, 2476, 1772, 1772, 1784, 1773, 1825, 1772, 1772, 1772, 2055, 2510, 1772, 1772, 1772, 2236, 2424, 1776,
  1781, 1772, 2055, 2164, 2212, 2482, 1772, 1772, 1781, 1621, 1772, 2262, 2182, 2483, 1772, 2118, 2119, 1748, 1773,
  1788, 1772, 1772, 1777, 1851, 1841, 1772, 1772, 2468, 1788, 2484, 1772, 2460, 2182, 1785, 1772, 1772, 1772, 2337,
  1840, 1772, 1772, 1772, 2443, 2545, 1772, 1772, 1772, 2525, 1785, 2469, 1772, 2558, 1786, 1772, 1607, 1772, 2133,
  1772, 2221, 2467, 1788, 1606, 1772, 2182, 1939, 2785, 1942, 1772, 2526, 2527, 2527, 1706, 1694, 1695, 2527, 1997,
  2699, 1772, 2047, 2556, 2048, 2523, 2422, 2524, 2629, 2566, 2573, 2579, 2582, 2587, 2575, 2586, 2588, 2592, 2598,
  2594, 2598, 2598, 2599, 1772, 1772, 1772, 2538, 1772, 2237, 2616, 1772, 1785, 1961, 1772, 2515, 1772, 2104, 1772,
  2183, 1772, 1772, 2216, 2204, 1767, 1772, 1772, 2636, 2623, 1772, 2297, 2182, 1827, 2627, 2470, 2633, 1772, 2305,
  1772, 1772, 2685, 2689, 1772, 2747, 2641, 1772, 2310, 1772, 2310, 2540, 2327, 2330, 2733, 2303, 1772, 2656, 1775,
  2305, 1772, 1772, 2647, 2651, 2637, 2713, 2229, 1772, 2405, 2409, 1772, 2043, 1772, 1772, 1719, 1850, 2669, 1772,
  2675, 1772, 2415, 1772, 1711, 2693, 2678, 1772, 1772, 2681, 2777, 2089, 2042, 2779, 1772, 2425, 2477, 1772, 2050,
  2083, 1772, 1773, 1772, 1772, 1773, 1921, 2505, 2704, 1690, 1774, 2304, 2739, 2692, 2725, 1772, 2450, 2182, 1772,
  2133, 1772, 1772, 2138, 1781, 2699, 1966, 1933, 2777, 1772, 1772, 1772, 2659, 2714, 1690, 1772, 1772, 2718, 2718,
  2056, 1772, 1772, 1772, 2697, 1934, 1772, 1772, 1772, 2728, 1772, 2705, 2303, 2304, 2442, 2732, 2303, 1772, 2464,
  1772, 1772, 2186, 1772, 1772, 2147, 1772, 1781, 1911, 1772, 2737, 2706, 1772, 1772, 1772, 2773, 2720, 1772, 1772,
  1772, 2776, 2491, 2744, 1772, 1931, 2757, 1781, 2167, 1772, 2485, 2777, 1772, 2401, 1772, 1772, 2645, 1772, 1964,
  1772, 2057, 1966, 2610, 1772, 1772, 2057, 2757, 2043, 1772, 1769, 2610, 1772, 1768, 2611, 1768, 2611, 2568, 2045,
  1770, 2611, 1772, 2491, 1966, 1772, 2469, 2468, 2468, 2761, 2045, 1956, 2612, 1772, 1772, 2057, 1768, 2762, 1768,
  2609, 2045, 2568, 2763, 1769, 2769, 2767, 2568, 2769, 2767, 2569, 2569, 2783, 2382, 1944, 1678, 2790, 2793, 1913,
  1772, 2811, 2814, 2816, 2823, 2820, 2827, 2832, 2828, 2832, 2835, 2839, 2840, 2844, 2850, 2840, 2847, 2854, 2466,
  1604, 2184, 1772, 2516, 1772, 1772, 2413, 1963, 1998, 1772, 1772, 1781, 1772, 1772, 2296, 2785, 2786, 2185, 1772,
  1772, 1772, 2796, 1999, 1772, 1772, 1783, 1998, 1782, 1772, 1772, 2516, 2449, 2181, 1772, 1772, 2373, 1772, 1774,
  1772, 1772, 1772, 2520, 2182, 1772, 1772, 1772, 2151, 2796, 2800, 1772, 1772, 1780, 1780, 1772, 1772, 1772, 2525,
  2527, 2527, 2527, 1772, 2860, 1772, 1772, 2537, 1772, 1772, 2120, 2806, 1772, 2797, 1718, 1772, 2559, 1718, 1772,
  2560, 1772, 1779, 1772, 2474, 2329, 1905, 2562, 1772, 1772, 2561, 1772, 1779, 1772, 1772, 2777, 1912, 2561, 1772,
  1772, 1772, 2607, 1772, 1772, 2603, 2700, 1965, 2305, 4, 524288, 2097152, 4194304, 268435456, 262208, -2147483584,
  268451840, 16384, 1, 0, 0, 8192, 0, 0, 0, 8, 1024, 0, 32768, 32832, 134234112, 16384, 16384, 134217728, 0, -671088640,
  0, 0, 1024, 262144, 0, 524288, 33587200, -2147450880, 32768, 32768, 32768, 32768, 32792, 32768, 1048576, 294976,
  32832, 33849344, -2147450880, -2147450880, -2147450880, 33849344, -2147450880, 32768, 32768, -2147483400, 32768,
  134288128, 75008, 32768, 32768, 32768, 8456448, -2080342016, 67141632, 67141632, 67272704, 17039360, 294912,
  1610874880, 278528, -2147188736, 294912, 17072128, 1610907648, -2147188736, 294912, -2147221256, 1610907648, 17072128,
  17072128, -2130411272, -2130411272, -2130411272, 67403776, -2063302408, 4, 16, 24, 0, 0, 1, 512, 0, 48, 56, 128, 128,
  512, 229376, 524288, 33554432, -2147483648, 0, 0, 17039360, 17039360, 17039360, 17039360, 0, 0, 0, 2048, -1073741824,
  1610612736, 0, 262144, 262144, 262144, 17039360, 17039360, 48, 0, 48, 32, 128, 2048, 8192, 256, 256, 0, 0, 0, 16384,
  1, 17039360, 17039360, 0, 64, 64, 64, 64, 64, 262144, 16384, 65536, 256, 256, 256, 1024, 17039360, 536870912,
  1073741824, 262144, 17039360, 17039360, 262144, 17039360, 0, 65536, 256, 0, 0, 2, 4, 128, 17039360, 536870912,
  1073741824, 64, 64, 64, 64, 0, 0, 17039360, 17039360, 536870912, 1073741824, 0, 0, 0, 32768, 0, 0, 0, 0, 1, 0, 0, 0,
  2, 0, 0, 0, 4, 0, 0, 0, 8, 0, 0, 0, 12, 0, 8388608, 262144, 262144, 67141632, 67141632, 67141632, 67141632, 17039360,
  17039360, 0, 262144, 17039360, 262144, 17039360, 262144, 0, 4, 2048, 134217728, 262152, 524296, 1048584, 134217736,
  131080, 8, 8, 8, 8, 10, 10, 10, 12, 33554432, 0, 0, 1536, 8388608, 536, 1048600, -2147483624, 520, 1359898, 81788928,
  1049112, 0, 8, 8, 1536, 4194304, 8388608, 0, 1049112, 1097752, 520, 0, 0, 536870912, 0, 0, 1, 8, 128, 1, 520, 8,
  1359896, 2066743832, 24, 2066743832, 2066744984, 2066745016, 2066745016, 2066745016, 2066745016, -80738632,
  2066745016, 2066794168, -80214184, 2066794168, 0, 1, 0, 1048576, 0, 1048576, 0, 1, 2, 12, -80214182, 2066794170,
  2067056312, 2066794170, 2067056314, 2066794170, 2066794170, 2066794170, 56, 73404418, 10, 1048600, 49160, 73412618,
  73462926, 73462942, 73462926, 73462926, 2066794170, 74511518, 2067056314, 2138060442, 0, 0, 2, 8, 0, 8, 262144,
  524288, 0, 0, 512, 512, 0, 12, 0, 0, 2, 12, 64, 128, 1536, 2048, 50331648, 1610612736, 0, 0, 4, 524288, 0, 4194304, 0,
  67108864, 33554432, 71303168, 0, 0, 0, 131072, 0, 0, 0, 512, 0, 0, 121634816, 2048, 0, 0, 0, 65536, 1, 32768, 0, 0,
  131072, 96, 256, 16384, 0, 0, 0, 524288, 0, 0, 0, 557056, 16384, 33587200, 0, 0, 8, 131072, 1280, 0, 0, 0, 688128, 0,
  256, 524288, 8, 524824, 1048600, 24, 8, 8, 8, 524296, 134217736, 268960256, 0, 4, 0, 0, 4, 128, 0, 0, 839615104,
  839615104, 839615104, 302547592, 302547592, 839418504, 839418504, 839418504, 839418504, 839418504, 839549576,
  839549576, 839615112, 839615112, 839419528, 839615116, 2131722976, 839419528, 839615116, 839615116, 839615116,
  839615116, 2131722992, 2136967920, -14710048, -14710046, -14710046, -14710048, -14710048, -14710048, -14710048,
  -10515726, -10515726, -10515726, -10515726, -14710036, -10515726, -14710036, -10515718, 0, 0, 0, 4194304, 0, 0, 0,
  262144, 0, 0, 0, 2784, 0, 512, 268435456, 0, 0, 0, 49152, 640, 0, 640, 753664, 1664, 0, 736, 838860800, 0, 0, 0,
  16908288, 1015808, 2130706432, 0, 0, 64, 134217728, -2147483648, 0, 0, 2784, 2064384, -16777216, 0, 0, 524288,
  301989888, 536870912, 0, 524288, 0, 224, 512, 229376, 262144, 1572864, 520093696, 524288, 520093696, 536870912,
  1073741824, 1572864, -1073741824, 0, 0, 0, 79691776, 0, 224, 512, 2048, 524288, 201326592, 536870912, -1073741824, 0,
  0, 128, 128, 128, 0, 0, 0, 5767168, 0, 5767168, 469762048, 536870912, 1073741824, 0, 262144, 0, 2048, 1048576,
  -1073741824, 0, 0, 96, 128, 512, 229376, 2048, 229376, 262144, 524288, 6291456, 33554432, -2147483648, 0, 0, 4194304,
  4194304, 32768, 32768, 131072, 163840, 67141632, 163904, 67141632, -2113634304, 262144, 278528, 512, 32768, 196608,
  524288, 4194304, 0, 0, 4194304, 8388608, 0, 0, 131072, 196608, 96, 512, 2048, 131072, 4194304, 8388608, 0, 0, 0, 128,
  0, 0, 0, 256, 512, 32768, 196608, 262144, 524288, 1048576, 16777216, 33554432, 469762048, 1073741824, 512, 131072,
  262144, 524288, 16777216, 33554432, 469762048, -1073741824, 0, 0, 524288, 33554432, 268435456, 0, 0, 131072, 96, 512,
  131072, 524288, 0, 96, 512, 2048, 32768, 131072, 524288, 1048576, 16777216, 33554432, 1073741824, -2147483648,
  201326592, 268435456, 1073741824, 0, 1, 8, 1536, 262144, 131072, 524288, 201326592, 268435456, 0, 512, 524288,
  268435456, 0, 0, 2048, -2147483648, 0, 0, 166, 25296896, 0, 268435456, 0, 268435456, 536870912, 0, 0, 128, 4194304,
  64, 201326592, 268435456, 0, 1, 268500992, 8, 0, 524824, 520, 8, 8, 8, 0, 268500992, 8, 1, 268500992, 8, 10, 24, 520,
  524296, 8, 8, 16, 256, 0, 0, 301989888, 0, 0, 0, 8388608, 0, 201326592, 268435456, -2147483648, 0, 0, 0, -2147483648,
  0, 0, 0, 64, 134217728, 0, 0, -2147483648, 0, 134217728, 0, 134217728, 0, 536887296, 0, 0, 239, 63832064, 536887296,
  134217728, 0, 0, 0, 134217728, 0, 0, 1073743872, 0, 1073743872, 0, 2, 64, 3072, 0, 1073743878, 1073743878, -775771994,
  -775771994, -788486106, -775771994, -775246106, -774723418, -775771994, -641554266, -775246106, -741429521,
  -741429521, -741429521, -741429521, -775246105, -788486106, -788486106, -788355034, -788355034, -779966298,
  -775771994, -775771994, -775771994, -775771994, -774723418, -741429521, -741429521, -674255121, -741429521, 6, 0, 0,
  0, 838860800, 166, 2048, 40960, 29491200, 0, 0, 0, 512, 4096, 38, 40960, 16777216, -805306368, 0, 30539776, 0, 0, 512,
  65792, 0, 230, 3584, 40960, 30015488, -805306368, 0, 0, 0, 0, 239, 3584, 40960, 63832064, -805306368, 0, 0, 1024,
  33554432, 0, 0, 16, 0, 231, 0, 63897600, 67108864, 33817600, 0, 0, 16384, 536870912, 0, 32768, 131072, 12582912,
  16777216, 33554432, 1342177280, 32, 8192, 32768, 16777216, 128, 8388608, 12582912, 0, 2, 3072, 8192, 49152, 4, 32, 64,
  128, 1536, 524288, 4194304, 8388608, 524288, 12582912, 16777216, 1342177280, -2147483648, 0, 0, 1536, 4194304, 0,
  67108864, 0, 0, 0, 1024, 0, 0, 0, 72, 0, 16384, 536870912, 1, 0, 0, 134217728, 268435456, 0, 128, 8388608, 4194304, 0,
  0, 67108864, 33554432, 1073741824, 0, 0, 2048, 49152, 2, 4, 64, 128, 3584, 8192, 32768, 131072, 262144, 524288, 1536,
  131072, 524288, 4194304, 8388608, 8388608, 33554432, 0, 0, 2048, 1073741824, 0, 0, 1, 12, 0, 4, 128, 4194304, 262144,
  0, 0, 262144, 262144, 262144, 262144, 16777216, 17039360, 17039360, 0, 8388608, 4194304, 0, 2, 1048576, 0, 0, 0, 64,
  512, 0, 8, 1536, 8388608, 131072, 262144, 262144, 17039360, 17039360, 17039360, 262144, 0, 128, 1024, 0, 0, 8, 16, 0,
  0, 0, 0, 33817600, 0, 0, 32768, 131072, 0, 34342400, 34342400, -1039399415, -1039399415, 1108084233, -1039399415,
  -1039399415, 34342408, -1039399415, 1108084232, 1108084233, 1108084233, 1108084233, -1014174197, 1108084233,
  -1039399415, -1039399415, -1039399415, -1039399415, -972290551, -1014174197, -739316149, -739316149, -745607669,
  -739316149, -739316149, -739316149, -739316149, -739316149, 0, 0, 4, 128, 1024, 1536, 34078720, 0, 0, 131072, 2097152,
  4194304, 0, 0, 34078720, -1073741824, 0, 0, 163840, 229376, 0, 57344, 262144, 59244544, -1073741824, 0, 101187584, 0,
  0, 262144, 33817600, 188416, 65536000, -805306368, 0, 3, 8, 3584, 8192, 188416, 262144, 65536000, -805306368, 0, 1536,
  0, 0, 524288, 512, 268435456, 0, 512, 131072, 524288, 0, 8, 1073741824, 0, 3, 12, 32, 32, 128, 128, 0, 65536, 256,
  100663296, 0, 0, 0, 524288, 1280, 64, 180224, 6291456, 268435456, 1073741824, -2147483648, 0, 3, 12, 262144, 3, 8, 64,
  3584, 8192, 180224, 262144, 524288, 6291456, 8388608, 16777216, 33554432, 0, 4, 1024, 262144, 536870912, 0, 0, 1,
  1024, 262144, 524288, 33554432, 0, 3, 3072, 8192, 49152, 262144, 524288, 8388608, 16777216, 0, 64, 131072, 6291456, 0,
  0, 0, 33554432, 268435456, -2147483648, 0, 3, 64, 3072, 49152, 262144, 524288, 33554432, 1073741824, 2, 2048, 8192,
  49152, 131072, 262144, 524288, 131072, 524288, 6291456, 0, 3, 72, 3584, 49152, 524288, 0, 0, 1048576, 1048576, 131072,
  524288, 2097152, 4194304, 32768, 131072, 2097152, 4194304, 4194304, 0, 32768, 131072, 2097152, 0, 0, 0, 6258688, 0, 0,
  0, 33554432, 0, 0, 0, 67108864, 33554432, 131072, 0, 131072, 131072, 131072, 131072, 0, 0, 512, 2048, 512, 0, 2048, 0,
  4, 8, 16, 128, 256, 0, 0, 512, 512, 0, 0, 8388608, 131072, 131072, 4096, 2048, 512, 9728, 0, 128, 2048, 9728, 4224,
  4224, 132, 4224, 4224, 132, 132, 644, 4224, 6276, 6276, 6276, 412, 6276, 6276, 6276, 6276, 6788, 6788, 6788, 412, 414,
  414, 414, 414, 926, 414, 414, 926, 4510, 7070, 414, 412, 414, 2462, 7070, 6558, 0, 0, 13631488, 0, 4, 128, 4, 0,
  302547464, 302547592
);

(:~
 : The token-string table.
 :)
declare variable $p:TOKEN as xs:string+ :=
(
  "EPSILON",
  "END",
  "DirCommentContents",
  "IntegerLiteral",
  "DecimalLiteral",
  "DoubleLiteral",
  "StringLiteral",
  "TextNodeLiteral",
  "PredefinedEntityRef",
  "'""""'",
  "EscapeApos",
  "ElementContentChar",
  "QuotAttrContentChar",
  "AposAttrContentChar",
  "S",
  "S",
  "CharRef",
  "NCName",
  "QName",
  "PITarget",
  "CommentContents",
  "PragmaContents",
  "DirPIContents",
  "CDataSection",
  "Wildcard",
  "EOF",
  "'!='",
  "'""'",
  "'#)'",
  "'#current'",
  "'#default'",
  "'$'",
  "''''",
  "'('",
  "'(#'",
  "'(:'",
  "')'",
  "'*'",
  "'*'",
  "'+'",
  "'+'",
  "','",
  "'-'",
  "'-->'",
  "'.'",
  "'..'",
  "'/'",
  "'//'",
  "'/>'",
  "':)'",
  "'::'",
  "':='",
  "';'",
  "'<'",
  "'<!--'",
  "'</'",
  "'<<'",
  "'<='",
  "'<?'",
  "'='",
  "'>'",
  "'>='",
  "'>>'",
  "'?'",
  "'?>'",
  "'@'",
  "'['",
  "']'",
  "'^'",
  "'ancestor'",
  "'ancestor-or-self'",
  "'and'",
  "'as'",
  "'ascending'",
  "'at'",
  "'attribute'",
  "'base-uri'",
  "'boundary-space'",
  "'by'",
  "'case'",
  "'cast'",
  "'castable'",
  "'child'",
  "'collation'",
  "'comment'",
  "'construction'",
  "'copy'",
  "'copy-namespaces'",
  "'declare'",
  "'default'",
  "'descendant'",
  "'descendant-or-self'",
  "'descending'",
  "'div'",
  "'document'",
  "'document-node'",
  "'element'",
  "'else'",
  "'empty'",
  "'empty-sequence'",
  "'encoding'",
  "'eq'",
  "'every'",
  "'except'",
  "'external'",
  "'following'",
  "'following-sibling'",
  "'for'",
  "'function'",
  "'ge'",
  "'greatest'",
  "'gt'",
  "'id'",
  "'idiv'",
  "'if'",
  "'import'",
  "'in'",
  "'inherit'",
  "'instance'",
  "'intersect'",
  "'is'",
  "'item'",
  "'key'",
  "'lax'",
  "'le'",
  "'least'",
  "'let'",
  "'lt'",
  "'mod'",
  "'module'",
  "'namespace'",
  "'ne'",
  "'no-inherit'",
  "'no-preserve'",
  "'node'",
  "'of'",
  "'option'",
  "'or'",
  "'order'",
  "'ordered'",
  "'ordering'",
  "'parent'",
  "'preceding'",
  "'preceding-sibling'",
  "'preserve'",
  "'processing-instruction'",
  "'return'",
  "'satisfies'",
  "'schema'",
  "'schema-attribute'",
  "'schema-element'",
  "'self'",
  "'some'",
  "'stable'",
  "'strict'",
  "'strip'",
  "'text'",
  "'then'",
  "'to'",
  "'treat'",
  "'tunnel'",
  "'typeswitch'",
  "'union'",
  "'unordered'",
  "'validate'",
  "'variable'",
  "'version'",
  "'where'",
  "'xquery'",
  "'{'",
  "'{{'",
  "'|'",
  "'}'",
  "'}}'"
);

(:~
 : Match next token in input string, starting at given index, using
 : the DFA entry state for the set of tokens that are expected in
 : the current context.
 :
 : @param $input the input string.
 : @param $begin the index where to start in input string.
 : @param $token-set the expected token set id.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:match($input as xs:string,
                         $begin as xs:integer,
                         $token-set as xs:integer) as xs:integer+
{
  let $result := $p:INITIAL[1 + $token-set]
  return p:transition($input,
                      $begin,
                      $begin,
                      $begin,
                      $result,
                      $result mod 2048,
                      0)
};

(:~
 : The DFA state transition function. If we are in a valid DFA state, save
 : it's result annotation, consume one input codepoint, calculate the next
 : state, and use tail recursion to do the same again. Otherwise, return
 : any valid result or a negative DFA state id in case of an error.
 :
 : @param $input the input string.
 : @param $begin the begin index of the current token in the input string.
 : @param $current the index of the current position in the input string.
 : @param $end the end index of the result in the input string.
 : @param $result the result code.
 : @param $current-state the current DFA state.
 : @param $previous-state the  previous DFA state.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:transition($input as xs:string,
                              $begin as xs:integer,
                              $current as xs:integer,
                              $end as xs:integer,
                              $result as xs:integer,
                              $current-state as xs:integer,
                              $previous-state as xs:integer) as xs:integer+
{
  if ($current-state = 0) then
    let $result := $result idiv 2048
    return
      if ($result != 0) then
      (
        $result mod 256 - 1,
        $begin,
        $end - $result idiv 256
      )
      else
      (
        - $previous-state,
        $begin,
        $current - 1
      )
  else
    let $c0 := (string-to-codepoints(substring($input, $current, 1)), 0)[1]
    let $c1 :=
      if ($c0 < 128) then
        $p:MAP0[1 + $c0]
      else if ($c0 < 55296) then
        let $c1 := $c0 idiv 8
        let $c2 := $c1 idiv 32
        return $p:MAP1[1 + $c0 mod 8 + $p:MAP1[1 + $c1 mod 32 + $p:MAP1[1 + $c2]]]
      else
        p:map2($c0, 1, 2)
    let $current := $current + 1
    let $i0 := 2048 * $c1 + $current-state - 1
    let $i1 := $i0 idiv 16
    let $next-state := $p:TRANSITION[$i0 mod 16 + $p:TRANSITION[$i1 + 1] + 1]
    return
      if ($next-state > 2047) then
        p:transition($input, $begin, $current, $current, $next-state, $next-state mod 2048, $current-state)
      else
        p:transition($input, $begin, $current, $end, $result, $next-state, $current-state)
};

(:~
 : Recursively translate one 32-bit chunk of an expected token bitset
 : to the corresponding sequence of token strings.
 :
 : @param $result the result of previous recursion levels.
 : @param $chunk the 32-bit chunk of the expected token bitset.
 : @param $base-token-code the token code of bit 0 in the current chunk.
 : @return the set of token strings.
 :)
declare function p:token($result as xs:string*,
                         $chunk as xs:integer,
                         $base-token-code as xs:integer) as xs:string*
{
  if ($chunk = 0) then
    $result
  else
    p:token
    (
      ($result, if ($chunk mod 2 != 0) then $p:TOKEN[$base-token-code] else ()),
      if ($chunk < 0) then $chunk idiv 2 + 2147483648 else $chunk idiv 2,
      $base-token-code + 1
    )
};

(:~
 : Calculate expected token set for a given DFA state as a sequence
 : of strings.
 :
 : @param $state the DFA state.
 : @return the set of token strings
 :)
declare function p:expected-token-set($state as xs:integer) as xs:string*
{
  if ($state > 0) then
    for $t in 0 to 5
    let $i0 := $t * 1387 + $state - 1
    let $i1 := $i0 idiv 4
    let $i2 := $i1 idiv 4
    let $i3 := $i2 idiv 16
    return p:token((), $p:EXPECTED[$i0 mod 4 + $p:EXPECTED[$i1 mod 4 + $p:EXPECTED[$i2 mod 16 + $p:EXPECTED[$i3 + 1] + 1] + 1] + 1], $t * 32 + 1)
  else
    ()
};

(:~
 : Classify codepoint by doing a tail recursive binary search for a
 : matching codepoint range entry in MAP2, the codepoint to charclass
 : map for codepoints above the surrogate block.
 :
 : @param $c the codepoint.
 : @param $lo the binary search lower bound map index.
 : @param $hi the binary search upper bound map index.
 : @return the character class.
 :)
declare function p:map2($c as xs:integer, $lo as xs:integer, $hi as xs:integer) as xs:integer
{
  if ($lo > $hi) then
    0
  else
    let $m := ($hi + $lo) idiv 2
    return
      if ($p:MAP2[$m] > $c) then
        p:map2($c, $lo, $m - 1)
      else if ($p:MAP2[2 + $m] < $c) then
        p:map2($c, $m + 1, $hi)
      else
        $p:MAP2[4 + $m]
};

(:~
 : The index of the parser state for accessing the combined
 : (i.e. level > 1) lookahead code.
 :)
declare variable $p:lk := 1;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the token that has been shifted.
 :)
declare variable $p:b0 := 2;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the token that has been shifted.
 :)
declare variable $p:e0 := 3;

(:~
 : The index of the parser state for accessing the code of the
 : level-1-lookahead token.
 :)
declare variable $p:l1 := 4;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-1-lookahead token.
 :)
declare variable $p:b1 := 5;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-1-lookahead token.
 :)
declare variable $p:e1 := 6;

(:~
 : The index of the parser state for accessing the code of the
 : level-2-lookahead token.
 :)
declare variable $p:l2 := 7;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-2-lookahead token.
 :)
declare variable $p:b2 := 8;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-2-lookahead token.
 :)
declare variable $p:e2 := 9;

(:~
 : The index of the parser state for accessing the code of the
 : level-3-lookahead token.
 :)
declare variable $p:l3 := 10;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-3-lookahead token.
 :)
declare variable $p:b3 := 11;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-3-lookahead token.
 :)
declare variable $p:e3 := 12;

(:~
 : The index of the parser state for accessing the token code that
 : was expected when an error was found.
 :)
declare variable $p:error := 13;

(:~
 : The index of the parser state that points to the first entry
 : used for collecting action results.
 :)
declare variable $p:result := 14;

(:~
 : Create a textual error message from a parsing error.
 :
 : @param $input the input string.
 : @param $error the parsing error descriptor.
 : @return the error message.
 :)
declare function p:error-message($input as xs:string, $error as element(error)) as xs:string
{
  let $begin := xs:integer($error/@b)
  let $context := string-to-codepoints(substring($input, 1, $begin - 1))
  let $linefeeds := index-of($context, 10)
  let $line := count($linefeeds) + 1
  let $column := ($begin - $linefeeds[last()], $begin)[1]
  return
    if ($error/@o) then
      concat
      (
        "syntax error, found ", $p:TOKEN[$error/@o + 1], "&#10;",
        "while expecting ", $p:TOKEN[$error/@x + 1], "&#10;",
        "after scanning ", string($error/@e - $begin), " characters at line ",
        string($line), ", column ", string($column), "&#10;",
        "...", substring($input, $begin, 32), "..."
      )
    else
      let $expected := p:expected-token-set($error/@s)
      return
        concat
        (
          "lexical analysis failed&#10;",
          "while expecting ",
          "["[exists($expected[2])],
          string-join($expected, ", "),
          "]"[exists($expected[2])],
          "&#10;",
          "after scanning ", string($error/@e - $begin), " characters at line ",
          string($line), ", column ", string($column), "&#10;",
          "...", substring($input, $begin, 32), "..."
        )
};

(:~
 : Shift one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : parser state.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:shift($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] = $code) then
  (
    $state[position() >= $p:l1 and position() <= $p:e3],
    0,
    $state[$p:e3],
    $state[position() >= $p:e3],
    if ($state[$p:e0] != $state[$p:b1]) then
      text {substring($input, $state[$p:e0], $state[$p:b1] - $state[$p:e0])}
    else
      (),
    let $name := $p:TOKEN[1 + $state[$p:l1]]
    let $content := substring($input, $state[$p:b1], $state[$p:e1] - $state[$p:b1])
    return
      if (starts-with($name, "'")) then
		    element TOKEN {$content}
	    else
	      element {$name} {$content}
  )
  else
  (
    $state[position() < $p:error],
    element error
    {
      attribute b {$state[$p:b1]},
      attribute e {$state[$p:e1]},
      if ($state[$p:l1] < 0) then
        attribute s {- $state[$p:l1]}
      else
        (attribute o {$state[$p:l1]}, attribute x {$code})
    },
    $state[position() > $p:error]
  )
};

(:~
 : Use p:match to fetch the next token, but skip any leading
 : whitespace.
 :
 : @param $input the input string.
 : @param $begin the index where to start.
 : @param $token-set the valid token set id.
 : @return a sequence of three values: the token code of the result
 : token, with input string positions of token begin and end.
 :)
declare function p:matchW($input as xs:string,
                          $begin as xs:integer,
                          $token-set as xs:integer) as xs:integer+
{
  let $match := p:match($input, $begin, $token-set)
  return
    if ($match[1] = 15) then                                (: S^WS :)
      p:matchW($input, $match[3], $token-set)
    else if ($match[1] = 35) then                           (: ('(' ':') :)
      let $state := p:parse-Whitespace($input, (0, 0, 0, $match, 0, $match[3], 0, 0, 0, 0, false()))
      return p:matchW($input, $state[$p:e0], $token-set)
    else
      $match
};

(:~
 : Lookahead one token on level 1 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead1W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] != 0) then
    $state
  else
    let $match := p:matchW($input, $state[$p:b1], $set)
    return
    (
      $match[1],
      $state[position() > $p:lk and position() < $p:l1],
      $match,
      0, $match[3], 0,
      $state[position() > $p:e2]
    )
};

(:~
 : Lookahead one token on level 2 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead2W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l2] != 0) then
      $state[position() >= $p:l2 and position() <= $p:e2]
    else
      p:matchW($input, $state[$p:b2], $set)
  return
  (
    $match[1] * 256 + $state[$p:l1],
    $state[position() > $p:lk and position() < $p:l2],
    $match,
    0, $match[3], 0,
    $state[position() > $p:e3]
  )
};

(:~
 : Lookahead one token on level 3 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead3W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l3] != 0) then
      $state[position() >= $p:l3 and position() <= $p:e3]
    else
      p:matchW($input, $state[$p:b3], $set)
  return
  (
    $match[1] * 65536 + $state[$p:lk],
    $state[position() > $p:lk and position() < $p:l3],
    $match,
    $state[position() > $p:e3]
  )
};

(:~
 : Lookahead one token on level 1.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead1($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] != 0) then
    $state
  else
    let $match := p:match($input, $state[$p:b1], $set)
    return
    (
      $match[1],
      $state[position() > $p:lk and position() < $p:l1],
      $match,
      0, $match[3], 0,
      $state[position() > $p:e2]
    )
};

(:~
 : Reduce the result stack. Pop $count element, wrap them in a
 : new element named $name, and push the new element.
 :
 : @param $state the parser state.
 : @param $name the name of the result node.
 : @param $count the number of child nodes.
 : @return the updated parser state.
 :)
declare function p:reduce($state as item()+, $name as xs:string, $count as xs:integer) as item()+
{
  $state[position() <= $count],
  element {$name}
  {
    $state[position() > $count]
  }
};

(:~
 : Parse the 1st loop of production Comment (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Comment-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(46, $input, $state)          (: CommentContents | ('(' ':') | (':' ')') :)
    return
      if ($state[$p:l1] = 49) then                          (: (':' ')') :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 20) then                      (: CommentContents :)
            let $state := p:shift(20, $input, $state)       (: CommentContents :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-Comment($input, $state)
            return $state
        return p:parse-Comment-1($input, $state)
};

(:~
 : Parse Comment.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Comment($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(35, $input, $state)                 (: ('(' ':') :)
  let $state := p:parse-Comment-1($input, $state)
  let $state := p:shift(49, $input, $state)                 (: (':' ')') :)
  return p:reduce($state, "Comment", $count)
};

(:~
 : Parse the 1st loop of production Whitespace (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Whitespace-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(21, $input, $state)          (: END | S^WS | ('(' ':') :)
    return
      if ($state[$p:l1] = 1) then                           (: END :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 15) then                      (: S^WS :)
            let $state := p:shift(15, $input, $state)       (: S^WS :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-Comment($input, $state)
            return $state
        return p:parse-Whitespace-1($input, $state)
};

(:~
 : Parse Whitespace.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Whitespace($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-Whitespace-1($input, $state)
  return p:reduce($state, "Whitespace", $count)
};

(:~
 : Parse Value.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Value($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(12, $input, $state)            (: StringLiteral | QName^Token :)
  let $state :=
    if ($state[$p:l1] = 6) then                             (: StringLiteral :)
      let $state := p:shift(6, $input, $state)              (: StringLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(18, $input, $state)             (: QName^Token :)
      return $state
  return p:reduce($state, "Value", $count)
};

(:~
 : Parse Key.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Key($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(18, $input, $state)                 (: QName^Token :)
  return p:reduce($state, "Key", $count)
};

(:~
 : Parse the 1st loop of production KeyValuePairs (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-KeyValuePairs-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(49, $input, $state)         (: S^WS | QName^Token | EOF | ('(' ':') :)
    return
      if ($state[$p:l1] != 18) then                         (: QName^Token :)
        $state
      else
        let $state := p:parse-Key($input, $state)
        let $state := p:lookahead1W(73, $input, $state)     (: S^WS | QName^Token | EOF | ('(' ':') | '=' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 59) then                 (: '=' :)
            let $state := p:shift(59, $input, $state)       (: '=' :)
            let $state := p:lookahead1W(47, $input, $state) (: StringLiteral | S^WS | QName^Token | ('(' ':') :)
            let $state := p:parse-Value($input, $state)
            return $state
          else
            $state
        return p:parse-KeyValuePairs-1($input, $state)
};

(:~
 : Parse KeyValuePairs.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-KeyValuePairs($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-KeyValuePairs-1($input, $state)
  let $state := p:shift(25, $input, $state)                 (: EOF :)
  return p:reduce($state, "KeyValuePairs", $count)
};

(:~
 : Parse ParamWithDefault.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParamWithDefault($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(52, $input, $state)           (: S^WS | '$' | ('(' ':') | 'tunnel' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 160) then                      (: 'tunnel' :)
      let $state := p:parse-Tunnel($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Param($input, $state)
  let $state := p:lookahead1W(75, $input, $state)           (: S^WS | ('(' ':') | ')' | ',' | ':=' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 51) then                       (: ':=' :)
      let $state := p:shift(51, $input, $state)             (: ':=' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-ExprSingle($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "ParamWithDefault", $count)
};

(:~
 : Parse the 1st loop of production RuleParamList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RuleParamList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(58, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-ParamWithDefault($input, $state)
        return p:parse-RuleParamList-1($input, $state)
};

(:~
 : Parse RuleParamList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RuleParamList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ParamWithDefault($input, $state)
  let $state := p:parse-RuleParamList-1($input, $state)
  return p:reduce($state, "RuleParamList", $count)
};

(:~
 : Parse NextPathPatternOpt.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NextPathPatternOpt($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(76, $input, $state)           (: S^WS | ('(' ':') | ')' | ';' | '|' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 171) then                      (: '|' :)
      let $state := p:shift(171, $input, $state)            (: '|' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-PathPattern($input, $state)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-NextPathPatternOpt($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "NextPathPatternOpt", $count)
};

(:~
 : Parse KeyValue.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-KeyValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(83, $input, $state)            (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | '$' :)
  let $state :=
    if ($state[$p:l1] = 31) then                            (: '$' :)
      let $state := p:parse-VarRef($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-Literal($input, $state)
      return $state
  return p:reduce($state, "KeyValue", $count)
};

(:~
 : Parse IdValue.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IdValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(13, $input, $state)            (: StringLiteral | '$' :)
  let $state :=
    if ($state[$p:l1] = 6) then                             (: StringLiteral :)
      let $state := p:shift(6, $input, $state)              (: StringLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-VarRef($input, $state)
      return $state
  return p:reduce($state, "IdValue", $count)
};

(:~
 : Parse IdKeyPattern.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IdKeyPattern($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 112) then                           (: 'id' :)
      let $state := p:shift(112, $input, $state)            (: 'id' :)
      let $state := p:lookahead1W(27, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:shift(33, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-IdValue($input, $state)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:shift(36, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(122, $input, $state)            (: 'key' :)
      let $state := p:lookahead1W(27, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:shift(33, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(22, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:shift(6, $input, $state)              (: StringLiteral :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | ',' :)
      let $state := p:shift(41, $input, $state)             (: ',' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-KeyValue($input, $state)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:shift(36, $input, $state)             (: ')' :)
      return $state
  return p:reduce($state, "IdKeyPattern", $count)
};

(:~
 : Parse PatternAxis.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PatternAxis($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 82) then                            (: 'child' :)
      let $state := p:shift(82, $input, $state)             (: 'child' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 75) then                       (: 'attribute' :)
      let $state := p:shift(75, $input, $state)             (: 'attribute' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(65, $input, $state)             (: '@' :)
      return $state
  return p:reduce($state, "PatternAxis", $count)
};

(:~
 : Parse PatternStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PatternStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(135, $input, $state)          (: S^WS | QName^Token | Wildcard | ('(' ':') | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'ne' | 'node' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 75) then                            (: 'attribute' :)
      let $state := p:lookahead2W(95, $input, $state)       (: S^WS | '(' | ('(' ':') | ')' | '/' | '//' | '::' | ';' |
                                                               '[' | '|' :)
      return $state
    else if ($state[$p:l1] = 82) then                       (: 'child' :)
      let $state := p:lookahead2W(93, $input, $state)       (: S^WS | ('(' ':') | ')' | '/' | '//' | '::' | ';' | '[' |
                                                               '|' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 65                             (: '@' :)
          or $state[$p:lk] = 12875                          (: 'attribute' '::' :)
          or $state[$p:lk] = 12882) then                    (: 'child' '::' :)
      let $state := p:parse-PatternAxis($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-NodeTest($input, $state)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-PredicateList($input, $state)
  return p:reduce($state, "PatternStep", $count)
};

(:~
 : Parse RelativePathPattern.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RelativePathPattern($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-PatternStep($input, $state)
  let $state := p:lookahead1W(87, $input, $state)           (: S^WS | ('(' ':') | ')' | '/' | '//' | ';' | '|' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 46                             (: '/' :)
          or $state[$p:l1] = 47) then                       (: '//' :)
      let $state :=
        if ($state[$p:l1] = 46) then                        (: '/' :)
          let $state := p:shift(46, $input, $state)         (: '/' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(47, $input, $state)         (: '//' :)
          return $state
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-RelativePathPattern($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "RelativePathPattern", $count)
};

(:~
 : Parse PathPattern.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PathPattern($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(142, $input, $state)          (: S^WS | QName^Token | Wildcard | ('(' ':') | '/' | '//' |
                                                               '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'id' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'key' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 46) then                            (: '/' :)
      let $state := p:shift(46, $input, $state)             (: '/' :)
      let $state := p:lookahead1W(141, $input, $state)      (: S^WS | QName^Token | Wildcard | ('(' ':') | ')' | ';' |
                                                               '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '|' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 36                        (: ')' :)
             and $state[$p:l1] != 52                        (: ';' :)
             and $state[$p:l1] != 171) then                 (: '|' :)
          let $state := p:parse-RelativePathPattern($input, $state)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 47) then                       (: '//' :)
      let $state := p:shift(47, $input, $state)             (: '//' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-RelativePathPattern($input, $state)
      return $state
    else if ($state[$p:l1] = 112                            (: 'id' :)
          or $state[$p:l1] = 122) then                      (: 'key' :)
      let $state := p:parse-IdKeyPattern($input, $state)
      let $state := p:lookahead1W(87, $input, $state)       (: S^WS | ('(' ':') | ')' | '/' | '//' | ';' | '|' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 46                         (: '/' :)
              or $state[$p:l1] = 47) then                   (: '//' :)
          let $state :=
            if ($state[$p:l1] = 46) then                    (: '/' :)
              let $state := p:shift(46, $input, $state)     (: '/' :)
              return $state
            else if ($state[$p:error]) then
              $state
            else
              let $state := p:shift(47, $input, $state)     (: '//' :)
              return $state
          let $state := p:lookahead1W(20, $input, $state)   (: EPSILON | S^WS | ('(' ':') :)
          let $state := p:parse-RelativePathPattern($input, $state)
          return $state
        else
          $state
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-RelativePathPattern($input, $state)
      return $state
  return p:reduce($state, "PathPattern", $count)
};

(:~
 : Parse Pattern.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Pattern($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-PathPattern($input, $state)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-NextPathPatternOpt($input, $state)
  return p:reduce($state, "Pattern", $count)
};

(:~
 : Parse the 1st loop of production RuleDecl (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RuleDecl-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(56, $input, $state)         (: S^WS | '(' | ('(' ':') | '|' :)
    return
      if ($state[$p:l1] != 171) then                        (: '|' :)
        $state
      else
        let $state := p:shift(171, $input, $state)          (: '|' :)
        let $state := p:lookahead1W(136, $input, $state)    (: S^WS | QName^Token | '#current' | '#default' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
        let $state := p:parse-ModeName($input, $state)
        return p:parse-RuleDecl-1($input, $state)
};

(:~
 : Parse RuleDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RuleDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(68, $input, $state)                 (: '^' :)
  let $state := p:lookahead1W(140, $input, $state)          (: S^WS | QName^Token | '#current' | '#default' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 33) then                      (: '(' :)
      let $state := p:parse-ModeName($input, $state)
      let $state := p:parse-RuleDecl-1($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Pattern($input, $state)
  let $state := p:lookahead1W(59, $input, $state)           (: S^WS | ('(' ':') | ')' | ';' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 52) then                       (: ';' :)
      let $state := p:shift(52, $input, $state)             (: ';' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-RuleParamList($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(72, $input, $state)           (: IntegerLiteral | DecimalLiteral | S^WS | ('(' ':') | ':=' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 51) then                      (: ':=' :)
      let $state :=
        if ($state[$p:l1] = 3) then                         (: IntegerLiteral :)
          let $state := p:shift(3, $input, $state)          (: IntegerLiteral :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(4, $input, $state)          (: DecimalLiteral :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(31, $input, $state)           (: S^WS | ('(' ':') | ':=' :)
  let $state := p:shift(51, $input, $state)                 (: ':=' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  return p:reduce($state, "RuleDecl", $count)
};

(:~
 : Parse the 1st loop of production ParamList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParamList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(58, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-Param($input, $state)
        return p:parse-ParamList-1($input, $state)
};

(:~
 : Parse ParamList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParamList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-Param($input, $state)
  let $state := p:parse-ParamList-1($input, $state)
  return p:reduce($state, "ParamList", $count)
};

(:~
 : Parse FunctionDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-FunctionName($input, $state)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(50, $input, $state)           (: S^WS | '$' | ('(' ':') | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:parse-ParamList($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(63, $input, $state)           (: S^WS | ('(' ':') | ':=' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 72) then                       (: 'as' :)
      let $state := p:shift(72, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(31, $input, $state)           (: S^WS | ('(' ':') | ':=' :)
  let $state := p:shift(51, $input, $state)                 (: ':=' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  return p:reduce($state, "FunctionDecl", $count)
};

(:~
 : Parse NodeComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NodeComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 120) then                           (: 'is' :)
      let $state := p:shift(120, $input, $state)            (: 'is' :)
      return $state
    else if ($state[$p:l1] = 56) then                       (: '<<' :)
      let $state := p:shift(56, $input, $state)             (: '<<' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(62, $input, $state)             (: '>>' :)
      return $state
  return p:reduce($state, "NodeComp", $count)
};

(:~
 : Parse GeneralComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-GeneralComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 59) then                            (: '=' :)
      let $state := p:shift(59, $input, $state)             (: '=' :)
      return $state
    else if ($state[$p:l1] = 26) then                       (: '!=' :)
      let $state := p:shift(26, $input, $state)             (: '!=' :)
      return $state
    else if ($state[$p:l1] = 53) then                       (: '<' :)
      let $state := p:shift(53, $input, $state)             (: '<' :)
      return $state
    else if ($state[$p:l1] = 57) then                       (: '<=' :)
      let $state := p:shift(57, $input, $state)             (: '<=' :)
      return $state
    else if ($state[$p:l1] = 60) then                       (: '>' :)
      let $state := p:shift(60, $input, $state)             (: '>' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(61, $input, $state)             (: '>=' :)
      return $state
  return p:reduce($state, "GeneralComp", $count)
};

(:~
 : Parse ValueComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValueComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 101) then                           (: 'eq' :)
      let $state := p:shift(101, $input, $state)            (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 131) then                      (: 'ne' :)
      let $state := p:shift(131, $input, $state)            (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 127) then                      (: 'lt' :)
      let $state := p:shift(127, $input, $state)            (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 124) then                      (: 'le' :)
      let $state := p:shift(124, $input, $state)            (: 'le' :)
      return $state
    else if ($state[$p:l1] = 111) then                      (: 'gt' :)
      let $state := p:shift(111, $input, $state)            (: 'gt' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(109, $input, $state)            (: 'ge' :)
      return $state
  return p:reduce($state, "ValueComp", $count)
};

(:~
 : Parse SingleType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SingleType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(127, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-AtomicType($input, $state)
  let $state := p:lookahead1W(112, $input, $state)          (: S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | '?' |
                                                               ']' | 'and' | 'ascending' | 'case' | 'castable' |
                                                               'collation' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'eq' | 'except' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'to' | 'treat' | 'union' |
                                                               'where' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 63) then                       (: '?' :)
      let $state := p:shift(63, $input, $state)             (: '?' :)
      return $state
    else
      $state
  return p:reduce($state, "SingleType", $count)
};

(:~
 : Parse Pragma.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Pragma($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(6, $input, $state)             (: '(#' :)
  let $state := p:shift(34, $input, $state)                 (: '(#' :)
  let $state := p:lookahead1(128, $input, $state)           (: S | QName^Token | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 14) then                       (: S :)
      let $state := p:shift(14, $input, $state)             (: S :)
      return $state
    else
      $state
  let $state := p:lookahead1(127, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-QName($input, $state)
  let $state := p:lookahead1(14, $input, $state)            (: S | '#)' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 14) then                       (: S :)
      let $state := p:shift(14, $input, $state)             (: S :)
      let $state := p:lookahead1(2, $input, $state)         (: PragmaContents :)
      let $state := p:shift(21, $input, $state)             (: PragmaContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(4, $input, $state)             (: '#)' :)
  let $state := p:shift(28, $input, $state)                 (: '#)' :)
  return p:reduce($state, "Pragma", $count)
};

(:~
 : Parse the 1st loop of production ExtensionExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ExtensionExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:parse-Pragma($input, $state)
    let $state := p:lookahead1W(57, $input, $state)         (: S^WS | '(#' | ('(' ':') | '{' :)
    return
      if ($state[$p:l1] != 34) then                         (: '(#' :)
        $state
      else
        p:parse-ExtensionExpr-1($input, $state)
};

(:~
 : Parse ExtensionExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ExtensionExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ExtensionExpr-1($input, $state)
  let $state := p:shift(169, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(147, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               '^' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 172) then                     (: '}' :)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(45, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(172, $input, $state)                (: '}' :)
  return p:reduce($state, "ExtensionExpr", $count)
};

(:~
 : Parse AbbrevForwardStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AbbrevForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 65) then                       (: '@' :)
      let $state := p:shift(65, $input, $state)             (: '@' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-NodeTest($input, $state)
  return p:reduce($state, "AbbrevForwardStep", $count)
};

(:~
 : Parse ForwardAxis.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForwardAxis($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 82) then                            (: 'child' :)
      let $state := p:shift(82, $input, $state)             (: 'child' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 90) then                       (: 'descendant' :)
      let $state := p:shift(90, $input, $state)             (: 'descendant' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 75) then                       (: 'attribute' :)
      let $state := p:shift(75, $input, $state)             (: 'attribute' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 151) then                      (: 'self' :)
      let $state := p:shift(151, $input, $state)            (: 'self' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 91) then                       (: 'descendant-or-self' :)
      let $state := p:shift(91, $input, $state)             (: 'descendant-or-self' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 106) then                      (: 'following-sibling' :)
      let $state := p:shift(106, $input, $state)            (: 'following-sibling' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(105, $input, $state)            (: 'following' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
  return p:reduce($state, "ForwardAxis", $count)
};

(:~
 : Parse ForwardStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 75) then                            (: 'attribute' :)
      let $state := p:lookahead2W(122, $input, $state)      (: S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 82                             (: 'descendant' :)
          or $state[$p:l1] = 90                             (: 'descendant-or-self' :)
          or $state[$p:l1] = 91                             (: 'following' :)
          or $state[$p:l1] = 105                            (: 'following-sibling' :)
          or $state[$p:l1] = 106                            (: 'self' :)
          or $state[$p:l1] = 151) then                      (: 'self' :)
      let $state := p:lookahead2W(120, $input, $state)      (: S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                               '/' | '//' | '::' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 12875                               (: 'attribute' '::' :)
     or $state[$p:lk] = 12882                               (: 'child' '::' :)
     or $state[$p:lk] = 12890                               (: 'descendant' '::' :)
     or $state[$p:lk] = 12891                               (: 'descendant-or-self' '::' :)
     or $state[$p:lk] = 12905                               (: 'following' '::' :)
     or $state[$p:lk] = 12906                               (: 'following-sibling' '::' :)
     or $state[$p:lk] = 12951) then                         (: 'self' '::' :)
      let $state := p:parse-ForwardAxis($input, $state)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-NodeTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AbbrevForwardStep($input, $state)
      return $state
  return p:reduce($state, "ForwardStep", $count)
};

(:~
 : Parse AbbrevReverseStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AbbrevReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(45, $input, $state)                 (: '..' :)
  return p:reduce($state, "AbbrevReverseStep", $count)
};

(:~
 : Parse NameTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NameTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 24) then                            (: Wildcard :)
      let $state := p:shift(24, $input, $state)             (: Wildcard :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-QName($input, $state)
      return $state
  return p:reduce($state, "NameTest", $count)
};

(:~
 : Parse NodeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NodeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(129, $input, $state)           (: QName^Token | Wildcard | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 75                                  (: 'comment' :)
     or $state[$p:l1] = 84                                  (: 'document-node' :)
     or $state[$p:l1] = 95                                  (: 'element' :)
     or $state[$p:l1] = 96                                  (: 'node' :)
     or $state[$p:l1] = 134                                 (: 'processing-instruction' :)
     or $state[$p:l1] = 145                                 (: 'schema-attribute' :)
     or $state[$p:l1] = 149                                 (: 'schema-element' :)
     or $state[$p:l1] = 150                                 (: 'text' :)
     or $state[$p:l1] = 156) then                           (: 'text' :)
      let $state := p:lookahead2W(119, $input, $state)      (: S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 8523                                (: 'attribute' '(' :)
     or $state[$p:lk] = 8532                                (: 'comment' '(' :)
     or $state[$p:lk] = 8543                                (: 'document-node' '(' :)
     or $state[$p:lk] = 8544                                (: 'element' '(' :)
     or $state[$p:lk] = 8582                                (: 'node' '(' :)
     or $state[$p:lk] = 8593                                (: 'processing-instruction' '(' :)
     or $state[$p:lk] = 8597                                (: 'schema-attribute' '(' :)
     or $state[$p:lk] = 8598                                (: 'schema-element' '(' :)
     or $state[$p:lk] = 8604) then                          (: 'text' '(' :)
      let $state := p:parse-KindTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NameTest($input, $state)
      return $state
  return p:reduce($state, "NodeTest", $count)
};

(:~
 : Parse ReverseAxis.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ReverseAxis($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 141) then                           (: 'parent' :)
      let $state := p:shift(141, $input, $state)            (: 'parent' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 69) then                       (: 'ancestor' :)
      let $state := p:shift(69, $input, $state)             (: 'ancestor' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'preceding-sibling' :)
      let $state := p:shift(143, $input, $state)            (: 'preceding-sibling' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 142) then                      (: 'preceding' :)
      let $state := p:shift(142, $input, $state)            (: 'preceding' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(70, $input, $state)             (: 'ancestor-or-self' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
  return p:reduce($state, "ReverseAxis", $count)
};

(:~
 : Parse ReverseStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 45) then                            (: '..' :)
      let $state := p:parse-AbbrevReverseStep($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ReverseAxis($input, $state)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-NodeTest($input, $state)
      return $state
  return p:reduce($state, "ReverseStep", $count)
};

(:~
 : Parse AxisStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AxisStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 69                                  (: 'ancestor-or-self' :)
     or $state[$p:l1] = 70                                  (: 'parent' :)
     or $state[$p:l1] = 141                                 (: 'preceding' :)
     or $state[$p:l1] = 142                                 (: 'preceding-sibling' :)
     or $state[$p:l1] = 143) then                           (: 'preceding-sibling' :)
      let $state := p:lookahead2W(120, $input, $state)      (: S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                               '/' | '//' | '::' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 45                                  (: '..' :)
     or $state[$p:lk] = 12869                               (: 'ancestor' '::' :)
     or $state[$p:lk] = 12870                               (: 'ancestor-or-self' '::' :)
     or $state[$p:lk] = 12941                               (: 'parent' '::' :)
     or $state[$p:lk] = 12942                               (: 'preceding' '::' :)
     or $state[$p:lk] = 12943) then                         (: 'preceding-sibling' '::' :)
      let $state := p:parse-ReverseStep($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ForwardStep($input, $state)
      return $state
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-PredicateList($input, $state)
  return p:reduce($state, "AxisStep", $count)
};

(:~
 : Parse Predicate.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Predicate($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(66, $input, $state)                 (: '[' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(34, $input, $state)           (: S^WS | ('(' ':') | ']' :)
  let $state := p:shift(67, $input, $state)                 (: ']' :)
  return p:reduce($state, "Predicate", $count)
};

(:~
 : Parse the 1st loop of production PredicateList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PredicateList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(116, $input, $state)        (: S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                               '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
    return
      if ($state[$p:l1] != 66) then                         (: '[' :)
        $state
      else
        let $state := p:parse-Predicate($input, $state)
        return p:parse-PredicateList-1($input, $state)
};

(:~
 : Parse PredicateList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PredicateList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-PredicateList-1($input, $state)
  return p:reduce($state, "PredicateList", $count)
};

(:~
 : Parse Param.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Param($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(5, $input, $state)             (: '$' :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(130, $input, $state)          (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-QName($input, $state)
  let $state := p:lookahead1W(84, $input, $state)           (: S^WS | ('(' ':') | ')' | ',' | ':=' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 72) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "Param", $count)
};

(:~
 : Parse Tunnel.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Tunnel($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(160, $input, $state)                (: 'tunnel' :)
  return p:reduce($state, "Tunnel", $count)
};

(:~
 : Parse InitializedParam.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InitializedParam($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(52, $input, $state)           (: S^WS | '$' | ('(' ':') | 'tunnel' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 160) then                      (: 'tunnel' :)
      let $state := p:parse-Tunnel($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Param($input, $state)
  let $state := p:lookahead1W(31, $input, $state)           (: S^WS | ('(' ':') | ':=' :)
  let $state := p:shift(51, $input, $state)                 (: ':=' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "InitializedParam", $count)
};

(:~
 : Parse the 1st loop of production RulesetCallParamList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RulesetCallParamList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(58, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-InitializedParam($input, $state)
        return p:parse-RulesetCallParamList-1($input, $state)
};

(:~
 : Parse RulesetCallParamList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RulesetCallParamList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-InitializedParam($input, $state)
  let $state := p:parse-RulesetCallParamList-1($input, $state)
  return p:reduce($state, "RulesetCallParamList", $count)
};

(:~
 : Parse ModeName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ModeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(131, $input, $state)           (: QName^Token | '#current' | '#default' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 29) then                            (: '#current' :)
      let $state := p:shift(29, $input, $state)             (: '#current' :)
      return $state
    else if ($state[$p:l1] = 30) then                       (: '#default' :)
      let $state := p:shift(30, $input, $state)             (: '#default' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-QName($input, $state)
      return $state
  return p:reduce($state, "ModeName", $count)
};

(:~
 : Parse RulesetCall.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RulesetCall($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(68, $input, $state)                 (: '^' :)
  let $state := p:lookahead1W(140, $input, $state)          (: S^WS | QName^Token | '#current' | '#default' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 33) then                      (: '(' :)
      let $state := p:parse-ModeName($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(149, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | ('(' ':') | ')' | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | ';' | '<' | '<!--' |
                                                               '<?' | '@' | '^' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36                            (: ')' :)
         and $state[$p:l1] != 52) then                      (: ';' :)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(59, $input, $state)           (: S^WS | ('(' ':') | ')' | ';' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 52) then                       (: ';' :)
      let $state := p:shift(52, $input, $state)             (: ';' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-RulesetCallParamList($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "RulesetCall", $count)
};

(:~
 : Parse CompCopyConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompCopyConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(86, $input, $state)                 (: 'copy' :)
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(169, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(45, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(172, $input, $state)                (: '}' :)
  return p:reduce($state, "CompCopyConstructor", $count)
};

(:~
 : Parse CompPIConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(145, $input, $state)                (: 'processing-instruction' :)
  let $state := p:lookahead1W(101, $input, $state)          (: S^WS | NCName^Token | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '{' :)
  let $state :=
    if ($state[$p:l1] = 169) then                           (: '{' :)
      let $state := p:shift(169, $input, $state)            (: '{' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-Expr($input, $state)
      let $state := p:lookahead1W(45, $input, $state)       (: S^WS | ('(' ':') | '}' :)
      let $state := p:shift(172, $input, $state)            (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NCName($input, $state)
      return $state
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(169, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(147, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               '^' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 172) then                     (: '}' :)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(45, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(172, $input, $state)                (: '}' :)
  return p:reduce($state, "CompPIConstructor", $count)
};

(:~
 : Parse CompCommentConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(84, $input, $state)                 (: 'comment' :)
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(169, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(45, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(172, $input, $state)                (: '}' :)
  return p:reduce($state, "CompCommentConstructor", $count)
};

(:~
 : Parse CompTextConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompTextConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(156, $input, $state)                (: 'text' :)
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(169, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(45, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(172, $input, $state)                (: '}' :)
  return p:reduce($state, "CompTextConstructor", $count)
};

(:~
 : Parse CompAttrConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompAttrConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(75, $input, $state)                 (: 'attribute' :)
  let $state := p:lookahead1W(134, $input, $state)          (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
  let $state :=
    if ($state[$p:l1] = 169) then                           (: '{' :)
      let $state := p:shift(169, $input, $state)            (: '{' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-Expr($input, $state)
      let $state := p:lookahead1W(45, $input, $state)       (: S^WS | ('(' ':') | '}' :)
      let $state := p:shift(172, $input, $state)            (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-QName($input, $state)
      return $state
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(169, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(147, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               '^' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 172) then                     (: '}' :)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(45, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(172, $input, $state)                (: '}' :)
  return p:reduce($state, "CompAttrConstructor", $count)
};

(:~
 : Parse ContentExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ContentExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-Expr($input, $state)
  return p:reduce($state, "ContentExpr", $count)
};

(:~
 : Parse CompElemConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(96, $input, $state)                 (: 'element' :)
  let $state := p:lookahead1W(134, $input, $state)          (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
  let $state :=
    if ($state[$p:l1] = 169) then                           (: '{' :)
      let $state := p:shift(169, $input, $state)            (: '{' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-Expr($input, $state)
      let $state := p:lookahead1W(45, $input, $state)       (: S^WS | ('(' ':') | '}' :)
      let $state := p:shift(172, $input, $state)            (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-QName($input, $state)
      return $state
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(169, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(147, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               '^' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 172) then                     (: '}' :)
      let $state := p:parse-ContentExpr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(45, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(172, $input, $state)                (: '}' :)
  return p:reduce($state, "CompElemConstructor", $count)
};

(:~
 : Parse CompDocConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompDocConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(94, $input, $state)                 (: 'document' :)
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(169, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(45, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(172, $input, $state)                (: '}' :)
  return p:reduce($state, "CompDocConstructor", $count)
};

(:~
 : Parse ComputedConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ComputedConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 94) then                            (: 'document' :)
      let $state := p:parse-CompDocConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 96) then                       (: 'element' :)
      let $state := p:parse-CompElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 75) then                       (: 'attribute' :)
      let $state := p:parse-CompAttrConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 156) then                      (: 'text' :)
      let $state := p:parse-CompTextConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'comment' :)
      let $state := p:parse-CompCommentConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'processing-instruction' :)
      let $state := p:parse-CompPIConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CompCopyConstructor($input, $state)
      return $state
  return p:reduce($state, "ComputedConstructor", $count)
};

(:~
 : Parse DirPIConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(58, $input, $state)                 (: '<?' :)
  let $state := p:lookahead1(1, $input, $state)             (: PITarget :)
  let $state := p:shift(19, $input, $state)                 (: PITarget :)
  let $state := p:lookahead1(17, $input, $state)            (: S | '?>' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 14) then                       (: S :)
      let $state := p:shift(14, $input, $state)             (: S :)
      let $state := p:lookahead1(3, $input, $state)         (: DirPIContents :)
      let $state := p:shift(22, $input, $state)             (: DirPIContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(10, $input, $state)            (: '?>' :)
  let $state := p:shift(64, $input, $state)                 (: '?>' :)
  return p:reduce($state, "DirPIConstructor", $count)
};

(:~
 : Parse DirCommentConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(54, $input, $state)                 (: '<!--' :)
  let $state := p:lookahead1(0, $input, $state)             (: DirCommentContents :)
  let $state := p:shift(2, $input, $state)                  (: DirCommentContents :)
  let $state := p:lookahead1(7, $input, $state)             (: '-->' :)
  let $state := p:shift(43, $input, $state)                 (: '-->' :)
  return p:reduce($state, "DirCommentConstructor", $count)
};

(:~
 : Parse DirElemContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirElemContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 53                                  (: '<' :)
     or $state[$p:l1] = 54                                  (: '<!--' :)
     or $state[$p:l1] = 58) then                            (: '<?' :)
      let $state := p:parse-DirectConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 23) then                       (: CDataSection :)
      let $state := p:shift(23, $input, $state)             (: CDataSection :)
      return $state
    else if ($state[$p:l1] = 11) then                       (: ElementContentChar :)
      let $state := p:shift(11, $input, $state)             (: ElementContentChar :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CommonContent($input, $state)
      return $state
  return p:reduce($state, "DirElemContent", $count)
};

(:~
 : Parse AposAttrValueContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AposAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 13) then                            (: AposAttrContentChar :)
      let $state := p:shift(13, $input, $state)             (: AposAttrContentChar :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CommonContent($input, $state)
      return $state
  return p:reduce($state, "AposAttrValueContent", $count)
};

(:~
 : Parse EnclosedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EnclosedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(169, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(45, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(172, $input, $state)                (: '}' :)
  return p:reduce($state, "EnclosedExpr", $count)
};

(:~
 : Parse CommonContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CommonContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 8) then                             (: PredefinedEntityRef :)
      let $state := p:shift(8, $input, $state)              (: PredefinedEntityRef :)
      return $state
    else if ($state[$p:l1] = 16) then                       (: CharRef :)
      let $state := p:shift(16, $input, $state)             (: CharRef :)
      return $state
    else if ($state[$p:l1] = 170) then                      (: '{{' :)
      let $state := p:shift(170, $input, $state)            (: '{{' :)
      return $state
    else if ($state[$p:l1] = 173) then                      (: '}}' :)
      let $state := p:shift(173, $input, $state)            (: '}}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-EnclosedExpr($input, $state)
      return $state
  return p:reduce($state, "CommonContent", $count)
};

(:~
 : Parse QuotAttrValueContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QuotAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 12) then                            (: QuotAttrContentChar :)
      let $state := p:shift(12, $input, $state)             (: QuotAttrContentChar :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CommonContent($input, $state)
      return $state
  return p:reduce($state, "QuotAttrValueContent", $count)
};

(:~
 : Parse the 1st loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeValue-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(89, $input, $state)          (: PredefinedEntityRef | EscapeQuot | QuotAttrContentChar |
                                                               CharRef | '"' | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 27) then                          (: '"' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 9) then                       (: EscapeQuot :)
            let $state := p:shift(9, $input, $state)        (: EscapeQuot :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-QuotAttrValueContent($input, $state)
            return $state
        return p:parse-DirAttributeValue-1($input, $state)
};

(:~
 : Parse the 2nd loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeValue-2($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(90, $input, $state)          (: PredefinedEntityRef | EscapeApos | AposAttrContentChar |
                                                               CharRef | "'" | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 32) then                          (: "'" :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 10) then                      (: EscapeApos :)
            let $state := p:shift(10, $input, $state)       (: EscapeApos :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-AposAttrValueContent($input, $state)
            return $state
        return p:parse-DirAttributeValue-2($input, $state)
};

(:~
 : Parse DirAttributeValue.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(18, $input, $state)            (: '"' | "'" :)
  let $state :=
    if ($state[$p:l1] = 27) then                            (: '"' :)
      let $state := p:shift(27, $input, $state)             (: '"' :)
      let $state := p:parse-DirAttributeValue-1($input, $state)
      let $state := p:shift(27, $input, $state)             (: '"' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(32, $input, $state)             (: "'" :)
      let $state := p:parse-DirAttributeValue-2($input, $state)
      let $state := p:shift(32, $input, $state)             (: "'" :)
      return $state
  return p:reduce($state, "DirAttributeValue", $count)
};

(:~
 : Parse the 1st loop of production DirAttributeList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(24, $input, $state)          (: S | '/>' | '>' :)
    return
      if ($state[$p:l1] != 14) then                         (: S :)
        $state
      else
        let $state := p:shift(14, $input, $state)           (: S :)
        let $state := p:lookahead1(132, $input, $state)     (: S | QName^Token | '/>' | '>' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] != 14                      (: S :)
               and $state[$p:l1] != 48                      (: '/>' :)
               and $state[$p:l1] != 60) then                (: '>' :)
            let $state := p:parse-QName($input, $state)
            let $state := p:lookahead1(15, $input, $state)  (: S | '=' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 14) then             (: S :)
                let $state := p:shift(14, $input, $state)   (: S :)
                return $state
              else
                $state
            let $state := p:lookahead1(8, $input, $state)   (: '=' :)
            let $state := p:shift(59, $input, $state)       (: '=' :)
            let $state := p:lookahead1(23, $input, $state)  (: S | '"' | "'" :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 14) then             (: S :)
                let $state := p:shift(14, $input, $state)   (: S :)
                return $state
              else
                $state
            let $state := p:parse-DirAttributeValue($input, $state)
            return $state
          else
            $state
        return p:parse-DirAttributeList-1($input, $state)
};

(:~
 : Parse DirAttributeList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-DirAttributeList-1($input, $state)
  return p:reduce($state, "DirAttributeList", $count)
};

(:~
 : Parse the 1st loop of production DirElemConstructor (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirElemConstructor-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(96, $input, $state)          (: PredefinedEntityRef | ElementContentChar | CharRef |
                                                               CDataSection | '<' | '<!--' | '</' | '<?' | '{' | '{{' |
                                                               '}}' :)
    return
      if ($state[$p:l1] = 55) then                          (: '</' :)
        $state
      else
        let $state := p:parse-DirElemContent($input, $state)
        return p:parse-DirElemConstructor-1($input, $state)
};

(:~
 : Parse DirElemConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(53, $input, $state)                 (: '<' :)
  let $state := p:lookahead1(127, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-QName($input, $state)
  let $state := p:parse-DirAttributeList($input, $state)
  let $state := p:lookahead1(19, $input, $state)            (: '/>' | '>' :)
  let $state :=
    if ($state[$p:l1] = 48) then                            (: '/>' :)
      let $state := p:shift(48, $input, $state)             (: '/>' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(60, $input, $state)             (: '>' :)
      let $state := p:parse-DirElemConstructor-1($input, $state)
      let $state := p:shift(55, $input, $state)             (: '</' :)
      let $state := p:lookahead1(127, $input, $state)       (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
      let $state := p:parse-QName($input, $state)
      let $state := p:lookahead1(16, $input, $state)        (: S | '>' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 14) then                   (: S :)
          let $state := p:shift(14, $input, $state)         (: S :)
          return $state
        else
          $state
      let $state := p:lookahead1(9, $input, $state)         (: '>' :)
      let $state := p:shift(60, $input, $state)             (: '>' :)
      return $state
  return p:reduce($state, "DirElemConstructor", $count)
};

(:~
 : Parse DirectConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirectConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 53) then                            (: '<' :)
      let $state := p:parse-DirElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 54) then                       (: '<!--' :)
      let $state := p:parse-DirCommentConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-DirPIConstructor($input, $state)
      return $state
  return p:reduce($state, "DirectConstructor", $count)
};

(:~
 : Parse Constructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Constructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 53                                  (: '<' :)
     or $state[$p:l1] = 54                                  (: '<!--' :)
     or $state[$p:l1] = 58) then                            (: '<?' :)
      let $state := p:parse-DirectConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ComputedConstructor($input, $state)
      return $state
  return p:reduce($state, "Constructor", $count)
};

(:~
 : Parse UnorderedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnorderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(163, $input, $state)                (: 'unordered' :)
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(169, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(45, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(172, $input, $state)                (: '}' :)
  return p:reduce($state, "UnorderedExpr", $count)
};

(:~
 : Parse OrderedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(139, $input, $state)                (: 'ordered' :)
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(169, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(45, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(172, $input, $state)                (: '}' :)
  return p:reduce($state, "OrderedExpr", $count)
};

(:~
 : Parse the 1st loop of production FunctionCall (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionCall-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(58, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-ExprSingle($input, $state)
        return p:parse-FunctionCall-1($input, $state)
};

(:~
 : Parse FunctionCall.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionCall($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-FunctionName($input, $state)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(145, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | ('(' ':') | ')' | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | '^' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36) then                      (: ')' :)
      let $state := p:parse-ExprSingle($input, $state)
      let $state := p:parse-FunctionCall-1($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "FunctionCall", $count)
};

(:~
 : Parse ContextItemExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ContextItemExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(44, $input, $state)                 (: '.' :)
  return p:reduce($state, "ContextItemExpr", $count)
};

(:~
 : Parse ParenthesizedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParenthesizedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(145, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | ('(' ':') | ')' | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | '^' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36) then                      (: ')' :)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "ParenthesizedExpr", $count)
};

(:~
 : Parse VarRef.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarRef($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(130, $input, $state)          (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  return p:reduce($state, "VarRef", $count)
};

(:~
 : Parse NumericLiteral.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NumericLiteral($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 3) then                             (: IntegerLiteral :)
      let $state := p:shift(3, $input, $state)              (: IntegerLiteral :)
      return $state
    else if ($state[$p:l1] = 4) then                        (: DecimalLiteral :)
      let $state := p:shift(4, $input, $state)              (: DecimalLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(5, $input, $state)              (: DoubleLiteral :)
      return $state
  return p:reduce($state, "NumericLiteral", $count)
};

(:~
 : Parse Literal.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Literal($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 6) then                             (: StringLiteral :)
      let $state := p:shift(6, $input, $state)              (: StringLiteral :)
      return $state
    else if ($state[$p:l1] = 7) then                        (: TextNodeLiteral :)
      let $state := p:shift(7, $input, $state)              (: TextNodeLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NumericLiteral($input, $state)
      return $state
  return p:reduce($state, "Literal", $count)
};

(:~
 : Parse PrimaryExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PrimaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(139, $input, $state)           (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | QName^Token | '$' |
                                                               '(' | '.' | '<' | '<!--' | '<?' | '^' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'element' | 'else' | 'empty' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'le' |
                                                               'let' | 'lt' | 'mod' | 'module' | 'ne' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'self' | 'some' | 'stable' |
                                                               'text' | 'to' | 'treat' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 94                                  (: 'ordered' :)
     or $state[$p:l1] = 139                                 (: 'unordered' :)
     or $state[$p:l1] = 163) then                           (: 'unordered' :)
      let $state := p:lookahead2W(55, $input, $state)       (: S^WS | '(' | ('(' ':') | '{' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 3                                   (: IntegerLiteral :)
     or $state[$p:lk] = 4                                   (: DecimalLiteral :)
     or $state[$p:lk] = 5                                   (: DoubleLiteral :)
     or $state[$p:lk] = 6                                   (: StringLiteral :)
     or $state[$p:lk] = 7) then                             (: TextNodeLiteral :)
      let $state := p:parse-Literal($input, $state)
      return $state
    else if ($state[$p:lk] = 31) then                       (: '$' :)
      let $state := p:parse-VarRef($input, $state)
      return $state
    else if ($state[$p:lk] = 33) then                       (: '(' :)
      let $state := p:parse-ParenthesizedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 44) then                       (: '.' :)
      let $state := p:parse-ContextItemExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 43403) then                    (: 'ordered' '{' :)
      let $state := p:parse-OrderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 43427) then                    (: 'unordered' '{' :)
      let $state := p:parse-UnorderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 53                             (: '<' :)
          or $state[$p:lk] = 54                             (: '<!--' :)
          or $state[$p:lk] = 58                             (: '<?' :)
          or $state[$p:lk] = 75                             (: 'attribute' :)
          or $state[$p:lk] = 84                             (: 'comment' :)
          or $state[$p:lk] = 86                             (: 'copy' :)
          or $state[$p:lk] = 96                             (: 'element' :)
          or $state[$p:lk] = 145                            (: 'processing-instruction' :)
          or $state[$p:lk] = 156                            (: 'text' :)
          or $state[$p:lk] = 43358) then                    (: 'document' '{' :)
      let $state := p:parse-Constructor($input, $state)
      return $state
    else if ($state[$p:lk] = 68) then                       (: '^' :)
      let $state := p:parse-RulesetCall($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-FunctionCall($input, $state)
      return $state
  return p:reduce($state, "PrimaryExpr", $count)
};

(:~
 : Parse FilterExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FilterExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-PrimaryExpr($input, $state)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-PredicateList($input, $state)
  return p:reduce($state, "FilterExpr", $count)
};

(:~
 : Parse StepExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-StepExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(143, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | ('(' ':') | '.' | '..' | '<' |
                                                               '<!--' | '<?' | '@' | '^' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'ne' | 'node' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 75) then                            (: 'attribute' :)
      let $state := p:lookahead2W(150, $input, $state)      (: S^WS | QName^Token | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | '::' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' | '|' | '}' :)
      let $state :=
        if ($state[$p:lk] = 20299) then                     (: 'attribute' 'case' :)
          let $state := p:lookahead3W(137, $input, $state)  (: S^WS | QName^Token | '$' | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
          return $state
        else if ($state[$p:lk] = 21323) then                (: 'attribute' 'collation' :)
          let $state := p:lookahead3W(48, $input, $state)   (: StringLiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 22859) then                (: 'attribute' 'default' :)
          let $state := p:lookahead3W(74, $input, $state)   (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 25163) then                (: 'attribute' 'empty' :)
          let $state := p:lookahead3W(80, $input, $state)   (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] = 30283) then                (: 'attribute' 'instance' :)
          let $state := p:lookahead3W(70, $input, $state)   (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] = 35403) then                (: 'attribute' 'order' :)
          let $state := p:lookahead3W(67, $input, $state)   (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = 39243) then                (: 'attribute' 'stable' :)
          let $state := p:lookahead3W(71, $input, $state)   (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = 18763                      (: 'attribute' 'descending' :)
              or $state[$p:lk] = 23627) then                (: 'attribute' 'descending' :)
          let $state := p:lookahead3W(88, $input, $state)   (: S^WS | ('(' ':') | ',' | 'collation' | 'empty' |
                                                               'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 27467                      (: 'attribute' 'let' :)
              or $state[$p:lk] = 32331) then                (: 'attribute' 'let' :)
          let $state := p:lookahead3W(53, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 20555                      (: 'attribute' 'castable' :)
              or $state[$p:lk] = 20811                      (: 'attribute' 'treat' :)
              or $state[$p:lk] = 40779) then                (: 'attribute' 'treat' :)
          let $state := p:lookahead3W(65, $input, $state)   (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 18251                      (: 'attribute' 'div' :)
              or $state[$p:lk] = 23883                      (: 'attribute' 'else' :)
              or $state[$p:lk] = 24907                      (: 'attribute' 'eq' :)
              or $state[$p:lk] = 25931                      (: 'attribute' 'except' :)
              or $state[$p:lk] = 26443                      (: 'attribute' 'ge' :)
              or $state[$p:lk] = 27979                      (: 'attribute' 'gt' :)
              or $state[$p:lk] = 28491                      (: 'attribute' 'idiv' :)
              or $state[$p:lk] = 29003                      (: 'attribute' 'intersect' :)
              or $state[$p:lk] = 30539                      (: 'attribute' 'is' :)
              or $state[$p:lk] = 30795                      (: 'attribute' 'le' :)
              or $state[$p:lk] = 31819                      (: 'attribute' 'lt' :)
              or $state[$p:lk] = 32587                      (: 'attribute' 'mod' :)
              or $state[$p:lk] = 32843                      (: 'attribute' 'ne' :)
              or $state[$p:lk] = 33611                      (: 'attribute' 'or' :)
              or $state[$p:lk] = 35147                      (: 'attribute' 'return' :)
              or $state[$p:lk] = 37451                      (: 'attribute' 'satisfies' :)
              or $state[$p:lk] = 37707                      (: 'attribute' 'to' :)
              or $state[$p:lk] = 40523                      (: 'attribute' 'union' :)
              or $state[$p:lk] = 41547                      (: 'attribute' 'where' :)
              or $state[$p:lk] = 42827) then                (: 'attribute' 'where' :)
          let $state := p:lookahead3W(146, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               '^' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 96) then                       (: 'element' :)
      let $state := p:lookahead2W(148, $input, $state)      (: S^WS | QName^Token | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' | '|' | '}' :)
      let $state :=
        if ($state[$p:lk] = 20320) then                     (: 'element' 'case' :)
          let $state := p:lookahead3W(137, $input, $state)  (: S^WS | QName^Token | '$' | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
          return $state
        else if ($state[$p:lk] = 21344) then                (: 'element' 'collation' :)
          let $state := p:lookahead3W(48, $input, $state)   (: StringLiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 22880) then                (: 'element' 'default' :)
          let $state := p:lookahead3W(74, $input, $state)   (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 25184) then                (: 'element' 'empty' :)
          let $state := p:lookahead3W(80, $input, $state)   (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] = 30304) then                (: 'element' 'instance' :)
          let $state := p:lookahead3W(70, $input, $state)   (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] = 35424) then                (: 'element' 'order' :)
          let $state := p:lookahead3W(67, $input, $state)   (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = 39264) then                (: 'element' 'stable' :)
          let $state := p:lookahead3W(71, $input, $state)   (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = 18784                      (: 'element' 'descending' :)
              or $state[$p:lk] = 23648) then                (: 'element' 'descending' :)
          let $state := p:lookahead3W(88, $input, $state)   (: S^WS | ('(' ':') | ',' | 'collation' | 'empty' |
                                                               'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 27488                      (: 'element' 'let' :)
              or $state[$p:lk] = 32352) then                (: 'element' 'let' :)
          let $state := p:lookahead3W(53, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 20576                      (: 'element' 'castable' :)
              or $state[$p:lk] = 20832                      (: 'element' 'treat' :)
              or $state[$p:lk] = 40800) then                (: 'element' 'treat' :)
          let $state := p:lookahead3W(65, $input, $state)   (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 18272                      (: 'element' 'div' :)
              or $state[$p:lk] = 23904                      (: 'element' 'else' :)
              or $state[$p:lk] = 24928                      (: 'element' 'eq' :)
              or $state[$p:lk] = 25952                      (: 'element' 'except' :)
              or $state[$p:lk] = 26464                      (: 'element' 'ge' :)
              or $state[$p:lk] = 28000                      (: 'element' 'gt' :)
              or $state[$p:lk] = 28512                      (: 'element' 'idiv' :)
              or $state[$p:lk] = 29024                      (: 'element' 'intersect' :)
              or $state[$p:lk] = 30560                      (: 'element' 'is' :)
              or $state[$p:lk] = 30816                      (: 'element' 'le' :)
              or $state[$p:lk] = 31840                      (: 'element' 'lt' :)
              or $state[$p:lk] = 32608                      (: 'element' 'mod' :)
              or $state[$p:lk] = 32864                      (: 'element' 'ne' :)
              or $state[$p:lk] = 33632                      (: 'element' 'or' :)
              or $state[$p:lk] = 35168                      (: 'element' 'return' :)
              or $state[$p:lk] = 37472                      (: 'element' 'satisfies' :)
              or $state[$p:lk] = 37728                      (: 'element' 'to' :)
              or $state[$p:lk] = 40544                      (: 'element' 'union' :)
              or $state[$p:lk] = 41568                      (: 'element' 'where' :)
              or $state[$p:lk] = 42848) then                (: 'element' 'where' :)
          let $state := p:lookahead3W(146, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               '^' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'processing-instruction' :)
      let $state := p:lookahead2W(124, $input, $state)      (: S^WS | NCName^Token | '!=' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'eq' | 'except' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'to' | 'treat' | 'union' |
                                                               'where' | '{' | '|' | '}' :)
      let $state :=
        if ($state[$p:lk] = 20369) then                     (: 'processing-instruction' 'case' :)
          let $state := p:lookahead3W(137, $input, $state)  (: S^WS | QName^Token | '$' | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
          return $state
        else if ($state[$p:lk] = 21393) then                (: 'processing-instruction' 'collation' :)
          let $state := p:lookahead3W(48, $input, $state)   (: StringLiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 22929) then                (: 'processing-instruction' 'default' :)
          let $state := p:lookahead3W(74, $input, $state)   (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 25233) then                (: 'processing-instruction' 'empty' :)
          let $state := p:lookahead3W(80, $input, $state)   (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] = 30353) then                (: 'processing-instruction' 'instance' :)
          let $state := p:lookahead3W(70, $input, $state)   (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] = 35473) then                (: 'processing-instruction' 'order' :)
          let $state := p:lookahead3W(67, $input, $state)   (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = 39313) then                (: 'processing-instruction' 'stable' :)
          let $state := p:lookahead3W(71, $input, $state)   (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = 18833                      (: 'processing-instruction' 'descending' :)
              or $state[$p:lk] = 23697) then                (: 'processing-instruction' 'descending' :)
          let $state := p:lookahead3W(88, $input, $state)   (: S^WS | ('(' ':') | ',' | 'collation' | 'empty' |
                                                               'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 27537                      (: 'processing-instruction' 'let' :)
              or $state[$p:lk] = 32401) then                (: 'processing-instruction' 'let' :)
          let $state := p:lookahead3W(53, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 20625                      (: 'processing-instruction' 'castable' :)
              or $state[$p:lk] = 20881                      (: 'processing-instruction' 'treat' :)
              or $state[$p:lk] = 40849) then                (: 'processing-instruction' 'treat' :)
          let $state := p:lookahead3W(65, $input, $state)   (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 18321                      (: 'processing-instruction' 'div' :)
              or $state[$p:lk] = 23953                      (: 'processing-instruction' 'else' :)
              or $state[$p:lk] = 24977                      (: 'processing-instruction' 'eq' :)
              or $state[$p:lk] = 26001                      (: 'processing-instruction' 'except' :)
              or $state[$p:lk] = 26513                      (: 'processing-instruction' 'ge' :)
              or $state[$p:lk] = 28049                      (: 'processing-instruction' 'gt' :)
              or $state[$p:lk] = 28561                      (: 'processing-instruction' 'idiv' :)
              or $state[$p:lk] = 29073                      (: 'processing-instruction' 'intersect' :)
              or $state[$p:lk] = 30609                      (: 'processing-instruction' 'is' :)
              or $state[$p:lk] = 30865                      (: 'processing-instruction' 'le' :)
              or $state[$p:lk] = 31889                      (: 'processing-instruction' 'lt' :)
              or $state[$p:lk] = 32657                      (: 'processing-instruction' 'mod' :)
              or $state[$p:lk] = 32913                      (: 'processing-instruction' 'ne' :)
              or $state[$p:lk] = 33681                      (: 'processing-instruction' 'or' :)
              or $state[$p:lk] = 35217                      (: 'processing-instruction' 'return' :)
              or $state[$p:lk] = 37521                      (: 'processing-instruction' 'satisfies' :)
              or $state[$p:lk] = 37777                      (: 'processing-instruction' 'to' :)
              or $state[$p:lk] = 40593                      (: 'processing-instruction' 'union' :)
              or $state[$p:lk] = 41617                      (: 'processing-instruction' 'where' :)
              or $state[$p:lk] = 42897) then                (: 'processing-instruction' 'where' :)
          let $state := p:lookahead3W(146, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               '^' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 84                             (: 'document' :)
          or $state[$p:l1] = 94                             (: 'ordered' :)
          or $state[$p:l1] = 139                            (: 'text' :)
          or $state[$p:l1] = 156                            (: 'unordered' :)
          or $state[$p:l1] = 163) then                      (: 'unordered' :)
      let $state := p:lookahead2W(123, $input, $state)      (: S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '{' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 69                             (: 'ancestor-or-self' :)
          or $state[$p:l1] = 70                             (: 'child' :)
          or $state[$p:l1] = 82                             (: 'descendant' :)
          or $state[$p:l1] = 90                             (: 'descendant-or-self' :)
          or $state[$p:l1] = 91                             (: 'following' :)
          or $state[$p:l1] = 105                            (: 'following-sibling' :)
          or $state[$p:l1] = 106                            (: 'parent' :)
          or $state[$p:l1] = 141                            (: 'preceding' :)
          or $state[$p:l1] = 142                            (: 'preceding-sibling' :)
          or $state[$p:l1] = 143                            (: 'self' :)
          or $state[$p:l1] = 151) then                      (: 'self' :)
      let $state := p:lookahead2W(122, $input, $state)      (: S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 18                             (: 'and' :)
          or $state[$p:l1] = 71                             (: 'ascending' :)
          or $state[$p:l1] = 73                             (: 'case' :)
          or $state[$p:l1] = 79                             (: 'cast' :)
          or $state[$p:l1] = 80                             (: 'castable' :)
          or $state[$p:l1] = 81                             (: 'collation' :)
          or $state[$p:l1] = 83                             (: 'declare' :)
          or $state[$p:l1] = 88                             (: 'default' :)
          or $state[$p:l1] = 89                             (: 'descending' :)
          or $state[$p:l1] = 92                             (: 'div' :)
          or $state[$p:l1] = 93                             (: 'else' :)
          or $state[$p:l1] = 97                             (: 'empty' :)
          or $state[$p:l1] = 98                             (: 'eq' :)
          or $state[$p:l1] = 101                            (: 'every' :)
          or $state[$p:l1] = 102                            (: 'except' :)
          or $state[$p:l1] = 103                            (: 'for' :)
          or $state[$p:l1] = 107                            (: 'ge' :)
          or $state[$p:l1] = 109                            (: 'gt' :)
          or $state[$p:l1] = 111                            (: 'idiv' :)
          or $state[$p:l1] = 113                            (: 'import' :)
          or $state[$p:l1] = 115                            (: 'instance' :)
          or $state[$p:l1] = 118                            (: 'intersect' :)
          or $state[$p:l1] = 119                            (: 'is' :)
          or $state[$p:l1] = 120                            (: 'le' :)
          or $state[$p:l1] = 124                            (: 'let' :)
          or $state[$p:l1] = 126                            (: 'lt' :)
          or $state[$p:l1] = 127                            (: 'mod' :)
          or $state[$p:l1] = 128                            (: 'module' :)
          or $state[$p:l1] = 129                            (: 'ne' :)
          or $state[$p:l1] = 131                            (: 'or' :)
          or $state[$p:l1] = 137                            (: 'order' :)
          or $state[$p:l1] = 138                            (: 'return' :)
          or $state[$p:l1] = 146                            (: 'satisfies' :)
          or $state[$p:l1] = 147                            (: 'some' :)
          or $state[$p:l1] = 152                            (: 'stable' :)
          or $state[$p:l1] = 153                            (: 'to' :)
          or $state[$p:l1] = 158                            (: 'treat' :)
          or $state[$p:l1] = 159                            (: 'union' :)
          or $state[$p:l1] = 162                            (: 'validate' :)
          or $state[$p:l1] = 164                            (: 'where' :)
          or $state[$p:l1] = 167                            (: 'xquery' :)
          or $state[$p:l1] = 168) then                      (: 'xquery' :)
      let $state := p:lookahead2W(119, $input, $state)      (: S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 3                                   (: IntegerLiteral :)
     or $state[$p:lk] = 4                                   (: DecimalLiteral :)
     or $state[$p:lk] = 5                                   (: DoubleLiteral :)
     or $state[$p:lk] = 6                                   (: StringLiteral :)
     or $state[$p:lk] = 7                                   (: TextNodeLiteral :)
     or $state[$p:lk] = 31                                  (: '$' :)
     or $state[$p:lk] = 33                                  (: '(' :)
     or $state[$p:lk] = 44                                  (: '.' :)
     or $state[$p:lk] = 53                                  (: '<' :)
     or $state[$p:lk] = 54                                  (: '<!--' :)
     or $state[$p:lk] = 58                                  (: '<?' :)
     or $state[$p:lk] = 68                                  (: '^' :)
     or $state[$p:lk] = 86                                  (: 'copy' :)
     or $state[$p:lk] = 4497                                (: 'processing-instruction' NCName^Token :)
     or $state[$p:lk] = 4683                                (: 'attribute' QName^Token :)
     or $state[$p:lk] = 4704                                (: 'element' QName^Token :)
     or $state[$p:lk] = 8466                                (: QName^Token '(' :)
     or $state[$p:lk] = 8517                                (: 'ancestor' '(' :)
     or $state[$p:lk] = 8518                                (: 'ancestor-or-self' '(' :)
     or $state[$p:lk] = 8519                                (: 'and' '(' :)
     or $state[$p:lk] = 8521                                (: 'ascending' '(' :)
     or $state[$p:lk] = 8527                                (: 'case' '(' :)
     or $state[$p:lk] = 8528                                (: 'cast' '(' :)
     or $state[$p:lk] = 8529                                (: 'castable' '(' :)
     or $state[$p:lk] = 8530                                (: 'child' '(' :)
     or $state[$p:lk] = 8531                                (: 'collation' '(' :)
     or $state[$p:lk] = 8536                                (: 'declare' '(' :)
     or $state[$p:lk] = 8537                                (: 'default' '(' :)
     or $state[$p:lk] = 8538                                (: 'descendant' '(' :)
     or $state[$p:lk] = 8539                                (: 'descendant-or-self' '(' :)
     or $state[$p:lk] = 8540                                (: 'descending' '(' :)
     or $state[$p:lk] = 8541                                (: 'div' '(' :)
     or $state[$p:lk] = 8542                                (: 'document' '(' :)
     or $state[$p:lk] = 8545                                (: 'else' '(' :)
     or $state[$p:lk] = 8546                                (: 'empty' '(' :)
     or $state[$p:lk] = 8549                                (: 'eq' '(' :)
     or $state[$p:lk] = 8550                                (: 'every' '(' :)
     or $state[$p:lk] = 8551                                (: 'except' '(' :)
     or $state[$p:lk] = 8553                                (: 'following' '(' :)
     or $state[$p:lk] = 8554                                (: 'following-sibling' '(' :)
     or $state[$p:lk] = 8555                                (: 'for' '(' :)
     or $state[$p:lk] = 8557                                (: 'ge' '(' :)
     or $state[$p:lk] = 8559                                (: 'gt' '(' :)
     or $state[$p:lk] = 8561                                (: 'idiv' '(' :)
     or $state[$p:lk] = 8563                                (: 'import' '(' :)
     or $state[$p:lk] = 8566                                (: 'instance' '(' :)
     or $state[$p:lk] = 8567                                (: 'intersect' '(' :)
     or $state[$p:lk] = 8568                                (: 'is' '(' :)
     or $state[$p:lk] = 8572                                (: 'le' '(' :)
     or $state[$p:lk] = 8574                                (: 'let' '(' :)
     or $state[$p:lk] = 8575                                (: 'lt' '(' :)
     or $state[$p:lk] = 8576                                (: 'mod' '(' :)
     or $state[$p:lk] = 8577                                (: 'module' '(' :)
     or $state[$p:lk] = 8579                                (: 'ne' '(' :)
     or $state[$p:lk] = 8585                                (: 'or' '(' :)
     or $state[$p:lk] = 8586                                (: 'order' '(' :)
     or $state[$p:lk] = 8587                                (: 'ordered' '(' :)
     or $state[$p:lk] = 8589                                (: 'parent' '(' :)
     or $state[$p:lk] = 8590                                (: 'preceding' '(' :)
     or $state[$p:lk] = 8591                                (: 'preceding-sibling' '(' :)
     or $state[$p:lk] = 8594                                (: 'return' '(' :)
     or $state[$p:lk] = 8595                                (: 'satisfies' '(' :)
     or $state[$p:lk] = 8599                                (: 'self' '(' :)
     or $state[$p:lk] = 8600                                (: 'some' '(' :)
     or $state[$p:lk] = 8601                                (: 'stable' '(' :)
     or $state[$p:lk] = 8606                                (: 'to' '(' :)
     or $state[$p:lk] = 8607                                (: 'treat' '(' :)
     or $state[$p:lk] = 8610                                (: 'union' '(' :)
     or $state[$p:lk] = 8611                                (: 'unordered' '(' :)
     or $state[$p:lk] = 8612                                (: 'validate' '(' :)
     or $state[$p:lk] = 8615                                (: 'where' '(' :)
     or $state[$p:lk] = 8616                                (: 'xquery' '(' :)
     or $state[$p:lk] = 17739                               (: 'attribute' 'ancestor' :)
     or $state[$p:lk] = 17760                               (: 'element' 'ancestor' :)
     or $state[$p:lk] = 17995                               (: 'attribute' 'ancestor-or-self' :)
     or $state[$p:lk] = 18016                               (: 'element' 'ancestor-or-self' :)
     or $state[$p:lk] = 19275                               (: 'attribute' 'attribute' :)
     or $state[$p:lk] = 19296                               (: 'element' 'attribute' :)
     or $state[$p:lk] = 21067                               (: 'attribute' 'child' :)
     or $state[$p:lk] = 21088                               (: 'element' 'child' :)
     or $state[$p:lk] = 21579                               (: 'attribute' 'comment' :)
     or $state[$p:lk] = 21600                               (: 'element' 'comment' :)
     or $state[$p:lk] = 22603                               (: 'attribute' 'declare' :)
     or $state[$p:lk] = 22624                               (: 'element' 'declare' :)
     or $state[$p:lk] = 23115                               (: 'attribute' 'descendant' :)
     or $state[$p:lk] = 23136                               (: 'element' 'descendant' :)
     or $state[$p:lk] = 23371                               (: 'attribute' 'descendant-or-self' :)
     or $state[$p:lk] = 23392                               (: 'element' 'descendant-or-self' :)
     or $state[$p:lk] = 24139                               (: 'attribute' 'document' :)
     or $state[$p:lk] = 24160                               (: 'element' 'document' :)
     or $state[$p:lk] = 24395                               (: 'attribute' 'document-node' :)
     or $state[$p:lk] = 24416                               (: 'element' 'document-node' :)
     or $state[$p:lk] = 24651                               (: 'attribute' 'element' :)
     or $state[$p:lk] = 24672                               (: 'element' 'element' :)
     or $state[$p:lk] = 25419                               (: 'attribute' 'empty-sequence' :)
     or $state[$p:lk] = 25440                               (: 'element' 'empty-sequence' :)
     or $state[$p:lk] = 26187                               (: 'attribute' 'every' :)
     or $state[$p:lk] = 26208                               (: 'element' 'every' :)
     or $state[$p:lk] = 26955                               (: 'attribute' 'following' :)
     or $state[$p:lk] = 26976                               (: 'element' 'following' :)
     or $state[$p:lk] = 27211                               (: 'attribute' 'following-sibling' :)
     or $state[$p:lk] = 27232                               (: 'element' 'following-sibling' :)
     or $state[$p:lk] = 29259                               (: 'attribute' 'if' :)
     or $state[$p:lk] = 29280                               (: 'element' 'if' :)
     or $state[$p:lk] = 29515                               (: 'attribute' 'import' :)
     or $state[$p:lk] = 29536                               (: 'element' 'import' :)
     or $state[$p:lk] = 31051                               (: 'attribute' 'item' :)
     or $state[$p:lk] = 31072                               (: 'element' 'item' :)
     or $state[$p:lk] = 33099                               (: 'attribute' 'module' :)
     or $state[$p:lk] = 33120                               (: 'element' 'module' :)
     or $state[$p:lk] = 34379                               (: 'attribute' 'node' :)
     or $state[$p:lk] = 34400                               (: 'element' 'node' :)
     or $state[$p:lk] = 35659                               (: 'attribute' 'ordered' :)
     or $state[$p:lk] = 35680                               (: 'element' 'ordered' :)
     or $state[$p:lk] = 36171                               (: 'attribute' 'parent' :)
     or $state[$p:lk] = 36192                               (: 'element' 'parent' :)
     or $state[$p:lk] = 36427                               (: 'attribute' 'preceding' :)
     or $state[$p:lk] = 36448                               (: 'element' 'preceding' :)
     or $state[$p:lk] = 36683                               (: 'attribute' 'preceding-sibling' :)
     or $state[$p:lk] = 36704                               (: 'element' 'preceding-sibling' :)
     or $state[$p:lk] = 37195                               (: 'attribute' 'processing-instruction' :)
     or $state[$p:lk] = 37216                               (: 'element' 'processing-instruction' :)
     or $state[$p:lk] = 38219                               (: 'attribute' 'schema-attribute' :)
     or $state[$p:lk] = 38240                               (: 'element' 'schema-attribute' :)
     or $state[$p:lk] = 38475                               (: 'attribute' 'schema-element' :)
     or $state[$p:lk] = 38496                               (: 'element' 'schema-element' :)
     or $state[$p:lk] = 38731                               (: 'attribute' 'self' :)
     or $state[$p:lk] = 38752                               (: 'element' 'self' :)
     or $state[$p:lk] = 38987                               (: 'attribute' 'some' :)
     or $state[$p:lk] = 39008                               (: 'element' 'some' :)
     or $state[$p:lk] = 40011                               (: 'attribute' 'text' :)
     or $state[$p:lk] = 40032                               (: 'element' 'text' :)
     or $state[$p:lk] = 41291                               (: 'attribute' 'typeswitch' :)
     or $state[$p:lk] = 41312                               (: 'element' 'typeswitch' :)
     or $state[$p:lk] = 41803                               (: 'attribute' 'unordered' :)
     or $state[$p:lk] = 41824                               (: 'element' 'unordered' :)
     or $state[$p:lk] = 42059                               (: 'attribute' 'validate' :)
     or $state[$p:lk] = 42080                               (: 'element' 'validate' :)
     or $state[$p:lk] = 43083                               (: 'attribute' 'xquery' :)
     or $state[$p:lk] = 43104                               (: 'element' 'xquery' :)
     or $state[$p:lk] = 43339                               (: 'attribute' '{' :)
     or $state[$p:lk] = 43348                               (: 'comment' '{' :)
     or $state[$p:lk] = 43358                               (: 'document' '{' :)
     or $state[$p:lk] = 43360                               (: 'element' '{' :)
     or $state[$p:lk] = 43403                               (: 'ordered' '{' :)
     or $state[$p:lk] = 43409                               (: 'processing-instruction' '{' :)
     or $state[$p:lk] = 43420                               (: 'text' '{' :)
     or $state[$p:lk] = 43427                               (: 'unordered' '{' :)
     or $state[$p:lk] = 11093835                            (: 'attribute' 'and' '{' :)
     or $state[$p:lk] = 11093856                            (: 'element' 'and' '{' :)
     or $state[$p:lk] = 11093905                            (: 'processing-instruction' 'and' '{' :)
     or $state[$p:lk] = 11094347                            (: 'attribute' 'ascending' '{' :)
     or $state[$p:lk] = 11094368                            (: 'element' 'ascending' '{' :)
     or $state[$p:lk] = 11094417                            (: 'processing-instruction' 'ascending' '{' :)
     or $state[$p:lk] = 11095883                            (: 'attribute' 'case' '{' :)
     or $state[$p:lk] = 11095904                            (: 'element' 'case' '{' :)
     or $state[$p:lk] = 11095953                            (: 'processing-instruction' 'case' '{' :)
     or $state[$p:lk] = 11096139                            (: 'attribute' 'cast' '{' :)
     or $state[$p:lk] = 11096160                            (: 'element' 'cast' '{' :)
     or $state[$p:lk] = 11096209                            (: 'processing-instruction' 'cast' '{' :)
     or $state[$p:lk] = 11096395                            (: 'attribute' 'castable' '{' :)
     or $state[$p:lk] = 11096416                            (: 'element' 'castable' '{' :)
     or $state[$p:lk] = 11096465                            (: 'processing-instruction' 'castable' '{' :)
     or $state[$p:lk] = 11096907                            (: 'attribute' 'collation' '{' :)
     or $state[$p:lk] = 11096928                            (: 'element' 'collation' '{' :)
     or $state[$p:lk] = 11096977                            (: 'processing-instruction' 'collation' '{' :)
     or $state[$p:lk] = 11098443                            (: 'attribute' 'default' '{' :)
     or $state[$p:lk] = 11098464                            (: 'element' 'default' '{' :)
     or $state[$p:lk] = 11098513                            (: 'processing-instruction' 'default' '{' :)
     or $state[$p:lk] = 11099211                            (: 'attribute' 'descending' '{' :)
     or $state[$p:lk] = 11099232                            (: 'element' 'descending' '{' :)
     or $state[$p:lk] = 11099281                            (: 'processing-instruction' 'descending' '{' :)
     or $state[$p:lk] = 11099467                            (: 'attribute' 'div' '{' :)
     or $state[$p:lk] = 11099488                            (: 'element' 'div' '{' :)
     or $state[$p:lk] = 11099537                            (: 'processing-instruction' 'div' '{' :)
     or $state[$p:lk] = 11100491                            (: 'attribute' 'else' '{' :)
     or $state[$p:lk] = 11100512                            (: 'element' 'else' '{' :)
     or $state[$p:lk] = 11100561                            (: 'processing-instruction' 'else' '{' :)
     or $state[$p:lk] = 11100747                            (: 'attribute' 'empty' '{' :)
     or $state[$p:lk] = 11100768                            (: 'element' 'empty' '{' :)
     or $state[$p:lk] = 11100817                            (: 'processing-instruction' 'empty' '{' :)
     or $state[$p:lk] = 11101515                            (: 'attribute' 'eq' '{' :)
     or $state[$p:lk] = 11101536                            (: 'element' 'eq' '{' :)
     or $state[$p:lk] = 11101585                            (: 'processing-instruction' 'eq' '{' :)
     or $state[$p:lk] = 11102027                            (: 'attribute' 'except' '{' :)
     or $state[$p:lk] = 11102048                            (: 'element' 'except' '{' :)
     or $state[$p:lk] = 11102097                            (: 'processing-instruction' 'except' '{' :)
     or $state[$p:lk] = 11103051                            (: 'attribute' 'for' '{' :)
     or $state[$p:lk] = 11103072                            (: 'element' 'for' '{' :)
     or $state[$p:lk] = 11103121                            (: 'processing-instruction' 'for' '{' :)
     or $state[$p:lk] = 11103563                            (: 'attribute' 'ge' '{' :)
     or $state[$p:lk] = 11103584                            (: 'element' 'ge' '{' :)
     or $state[$p:lk] = 11103633                            (: 'processing-instruction' 'ge' '{' :)
     or $state[$p:lk] = 11104075                            (: 'attribute' 'gt' '{' :)
     or $state[$p:lk] = 11104096                            (: 'element' 'gt' '{' :)
     or $state[$p:lk] = 11104145                            (: 'processing-instruction' 'gt' '{' :)
     or $state[$p:lk] = 11104587                            (: 'attribute' 'idiv' '{' :)
     or $state[$p:lk] = 11104608                            (: 'element' 'idiv' '{' :)
     or $state[$p:lk] = 11104657                            (: 'processing-instruction' 'idiv' '{' :)
     or $state[$p:lk] = 11105867                            (: 'attribute' 'instance' '{' :)
     or $state[$p:lk] = 11105888                            (: 'element' 'instance' '{' :)
     or $state[$p:lk] = 11105937                            (: 'processing-instruction' 'instance' '{' :)
     or $state[$p:lk] = 11106123                            (: 'attribute' 'intersect' '{' :)
     or $state[$p:lk] = 11106144                            (: 'element' 'intersect' '{' :)
     or $state[$p:lk] = 11106193                            (: 'processing-instruction' 'intersect' '{' :)
     or $state[$p:lk] = 11106379                            (: 'attribute' 'is' '{' :)
     or $state[$p:lk] = 11106400                            (: 'element' 'is' '{' :)
     or $state[$p:lk] = 11106449                            (: 'processing-instruction' 'is' '{' :)
     or $state[$p:lk] = 11107403                            (: 'attribute' 'le' '{' :)
     or $state[$p:lk] = 11107424                            (: 'element' 'le' '{' :)
     or $state[$p:lk] = 11107473                            (: 'processing-instruction' 'le' '{' :)
     or $state[$p:lk] = 11107915                            (: 'attribute' 'let' '{' :)
     or $state[$p:lk] = 11107936                            (: 'element' 'let' '{' :)
     or $state[$p:lk] = 11107985                            (: 'processing-instruction' 'let' '{' :)
     or $state[$p:lk] = 11108171                            (: 'attribute' 'lt' '{' :)
     or $state[$p:lk] = 11108192                            (: 'element' 'lt' '{' :)
     or $state[$p:lk] = 11108241                            (: 'processing-instruction' 'lt' '{' :)
     or $state[$p:lk] = 11108427                            (: 'attribute' 'mod' '{' :)
     or $state[$p:lk] = 11108448                            (: 'element' 'mod' '{' :)
     or $state[$p:lk] = 11108497                            (: 'processing-instruction' 'mod' '{' :)
     or $state[$p:lk] = 11109195                            (: 'attribute' 'ne' '{' :)
     or $state[$p:lk] = 11109216                            (: 'element' 'ne' '{' :)
     or $state[$p:lk] = 11109265                            (: 'processing-instruction' 'ne' '{' :)
     or $state[$p:lk] = 11110731                            (: 'attribute' 'or' '{' :)
     or $state[$p:lk] = 11110752                            (: 'element' 'or' '{' :)
     or $state[$p:lk] = 11110801                            (: 'processing-instruction' 'or' '{' :)
     or $state[$p:lk] = 11110987                            (: 'attribute' 'order' '{' :)
     or $state[$p:lk] = 11111008                            (: 'element' 'order' '{' :)
     or $state[$p:lk] = 11111057                            (: 'processing-instruction' 'order' '{' :)
     or $state[$p:lk] = 11113035                            (: 'attribute' 'return' '{' :)
     or $state[$p:lk] = 11113056                            (: 'element' 'return' '{' :)
     or $state[$p:lk] = 11113105                            (: 'processing-instruction' 'return' '{' :)
     or $state[$p:lk] = 11113291                            (: 'attribute' 'satisfies' '{' :)
     or $state[$p:lk] = 11113312                            (: 'element' 'satisfies' '{' :)
     or $state[$p:lk] = 11113361                            (: 'processing-instruction' 'satisfies' '{' :)
     or $state[$p:lk] = 11114827                            (: 'attribute' 'stable' '{' :)
     or $state[$p:lk] = 11114848                            (: 'element' 'stable' '{' :)
     or $state[$p:lk] = 11114897                            (: 'processing-instruction' 'stable' '{' :)
     or $state[$p:lk] = 11116107                            (: 'attribute' 'to' '{' :)
     or $state[$p:lk] = 11116128                            (: 'element' 'to' '{' :)
     or $state[$p:lk] = 11116177                            (: 'processing-instruction' 'to' '{' :)
     or $state[$p:lk] = 11116363                            (: 'attribute' 'treat' '{' :)
     or $state[$p:lk] = 11116384                            (: 'element' 'treat' '{' :)
     or $state[$p:lk] = 11116433                            (: 'processing-instruction' 'treat' '{' :)
     or $state[$p:lk] = 11117131                            (: 'attribute' 'union' '{' :)
     or $state[$p:lk] = 11117152                            (: 'element' 'union' '{' :)
     or $state[$p:lk] = 11117201                            (: 'processing-instruction' 'union' '{' :)
     or $state[$p:lk] = 11118411                            (: 'attribute' 'where' '{' :)
     or $state[$p:lk] = 11118432                            (: 'element' 'where' '{' :)
     or $state[$p:lk] = 11118481) then                      (: 'processing-instruction' 'where' '{' :)
      let $state := p:parse-FilterExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AxisStep($input, $state)
      return $state
  return p:reduce($state, "StepExpr", $count)
};

(:~
 : Parse the 1st loop of production RelativePathExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RelativePathExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(114, $input, $state)        (: S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                               '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'and' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'ne' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'to' | 'treat' |
                                                               'union' | 'where' | '|' | '}' :)
    return
      if ($state[$p:l1] != 46                               (: '/' :)
      and $state[$p:l1] != 47) then                         (: '//' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 46) then                      (: '/' :)
            let $state := p:shift(46, $input, $state)       (: '/' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(47, $input, $state)       (: '//' :)
            return $state
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-StepExpr($input, $state)
        return p:parse-RelativePathExpr-1($input, $state)
};

(:~
 : Parse RelativePathExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RelativePathExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-StepExpr($input, $state)
  let $state := p:parse-RelativePathExpr-1($input, $state)
  return p:reduce($state, "RelativePathExpr", $count)
};

(:~
 : Parse PathExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PathExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 46) then                            (: '/' :)
      let $state := p:shift(46, $input, $state)             (: '/' :)
      let $state := p:lookahead1W(151, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '!=' | '$' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '.' | '..' | ';' | '<' | '<!--' |
                                                               '<<' | '<=' | '<?' | '=' | '>' | '>=' | '>>' | '@' |
                                                               ']' | '^' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '|' | '}' :)
      let $state :=
        if ($state[$p:l1] = 26                              (: '!=' :)
         or $state[$p:l1] = 36                              (: ')' :)
         or $state[$p:l1] = 37                              (: '*' :)
         or $state[$p:l1] = 39                              (: '+' :)
         or $state[$p:l1] = 41                              (: ',' :)
         or $state[$p:l1] = 42                              (: '-' :)
         or $state[$p:l1] = 52                              (: ';' :)
         or $state[$p:l1] = 56                              (: '<<' :)
         or $state[$p:l1] = 57                              (: '<=' :)
         or $state[$p:l1] = 59                              (: '=' :)
         or $state[$p:l1] = 60                              (: '>' :)
         or $state[$p:l1] = 61                              (: '>=' :)
         or $state[$p:l1] = 62                              (: '>>' :)
         or $state[$p:l1] = 67                              (: ']' :)
         or $state[$p:l1] = 171                             (: '|' :)
         or $state[$p:l1] = 172) then                       (: '}' :)
          $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:parse-RelativePathExpr($input, $state)
          return $state
      return $state
    else if ($state[$p:l1] = 47) then                       (: '//' :)
      let $state := p:shift(47, $input, $state)             (: '//' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-RelativePathExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-RelativePathExpr($input, $state)
      return $state
  return p:reduce($state, "PathExpr", $count)
};

(:~
 : Parse ValidationMode.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValidationMode($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 123) then                           (: 'lax' :)
      let $state := p:shift(123, $input, $state)            (: 'lax' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(154, $input, $state)            (: 'strict' :)
      return $state
  return p:reduce($state, "ValidationMode", $count)
};

(:~
 : Parse ValidateExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValidateExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(164, $input, $state)                (: 'validate' :)
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | ('(' ':') | 'lax' | 'strict' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 169) then                     (: '{' :)
      let $state := p:parse-ValidationMode($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(169, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(45, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(172, $input, $state)                (: '}' :)
  return p:reduce($state, "ValidateExpr", $count)
};

(:~
 : Parse ValueExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValueExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 164) then                           (: 'validate' :)
      let $state := p:lookahead2W(125, $input, $state)      (: S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'lax' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'strict' | 'to' | 'treat' | 'union' |
                                                               'where' | '{' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 31652                               (: 'validate' 'lax' :)
     or $state[$p:lk] = 39588                               (: 'validate' 'strict' :)
     or $state[$p:lk] = 43428) then                         (: 'validate' '{' :)
      let $state := p:parse-ValidateExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 34) then                       (: '(#' :)
      let $state := p:parse-ExtensionExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-PathExpr($input, $state)
      return $state
  return p:reduce($state, "ValueExpr", $count)
};

(:~
 : Parse the 1st loop of production UnaryExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnaryExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(144, $input, $state)        (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               '^' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
    return
      if ($state[$p:l1] != 39                               (: '+' :)
      and $state[$p:l1] != 42) then                         (: '-' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 42) then                      (: '-' :)
            let $state := p:shift(42, $input, $state)       (: '-' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(39, $input, $state)       (: '+' :)
            return $state
        return p:parse-UnaryExpr-1($input, $state)
};

(:~
 : Parse UnaryExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-UnaryExpr-1($input, $state)
  let $state := p:parse-ValueExpr($input, $state)
  return p:reduce($state, "UnaryExpr", $count)
};

(:~
 : Parse CastExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CastExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-UnaryExpr($input, $state)
  let $state := p:lookahead1W(113, $input, $state)          (: S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'eq' | 'except' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'to' | 'treat' | 'union' |
                                                               'where' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 80) then                       (: 'cast' :)
      let $state := p:shift(80, $input, $state)             (: 'cast' :)
      let $state := p:lookahead1W(35, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:shift(72, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-SingleType($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "CastExpr", $count)
};

(:~
 : Parse CastableExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CastableExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-CastExpr($input, $state)
  let $state := p:lookahead1W(111, $input, $state)          (: S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'castable' | 'collation' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'eq' | 'except' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 81) then                       (: 'castable' :)
      let $state := p:shift(81, $input, $state)             (: 'castable' :)
      let $state := p:lookahead1W(35, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:shift(72, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-SingleType($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "CastableExpr", $count)
};

(:~
 : Parse TreatExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TreatExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-CastableExpr($input, $state)
  let $state := p:lookahead1W(110, $input, $state)          (: S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 159) then                      (: 'treat' :)
      let $state := p:shift(159, $input, $state)            (: 'treat' :)
      let $state := p:lookahead1W(35, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:shift(72, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "TreatExpr", $count)
};

(:~
 : Parse InstanceofExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InstanceofExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-TreatExpr($input, $state)
  let $state := p:lookahead1W(109, $input, $state)          (: S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'union' | 'where' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 118) then                      (: 'instance' :)
      let $state := p:shift(118, $input, $state)            (: 'instance' :)
      let $state := p:lookahead1W(40, $input, $state)       (: S^WS | ('(' ':') | 'of' :)
      let $state := p:shift(135, $input, $state)            (: 'of' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "InstanceofExpr", $count)
};

(:~
 : Parse the 1st loop of production IntersectExceptExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IntersectExceptExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(108, $input, $state)        (: S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'intersect' |
                                                               'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'to' |
                                                               'union' | 'where' | '|' | '}' :)
    return
      if ($state[$p:l1] != 103                              (: 'except' :)
      and $state[$p:l1] != 119) then                        (: 'intersect' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 119) then                     (: 'intersect' :)
            let $state := p:shift(119, $input, $state)      (: 'intersect' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(103, $input, $state)      (: 'except' :)
            return $state
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-InstanceofExpr($input, $state)
        return p:parse-IntersectExceptExpr-1($input, $state)
};

(:~
 : Parse IntersectExceptExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IntersectExceptExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-InstanceofExpr($input, $state)
  let $state := p:parse-IntersectExceptExpr-1($input, $state)
  return p:reduce($state, "IntersectExceptExpr", $count)
};

(:~
 : Parse the 1st loop of production UnionExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnionExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(107, $input, $state)        (: S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'to' | 'union' | 'where' | '|' | '}' :)
    return
      if ($state[$p:l1] != 162                              (: 'union' :)
      and $state[$p:l1] != 171) then                        (: '|' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 162) then                     (: 'union' :)
            let $state := p:shift(162, $input, $state)      (: 'union' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(171, $input, $state)      (: '|' :)
            return $state
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-IntersectExceptExpr($input, $state)
        return p:parse-UnionExpr-1($input, $state)
};

(:~
 : Parse UnionExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnionExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-IntersectExceptExpr($input, $state)
  let $state := p:parse-UnionExpr-1($input, $state)
  return p:reduce($state, "UnionExpr", $count)
};

(:~
 : Parse the 1st loop of production MultiplicativeExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MultiplicativeExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(106, $input, $state)        (: S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'to' | 'where' | '}' :)
    return
      if ($state[$p:l1] != 37                               (: '*' :)
      and $state[$p:l1] != 93                               (: 'div' :)
      and $state[$p:l1] != 113                              (: 'idiv' :)
      and $state[$p:l1] != 128) then                        (: 'mod' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 37) then                      (: '*' :)
            let $state := p:shift(37, $input, $state)       (: '*' :)
            return $state
          else if ($state[$p:l1] = 93) then                 (: 'div' :)
            let $state := p:shift(93, $input, $state)       (: 'div' :)
            return $state
          else if ($state[$p:l1] = 113) then                (: 'idiv' :)
            let $state := p:shift(113, $input, $state)      (: 'idiv' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(128, $input, $state)      (: 'mod' :)
            return $state
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-UnionExpr($input, $state)
        return p:parse-MultiplicativeExpr-1($input, $state)
};

(:~
 : Parse MultiplicativeExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MultiplicativeExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-UnionExpr($input, $state)
  let $state := p:parse-MultiplicativeExpr-1($input, $state)
  return p:reduce($state, "MultiplicativeExpr", $count)
};

(:~
 : Parse the 1st loop of production AdditiveExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AdditiveExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(105, $input, $state)        (: S^WS | '!=' | ('(' ':') | ')' | '+' | ',' | '-' | ';' |
                                                               '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'else' | 'empty' | 'eq' | 'for' | 'ge' |
                                                               'gt' | 'is' | 'le' | 'let' | 'lt' | 'ne' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'to' |
                                                               'where' | '}' :)
    return
      if ($state[$p:l1] != 39                               (: '+' :)
      and $state[$p:l1] != 42) then                         (: '-' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 39) then                      (: '+' :)
            let $state := p:shift(39, $input, $state)       (: '+' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(42, $input, $state)       (: '-' :)
            return $state
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-MultiplicativeExpr($input, $state)
        return p:parse-AdditiveExpr-1($input, $state)
};

(:~
 : Parse AdditiveExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AdditiveExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-MultiplicativeExpr($input, $state)
  let $state := p:parse-AdditiveExpr-1($input, $state)
  return p:reduce($state, "AdditiveExpr", $count)
};

(:~
 : Parse RangeExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RangeExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-AdditiveExpr($input, $state)
  let $state := p:lookahead1W(104, $input, $state)          (: S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' |
                                                               'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'else' | 'empty' | 'eq' | 'for' | 'ge' |
                                                               'gt' | 'is' | 'le' | 'let' | 'lt' | 'ne' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'to' |
                                                               'where' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 158) then                      (: 'to' :)
      let $state := p:shift(158, $input, $state)            (: 'to' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-AdditiveExpr($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "RangeExpr", $count)
};

(:~
 : Parse ComparisonExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ComparisonExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-RangeExpr($input, $state)
  let $state := p:lookahead1W(102, $input, $state)          (: S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' |
                                                               'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'else' | 'empty' | 'eq' | 'for' | 'ge' |
                                                               'gt' | 'is' | 'le' | 'let' | 'lt' | 'ne' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'where' |
                                                               '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 26                             (: '!=' :)
          or $state[$p:l1] = 53                             (: '<' :)
          or $state[$p:l1] = 56                             (: '<<' :)
          or $state[$p:l1] = 57                             (: '<=' :)
          or $state[$p:l1] = 59                             (: '=' :)
          or $state[$p:l1] = 60                             (: '>' :)
          or $state[$p:l1] = 61                             (: '>=' :)
          or $state[$p:l1] = 62                             (: '>>' :)
          or $state[$p:l1] = 101                            (: 'eq' :)
          or $state[$p:l1] = 109                            (: 'ge' :)
          or $state[$p:l1] = 111                            (: 'gt' :)
          or $state[$p:l1] = 120                            (: 'is' :)
          or $state[$p:l1] = 124                            (: 'le' :)
          or $state[$p:l1] = 127                            (: 'lt' :)
          or $state[$p:l1] = 131) then                      (: 'ne' :)
      let $state :=
        if ($state[$p:l1] = 101                             (: 'eq' :)
         or $state[$p:l1] = 109                             (: 'ge' :)
         or $state[$p:l1] = 111                             (: 'gt' :)
         or $state[$p:l1] = 124                             (: 'le' :)
         or $state[$p:l1] = 127                             (: 'lt' :)
         or $state[$p:l1] = 131) then                       (: 'ne' :)
          let $state := p:parse-ValueComp($input, $state)
          return $state
        else if ($state[$p:l1] = 56                         (: '<<' :)
              or $state[$p:l1] = 62                         (: '>>' :)
              or $state[$p:l1] = 120) then                  (: 'is' :)
          let $state := p:parse-NodeComp($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:parse-GeneralComp($input, $state)
          return $state
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-RangeExpr($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "ComparisonExpr", $count)
};

(:~
 : Parse the 1st loop of production AndExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AndExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(98, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' | ';' | ']' | 'and' |
                                                               'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'else' | 'empty' | 'for' | 'let' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'where' |
                                                               '}' :)
    return
      if ($state[$p:l1] != 71) then                         (: 'and' :)
        $state
      else
        let $state := p:shift(71, $input, $state)           (: 'and' :)
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-ComparisonExpr($input, $state)
        return p:parse-AndExpr-1($input, $state)
};

(:~
 : Parse AndExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AndExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ComparisonExpr($input, $state)
  let $state := p:parse-AndExpr-1($input, $state)
  return p:reduce($state, "AndExpr", $count)
};

(:~
 : Parse the 1st loop of production OrExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(97, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' | ';' | ']' | 'ascending' |
                                                               'case' | 'collation' | 'default' | 'descending' |
                                                               'else' | 'empty' | 'for' | 'let' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'where' | '}' :)
    return
      if ($state[$p:l1] != 137) then                        (: 'or' :)
        $state
      else
        let $state := p:shift(137, $input, $state)          (: 'or' :)
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-AndExpr($input, $state)
        return p:parse-OrExpr-1($input, $state)
};

(:~
 : Parse OrExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-AndExpr($input, $state)
  let $state := p:parse-OrExpr-1($input, $state)
  return p:reduce($state, "OrExpr", $count)
};

(:~
 : Parse IfExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IfExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(114, $input, $state)                (: 'if' :)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | ('(' ':') | 'then' :)
  let $state := p:shift(157, $input, $state)                (: 'then' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:lookahead1W(37, $input, $state)           (: S^WS | ('(' ':') | 'else' :)
  let $state := p:shift(97, $input, $state)                 (: 'else' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "IfExpr", $count)
};

(:~
 : Parse CaseClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CaseClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(11, $input, $state)            (: 'case' :)
  let $state := p:shift(79, $input, $state)                 (: 'case' :)
  let $state := p:lookahead1W(133, $input, $state)          (: S^WS | QName^Token | '$' | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:shift(31, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(130, $input, $state)      (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
      let $state := p:parse-VarName($input, $state)
      let $state := p:lookahead1W(35, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:shift(72, $input, $state)             (: 'as' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-SequenceType($input, $state)
  let $state := p:lookahead1W(42, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:shift(146, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "CaseClause", $count)
};

(:~
 : Parse the 1st loop of production TypeswitchExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeswitchExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(20, $input, $state)         (: EPSILON | S^WS | ('(' ':') :)
    let $state := p:parse-CaseClause($input, $state)
    let $state := p:lookahead1W(68, $input, $state)         (: S^WS | ('(' ':') | 'case' | 'default' :)
    return
      if ($state[$p:l1] != 79) then                         (: 'case' :)
        $state
      else
        p:parse-TypeswitchExpr-1($input, $state)
};

(:~
 : Parse TypeswitchExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeswitchExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(161, $input, $state)                (: 'typeswitch' :)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-TypeswitchExpr-1($input, $state)
  let $state := p:shift(89, $input, $state)                 (: 'default' :)
  let $state := p:lookahead1W(51, $input, $state)           (: S^WS | '$' | ('(' ':') | 'return' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:shift(31, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(130, $input, $state)      (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
      let $state := p:parse-VarName($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(42, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:shift(146, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "TypeswitchExpr", $count)
};

(:~
 : Parse the 1st loop of production QuantifiedExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QuantifiedExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(62, $input, $state)         (: S^WS | ('(' ':') | ',' | 'satisfies' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(26, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state := p:shift(31, $input, $state)           (: '$' :)
        let $state := p:lookahead1W(130, $input, $state)    (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
        let $state := p:parse-VarName($input, $state)
        let $state := p:lookahead1W(64, $input, $state)     (: S^WS | ('(' ':') | 'as' | 'in' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 72) then                 (: 'as' :)
            let $state := p:parse-TypeDeclaration($input, $state)
            return $state
          else
            $state
        let $state := p:lookahead1W(38, $input, $state)     (: S^WS | ('(' ':') | 'in' :)
        let $state := p:shift(116, $input, $state)          (: 'in' :)
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-ExprSingle($input, $state)
        return p:parse-QuantifiedExpr-1($input, $state)
};

(:~
 : Parse QuantifiedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QuantifiedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 152) then                           (: 'some' :)
      let $state := p:shift(152, $input, $state)            (: 'some' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(102, $input, $state)            (: 'every' :)
      return $state
  let $state := p:lookahead1W(26, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(130, $input, $state)          (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(64, $input, $state)           (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 72) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(38, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:shift(116, $input, $state)                (: 'in' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:parse-QuantifiedExpr-1($input, $state)
  let $state := p:shift(147, $input, $state)                (: 'satisfies' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "QuantifiedExpr", $count)
};

(:~
 : Parse OrderModifier.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderModifier($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(91, $input, $state)           (: S^WS | ('(' ':') | ',' | 'ascending' | 'collation' |
                                                               'descending' | 'empty' | 'return' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 73                             (: 'ascending' :)
          or $state[$p:l1] = 92) then                       (: 'descending' :)
      let $state :=
        if ($state[$p:l1] = 73) then                        (: 'ascending' :)
          let $state := p:shift(73, $input, $state)         (: 'ascending' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(92, $input, $state)         (: 'descending' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(85, $input, $state)           (: S^WS | ('(' ':') | ',' | 'collation' | 'empty' | 'return' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 98) then                       (: 'empty' :)
      let $state := p:shift(98, $input, $state)             (: 'empty' :)
      let $state := p:lookahead1W(69, $input, $state)       (: S^WS | ('(' ':') | 'greatest' | 'least' :)
      let $state :=
        if ($state[$p:l1] = 110) then                       (: 'greatest' :)
          let $state := p:shift(110, $input, $state)        (: 'greatest' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(125, $input, $state)        (: 'least' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(78, $input, $state)           (: S^WS | ('(' ':') | ',' | 'collation' | 'return' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 83) then                       (: 'collation' :)
      let $state := p:shift(83, $input, $state)             (: 'collation' :)
      let $state := p:lookahead1W(22, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:parse-URILiteral($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "OrderModifier", $count)
};

(:~
 : Parse OrderSpec.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderSpec($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-OrderModifier($input, $state)
  return p:reduce($state, "OrderSpec", $count)
};

(:~
 : Parse the 1st loop of production OrderSpecList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderSpecList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(61, $input, $state)         (: S^WS | ('(' ':') | ',' | 'return' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-OrderSpec($input, $state)
        return p:parse-OrderSpecList-1($input, $state)
};

(:~
 : Parse OrderSpecList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderSpecList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-OrderSpec($input, $state)
  let $state := p:parse-OrderSpecList-1($input, $state)
  return p:reduce($state, "OrderSpecList", $count)
};

(:~
 : Parse OrderByClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderByClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 138) then                           (: 'order' :)
      let $state := p:shift(138, $input, $state)            (: 'order' :)
      let $state := p:lookahead1W(36, $input, $state)       (: S^WS | ('(' ':') | 'by' :)
      let $state := p:shift(78, $input, $state)             (: 'by' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(153, $input, $state)            (: 'stable' :)
      let $state := p:lookahead1W(41, $input, $state)       (: S^WS | ('(' ':') | 'order' :)
      let $state := p:shift(138, $input, $state)            (: 'order' :)
      let $state := p:lookahead1W(36, $input, $state)       (: S^WS | ('(' ':') | 'by' :)
      let $state := p:shift(78, $input, $state)             (: 'by' :)
      return $state
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-OrderSpecList($input, $state)
  return p:reduce($state, "OrderByClause", $count)
};

(:~
 : Parse WhereClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-WhereClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(167, $input, $state)                (: 'where' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "WhereClause", $count)
};

(:~
 : Parse the 1st loop of production LetClause (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LetClause-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(94, $input, $state)         (: S^WS | ('(' ':') | ',' | 'for' | 'let' | 'order' |
                                                               'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(26, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state := p:shift(31, $input, $state)           (: '$' :)
        let $state := p:lookahead1W(130, $input, $state)    (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
        let $state := p:parse-VarName($input, $state)
        let $state := p:lookahead1W(63, $input, $state)     (: S^WS | ('(' ':') | ':=' | 'as' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 72) then                 (: 'as' :)
            let $state := p:parse-TypeDeclaration($input, $state)
            return $state
          else
            $state
        let $state := p:lookahead1W(31, $input, $state)     (: S^WS | ('(' ':') | ':=' :)
        let $state := p:shift(51, $input, $state)           (: ':=' :)
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-ExprSingle($input, $state)
        return p:parse-LetClause-1($input, $state)
};

(:~
 : Parse LetClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LetClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(126, $input, $state)                (: 'let' :)
  let $state := p:lookahead1W(26, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(130, $input, $state)          (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(63, $input, $state)           (: S^WS | ('(' ':') | ':=' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 72) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(31, $input, $state)           (: S^WS | ('(' ':') | ':=' :)
  let $state := p:shift(51, $input, $state)                 (: ':=' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:parse-LetClause-1($input, $state)
  return p:reduce($state, "LetClause", $count)
};

(:~
 : Parse PositionalVar.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PositionalVar($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(74, $input, $state)                 (: 'at' :)
  let $state := p:lookahead1W(26, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(130, $input, $state)          (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  return p:reduce($state, "PositionalVar", $count)
};

(:~
 : Parse VarName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-QName($input, $state)
  return p:reduce($state, "VarName", $count)
};

(:~
 : Parse the 1st loop of production ForClause (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForClause-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(94, $input, $state)         (: S^WS | ('(' ':') | ',' | 'for' | 'let' | 'order' |
                                                               'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(26, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state := p:shift(31, $input, $state)           (: '$' :)
        let $state := p:lookahead1W(130, $input, $state)    (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
        let $state := p:parse-VarName($input, $state)
        let $state := p:lookahead1W(79, $input, $state)     (: S^WS | ('(' ':') | 'as' | 'at' | 'in' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 72) then                 (: 'as' :)
            let $state := p:parse-TypeDeclaration($input, $state)
            return $state
          else
            $state
        let $state := p:lookahead1W(66, $input, $state)     (: S^WS | ('(' ':') | 'at' | 'in' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 74) then                 (: 'at' :)
            let $state := p:parse-PositionalVar($input, $state)
            return $state
          else
            $state
        let $state := p:lookahead1W(38, $input, $state)     (: S^WS | ('(' ':') | 'in' :)
        let $state := p:shift(116, $input, $state)          (: 'in' :)
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-ExprSingle($input, $state)
        return p:parse-ForClause-1($input, $state)
};

(:~
 : Parse ForClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(107, $input, $state)                (: 'for' :)
  let $state := p:lookahead1W(26, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(130, $input, $state)          (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(79, $input, $state)           (: S^WS | ('(' ':') | 'as' | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 72) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(66, $input, $state)           (: S^WS | ('(' ':') | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 74) then                       (: 'at' :)
      let $state := p:parse-PositionalVar($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(38, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:shift(116, $input, $state)                (: 'in' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:parse-ForClause-1($input, $state)
  return p:reduce($state, "ForClause", $count)
};

(:~
 : Parse the 1st loop of production FLWORExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FLWORExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:l1] = 107) then                         (: 'for' :)
        let $state := p:parse-ForClause($input, $state)
        return $state
      else if ($state[$p:error]) then
        $state
      else
        let $state := p:parse-LetClause($input, $state)
        return $state
    let $state := p:lookahead1W(92, $input, $state)         (: S^WS | ('(' ':') | 'for' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' :)
    return
      if ($state[$p:l1] != 107                              (: 'for' :)
      and $state[$p:l1] != 126) then                        (: 'let' :)
        $state
      else
        p:parse-FLWORExpr-1($input, $state)
};

(:~
 : Parse FLWORExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FLWORExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-FLWORExpr-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 167) then                      (: 'where' :)
      let $state := p:parse-WhereClause($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(82, $input, $state)           (: S^WS | ('(' ':') | 'order' | 'return' | 'stable' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 146) then                     (: 'return' :)
      let $state := p:parse-OrderByClause($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(42, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:shift(146, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "FLWORExpr", $count)
};

(:~
 : Parse ExprSingle.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ExprSingle($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(144, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               '^' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 114                                 (: 'typeswitch' :)
     or $state[$p:l1] = 161) then                           (: 'typeswitch' :)
      let $state := p:lookahead2W(119, $input, $state)      (: S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 102                            (: 'for' :)
          or $state[$p:l1] = 107                            (: 'let' :)
          or $state[$p:l1] = 126                            (: 'some' :)
          or $state[$p:l1] = 152) then                      (: 'some' :)
      let $state := p:lookahead2W(121, $input, $state)      (: S^WS | '!=' | '$' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 8043                                (: 'for' '$' :)
     or $state[$p:lk] = 8062) then                          (: 'let' '$' :)
      let $state := p:parse-FLWORExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 8038                           (: 'every' '$' :)
          or $state[$p:lk] = 8088) then                     (: 'some' '$' :)
      let $state := p:parse-QuantifiedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 8609) then                     (: 'typeswitch' '(' :)
      let $state := p:parse-TypeswitchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 8562) then                     (: 'if' '(' :)
      let $state := p:parse-IfExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-OrExpr($input, $state)
      return $state
  return p:reduce($state, "ExprSingle", $count)
};

(:~
 : Parse the 1st loop of production Expr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Expr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(86, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' | ';' | ']' | '}' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-ExprSingle($input, $state)
        return p:parse-Expr-1($input, $state)
};

(:~
 : Parse Expr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Expr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:parse-Expr-1($input, $state)
  return p:reduce($state, "Expr", $count)
};

(:~
 : Parse OccurrenceIndicator.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OccurrenceIndicator($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 63) then                            (: '?' :)
      let $state := p:shift(63, $input, $state)             (: '?' :)
      return $state
    else if ($state[$p:l1] = 38) then                       (: '*' :)
      let $state := p:shift(38, $input, $state)             (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(40, $input, $state)             (: '+' :)
      return $state
  return p:reduce($state, "OccurrenceIndicator", $count)
};

(:~
 : Parse AtomicType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AtomicType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-QName($input, $state)
  return p:reduce($state, "AtomicType", $count)
};

(:~
 : Parse AnyKindTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AnyKindTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(134, $input, $state)                (: 'node' :)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "AnyKindTest", $count)
};

(:~
 : Parse TextTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TextTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(156, $input, $state)                (: 'text' :)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "TextTest", $count)
};

(:~
 : Parse CommentTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CommentTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(84, $input, $state)                 (: 'comment' :)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "CommentTest", $count)
};

(:~
 : Parse PITest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PITest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(145, $input, $state)                (: 'processing-instruction' :)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(103, $input, $state)          (: StringLiteral | S^WS | NCName^Token | ('(' ':') | ')' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'eq' | 'except' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'to' | 'treat' | 'union' |
                                                               'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36) then                      (: ')' :)
      let $state :=
        if ($state[$p:l1] = 6) then                         (: StringLiteral :)
          let $state := p:shift(6, $input, $state)          (: StringLiteral :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:parse-NCName($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "PITest", $count)
};

(:~
 : Parse AttributeDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttributeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-AttributeName($input, $state)
  return p:reduce($state, "AttributeDeclaration", $count)
};

(:~
 : Parse SchemaAttributeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaAttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(149, $input, $state)                (: 'schema-attribute' :)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(130, $input, $state)          (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-AttributeDeclaration($input, $state)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "SchemaAttributeTest", $count)
};

(:~
 : Parse AttributeName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttributeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-QName($input, $state)
  return p:reduce($state, "AttributeName", $count)
};

(:~
 : Parse AttribNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttribNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 37) then                            (: '*' :)
      let $state := p:shift(37, $input, $state)             (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AttributeName($input, $state)
      return $state
  return p:reduce($state, "AttribNameOrWildcard", $count)
};

(:~
 : Parse AttributeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(75, $input, $state)                 (: 'attribute' :)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(138, $input, $state)          (: S^WS | QName^Token | ('(' ':') | ')' | '*' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36) then                      (: ')' :)
      let $state := p:parse-AttribNameOrWildcard($input, $state)
      let $state := p:lookahead1W(58, $input, $state)       (: S^WS | ('(' ':') | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 41) then                   (: ',' :)
          let $state := p:shift(41, $input, $state)         (: ',' :)
          let $state := p:lookahead1W(130, $input, $state)  (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
          let $state := p:parse-TypeName($input, $state)
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "AttributeTest", $count)
};

(:~
 : Parse ElementDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ElementName($input, $state)
  return p:reduce($state, "ElementDeclaration", $count)
};

(:~
 : Parse SchemaElementTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaElementTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(150, $input, $state)                (: 'schema-element' :)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(130, $input, $state)          (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-ElementDeclaration($input, $state)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "SchemaElementTest", $count)
};

(:~
 : Parse TypeName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-QName($input, $state)
  return p:reduce($state, "TypeName", $count)
};

(:~
 : Parse ElementName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-QName($input, $state)
  return p:reduce($state, "ElementName", $count)
};

(:~
 : Parse ElementNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 37) then                            (: '*' :)
      let $state := p:shift(37, $input, $state)             (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ElementName($input, $state)
      return $state
  return p:reduce($state, "ElementNameOrWildcard", $count)
};

(:~
 : Parse ElementTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(96, $input, $state)                 (: 'element' :)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(138, $input, $state)          (: S^WS | QName^Token | ('(' ':') | ')' | '*' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36) then                      (: ')' :)
      let $state := p:parse-ElementNameOrWildcard($input, $state)
      let $state := p:lookahead1W(58, $input, $state)       (: S^WS | ('(' ':') | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 41) then                   (: ',' :)
          let $state := p:shift(41, $input, $state)         (: ',' :)
          let $state := p:lookahead1W(130, $input, $state)  (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
          let $state := p:parse-TypeName($input, $state)
          let $state := p:lookahead1W(60, $input, $state)   (: S^WS | ('(' ':') | ')' | '?' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 63) then               (: '?' :)
              let $state := p:shift(63, $input, $state)     (: '?' :)
              return $state
            else
              $state
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "ElementTest", $count)
};

(:~
 : Parse DocumentTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DocumentTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(95, $input, $state)                 (: 'document-node' :)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(77, $input, $state)           (: S^WS | ('(' ':') | ')' | 'element' | 'schema-element' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36) then                      (: ')' :)
      let $state :=
        if ($state[$p:l1] = 96) then                        (: 'element' :)
          let $state := p:parse-ElementTest($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:parse-SchemaElementTest($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "DocumentTest", $count)
};

(:~
 : Parse KindTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-KindTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 95) then                            (: 'document-node' :)
      let $state := p:parse-DocumentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 96) then                       (: 'element' :)
      let $state := p:parse-ElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 75) then                       (: 'attribute' :)
      let $state := p:parse-AttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 150) then                      (: 'schema-element' :)
      let $state := p:parse-SchemaElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 149) then                      (: 'schema-attribute' :)
      let $state := p:parse-SchemaAttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'processing-instruction' :)
      let $state := p:parse-PITest($input, $state)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'comment' :)
      let $state := p:parse-CommentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 156) then                      (: 'text' :)
      let $state := p:parse-TextTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AnyKindTest($input, $state)
      return $state
  return p:reduce($state, "KindTest", $count)
};

(:~
 : Parse ItemType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ItemType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 75                                  (: 'comment' :)
     or $state[$p:l1] = 84                                  (: 'document-node' :)
     or $state[$p:l1] = 95                                  (: 'element' :)
     or $state[$p:l1] = 96                                  (: 'item' :)
     or $state[$p:l1] = 121                                 (: 'node' :)
     or $state[$p:l1] = 134                                 (: 'processing-instruction' :)
     or $state[$p:l1] = 145                                 (: 'schema-attribute' :)
     or $state[$p:l1] = 149                                 (: 'schema-element' :)
     or $state[$p:l1] = 150                                 (: 'text' :)
     or $state[$p:l1] = 156) then                           (: 'text' :)
      let $state := p:lookahead2W(118, $input, $state)      (: S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '*' | '+' |
                                                               '+' | ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '?' | ']' | 'and' | 'ascending' |
                                                               'at' | 'case' | 'collation' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'in' | 'instance' | 'intersect' |
                                                               'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'to' |
                                                               'union' | 'where' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 8523                                (: 'attribute' '(' :)
     or $state[$p:lk] = 8532                                (: 'comment' '(' :)
     or $state[$p:lk] = 8543                                (: 'document-node' '(' :)
     or $state[$p:lk] = 8544                                (: 'element' '(' :)
     or $state[$p:lk] = 8582                                (: 'node' '(' :)
     or $state[$p:lk] = 8593                                (: 'processing-instruction' '(' :)
     or $state[$p:lk] = 8597                                (: 'schema-attribute' '(' :)
     or $state[$p:lk] = 8598                                (: 'schema-element' '(' :)
     or $state[$p:lk] = 8604) then                          (: 'text' '(' :)
      let $state := p:parse-KindTest($input, $state)
      return $state
    else if ($state[$p:lk] = 8569) then                     (: 'item' '(' :)
      let $state := p:shift(121, $input, $state)            (: 'item' :)
      let $state := p:lookahead1W(27, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:shift(33, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:shift(36, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AtomicType($input, $state)
      return $state
  return p:reduce($state, "ItemType", $count)
};

(:~
 : Parse SequenceType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SequenceType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(127, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 99) then                            (: 'empty-sequence' :)
      let $state := p:lookahead2W(118, $input, $state)      (: S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '*' | '+' |
                                                               '+' | ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '?' | ']' | 'and' | 'ascending' |
                                                               'at' | 'case' | 'collation' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'in' | 'instance' | 'intersect' |
                                                               'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'to' |
                                                               'union' | 'where' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 8547) then                          (: 'empty-sequence' '(' :)
      let $state := p:shift(99, $input, $state)             (: 'empty-sequence' :)
      let $state := p:lookahead1W(27, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:shift(33, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:shift(36, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ItemType($input, $state)
      let $state := p:lookahead1W(115, $input, $state)      (: S^WS | '!=' | ('(' ':') | ')' | '*' | '*' | '+' | '+' |
                                                               ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '?' | ']' | 'and' | 'ascending' | 'at' |
                                                               'case' | 'collation' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'gt' | 'idiv' | 'in' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'ne' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'to' | 'union' |
                                                               'where' | '|' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 38                         (: '*' :)
              or $state[$p:l1] = 40                         (: '+' :)
              or $state[$p:l1] = 63) then                   (: '?' :)
          let $state := p:parse-OccurrenceIndicator($input, $state)
          return $state
        else
          $state
      return $state
  return p:reduce($state, "SequenceType", $count)
};

(:~
 : Parse TypeDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(72, $input, $state)                 (: 'as' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-SequenceType($input, $state)
  return p:reduce($state, "TypeDeclaration", $count)
};

(:~
 : Parse FunctionName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(117, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'else' | 'empty' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'module' | 'ne' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'return' |
                                                               'satisfies' | 'self' | 'some' | 'stable' | 'to' |
                                                               'treat' | 'union' | 'unordered' | 'validate' | 'where' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:l1] = 69) then                            (: 'ancestor' :)
      let $state := p:shift(69, $input, $state)             (: 'ancestor' :)
      return $state
    else if ($state[$p:l1] = 70) then                       (: 'ancestor-or-self' :)
      let $state := p:shift(70, $input, $state)             (: 'ancestor-or-self' :)
      return $state
    else if ($state[$p:l1] = 71) then                       (: 'and' :)
      let $state := p:shift(71, $input, $state)             (: 'and' :)
      return $state
    else if ($state[$p:l1] = 73) then                       (: 'ascending' :)
      let $state := p:shift(73, $input, $state)             (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 79) then                       (: 'case' :)
      let $state := p:shift(79, $input, $state)             (: 'case' :)
      return $state
    else if ($state[$p:l1] = 80) then                       (: 'cast' :)
      let $state := p:shift(80, $input, $state)             (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 81) then                       (: 'castable' :)
      let $state := p:shift(81, $input, $state)             (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 82) then                       (: 'child' :)
      let $state := p:shift(82, $input, $state)             (: 'child' :)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'collation' :)
      let $state := p:shift(83, $input, $state)             (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 88) then                       (: 'declare' :)
      let $state := p:shift(88, $input, $state)             (: 'declare' :)
      return $state
    else if ($state[$p:l1] = 89) then                       (: 'default' :)
      let $state := p:shift(89, $input, $state)             (: 'default' :)
      return $state
    else if ($state[$p:l1] = 90) then                       (: 'descendant' :)
      let $state := p:shift(90, $input, $state)             (: 'descendant' :)
      return $state
    else if ($state[$p:l1] = 91) then                       (: 'descendant-or-self' :)
      let $state := p:shift(91, $input, $state)             (: 'descendant-or-self' :)
      return $state
    else if ($state[$p:l1] = 92) then                       (: 'descending' :)
      let $state := p:shift(92, $input, $state)             (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'div' :)
      let $state := p:shift(93, $input, $state)             (: 'div' :)
      return $state
    else if ($state[$p:l1] = 94) then                       (: 'document' :)
      let $state := p:shift(94, $input, $state)             (: 'document' :)
      return $state
    else if ($state[$p:l1] = 97) then                       (: 'else' :)
      let $state := p:shift(97, $input, $state)             (: 'else' :)
      return $state
    else if ($state[$p:l1] = 98) then                       (: 'empty' :)
      let $state := p:shift(98, $input, $state)             (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 101) then                      (: 'eq' :)
      let $state := p:shift(101, $input, $state)            (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 102) then                      (: 'every' :)
      let $state := p:shift(102, $input, $state)            (: 'every' :)
      return $state
    else if ($state[$p:l1] = 103) then                      (: 'except' :)
      let $state := p:shift(103, $input, $state)            (: 'except' :)
      return $state
    else if ($state[$p:l1] = 105) then                      (: 'following' :)
      let $state := p:shift(105, $input, $state)            (: 'following' :)
      return $state
    else if ($state[$p:l1] = 106) then                      (: 'following-sibling' :)
      let $state := p:shift(106, $input, $state)            (: 'following-sibling' :)
      return $state
    else if ($state[$p:l1] = 107) then                      (: 'for' :)
      let $state := p:shift(107, $input, $state)            (: 'for' :)
      return $state
    else if ($state[$p:l1] = 109) then                      (: 'ge' :)
      let $state := p:shift(109, $input, $state)            (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 111) then                      (: 'gt' :)
      let $state := p:shift(111, $input, $state)            (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 113) then                      (: 'idiv' :)
      let $state := p:shift(113, $input, $state)            (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 115) then                      (: 'import' :)
      let $state := p:shift(115, $input, $state)            (: 'import' :)
      return $state
    else if ($state[$p:l1] = 118) then                      (: 'instance' :)
      let $state := p:shift(118, $input, $state)            (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 119) then                      (: 'intersect' :)
      let $state := p:shift(119, $input, $state)            (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 120) then                      (: 'is' :)
      let $state := p:shift(120, $input, $state)            (: 'is' :)
      return $state
    else if ($state[$p:l1] = 124) then                      (: 'le' :)
      let $state := p:shift(124, $input, $state)            (: 'le' :)
      return $state
    else if ($state[$p:l1] = 126) then                      (: 'let' :)
      let $state := p:shift(126, $input, $state)            (: 'let' :)
      return $state
    else if ($state[$p:l1] = 127) then                      (: 'lt' :)
      let $state := p:shift(127, $input, $state)            (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 128) then                      (: 'mod' :)
      let $state := p:shift(128, $input, $state)            (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 129) then                      (: 'module' :)
      let $state := p:shift(129, $input, $state)            (: 'module' :)
      return $state
    else if ($state[$p:l1] = 131) then                      (: 'ne' :)
      let $state := p:shift(131, $input, $state)            (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 137) then                      (: 'or' :)
      let $state := p:shift(137, $input, $state)            (: 'or' :)
      return $state
    else if ($state[$p:l1] = 138) then                      (: 'order' :)
      let $state := p:shift(138, $input, $state)            (: 'order' :)
      return $state
    else if ($state[$p:l1] = 139) then                      (: 'ordered' :)
      let $state := p:shift(139, $input, $state)            (: 'ordered' :)
      return $state
    else if ($state[$p:l1] = 141) then                      (: 'parent' :)
      let $state := p:shift(141, $input, $state)            (: 'parent' :)
      return $state
    else if ($state[$p:l1] = 142) then                      (: 'preceding' :)
      let $state := p:shift(142, $input, $state)            (: 'preceding' :)
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'preceding-sibling' :)
      let $state := p:shift(143, $input, $state)            (: 'preceding-sibling' :)
      return $state
    else if ($state[$p:l1] = 146) then                      (: 'return' :)
      let $state := p:shift(146, $input, $state)            (: 'return' :)
      return $state
    else if ($state[$p:l1] = 147) then                      (: 'satisfies' :)
      let $state := p:shift(147, $input, $state)            (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 151) then                      (: 'self' :)
      let $state := p:shift(151, $input, $state)            (: 'self' :)
      return $state
    else if ($state[$p:l1] = 152) then                      (: 'some' :)
      let $state := p:shift(152, $input, $state)            (: 'some' :)
      return $state
    else if ($state[$p:l1] = 153) then                      (: 'stable' :)
      let $state := p:shift(153, $input, $state)            (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 158) then                      (: 'to' :)
      let $state := p:shift(158, $input, $state)            (: 'to' :)
      return $state
    else if ($state[$p:l1] = 159) then                      (: 'treat' :)
      let $state := p:shift(159, $input, $state)            (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 162) then                      (: 'union' :)
      let $state := p:shift(162, $input, $state)            (: 'union' :)
      return $state
    else if ($state[$p:l1] = 163) then                      (: 'unordered' :)
      let $state := p:shift(163, $input, $state)            (: 'unordered' :)
      return $state
    else if ($state[$p:l1] = 164) then                      (: 'validate' :)
      let $state := p:shift(164, $input, $state)            (: 'validate' :)
      return $state
    else if ($state[$p:l1] = 167) then                      (: 'where' :)
      let $state := p:shift(167, $input, $state)            (: 'where' :)
      return $state
    else if ($state[$p:l1] = 168) then                      (: 'xquery' :)
      let $state := p:shift(168, $input, $state)            (: 'xquery' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(18, $input, $state)             (: QName^Token :)
      return $state
  return p:reduce($state, "FunctionName", $count)
};

(:~
 : Parse QName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(127, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 75) then                            (: 'attribute' :)
      let $state := p:shift(75, $input, $state)             (: 'attribute' :)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'comment' :)
      let $state := p:shift(84, $input, $state)             (: 'comment' :)
      return $state
    else if ($state[$p:l1] = 95) then                       (: 'document-node' :)
      let $state := p:shift(95, $input, $state)             (: 'document-node' :)
      return $state
    else if ($state[$p:l1] = 96) then                       (: 'element' :)
      let $state := p:shift(96, $input, $state)             (: 'element' :)
      return $state
    else if ($state[$p:l1] = 99) then                       (: 'empty-sequence' :)
      let $state := p:shift(99, $input, $state)             (: 'empty-sequence' :)
      return $state
    else if ($state[$p:l1] = 114) then                      (: 'if' :)
      let $state := p:shift(114, $input, $state)            (: 'if' :)
      return $state
    else if ($state[$p:l1] = 121) then                      (: 'item' :)
      let $state := p:shift(121, $input, $state)            (: 'item' :)
      return $state
    else if ($state[$p:l1] = 134) then                      (: 'node' :)
      let $state := p:shift(134, $input, $state)            (: 'node' :)
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'processing-instruction' :)
      let $state := p:shift(145, $input, $state)            (: 'processing-instruction' :)
      return $state
    else if ($state[$p:l1] = 149) then                      (: 'schema-attribute' :)
      let $state := p:shift(149, $input, $state)            (: 'schema-attribute' :)
      return $state
    else if ($state[$p:l1] = 150) then                      (: 'schema-element' :)
      let $state := p:shift(150, $input, $state)            (: 'schema-element' :)
      return $state
    else if ($state[$p:l1] = 156) then                      (: 'text' :)
      let $state := p:shift(156, $input, $state)            (: 'text' :)
      return $state
    else if ($state[$p:l1] = 161) then                      (: 'typeswitch' :)
      let $state := p:shift(161, $input, $state)            (: 'typeswitch' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-FunctionName($input, $state)
      return $state
  return p:reduce($state, "QName", $count)
};

(:~
 : Parse VarDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(130, $input, $state)          (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-QName($input, $state)
  let $state := p:lookahead1W(63, $input, $state)           (: S^WS | ('(' ':') | ':=' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 72) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(31, $input, $state)           (: S^WS | ('(' ':') | ':=' :)
  let $state := p:shift(51, $input, $state)                 (: ':=' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  return p:reduce($state, "VarDecl", $count)
};

(:~
 : Parse Separator.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Separator($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(52, $input, $state)                 (: ';' :)
  return p:reduce($state, "Separator", $count)
};

(:~
 : Parse URILiteral.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-URILiteral($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(6, $input, $state)                  (: StringLiteral :)
  return p:reduce($state, "URILiteral", $count)
};

(:~
 : Parse NCName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NCName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(99, $input, $state)            (: NCName^Token | 'and' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'ne' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'to' | 'treat' |
                                                               'union' | 'where' :)
  let $state :=
    if ($state[$p:l1] = 71) then                            (: 'and' :)
      let $state := p:shift(71, $input, $state)             (: 'and' :)
      return $state
    else if ($state[$p:l1] = 73) then                       (: 'ascending' :)
      let $state := p:shift(73, $input, $state)             (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 79) then                       (: 'case' :)
      let $state := p:shift(79, $input, $state)             (: 'case' :)
      return $state
    else if ($state[$p:l1] = 80) then                       (: 'cast' :)
      let $state := p:shift(80, $input, $state)             (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 81) then                       (: 'castable' :)
      let $state := p:shift(81, $input, $state)             (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'collation' :)
      let $state := p:shift(83, $input, $state)             (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 89) then                       (: 'default' :)
      let $state := p:shift(89, $input, $state)             (: 'default' :)
      return $state
    else if ($state[$p:l1] = 92) then                       (: 'descending' :)
      let $state := p:shift(92, $input, $state)             (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'div' :)
      let $state := p:shift(93, $input, $state)             (: 'div' :)
      return $state
    else if ($state[$p:l1] = 97) then                       (: 'else' :)
      let $state := p:shift(97, $input, $state)             (: 'else' :)
      return $state
    else if ($state[$p:l1] = 98) then                       (: 'empty' :)
      let $state := p:shift(98, $input, $state)             (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 101) then                      (: 'eq' :)
      let $state := p:shift(101, $input, $state)            (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 103) then                      (: 'except' :)
      let $state := p:shift(103, $input, $state)            (: 'except' :)
      return $state
    else if ($state[$p:l1] = 107) then                      (: 'for' :)
      let $state := p:shift(107, $input, $state)            (: 'for' :)
      return $state
    else if ($state[$p:l1] = 109) then                      (: 'ge' :)
      let $state := p:shift(109, $input, $state)            (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 111) then                      (: 'gt' :)
      let $state := p:shift(111, $input, $state)            (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 113) then                      (: 'idiv' :)
      let $state := p:shift(113, $input, $state)            (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 118) then                      (: 'instance' :)
      let $state := p:shift(118, $input, $state)            (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 119) then                      (: 'intersect' :)
      let $state := p:shift(119, $input, $state)            (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 120) then                      (: 'is' :)
      let $state := p:shift(120, $input, $state)            (: 'is' :)
      return $state
    else if ($state[$p:l1] = 124) then                      (: 'le' :)
      let $state := p:shift(124, $input, $state)            (: 'le' :)
      return $state
    else if ($state[$p:l1] = 126) then                      (: 'let' :)
      let $state := p:shift(126, $input, $state)            (: 'let' :)
      return $state
    else if ($state[$p:l1] = 127) then                      (: 'lt' :)
      let $state := p:shift(127, $input, $state)            (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 128) then                      (: 'mod' :)
      let $state := p:shift(128, $input, $state)            (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 131) then                      (: 'ne' :)
      let $state := p:shift(131, $input, $state)            (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 137) then                      (: 'or' :)
      let $state := p:shift(137, $input, $state)            (: 'or' :)
      return $state
    else if ($state[$p:l1] = 138) then                      (: 'order' :)
      let $state := p:shift(138, $input, $state)            (: 'order' :)
      return $state
    else if ($state[$p:l1] = 146) then                      (: 'return' :)
      let $state := p:shift(146, $input, $state)            (: 'return' :)
      return $state
    else if ($state[$p:l1] = 147) then                      (: 'satisfies' :)
      let $state := p:shift(147, $input, $state)            (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 153) then                      (: 'stable' :)
      let $state := p:shift(153, $input, $state)            (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 158) then                      (: 'to' :)
      let $state := p:shift(158, $input, $state)            (: 'to' :)
      return $state
    else if ($state[$p:l1] = 159) then                      (: 'treat' :)
      let $state := p:shift(159, $input, $state)            (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 162) then                      (: 'union' :)
      let $state := p:shift(162, $input, $state)            (: 'union' :)
      return $state
    else if ($state[$p:l1] = 167) then                      (: 'where' :)
      let $state := p:shift(167, $input, $state)            (: 'where' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(17, $input, $state)             (: NCName^Token :)
      return $state
  return p:reduce($state, "NCName", $count)
};

(:~
 : Parse NamespaceDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NamespaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(88, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(39, $input, $state)           (: S^WS | ('(' ':') | 'namespace' :)
  let $state := p:shift(130, $input, $state)                (: 'namespace' :)
  let $state := p:lookahead1W(100, $input, $state)          (: S^WS | NCName^Token | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' :)
  let $state := p:parse-NCName($input, $state)
  let $state := p:lookahead1W(33, $input, $state)           (: S^WS | ('(' ':') | '=' :)
  let $state := p:shift(59, $input, $state)                 (: '=' :)
  let $state := p:lookahead1W(22, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:parse-URILiteral($input, $state)
  return p:reduce($state, "NamespaceDecl", $count)
};

(:~
 : Parse the 1st loop of production CarrotModule (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CarrotModule-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(126, $input, $state)        (: S^WS | QName^Token | EOF | '$' | ('(' ':') | '^' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'else' | 'empty' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'module' | 'ne' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'return' |
                                                               'satisfies' | 'self' | 'some' | 'stable' | 'to' |
                                                               'treat' | 'union' | 'unordered' | 'validate' | 'where' |
                                                               'xquery' :)
    let $state :=
      if ($state[$p:l1] = 88) then                          (: 'declare' :)
        let $state := p:lookahead2W(54, $input, $state)     (: S^WS | '(' | ('(' ':') | 'namespace' :)
        return $state
      else
        ($state[$p:l1], $state[position() > $p:lk])
    return
      if ($state[$p:lk] != 33368) then                      (: 'declare' 'namespace' :)
        $state
      else
        let $state := p:parse-NamespaceDecl($input, $state)
        let $state := p:lookahead1W(32, $input, $state)     (: S^WS | ('(' ':') | ';' :)
        let $state := p:parse-Separator($input, $state)
        return p:parse-CarrotModule-1($input, $state)
};

(:~
 : Parse the 2nd loop of production CarrotModule (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CarrotModule-2($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(126, $input, $state)        (: S^WS | QName^Token | EOF | '$' | ('(' ':') | '^' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'else' | 'empty' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'module' | 'ne' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'return' |
                                                               'satisfies' | 'self' | 'some' | 'stable' | 'to' |
                                                               'treat' | 'union' | 'unordered' | 'validate' | 'where' |
                                                               'xquery' :)
    return
      if ($state[$p:l1] = 25) then                          (: EOF :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 31) then                      (: '$' :)
            let $state := p:parse-VarDecl($input, $state)
            return $state
          else if ($state[$p:l1] = 68) then                 (: '^' :)
            let $state := p:parse-RuleDecl($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-FunctionDecl($input, $state)
            return $state
        let $state := p:lookahead1W(32, $input, $state)     (: S^WS | ('(' ':') | ';' :)
        let $state := p:parse-Separator($input, $state)
        return p:parse-CarrotModule-2($input, $state)
};

(:~
 : Parse CarrotModule.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CarrotModule($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-CarrotModule-1($input, $state)
  let $state := p:parse-CarrotModule-2($input, $state)
  return p:reduce($state, "CarrotModule", $count)
};

(:~
 : Parse Carrot.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Carrot($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-CarrotModule($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | EOF | ('(' ':') :)
  let $state := p:shift(25, $input, $state)                 (: EOF :)
  return p:reduce($state, "Carrot", $count)
};

(:~
 : Parse start symbol Carrot from given string.
 :
 : @param $s the string to be parsed.
 : @return the result as generated by parser actions.
 :)
declare function p:parse-Carrot($s as xs:string) as item()*
{
  let $state := p:parse-Carrot($s, (0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, false()))
  let $error := $state[$p:error]
  return
    if ($error) then
      element ERROR {$error/@*, p:error-message($s, $error)}
    else
      $state[position() >= $p:result]
};

(:~
 : Parse start symbol KeyValuePairs from given string.
 :
 : @param $s the string to be parsed.
 : @return the result as generated by parser actions.
 :)
declare function p:parse-KeyValuePairs($s as xs:string) as item()*
{
  let $state := p:parse-KeyValuePairs($s, (0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, false()))
  let $error := $state[$p:error]
  return
    if ($error) then
      element ERROR {$error/@*, p:error-message($s, $error)}
    else
      $state[position() >= $p:result]
};

(: End :)
