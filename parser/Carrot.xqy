xquery version "1.0" encoding "UTF-8";

(: This file was generated on Mon Jan  9, 2012 21:40 by REx v5.10 which is Copyright (c) 1979-2011 by Gunther Rademacher <grd@gmx.net> :)
(: REx command line: Carrot.ebnf -xquery -tree :)

(:~
 : The parser that was generated for the Carrot grammar.
 :)
module namespace p="Carrot";

(: EDL: Manually added to make this work in MarkLogic Server :)
declare default function namespace "http://www.w3.org/2005/xpath-functions";

(:~
 : The codepoint to charclass mapping for 7 bit codepoints.
 :)
declare variable $p:MAP0 as xs:integer+ :=
(
  64, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7,
  8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,
  29, 26, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 31, 30, 30, 30, 30, 30, 30, 32, 6, 33, 34, 30, 35, 36, 37,
  38, 39, 40, 41, 42, 43, 44, 30, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 30, 60, 61, 62, 6, 6
);

(:~
 : The codepoint to charclass mapping for codepoints below the surrogate block.
 :)
declare variable $p:MAP1 as xs:integer+ :=
(
  216, 291, 323, 383, 415, 908, 351, 815, 815, 447, 479, 511, 543, 575, 621, 882, 589, 681, 815, 815, 815, 815, 815,
  815, 815, 815, 815, 815, 815, 815, 713, 745, 821, 649, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815,
  815, 815, 777, 809, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815,
  815, 815, 815, 815, 815, 815, 815, 815, 815, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 259, 815,
  815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 853, 940, 949, 941, 941, 957, 965, 973, 979, 987, 1259, 1010, 1027, 1045,
  1053, 1061, 1069, 1267, 1267, 1267, 1267, 1267, 1267, 1425, 1267, 1259, 1259, 1260, 1259, 1259, 1259, 1260, 1259,
  1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259,
  1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1261, 1267, 1267, 1267, 1267, 1267, 1267,
  1267, 1267, 1267, 1267, 1267, 1259, 1259, 1259, 1259, 1259, 1259, 1347, 1260, 1258, 1257, 1259, 1259, 1259, 1259,
  1259, 1260, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1263, 1083, 1259, 1259, 1259, 1259, 1188, 1086, 1259,
  1259, 1259, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259,
  1259, 1266, 1267, 1085, 1265, 1267, 1393, 1267, 1267, 1267, 1267, 1267, 1258, 1259, 1259, 1264, 1125, 1313, 1392,
  1267, 1387, 1393, 1125, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1349, 1259, 1260, 1136, 1387, 1302, 1201,
  1387, 1393, 1387, 1387, 1387, 1387, 1387, 1387, 1387, 1387, 1389, 1267, 1267, 1267, 1393, 1267, 1267, 1267, 1372,
  1236, 1259, 1259, 1256, 1259, 1259, 1259, 1259, 1260, 1260, 1412, 1257, 1259, 1263, 1267, 1258, 1094, 1259, 1259,
  1259, 1259, 1259, 1259, 1259, 1259, 1258, 1094, 1259, 1259, 1259, 1259, 1103, 1267, 1259, 1259, 1259, 1259, 1259,
  1259, 1116, 1034, 1259, 1259, 1259, 1117, 1261, 1265, 1438, 1259, 1259, 1259, 1259, 1259, 1259, 1154, 1387, 1389,
  1202, 1259, 1172, 1387, 1267, 1267, 1438, 1116, 1348, 1259, 1259, 1257, 1186, 1197, 1163, 1175, 1425, 1212, 1172,
  1387, 1265, 1267, 1223, 1246, 1348, 1259, 1259, 1257, 1402, 1197, 1178, 1175, 1267, 1234, 1426, 1387, 1244, 1267,
  1438, 1235, 1256, 1259, 1259, 1257, 1254, 1154, 1277, 1108, 1267, 1267, 994, 1387, 1267, 1267, 1438, 1116, 1348, 1259,
  1259, 1257, 1345, 1154, 1203, 1175, 1426, 1212, 1037, 1387, 1267, 1267, 1002, 1015, 1290, 1286, 1189, 1015, 1127,
  1037, 1204, 1201, 1425, 1267, 1425, 1387, 1267, 1267, 1438, 1094, 1257, 1259, 1259, 1257, 1095, 1037, 1278, 1201,
  1427, 1267, 1037, 1387, 1267, 1267, 1002, 1094, 1257, 1259, 1259, 1257, 1095, 1037, 1278, 1201, 1427, 1269, 1037,
  1387, 1267, 1267, 1002, 1094, 1257, 1259, 1259, 1257, 1259, 1037, 1164, 1201, 1425, 1267, 1037, 1387, 1267, 1267,
  1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1259,
  1259, 1259, 1259, 1261, 1267, 1259, 1259, 1259, 1259, 1260, 1267, 1258, 1259, 1259, 1259, 1259, 1260, 1298, 1392,
  1310, 1388, 1387, 1393, 1267, 1267, 1267, 1267, 1215, 1322, 1084, 1258, 1332, 1342, 1298, 1146, 1357, 1389, 1387,
  1393, 1267, 1267, 1267, 1267, 1269, 1019, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1264, 1267,
  1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1254, 1401, 1264, 1267, 1267,
  1267, 1267, 1410, 1266, 1410, 1188, 1081, 1334, 1187, 1214, 1267, 1267, 1267, 1267, 1269, 1267, 1324, 1268, 1288,
  1264, 1267, 1267, 1267, 1267, 1421, 1266, 1423, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259,
  1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1263, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259,
  1259, 1265, 1259, 1259, 1261, 1261, 1259, 1259, 1259, 1259, 1261, 1261, 1259, 1413, 1259, 1259, 1259, 1261, 1259,
  1259, 1259, 1259, 1259, 1259, 1094, 1128, 1226, 1262, 1117, 1263, 1259, 1262, 1226, 1262, 1075, 1267, 1267, 1267,
  1258, 1314, 1162, 1267, 1258, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1262, 999, 1258, 1259, 1259, 1259,
  1259, 1259, 1259, 1259, 1259, 1259, 1259, 1435, 1083, 1259, 1259, 1259, 1259, 1262, 1267, 1267, 1267, 1267, 1267,
  1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267,
  1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1387, 1390, 1370, 1267, 1267, 1267, 1259, 1259, 1259, 1259, 1259,
  1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1263, 1267, 1267, 1267,
  1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1393, 1387, 1393, 1380, 1362, 1259, 1258, 1259, 1259, 1259, 1265,
  1386, 1387, 1278, 1391, 1277, 1386, 1387, 1389, 1386, 1370, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1258,
  1259, 1259, 1259, 1260, 1423, 1258, 1259, 1259, 1259, 1260, 1267, 1386, 1387, 1160, 1387, 1387, 1142, 1367, 1267,
  1259, 1259, 1259, 1264, 1264, 1267, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
  11, 12, 13, 14, 15, 16, 17, 17, 17, 17, 17, 17, 17, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 26, 30, 6, 6,
  6, 6, 6, 63, 63, 6, 6, 63, 63, 6, 30, 30, 30, 30, 30, 30, 30, 31, 30, 30, 30, 6, 6, 6, 30, 30, 6, 6, 30, 6, 30, 30,
  30, 32, 6, 33, 34, 30, 6, 6, 30, 30, 6, 6, 6, 6, 63, 63, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 30, 45, 46, 47, 48,
  49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 30, 60, 61, 62, 6, 6, 6, 6, 6, 63, 6, 30, 6, 6, 6, 6, 6, 30, 30, 30, 30,
  30, 30, 30, 30, 30, 30, 30, 6, 30, 30, 30, 30, 30, 6, 63, 63, 63, 63, 6, 63, 63, 63, 6, 6, 30, 30, 30, 30, 30, 6, 6,
  30, 30, 63, 30, 30, 30, 30, 30, 30, 30, 6, 30, 6, 30, 30, 30, 30, 6, 30, 63, 63, 6, 63, 63, 63, 6, 63, 63, 30, 6, 6,
  30, 30, 6, 6, 63, 30, 63, 63, 6, 63, 63, 63, 63, 63, 6, 6, 63, 63, 30, 30, 63, 63, 6, 6, 63, 63, 63, 6, 6, 6, 6, 63,
  30, 6, 30, 6, 6, 6, 30, 30, 6, 6, 6, 30, 30, 6, 6, 63, 6, 63, 63, 63, 63, 6, 6, 6, 63, 63, 6, 6, 6, 6, 30, 30, 6, 30,
  6, 6, 30, 6, 6, 63, 6, 6, 30, 30, 30, 6, 30, 30, 6, 30, 30, 30, 30, 6, 30, 6, 30, 30, 63, 63, 30, 30, 30, 6, 6, 6, 6,
  30, 30, 6, 30, 30, 6, 30, 30, 30, 30, 30, 30, 30, 30, 6, 6, 6, 6, 6, 6, 6, 6, 30, 6, 63, 63, 63, 63, 63, 63, 6, 63,
  63, 6, 30, 30, 6, 30, 6, 30, 30, 30, 30, 6, 6, 30, 63, 30, 30, 63, 63, 63, 63, 63, 30, 30, 63, 30, 30, 30, 30, 30, 30,
  63, 63, 63, 63, 63, 63, 30, 6, 30, 6, 6, 30, 6, 6, 30, 30, 6, 30, 30, 30, 6, 30, 6, 30, 6, 30, 6, 6, 30, 30, 6, 30,
  30, 6, 6, 30, 30, 30, 30, 30, 6, 30, 30, 30, 30, 30, 6, 63, 6, 6, 6, 6, 63, 63, 6, 63, 6, 6, 6, 6, 6, 6, 30, 63, 6, 6,
  6, 6, 6, 63, 6, 63, 63, 63, 63, 63, 63, 63, 63, 6, 6, 6, 6, 6, 6, 6, 30, 6, 30, 30, 6, 30, 30, 6, 6, 6, 6, 6, 30, 6,
  30, 6, 30, 6, 30, 6, 6, 6, 30, 6, 6, 6, 6, 6, 6, 6, 63, 63, 6, 30, 30, 30, 6, 63, 63, 63, 6, 30, 30, 30
);

(:~
 : The codepoint to charclass mapping for codepoints above the surrogate block.
 :)
declare variable $p:MAP2 as xs:integer+ :=
(
  57344, 65536, 65533, 1114111, 6, 6
);

(:~
 : The token-set-id to DFA-initial-state mapping.
 :)
declare variable $p:INITIAL as xs:integer+ :=
(
  6145, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 2069, 4117, 22, 23, 24, 25, 26, 27, 28, 29,
  30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58,
  59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87,
  88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113,
  114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136,
  137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150
);

(:~
 : The DFA transition table.
 :)
declare variable $p:TRANSITION as xs:integer+ :=
(
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 8320, 8334, 8342, 8405, 8405,
  8358, 8404, 8428, 8421, 8372, 8444, 8465, 22788, 14523, 8805, 9979, 8857, 12648, 8857, 9023, 8493, 8509, 9582, 8532,
  8548, 20961, 8760, 8564, 12660, 8754, 8585, 8569, 8598, 15213, 13323, 8645, 8661, 8688, 8745, 8857, 13063, 8993, 8857,
  13078, 8776, 12715, 8798, 8821, 8849, 8874, 8903, 8890, 8983, 15162, 14065, 8929, 23151, 8972, 9009, 23159, 9050,
  9076, 9092, 9121, 8858, 9105, 9151, 12283, 8712, 8700, 12668, 9167, 9193, 9177, 9224, 9255, 9239, 9298, 9355, 8729,
  8857, 9313, 8833, 8724, 9403, 9419, 9434, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9452, 9435, 8388, 9435, 9435, 12984, 16397, 16411, 9435,
  9472, 9503, 8465, 22788, 9521, 8805, 9979, 8857, 12648, 8857, 13114, 8493, 8509, 9582, 8532, 8548, 20961, 8760, 8564,
  12660, 8754, 8585, 8569, 8598, 15213, 13323, 8645, 8661, 8688, 8745, 8857, 13063, 8993, 8857, 13078, 8776, 12715,
  8798, 8821, 8849, 8874, 8903, 8890, 8983, 15162, 14065, 8929, 23151, 8972, 9009, 23159, 9050, 9076, 9092, 9121, 8858,
  9105, 9151, 12283, 8712, 8700, 12668, 9167, 9193, 9177, 9224, 9255, 9239, 9298, 9355, 8729, 8857, 9313, 8833, 8724,
  9403, 9419, 9434, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9546, 9575, 18429, 9435, 9435, 9559, 8383, 9435, 9945, 9487, 9503, 8465, 11087,
  14523, 8805, 9979, 8857, 12648, 8857, 12297, 8493, 8509, 9582, 8532, 8548, 20961, 8760, 8564, 12660, 8754, 8585, 8569,
  8598, 15213, 13323, 8645, 8661, 8688, 8745, 8857, 13063, 8993, 8857, 13078, 8776, 12715, 8798, 8821, 8849, 8874, 8903,
  8890, 8983, 15162, 14065, 8929, 23151, 8972, 9009, 23159, 9050, 9076, 9092, 9121, 8858, 9105, 9151, 12283, 8712, 8700,
  12668, 9167, 9193, 9177, 9224, 9255, 9239, 9298, 9355, 8729, 8857, 9313, 8833, 8724, 9403, 9419, 9434, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9598, 9435, 8388, 9435, 9435, 12984, 9435, 9435, 9633, 12578, 9503, 9660, 10984, 14523, 8805, 9979, 8857, 12648,
  8857, 9135, 9688, 9704, 9582, 8532, 8548, 20961, 8760, 8564, 12660, 8754, 8585, 8569, 8598, 15213, 13323, 8645, 8661,
  8688, 8745, 8857, 13063, 8993, 8857, 13078, 8776, 12715, 8798, 8821, 8849, 8874, 8903, 8890, 8983, 15162, 14065, 8929,
  23151, 8972, 9009, 23159, 9050, 9076, 9092, 9121, 8858, 9105, 9151, 12283, 8712, 8700, 12668, 9167, 9193, 9177, 9224,
  9255, 9239, 9298, 9355, 8729, 8857, 9313, 8833, 8724, 9403, 9419, 9434, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9733, 11204, 8388, 9831,
  11206, 9756, 9435, 9740, 9818, 9851, 9503, 8465, 22788, 14523, 8805, 9979, 8857, 12648, 8857, 9023, 8493, 8509, 9582,
  8532, 8548, 20961, 8760, 8564, 12660, 8754, 8585, 8569, 8598, 15213, 13323, 8645, 8661, 8688, 8745, 8857, 13063, 8993,
  8857, 13078, 8776, 12715, 8798, 8821, 8849, 8874, 8903, 8890, 8983, 15162, 14065, 8929, 23151, 8972, 9009, 23159,
  9050, 9076, 9092, 9121, 8858, 9105, 9151, 12283, 8712, 8700, 12668, 9167, 9193, 9177, 9224, 9255, 9239, 9298, 9355,
  8729, 8857, 9313, 8833, 8724, 9403, 9419, 9434, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9452, 9435, 8388, 9435, 9435, 12984, 9435, 9435,
  9435, 12145, 9503, 8465, 22788, 14523, 8805, 9979, 8857, 12648, 8857, 9023, 8493, 8509, 9582, 8532, 8548, 20961, 8760,
  8564, 12660, 8754, 8585, 8569, 8598, 15213, 13323, 8645, 8661, 8688, 8745, 8857, 13063, 8993, 8857, 13078, 8776,
  12715, 8798, 8821, 8849, 8874, 8903, 8890, 8983, 15162, 14065, 8929, 23151, 8972, 9009, 23159, 9050, 9076, 9092, 9121,
  8858, 9105, 9151, 12283, 8712, 8700, 12668, 9167, 9193, 9177, 9224, 9255, 9239, 9298, 9355, 8729, 8857, 9313, 8833,
  8724, 9403, 9419, 9434, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9452, 9435, 8388, 9435, 9435, 8672, 9435, 9435, 9435, 12350, 9867, 8465,
  20836, 14523, 8805, 9979, 8857, 12648, 8857, 9023, 8493, 8509, 9582, 8532, 8548, 20961, 8760, 8564, 12660, 8754, 8585,
  8569, 8598, 15213, 13323, 8645, 8661, 8688, 8745, 8857, 13063, 8993, 8857, 13078, 8776, 12715, 8798, 8821, 8849, 8874,
  8903, 8890, 8983, 15162, 14065, 8929, 23151, 8972, 9009, 23159, 9050, 9076, 9092, 9121, 8858, 9105, 9151, 12283, 8712,
  8700, 12668, 9167, 9193, 9177, 9224, 9255, 9239, 9298, 9355, 8729, 8857, 9313, 8833, 8724, 9403, 9419, 9434, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9885, 9938, 13695, 9435, 9435, 8956, 18424, 9435, 10018, 9961, 9977, 8465, 9770, 14523, 8805, 9979, 8857,
  12648, 8857, 9023, 9995, 8509, 9582, 8532, 8548, 20961, 8760, 8564, 12660, 8754, 8585, 8569, 8598, 15213, 13323, 8645,
  8661, 8688, 8745, 8857, 13063, 8993, 8857, 13078, 8776, 12715, 8798, 8821, 8849, 8874, 8903, 8890, 8983, 15162, 14065,
  8929, 23151, 8972, 9009, 23159, 9050, 9076, 9092, 9121, 8858, 9105, 9151, 12283, 8712, 8700, 12668, 9167, 9193, 9177,
  9224, 9255, 9239, 9298, 9355, 8729, 8857, 9313, 8833, 8724, 9403, 9419, 9434, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 10011, 9783, 9802,
  9795, 10078, 10034, 10077, 10048, 10094, 10108, 9503, 10124, 22788, 14523, 8805, 9979, 8857, 12648, 8857, 9023, 10158,
  8509, 9582, 8532, 8548, 20961, 8760, 8564, 12660, 8754, 8585, 8569, 8598, 15213, 13323, 8645, 8661, 8688, 8745, 8857,
  13063, 8993, 8857, 13078, 8776, 12715, 8798, 8821, 8849, 8874, 8903, 8890, 8983, 15162, 14065, 8929, 23151, 8972,
  9009, 23159, 9050, 9076, 9092, 9121, 8858, 9105, 9151, 12283, 8712, 8700, 12668, 9167, 9193, 9177, 9224, 9255, 9239,
  9298, 9355, 8729, 8857, 9313, 8833, 8724, 9403, 9419, 9434, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9452, 16889, 8388, 10198, 19876, 10174,
  10224, 10188, 19141, 10240, 9503, 10256, 22788, 14523, 8805, 9979, 8857, 12648, 8857, 9023, 10290, 8509, 9582, 8532,
  8548, 20961, 8760, 8564, 12660, 8754, 8585, 8569, 8598, 15213, 13323, 8645, 8661, 8688, 8745, 8857, 13063, 8993, 8857,
  13078, 8776, 12715, 8798, 8821, 8849, 8874, 8903, 8890, 8983, 15162, 14065, 8929, 23151, 8972, 9009, 23159, 9050,
  9076, 9092, 9121, 8858, 9105, 9151, 12283, 8712, 8700, 12668, 9167, 9193, 9177, 9224, 9255, 9239, 9298, 9355, 8729,
  8857, 9313, 8833, 8724, 9403, 9419, 9434, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9452, 9435, 8388, 9435, 9435, 12984, 22992, 10306, 9339,
  10321, 9503, 8465, 22788, 14523, 8805, 9979, 8857, 12648, 8857, 9023, 8493, 8509, 9582, 8532, 8548, 20961, 8760, 8564,
  9208, 8754, 8585, 8569, 8598, 15213, 13323, 8645, 8661, 8688, 8745, 8857, 13063, 8993, 8857, 13078, 8776, 12715, 8798,
  8821, 8849, 8874, 8903, 8890, 8983, 15162, 14065, 8929, 23151, 8972, 9009, 23159, 9050, 9076, 9092, 9121, 8858, 9105,
  9151, 12283, 8712, 8700, 12668, 9167, 9193, 9177, 9224, 9255, 9239, 9298, 9355, 8729, 8857, 9313, 8833, 8724, 9403,
  9419, 9434, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9452, 9435, 8388, 9435, 9435, 12984, 17130, 10337, 22121, 17140, 9503, 8465, 22788,
  14523, 8805, 9979, 8857, 12648, 8857, 9023, 8493, 10364, 9582, 8532, 8548, 20961, 8760, 8564, 12660, 8754, 8585, 8569,
  8598, 15213, 13323, 8645, 8661, 8688, 8745, 8857, 13063, 8993, 8857, 13078, 8776, 12715, 8798, 8821, 8849, 8874, 8903,
  8890, 8983, 15162, 14065, 8929, 23151, 8972, 9009, 23159, 9050, 9076, 9092, 9121, 8858, 9105, 9151, 12283, 8712, 8700,
  12668, 9167, 9193, 9177, 9224, 9255, 9239, 9298, 9355, 8729, 8857, 9313, 8833, 8724, 9403, 9419, 9434, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9452, 22794, 8388, 19902, 20242, 10410, 10451, 10424, 9435, 10467, 9503, 8465, 22788, 14523, 8805, 9979, 8857,
  12648, 8857, 9023, 8493, 8509, 9582, 8532, 8548, 20961, 8760, 8564, 12660, 8754, 8585, 8569, 8598, 15213, 13323, 8645,
  8661, 8688, 8745, 8857, 13063, 8993, 8857, 13078, 8776, 12715, 8798, 8821, 8849, 8874, 8903, 8890, 8983, 15162, 14065,
  8929, 23151, 8972, 9009, 23159, 9050, 9076, 9092, 9121, 8858, 9105, 9151, 12283, 8712, 8700, 12668, 9167, 9193, 9177,
  9224, 9255, 9239, 9298, 9355, 8729, 8857, 9313, 8833, 8724, 9403, 9419, 9434, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 10483, 9435, 8388,
  9435, 9435, 12984, 17310, 10507, 9034, 17320, 10534, 10552, 17375, 20039, 21164, 9436, 13823, 11260, 10611, 14769,
  13084, 17381, 22145, 11166, 14472, 15041, 13823, 13823, 11248, 10611, 10611, 10631, 21713, 9435, 10555, 11165, 14472,
  19581, 13823, 13823, 10571, 10611, 10611, 16193, 9435, 21259, 11166, 15044, 13823, 13823, 18815, 10611, 10611, 9435,
  20039, 21165, 13823, 13823, 10590, 10610, 16956, 11161, 19579, 13823, 10628, 18252, 20036, 14616, 13824, 10611, 19639,
  13852, 15806, 18206, 17758, 10647, 15985, 10679, 10707, 21441, 17481, 10736, 21451, 16222, 16226, 21847, 16197, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9452, 9435, 8388, 9435, 19730, 10777, 9435, 9435, 12478, 10836, 10534, 10852, 11622, 20039, 21164, 9436,
  13823, 11260, 10611, 19121, 13084, 9435, 21260, 11166, 14472, 15041, 13823, 13823, 11248, 10611, 10611, 10574, 21713,
  9435, 9435, 11165, 14472, 19581, 13823, 13823, 10571, 10611, 10611, 16193, 9435, 21259, 11166, 15044, 13823, 13823,
  18815, 10611, 10611, 9435, 20039, 21165, 13823, 13823, 18816, 10611, 19638, 11161, 19579, 13823, 18817, 10611, 20036,
  14616, 13824, 10611, 19639, 14614, 13825, 10611, 17758, 13824, 10611, 10876, 18212, 17484, 17481, 17478, 21451, 16222,
  16226, 21847, 16197, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9452, 15279, 8388, 9435, 9435, 18336, 9505, 10902, 15284, 10929, 9503, 8465,
  11196, 10945, 8805, 9979, 8857, 12648, 8857, 9023, 8493, 8509, 9582, 8532, 8548, 20961, 8760, 8564, 12660, 8754, 8585,
  8569, 8598, 15213, 13323, 8645, 8661, 8688, 8745, 8857, 13063, 8993, 8857, 13078, 8776, 12715, 8798, 8821, 8849, 8874,
  8903, 8890, 8983, 15162, 14065, 8929, 23151, 8972, 9009, 23159, 9050, 9076, 9092, 9121, 8858, 9105, 9151, 12283, 8712,
  8700, 12668, 9167, 9193, 9177, 9224, 9255, 9239, 9298, 9355, 8729, 8857, 9313, 8833, 8724, 9403, 9419, 9434, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9452, 9435, 8388, 9435, 16883, 10970, 9435, 9435, 13782, 11010, 10534, 11026, 19842, 20039, 21164, 9436,
  13823, 11260, 10611, 14176, 13084, 10860, 21260, 11166, 14472, 15041, 13823, 13823, 11248, 10611, 10611, 10574, 21753,
  15249, 13690, 11165, 14472, 19581, 13823, 13823, 10571, 10611, 10611, 11073, 9435, 11112, 11166, 15044, 13823, 13823,
  18815, 10611, 10611, 11136, 11157, 21165, 13823, 13823, 18816, 10611, 19638, 11161, 19579, 13823, 18817, 10611, 20036,
  14616, 13824, 10611, 19639, 14614, 13825, 10611, 17758, 13824, 10611, 10876, 18212, 17484, 17481, 17478, 21451, 16222,
  16226, 21847, 16197, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9452, 12537, 12871, 22041, 21925, 11182, 9435, 11222, 9435, 10061, 11276, 11299,
  22788, 14523, 8805, 10536, 11444, 11565, 11697, 12044, 11333, 8509, 9582, 8532, 8548, 15665, 11496, 11349, 11553,
  11702, 11379, 11654, 11609, 15213, 13323, 8645, 8661, 11408, 11485, 11444, 11363, 11522, 11697, 11774, 8776, 12715,
  8798, 11471, 11436, 11879, 11512, 12030, 11688, 15162, 14065, 11538, 11422, 11581, 11644, 11677, 11718, 9076, 11744,
  11864, 11817, 11796, 11833, 11849, 11595, 11923, 11661, 11895, 11759, 11911, 11939, 11955, 11985, 12001, 12071, 11455,
  11452, 12016, 11392, 11809, 12087, 11969, 12103, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9452, 9869, 8388, 19851, 19850, 12120, 12161, 12134,
  19848, 12177, 9503, 8465, 22788, 14523, 8805, 9979, 8857, 12648, 8857, 9023, 8493, 8509, 9582, 8532, 8548, 20961,
  8760, 8564, 12660, 8754, 8585, 8569, 8598, 15213, 12193, 8645, 8661, 8688, 8745, 8857, 13063, 8993, 8857, 8944, 12228,
  12252, 8798, 8821, 8849, 8874, 8903, 8890, 8983, 12309, 12268, 8929, 23151, 8972, 9009, 23159, 9050, 9076, 9092, 9121,
  8858, 9105, 9151, 12283, 8712, 8700, 12668, 9167, 9193, 9177, 9224, 9255, 9239, 9298, 9355, 8729, 8857, 9313, 8833,
  8724, 9403, 9419, 9434, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9452, 9435, 8388, 9435, 9435, 9835, 12325, 12339, 13522, 12366, 9503, 8465,
  22788, 14523, 10954, 9979, 8857, 12648, 8857, 9369, 8493, 8509, 9582, 8532, 8548, 20961, 8760, 8564, 12660, 8754,
  8585, 8569, 8598, 15213, 13323, 8645, 8661, 8688, 8745, 8857, 13063, 8993, 8857, 13078, 8776, 12715, 8798, 8821, 8849,
  8874, 8903, 8890, 8983, 15162, 14065, 8929, 23151, 8972, 9009, 23159, 9050, 9076, 9092, 9121, 8858, 9105, 9151, 12283,
  8712, 8700, 12668, 9167, 9193, 9177, 9224, 9255, 9239, 9298, 9355, 8729, 8857, 9313, 8833, 8724, 9403, 9419, 9434,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 12382, 9435, 12397, 9435, 12391, 12984, 12413, 12427, 9435, 12454, 12470, 8465, 22788, 14523, 12740,
  9979, 8857, 12648, 8857, 9327, 8493, 8509, 9582, 8532, 8548, 20961, 8760, 8564, 12660, 8754, 8585, 8569, 8598, 15213,
  13323, 8645, 8661, 8688, 8745, 8857, 13063, 8993, 8857, 13078, 8776, 12715, 8798, 8821, 8849, 8874, 8903, 8890, 8983,
  15162, 14065, 8929, 23151, 8972, 9009, 23159, 9050, 9076, 9092, 9121, 8858, 9105, 9151, 12283, 8712, 8700, 12668,
  9167, 9193, 9177, 9224, 9255, 9239, 9298, 9355, 8729, 8857, 9313, 8833, 8724, 9403, 9419, 9434, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  12494, 12529, 8388, 9435, 9435, 12984, 12553, 12567, 12534, 12594, 12610, 8465, 22788, 14523, 9530, 9979, 8857, 12648,
  8857, 9269, 8493, 8509, 9582, 8532, 8548, 20961, 8760, 8564, 12660, 8754, 8585, 8569, 8598, 15213, 13323, 8645, 8661,
  8688, 8745, 8857, 13063, 8993, 8857, 13078, 8776, 12715, 8798, 8821, 8849, 8874, 8903, 8890, 8983, 15162, 14065, 8929,
  23151, 8972, 9009, 23159, 9050, 9076, 9092, 9121, 8858, 9105, 9151, 12283, 8712, 8700, 12668, 9167, 9193, 9177, 9224,
  9255, 9239, 9298, 12634, 8729, 8857, 9313, 8833, 8724, 9403, 9419, 9434, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 12684, 12693, 8388, 12618,
  9435, 12984, 12614, 12711, 9435, 12438, 9503, 8465, 22788, 12731, 8805, 9979, 8857, 12648, 8857, 23189, 8493, 8509,
  9582, 8532, 8548, 20961, 8760, 8564, 12660, 8754, 8585, 8569, 8598, 15213, 13323, 8645, 8661, 8688, 8745, 8857, 13063,
  8993, 8857, 13078, 8776, 12715, 8798, 8821, 8849, 8874, 8903, 8890, 8983, 15162, 14065, 8929, 23151, 8972, 9009,
  23159, 9050, 9076, 9092, 9121, 8858, 9105, 9151, 12283, 8712, 8700, 12668, 9167, 9193, 9177, 9224, 9255, 9239, 9298,
  9355, 8729, 8857, 9313, 8833, 8724, 9403, 9419, 9434, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9452, 9435, 8388, 9435, 9435, 12984, 9435,
  9435, 23201, 12756, 9503, 8465, 22788, 14523, 8805, 9979, 8857, 12648, 8857, 9023, 8493, 8509, 9582, 8532, 8548,
  20961, 8760, 8564, 12660, 8754, 8585, 8569, 8598, 15213, 13323, 8645, 8661, 8688, 8745, 8857, 13063, 8993, 8857,
  13078, 8776, 12715, 8798, 8821, 8849, 8874, 8903, 8890, 8983, 15162, 14065, 8929, 23151, 8972, 9009, 23159, 9050,
  9076, 9092, 9121, 8858, 9105, 9151, 12283, 8712, 8700, 12668, 9167, 9193, 9177, 9224, 9255, 9239, 9298, 9355, 8729,
  8857, 9313, 8833, 8724, 9403, 9419, 9434, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 12772, 9435, 11141, 9435, 12778, 12984, 12866, 18559,
  10657, 19316, 10534, 10552, 17375, 20039, 21164, 9436, 13823, 11260, 10611, 14769, 21723, 9435, 21260, 11166, 14472,
  15041, 13823, 13823, 13223, 10611, 10611, 10574, 21713, 9435, 13925, 11165, 14472, 19581, 13823, 13823, 10571, 10611,
  10611, 20822, 9435, 12794, 11166, 15044, 13823, 13823, 18815, 10611, 10611, 11136, 12828, 21165, 13823, 13823, 18816,
  10611, 19638, 11161, 19579, 13823, 18817, 10611, 13737, 14616, 13824, 10611, 19639, 14614, 13825, 10611, 17758, 13824,
  10611, 10876, 18212, 17484, 17481, 17478, 21451, 16222, 16226, 21847, 16197, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 12772, 9435, 11141, 9435,
  12778, 12984, 12866, 18559, 10657, 19316, 10534, 10552, 17375, 20039, 21164, 9436, 13823, 11260, 10611, 14769, 21723,
  9435, 21260, 11166, 14472, 15041, 13823, 13823, 13223, 10611, 10611, 10574, 21713, 9435, 13925, 11165, 14472, 19581,
  13823, 13823, 10571, 10611, 10611, 20822, 9435, 12794, 11166, 15044, 13823, 13823, 18815, 10611, 10611, 11136, 11157,
  21165, 13823, 13823, 18816, 10611, 19638, 11161, 19579, 13823, 18817, 10611, 20036, 14616, 13824, 10611, 19639, 14614,
  13825, 10611, 17758, 13824, 10611, 10876, 18212, 17484, 17481, 17478, 21451, 16222, 16226, 21847, 16197, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 12772, 9435, 11141, 9435, 12778, 12984, 12866, 18559, 10657, 19316, 10534, 10552, 17375, 20039, 21164, 9436,
  13823, 11260, 10611, 14769, 21723, 9435, 21260, 11166, 14472, 15041, 13823, 13823, 13223, 10611, 10611, 10574, 21713,
  9435, 16315, 11165, 14472, 19581, 13823, 13823, 10571, 10611, 10611, 20822, 9435, 12794, 11166, 15044, 13823, 13823,
  18815, 10611, 10611, 11136, 11157, 21165, 13823, 13823, 18816, 10611, 19638, 11161, 19579, 13823, 18817, 10611, 20036,
  14616, 13824, 10611, 19639, 14614, 13825, 10611, 17758, 13824, 10611, 10876, 18212, 17484, 17481, 17478, 21451, 16222,
  16226, 21847, 16197, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 12772, 9435, 11141, 9435, 12778, 12984, 12866, 18559, 10657, 19316, 10534, 10552,
  17375, 20039, 21164, 9436, 13823, 11260, 10611, 14769, 21723, 9435, 21260, 11166, 14472, 15041, 13823, 13823, 13223,
  10611, 10611, 10574, 21713, 9435, 13925, 11165, 14472, 19581, 13823, 13823, 10571, 10611, 10611, 20822, 9435, 12853,
  11166, 15044, 13823, 13823, 18815, 10611, 10611, 11136, 11157, 21165, 13823, 13823, 18816, 10611, 19638, 11161, 19579,
  13823, 18817, 10611, 20036, 14616, 13824, 10611, 19639, 14614, 13825, 10611, 17758, 13824, 10611, 10876, 18212, 17484,
  17481, 17478, 21451, 16222, 16226, 21847, 16197, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 12772, 9435, 11141, 9435, 12778, 12984, 12866,
  18559, 10657, 19316, 10534, 10552, 12206, 20039, 21164, 9436, 13823, 11260, 10611, 14769, 21723, 10142, 21260, 11166,
  14472, 15041, 13823, 13823, 13223, 10611, 10611, 10574, 21713, 9435, 13925, 11165, 14472, 19581, 13823, 13823, 10571,
  10611, 10611, 20822, 9435, 12794, 11166, 15044, 13823, 13823, 18815, 10611, 10611, 11136, 11157, 21165, 13823, 13823,
  18816, 10611, 19638, 11161, 19579, 13823, 18817, 10611, 20036, 14616, 13824, 10611, 19639, 14614, 13825, 10611, 17758,
  13824, 10611, 10876, 18212, 17484, 17481, 17478, 21451, 16222, 16226, 21847, 16197, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 12772, 9435,
  11141, 9435, 12778, 12984, 12866, 18559, 10657, 19316, 10534, 10552, 17375, 20039, 21164, 9436, 13823, 11260, 10611,
  14769, 21723, 9435, 21260, 11166, 14472, 15041, 13823, 13823, 13223, 10611, 10611, 10574, 21713, 9435, 9435, 11165,
  14472, 19581, 13823, 13823, 10571, 10611, 10611, 16193, 9435, 21259, 11166, 15044, 13823, 13823, 18815, 10611, 10611,
  9435, 20039, 21165, 13823, 13823, 18816, 10611, 19638, 11161, 19579, 13823, 18817, 10611, 20036, 14616, 13824, 10611,
  19639, 14614, 13825, 10611, 17758, 13824, 10611, 10876, 18212, 17484, 17481, 17478, 21451, 16222, 16226, 21847, 16197,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 12772, 9435, 11141, 9435, 12778, 12984, 12866, 18559, 10657, 19316, 10534, 10552, 17375, 20039,
  21164, 9436, 13823, 11260, 10611, 14769, 21723, 9435, 21260, 11166, 14472, 15041, 13823, 13823, 13223, 10611, 10611,
  10574, 21713, 9435, 9435, 11165, 14472, 19581, 13823, 13823, 10571, 10611, 10611, 16193, 9435, 21259, 11166, 15044,
  13823, 13823, 18815, 10611, 10611, 9435, 20039, 21165, 13823, 13823, 18816, 10611, 19638, 20330, 19579, 13823, 18817,
  10611, 20036, 14616, 13824, 10611, 19639, 14614, 13825, 10611, 17758, 13824, 10611, 10876, 18212, 17484, 17481, 17478,
  21451, 16222, 16226, 21847, 16197, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9452, 9435, 8388, 9435, 9435, 14092, 9435, 12887, 9435, 12914, 9503,
  8465, 22788, 14523, 8805, 9979, 8857, 12648, 8857, 9023, 8493, 8509, 11096, 8532, 8548, 20961, 8760, 8564, 12660,
  8754, 8585, 8569, 8598, 15213, 13323, 8645, 8661, 8688, 8745, 8857, 13063, 8993, 8857, 13078, 8776, 12715, 8798, 8821,
  8849, 8874, 8903, 8890, 8983, 15162, 14065, 8929, 23151, 8972, 9009, 23159, 9050, 9076, 9092, 9121, 8858, 9105, 9151,
  12283, 8712, 8700, 8913, 9167, 9193, 9177, 9224, 9255, 9239, 9298, 9355, 8729, 8857, 9313, 8833, 8724, 9403, 9419,
  9434, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9452, 9435, 12930, 9435, 9435, 12959, 13000, 12973, 9435, 13016, 9503, 8465, 22788, 14523,
  8805, 9979, 8857, 12648, 8857, 9023, 8493, 8509, 9582, 8532, 8548, 20961, 8760, 8564, 12660, 8754, 8585, 8569, 8598,
  15213, 13323, 8645, 8661, 8688, 8745, 8857, 13063, 8993, 8857, 13078, 8776, 12715, 8798, 8821, 8849, 8874, 8903, 8890,
  8983, 15162, 14065, 8929, 23151, 8972, 9009, 23159, 9050, 9076, 9092, 9121, 8858, 9105, 9151, 12283, 8712, 8700,
  12668, 9167, 9193, 9177, 13032, 9255, 9239, 13048, 13100, 8729, 8857, 9313, 8833, 8724, 9403, 9419, 9434, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9452, 9435, 8388, 9435, 9435, 12984, 9435, 11780, 13806, 13142, 9503, 8465, 22788, 14523, 8805, 9979, 8857,
  12648, 8857, 9023, 8493, 8509, 9582, 8532, 8548, 20961, 8760, 8564, 12660, 8754, 8585, 8569, 8598, 15213, 13323, 8645,
  8661, 8688, 8745, 8857, 13063, 8993, 8857, 13078, 8776, 12715, 8798, 8821, 8849, 8874, 8903, 8890, 8983, 15162, 14065,
  8929, 23151, 8972, 9009, 23159, 9050, 9076, 9092, 9121, 8858, 9105, 9151, 12283, 8712, 8700, 12668, 9167, 9193, 9177,
  9224, 9255, 9239, 9298, 9355, 8729, 8857, 9313, 8833, 8724, 9403, 9419, 9434, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9452, 9435, 8388,
  9435, 9435, 13158, 9435, 9435, 14394, 13194, 9503, 8465, 13172, 14523, 8805, 9979, 8857, 12648, 8857, 9023, 8493,
  8516, 9582, 8532, 8548, 20961, 8760, 8564, 12660, 8754, 8585, 8569, 8598, 15213, 13323, 8645, 8661, 8688, 8745, 8857,
  13063, 8993, 8857, 13078, 8776, 12715, 8798, 8821, 8849, 8874, 8903, 8890, 8983, 15162, 14065, 8929, 23151, 8972,
  9009, 23159, 9050, 9076, 9092, 9121, 8858, 9105, 9151, 12283, 8712, 8700, 12668, 9167, 9193, 9177, 9224, 9255, 9239,
  9298, 9355, 8729, 8857, 9313, 8833, 8724, 9403, 9419, 9434, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 12772, 9435, 13210, 8449, 16482, 13239,
  13255, 13271, 13287, 13301, 10534, 13317, 13339, 16582, 21005, 20842, 13374, 13390, 13420, 19063, 13436, 13465, 21260,
  11166, 13514, 15041, 13823, 16104, 13538, 10611, 10611, 19632, 21713, 15244, 13925, 21158, 13554, 20659, 13823, 13570,
  13588, 10611, 17837, 20822, 9456, 13635, 13651, 19703, 22087, 13823, 22315, 18293, 10611, 13675, 11157, 21165, 13823,
  20758, 13711, 17054, 13731, 11161, 19579, 13823, 18817, 10611, 20036, 15631, 19602, 22247, 13753, 14614, 13825, 10611,
  17758, 13824, 10611, 10876, 18212, 17484, 17481, 17478, 21451, 16222, 16226, 21847, 16197, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 12772,
  9435, 15342, 9435, 13775, 12984, 12866, 18559, 10657, 19316, 10534, 10552, 17375, 20039, 21164, 9436, 13823, 11260,
  10611, 14769, 21723, 9435, 21260, 11166, 14472, 15041, 13823, 13823, 13223, 10611, 10611, 10574, 21713, 19736, 13925,
  11165, 13798, 19581, 13823, 13822, 10571, 10611, 15395, 20822, 9435, 12794, 11166, 15044, 13823, 13823, 18815, 10611,
  10611, 11136, 13841, 10394, 13878, 17857, 16062, 10611, 19638, 11161, 19579, 13823, 18817, 10611, 20036, 14616, 13824,
  10611, 19639, 14614, 13825, 10611, 17758, 13824, 10611, 10876, 18212, 17484, 13896, 17478, 21451, 16222, 16226, 21847,
  16197, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 13912, 9435, 11141, 9435, 13946, 13974, 14005, 13989, 14021, 14035, 10534, 14051, 17375,
  20039, 21164, 9436, 13823, 14727, 13715, 14081, 21723, 9435, 14921, 17216, 14472, 13478, 14108, 13823, 18762, 14132,
  10611, 10574, 21713, 9435, 16683, 10387, 14472, 9387, 17185, 13572, 14162, 10611, 14203, 20822, 19199, 12794, 11166,
  15044, 13823, 13823, 18815, 10611, 10611, 11136, 11157, 21165, 13823, 13823, 18816, 10611, 19638, 19416, 14222, 13823,
  18817, 14238, 20036, 14257, 14278, 22704, 19639, 14614, 20470, 16035, 17758, 13824, 10611, 10876, 18212, 17484, 14311,
  17478, 21451, 16222, 16226, 14345, 16197, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 12772, 9435, 11141, 9435, 14387, 16934, 14410, 14424,
  14440, 14454, 10534, 10552, 17375, 20039, 14470, 12943, 16098, 19107, 20522, 14488, 19517, 9435, 11317, 16350, 14515,
  14539, 13823, 14567, 16135, 14587, 16757, 10574, 21713, 9435, 13925, 11165, 14472, 19581, 13823, 13823, 10571, 10611,
  10611, 20822, 9435, 12794, 11166, 10820, 13823, 11049, 21459, 10611, 19491, 11136, 14604, 21165, 14632, 14649, 19266,
  20791, 19638, 14668, 9911, 14694, 16738, 17831, 20036, 14616, 13824, 10611, 19639, 14614, 21098, 10611, 14713, 13824,
  10611, 10876, 18212, 14795, 17481, 17478, 21451, 16222, 16226, 21847, 16197, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 12772, 9435, 11235, 9435,
  12513, 14830, 14846, 14860, 14876, 14890, 14906, 14958, 9282, 14984, 15000, 15037, 15060, 15096, 15137, 21305, 17784,
  15178, 17693, 11166, 15205, 16457, 18523, 10720, 18696, 21511, 21375, 21573, 15229, 10812, 17683, 21659, 15265, 15300,
  15371, 9922, 15387, 15411, 15427, 15464, 10913, 15494, 15523, 15044, 15539, 21961, 15570, 15586, 15604, 15647, 15681,
  15701, 21684, 15733, 14814, 15448, 15764, 15685, 15788, 15822, 20713, 15839, 15859, 15897, 15933, 15963, 16001, 14614,
  15907, 16034, 19093, 21478, 10594, 16051, 16086, 16120, 16151, 16178, 21451, 18178, 16214, 21847, 16197, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 12772, 9435, 11141, 9435, 12778, 21316, 16242, 16256, 16272, 16286, 16302, 10552, 17375, 20039, 21164, 9436,
  13823, 17350, 20785, 15110, 21723, 16331, 23056, 16348, 14472, 15041, 16366, 13823, 13223, 21342, 10611, 10574, 21713,
  9435, 13925, 11165, 14472, 19581, 19583, 13823, 10571, 10611, 21504, 16383, 9435, 12794, 11166, 15044, 13823, 13823,
  18815, 10611, 10611, 16447, 11157, 16473, 13823, 16498, 18816, 22400, 19638, 11161, 19579, 13823, 18817, 10611, 20036,
  14616, 13824, 10611, 19639, 14614, 13825, 10611, 17758, 13824, 10611, 10876, 18212, 17484, 17481, 17478, 21451, 10749,
  17504, 16519, 16197, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 12772, 9435, 11141, 9435, 16568, 12984, 16610, 16624, 16640, 16654, 10534, 10552,
  10802, 20039, 21164, 9436, 13823, 11260, 10611, 14146, 16670, 20636, 21260, 11166, 14472, 15041, 13823, 13823, 13223,
  10611, 10611, 10574, 21713, 9435, 9435, 11165, 14472, 19581, 13823, 13823, 10571, 10611, 10611, 16193, 9435, 21259,
  11166, 15044, 13823, 13823, 18815, 10611, 10611, 9435, 20039, 21165, 13823, 13823, 18816, 10611, 19638, 11161, 19579,
  13823, 18817, 10611, 20036, 14616, 13824, 10611, 20723, 14678, 16710, 22291, 14741, 16726, 16773, 10876, 18212, 17484,
  17481, 17478, 21451, 16222, 14359, 21847, 16197, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 12772, 9435, 11141, 9435, 12778, 12984, 12866,
  18559, 10657, 19316, 16800, 10552, 17375, 16816, 14942, 9436, 16840, 16858, 16905, 16923, 21723, 10136, 21260, 11166,
  14472, 15041, 13823, 13823, 15554, 10611, 10611, 16950, 21713, 9435, 9435, 11165, 14472, 19581, 13823, 13823, 10571,
  10611, 10611, 16193, 9435, 21259, 11166, 15044, 13823, 13823, 18815, 10611, 10611, 9435, 20039, 21165, 13823, 13823,
  18816, 10611, 19638, 11161, 19579, 13823, 18817, 10611, 20036, 14616, 13824, 10611, 19639, 14614, 13825, 10611, 17758,
  17036, 14206, 10876, 18212, 17484, 17481, 17478, 21451, 16222, 16226, 21847, 16197, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 12772, 9435,
  15717, 20861, 15710, 12984, 16972, 16988, 17004, 17018, 10534, 10552, 17375, 19537, 21164, 9613, 17034, 21291, 17052,
  14769, 21723, 9435, 21260, 16431, 15873, 17070, 16503, 14697, 13223, 13614, 17101, 17903, 21713, 17119, 9435, 11165,
  17156, 19581, 17803, 17180, 10571, 10611, 21603, 16193, 9435, 21259, 11166, 15044, 13823, 19471, 21107, 10611, 10611,
  9435, 20039, 21165, 13823, 13823, 18816, 10611, 14329, 17201, 9717, 17238, 17261, 17285, 22616, 17336, 22381, 19988,
  17397, 14614, 13825, 10611, 17758, 13824, 10611, 10876, 20528, 17465, 17481, 17478, 14805, 17500, 16226, 17520, 16197,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 12772, 9435, 11141, 9435, 12778, 12984, 12866, 18559, 10886, 19316, 10534, 10552, 17375, 20039,
  21164, 9436, 13823, 11260, 10611, 14769, 21723, 9435, 21260, 11166, 14472, 15041, 13823, 13823, 13223, 10611, 10611,
  10574, 21713, 9435, 9435, 11165, 14472, 19581, 13823, 13823, 10571, 10611, 10611, 16193, 9435, 21259, 11166, 15044,
  13823, 13823, 18815, 10611, 10611, 9435, 20039, 21165, 13823, 13823, 18816, 10611, 19638, 11161, 19579, 13823, 18817,
  10611, 20036, 14616, 13824, 10611, 19639, 14614, 13825, 10611, 17758, 13824, 10611, 10876, 18212, 17484, 17481, 17478,
  21451, 16222, 16226, 21847, 16197, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 12772, 9435, 11141, 9435, 17551, 15189, 17591, 17605, 17621, 17635,
  17651, 17670, 10802, 13126, 17222, 17654, 17709, 20400, 17728, 21069, 16670, 10348, 13930, 11166, 14472, 9617, 14116,
  19963, 18848, 22594, 10611, 17747, 17774, 21934, 9435, 12806, 14472, 18990, 17800, 13823, 17819, 16750, 10611, 16193,
  12104, 21259, 19436, 15044, 21199, 17853, 18815, 19239, 21555, 9060, 13759, 21165, 19465, 13823, 15917, 10611, 19638,
  16011, 17873, 13823, 17896, 10611, 17919, 14616, 13824, 10611, 20451, 14614, 22458, 18270, 17758, 13824, 10611, 10876,
  18212, 17484, 17481, 17938, 17954, 16222, 16533, 21847, 16197, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 12772, 9435, 11141, 9435, 12778, 12984,
  17995, 18009, 18025, 18039, 10534, 10552, 23049, 9672, 12812, 12504, 18055, 21055, 18077, 17299, 21723, 9435, 18100,
  11166, 14472, 15041, 13823, 17245, 19347, 22888, 10611, 18119, 18141, 10518, 9435, 11165, 14472, 19581, 13823, 8629,
  18167, 18194, 10611, 16193, 8477, 21259, 11166, 15044, 18228, 14571, 18247, 18268, 18286, 9435, 20039, 21165, 13823,
  13823, 18816, 10611, 19638, 11161, 19579, 13823, 18817, 10611, 20036, 14616, 13824, 10611, 19639, 14614, 13825, 10611,
  17758, 13824, 10611, 18309, 19996, 17484, 17481, 17478, 21451, 16222, 16226, 21847, 16197, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 12772,
  9435, 11141, 9435, 12778, 12984, 18352, 18366, 18382, 18396, 18412, 10552, 17375, 17164, 18445, 9644, 17449, 18479,
  21819, 15151, 21763, 9435, 21260, 11166, 14472, 15041, 13823, 13823, 13223, 10611, 10611, 10574, 21713, 18495, 9435,
  11165, 14472, 19581, 13823, 13823, 10571, 10611, 10611, 16193, 9435, 10491, 22212, 18513, 18231, 16546, 14288, 10612,
  13619, 18961, 12055, 18546, 14551, 18586, 18570, 10761, 19638, 11161, 17437, 19181, 10691, 10611, 18602, 15507, 18639,
  18665, 20157, 18681, 18061, 18712, 17758, 22685, 18724, 10876, 18212, 18747, 18778, 18809, 21451, 16784, 16226, 18833,
  16197, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 12772, 9435, 22759, 9435, 15478, 16694, 18864, 18878, 18894, 18908, 10534, 18924, 20425,
  18935, 18951, 18977, 19035, 21900, 19079, 21914, 21723, 9435, 21260, 11166, 14472, 15041, 13823, 17712, 15748, 10611,
  16907, 18084, 21713, 9435, 19132, 11165, 17425, 19581, 19157, 19178, 10571, 16070, 19219, 18793, 19197, 20992, 11166,
  15044, 22080, 13823, 18815, 21537, 10611, 9435, 20039, 21165, 13823, 13823, 18816, 10611, 19638, 11161, 21194, 13823,
  19215, 10611, 14779, 22069, 13824, 19235, 19639, 14614, 13825, 10611, 13404, 16367, 10611, 19255, 19288, 18649, 17481,
  17478, 21451, 16222, 16226, 19332, 16197, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 12772, 9435, 11141, 9435, 12778, 12984, 12866, 19363,
  19379, 19393, 10534, 10552, 17375, 20039, 21164, 9436, 13823, 11260, 10611, 14769, 21723, 12695, 19409, 19432, 14472,
  15041, 19452, 13823, 17085, 19272, 19487, 22255, 19507, 16198, 10268, 11165, 14472, 19581, 13823, 13823, 10571, 10611,
  10611, 20616, 9435, 19533, 19553, 19575, 15073, 13823, 18815, 15439, 10611, 9435, 20039, 21165, 13823, 13823, 18816,
  10611, 19638, 11161, 19579, 13823, 18817, 10611, 20036, 14616, 13824, 10611, 19639, 14614, 13825, 10611, 17758, 13824,
  10611, 10876, 18212, 17484, 17481, 17478, 21451, 16222, 16226, 21847, 16197, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 12772, 9435, 11141, 9435,
  12778, 12984, 12866, 18559, 10657, 19316, 10534, 10552, 22982, 17922, 19559, 13349, 19599, 19618, 19655, 19674, 19690,
  22815, 21260, 11166, 14472, 15041, 13823, 13823, 13223, 10611, 10611, 10574, 21713, 9435, 9435, 11165, 14472, 19581,
  13823, 13823, 10571, 10611, 10611, 16193, 9435, 21259, 11166, 15044, 13823, 13823, 18815, 10611, 10611, 9435, 20039,
  21165, 13823, 13823, 18816, 10611, 19638, 11161, 19579, 13823, 18817, 10611, 20036, 14616, 13824, 10611, 19639, 14614,
  22481, 22238, 17758, 13824, 10611, 10876, 18212, 17484, 17481, 17478, 21451, 16222, 16226, 21847, 16197, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 12772, 9435, 15772, 19719, 21024, 19752, 19782, 19766, 19798, 19812, 19828, 19867, 17375, 16422, 19892, 10274,
  18530, 15314, 21349, 16872, 21723, 20370, 10376, 14935, 14472, 15041, 11057, 19918, 19939, 15588, 17731, 10574, 21713,
  9435, 22939, 11165, 20362, 14262, 13823, 19955, 19979, 20012, 21218, 20032, 20631, 21259, 17575, 20055, 22861, 15080,
  18815, 21115, 20077, 20093, 20039, 21165, 20110, 13823, 20685, 10611, 19638, 11161, 19579, 15797, 18817, 17103, 20036,
  18615, 15823, 10611, 19639, 14614, 13825, 10611, 17758, 13824, 10611, 20131, 20495, 17484, 20147, 17478, 21451, 16162,
  16226, 21847, 16197, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 12772, 9435, 11141, 8782, 13358, 14499, 20173, 20187, 20203, 20217, 20233, 20258,
  17979, 15881, 20274, 20285, 20751, 20301, 22282, 15328, 20317, 9435, 13449, 20351, 14472, 10435, 20386, 13823, 17535,
  20441, 15976, 10574, 21713, 11311, 9435, 11165, 14472, 19581, 13823, 13823, 10571, 10611, 10611, 16193, 18455, 18463,
  20335, 21952, 13823, 20467, 20486, 10611, 20511, 15015, 17566, 20544, 16842, 13823, 20575, 21629, 18125, 11161, 19579,
  14633, 20601, 17269, 20036, 14616, 13824, 10611, 20585, 20652, 20675, 20016, 17758, 13824, 10611, 20701, 20739, 10663,
  18999, 20774, 20807, 16222, 16226, 21847, 16197, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 12772, 9435, 11283, 20858, 12778, 12984, 20877,
  20893, 20909, 20923, 10534, 20939, 20955, 11728, 20977, 21040, 21085, 21131, 13601, 17364, 18151, 9435, 21147, 22837,
  21181, 11038, 14652, 8621, 20559, 21215, 21792, 21234, 18323, 9435, 21256, 17411, 13659, 21276, 13491, 19162, 21332,
  21365, 22895, 16193, 22194, 21259, 22419, 9381, 13823, 21391, 18815, 10611, 14295, 16332, 21412, 16018, 21428, 21475,
  21494, 21527, 21240, 11120, 8611, 13498, 21589, 14588, 15619, 16594, 13862, 21619, 21645, 21675, 21700, 18731, 17758,
  21739, 21779, 10876, 18212, 17484, 17481, 21808, 21835, 21863, 16226, 21885, 16197, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 12772, 9435,
  11141, 9435, 12778, 12984, 21977, 21991, 22007, 22021, 10534, 22037, 17375, 20039, 21164, 9436, 13823, 11260, 10611,
  14769, 21723, 9435, 22057, 11166, 14472, 15041, 13823, 13823, 22103, 10611, 10611, 15843, 15947, 9435, 22119, 11165,
  22137, 20061, 18623, 17880, 22161, 19658, 22177, 16193, 21943, 21259, 22210, 22438, 13823, 13823, 21869, 10611, 10611,
  9435, 20039, 21165, 13823, 13823, 18816, 10611, 19008, 11161, 19579, 21396, 22228, 10611, 20036, 14616, 13824, 10611,
  19639, 14614, 13825, 10611, 17758, 16552, 22567, 10876, 18212, 17484, 17481, 22271, 22307, 16222, 14371, 21847, 16197,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 12772, 9435, 11141, 9435, 12778, 12984, 12866, 22331, 22347, 22361, 10534, 10552, 17375, 20039,
  21164, 9436, 22377, 19049, 22397, 20414, 21723, 9435, 21260, 22416, 14472, 22435, 22454, 13823, 13223, 21564, 10611,
  10574, 21713, 9435, 9435, 16824, 12837, 19581, 22474, 13823, 10571, 21546, 10611, 16193, 9435, 21259, 11166, 15044,
  13823, 13823, 18815, 10611, 10611, 9435, 20039, 21165, 13823, 13823, 18816, 10611, 19638, 11161, 19579, 13823, 18817,
  10611, 20036, 14616, 13824, 10611, 19639, 14614, 13825, 10611, 17758, 13824, 10611, 10876, 18212, 17484, 17481, 17478,
  21451, 16222, 16226, 21847, 16197, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 12772, 9435, 11141, 9435, 12778, 15121, 22497, 22511, 22527, 22541,
  10534, 10552, 17375, 20039, 21164, 9436, 13823, 11260, 10611, 14769, 21723, 9435, 21260, 11166, 14472, 15041, 13823,
  13823, 13223, 10611, 10611, 10574, 21713, 9435, 9435, 11165, 14472, 19581, 13823, 13823, 10571, 10611, 10611, 16193,
  9435, 21259, 11166, 15044, 13823, 13823, 18815, 10611, 10611, 9435, 20039, 21165, 19923, 13823, 22557, 22583, 22610,
  11161, 19579, 13823, 18817, 10611, 20036, 14616, 13824, 10611, 19639, 14614, 13825, 10611, 17758, 13824, 10611, 10876,
  18212, 17484, 17481, 17478, 21451, 16222, 16226, 21847, 16197, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 12772, 9435, 11141, 9435, 12778, 12984,
  12866, 22632, 22648, 22662, 10534, 10552, 17375, 18103, 21164, 21015, 22678, 19302, 22701, 17968, 21723, 14968, 21260,
  11166, 14472, 15041, 13823, 13823, 15355, 10611, 10611, 14323, 22720, 18497, 9435, 11165, 14472, 19581, 13823, 13823,
  10571, 10611, 10611, 16193, 9435, 21259, 11166, 15044, 13823, 13823, 18815, 10611, 10611, 9435, 20039, 21165, 13823,
  13823, 18816, 10611, 19638, 11161, 19579, 13823, 18817, 10611, 20036, 14616, 13824, 10611, 19639, 14614, 13825, 10611,
  17758, 13824, 10611, 10876, 18212, 17484, 17481, 17478, 21451, 16222, 16226, 21847, 16197, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 12772,
  9435, 11141, 9435, 12778, 12984, 12866, 18559, 10657, 19316, 22749, 10552, 17375, 20039, 21164, 9436, 13823, 14755,
  14241, 14769, 21723, 9435, 21260, 11166, 14472, 15041, 13823, 13823, 13223, 10611, 10611, 10574, 22775, 9435, 9435,
  11165, 14472, 19581, 13823, 13823, 10571, 10611, 10611, 22810, 9435, 14187, 22831, 15044, 22853, 13880, 18815, 22877,
  10611, 9435, 20039, 21165, 13823, 20115, 18816, 10611, 22187, 11161, 19579, 13823, 18817, 10611, 20036, 14616, 13824,
  10611, 19639, 14614, 13825, 10611, 17758, 13824, 10611, 10876, 18212, 17484, 17481, 17478, 21451, 16222, 16226, 21847,
  16197, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9452, 9435, 15021, 22921, 22911, 13958, 22936, 10994, 22931, 22955, 9503, 8465, 10791, 14523,
  8805, 9979, 8857, 12648, 8857, 9023, 8493, 8509, 9582, 8532, 8548, 20961, 8760, 8564, 12660, 8754, 8585, 8569, 8598,
  15213, 13323, 8645, 8661, 8688, 8745, 8857, 13063, 8993, 8857, 13078, 8776, 12715, 8798, 8821, 8849, 8874, 8903, 8890,
  8983, 15162, 14065, 8929, 23151, 8972, 9009, 23159, 9050, 9076, 9092, 9121, 8858, 9105, 9151, 12283, 8712, 8700,
  12668, 9167, 9193, 9177, 9224, 9255, 9239, 9298, 9355, 8729, 8857, 9313, 8833, 8724, 9403, 9419, 9434, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9452, 9435, 8388, 15659, 12236, 22733, 10208, 22971, 12234, 23008, 9503, 8465, 22788, 14523, 8805, 9979, 8857,
  12648, 8857, 9023, 8493, 8509, 9582, 8532, 8548, 20961, 8760, 8564, 12660, 8754, 8585, 8569, 8598, 15213, 13323, 8645,
  8661, 8688, 8745, 8857, 13063, 8993, 8857, 13078, 8776, 12715, 8798, 8821, 8849, 8874, 8903, 8890, 8983, 15162, 14065,
  8929, 23151, 8972, 9009, 23159, 9050, 9076, 9092, 9121, 8858, 9105, 9151, 12283, 8712, 8700, 12668, 9167, 9193, 9177,
  9224, 9255, 9239, 9298, 9355, 8729, 8857, 9313, 8833, 8724, 9403, 9419, 9434, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9452, 9435, 12212,
  9435, 9435, 23024, 23072, 23038, 9435, 23088, 9503, 8465, 9899, 14523, 8805, 9979, 8857, 12648, 8857, 9023, 8493,
  8509, 9582, 8532, 8548, 20961, 8760, 8564, 12660, 8754, 8585, 8569, 8598, 15213, 13323, 8645, 8661, 8688, 8745, 8857,
  13063, 8993, 8857, 13078, 8776, 12715, 8798, 8821, 8849, 8874, 8903, 8890, 8983, 15162, 14065, 8929, 23151, 8972,
  9009, 23159, 9050, 9076, 9092, 9121, 8858, 9105, 9151, 12283, 8712, 8700, 12668, 9167, 9193, 9177, 9224, 9255, 9239,
  9298, 9355, 8729, 8857, 9313, 8833, 8724, 9403, 9419, 9434, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9452, 9435, 8388, 9435, 9435, 12984,
  9435, 9435, 9435, 12898, 10534, 10552, 17375, 20039, 21164, 9436, 13823, 11260, 10611, 14769, 13084, 9435, 21260,
  11166, 14472, 15041, 13823, 13823, 11248, 10611, 10611, 10574, 21713, 9435, 9435, 11165, 14472, 19581, 13823, 13823,
  10571, 10611, 10611, 16193, 9435, 21259, 11166, 15044, 13823, 13823, 18815, 10611, 10611, 9435, 20039, 21165, 13823,
  13823, 18816, 10611, 19638, 11161, 19579, 13823, 18817, 10611, 20036, 14616, 13824, 10611, 19639, 14614, 13825, 10611,
  17758, 13824, 10611, 10876, 18212, 17484, 17481, 17478, 21451, 16222, 16226, 21847, 16197, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  19017, 20094, 9435, 19019, 9435, 9435, 11628, 9435, 9435, 9032, 13178, 8472, 14523, 8805, 9979, 8857, 12648, 8857,
  9023, 23104, 8509, 9582, 8532, 8548, 20961, 8760, 8564, 12660, 8754, 8585, 8569, 8598, 15213, 13323, 8645, 8661, 8688,
  8745, 8857, 13063, 8993, 8857, 13078, 8776, 12715, 8798, 8821, 8849, 8874, 8903, 8890, 8983, 15162, 14065, 8929,
  23151, 8972, 9009, 23159, 9050, 9076, 9092, 9121, 8858, 9105, 9151, 12283, 8712, 8700, 12668, 9167, 9193, 9177, 23120,
  9255, 9239, 23136, 23175, 8729, 8857, 9313, 8833, 8724, 9403, 9419, 9434, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435,
  9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 9435, 6145, 0, 3, 4, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 30883, 30883, 0, 0, 32933, 32933, 30883, 30883, 32933, 32933, 32933, 32933, 32933, 32933, 32933,
  32933, 32933, 32933, 32933, 32933, 177, 32933, 32933, 32933, 0, 32933, 32933, 32933, 32933, 32933, 26624, 28672,
  32933, 32933, 32933, 32933, 32933, 24576, 32933, 32933, 32933, 32933, 32933, 32933, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 160,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 177, 0, 0, 0, 0, 32933, 32933, 32933, 32933, 32933, 32933, 32933, 32933, 32933,
  32933, 32933, 32933, 32933, 32933, 32933, 32933, 32933, 0, 30883, 32933, 32933, 32933, 32933, 32933, 32933, 0, 32933,
  32933, 32933, 32933, 32933, 32933, 32933, 32933, 32933, 32933, 0, 30883, 0, 161, 563200, 30883, 0, 32933, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 169, 169, 169, 183, 177, 177, 177, 0, 0, 0, 0, 0, 0, 0, 0, 532480, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 863, 0, 0, 0, 0, 0, 0, 675840, 688128, 0, 765952, 804864, 0, 0, 0, 177, 177, 0, 0, 679936, 0, 0, 0, 534528,
  0, 0, 0, 0, 0, 0, 534528, 0, 0, 0, 0, 0, 0, 534528, 0, 0, 198, 0, 0, 561152, 561152, 561152, 561152, 735232, 561152,
  561152, 751616, 755712, 561152, 561152, 774144, 782336, 788480, 561152, 796672, 808960, 561152, 561152, 561152,
  851968, 561152, 561152, 561152, 735232, 751616, 755712, 774144, 782336, 788480, 796672, 851968, 788480, 563200,
  796672, 808960, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 851968, 563200, 563200, 563200, 563200,
  563200, 563200, 0, 0, 0, 755712, 563200, 761856, 563200, 563200, 774144, 563200, 782336, 788480, 563200, 796672,
  563200, 808960, 563200, 563200, 563200, 0, 0, 0, 0, 0, 0, 0, 0, 0, 563200, 0, 0, 0, 0, 162, 162, 162, 162, 162, 1085,
  162, 162, 162, 162, 162, 162, 621, 622, 162, 162, 162, 162, 162, 162, 162, 162, 796, 162, 798, 162, 800, 162, 162,
  162, 673792, 673792, 561152, 561152, 561152, 561152, 561152, 718848, 561152, 561152, 561152, 747520, 561152, 561152,
  561152, 786432, 790528, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 718848, 0, 790528, 0, 0, 0, 0, 0, 0,
  202, 202, 0, 0, 0, 0, 0, 202, 0, 0, 0, 0, 563200, 673792, 563200, 563200, 563200, 563200, 563200, 563200, 563200,
  718848, 563200, 563200, 563200, 563200, 700416, 708608, 710656, 563200, 563200, 724992, 563200, 563200, 563200,
  563200, 813056, 563200, 563200, 563200, 563200, 563200, 700416, 563200, 724992, 563200, 563200, 563200, 563200,
  563200, 835584, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200,
  563200, 563200, 0, 563200, 563200, 563200, 747520, 563200, 563200, 563200, 563200, 786432, 790528, 563200, 563200,
  563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 735232, 563200, 563200, 563200, 751616,
  755712, 563200, 563200, 563200, 774144, 782336, 0, 0, 727040, 0, 0, 849920, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 182, 0,
  0, 0, 0, 561152, 561152, 561152, 727040, 561152, 561152, 759808, 561152, 561152, 561152, 561152, 561152, 561152,
  561152, 561152, 561152, 561152, 0, 0, 0, 0, 0, 0, 759808, 0, 0, 0, 0, 0, 0, 692224, 563200, 563200, 690176, 692224,
  563200, 563200, 563200, 563200, 835584, 563200, 563200, 563200, 563200, 731136, 563200, 563200, 835584, 563200,
  563200, 731136, 563200, 563200, 727040, 563200, 563200, 563200, 563200, 759808, 563200, 563200, 563200, 563200,
  563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 739328, 563200,
  837632, 839680, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200,
  776192, 563200, 563200, 727040, 563200, 563200, 563200, 563200, 759808, 563200, 563200, 563200, 776192, 563200,
  802816, 563200, 563200, 847872, 563200, 563200, 563200, 563200, 690176, 692224, 563200, 563200, 563200, 563200,
  563200, 563200, 0, 0, 0, 753664, 0, 0, 0, 0, 1192, 561152, 561152, 561152, 811008, 561152, 561152, 561152, 854016,
  860160, 870400, 860160, 0, 0, 0, 854016, 0, 563200, 0, 0, 563200, 563200, 690176, 160, 0, 0, 0, 160, 0, 161, 0, 0, 0,
  0, 0, 26624, 67789, 0, 0, 0, 0, 0, 24576, 0, 0, 811008, 563200, 563200, 563200, 563200, 563200, 854016, 860160,
  563200, 563200, 870400, 563200, 563200, 563200, 563200, 563200, 837632, 839680, 563200, 847872, 563200, 563200,
  563200, 563200, 563200, 563200, 563200, 747520, 563200, 563200, 563200, 563200, 563200, 786432, 790528, 563200,
  563200, 729088, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 696320, 563200, 563200, 563200, 563200,
  563200, 563200, 563200, 0, 0, 563200, 563200, 563200, 563200, 563200, 0, 563200, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 88064, 88064, 854016, 563200, 860160, 563200, 563200, 870400, 563200, 0, 0, 827392, 0, 0, 0, 0, 0, 0, 0, 0,
  331776, 0, 972, 0, 0, 0, 0, 0, 843776, 841728, 0, 0, 0, 561152, 561152, 561152, 561152, 561152, 739328, 561152,
  561152, 827392, 561152, 841728, 739328, 0, 0, 0, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200,
  739328, 563200, 763904, 563200, 563200, 792576, 563200, 817152, 563200, 563200, 827392, 563200, 563200, 841728,
  563200, 563200, 563200, 563200, 792576, 563200, 817152, 563200, 827392, 563200, 841728, 563200, 563200, 872448,
  563200, 563200, 563200, 563200, 563200, 0, 0, 563200, 563200, 563200, 563200, 563200, 0, 563200, 0, 0, 0, 0, 517,
  872448, 0, 0, 0, 710656, 0, 724992, 0, 0, 0, 0, 0, 561152, 561152, 561152, 710656, 694272, 561152, 561152, 770048,
  561152, 561152, 0, 770048, 694272, 669696, 563200, 694272, 563200, 563200, 563200, 720896, 563200, 563200, 770048,
  563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 770048, 563200, 563200, 563200, 563200, 864256,
  563200, 720896, 563200, 563200, 563200, 563200, 563200, 669696, 563200, 0, 563200, 563200, 563200, 563200, 563200,
  761856, 563200, 563200, 563200, 563200, 563200, 563200, 0, 51200, 563200, 864256, 829440, 0, 698368, 677888, 0, 1192,
  677888, 698368, 561152, 772096, 829440, 772096, 563200, 677888, 681984, 698368, 563200, 563200, 563200, 563200,
  743424, 772096, 819200, 563200, 829440, 563200, 563200, 563200, 862208, 698368, 563200, 563200, 743424, 772096,
  819200, 829440, 862208, 681984, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 0, 0, 563200, 563200, 563200,
  563200, 563200, 0, 563200, 0, 90112, 0, 0, 0, 0, 348, 198, 0, 0, 0, 0, 0, 0, 0, 0, 357, 0, 0, 716800, 1192, 716800,
  563200, 712704, 716800, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 858112, 563200, 0, 563200, 563200,
  563200, 563200, 722944, 563200, 563200, 563200, 563200, 563200, 563200, 722944, 563200, 563200, 0, 0, 563200, 563200,
  563200, 563200, 563200, 0, 563200, 120832, 0, 0, 0, 0, 0, 51486, 0, 0, 77824, 0, 0, 51486, 51486, 51486, 51486, 51486,
  712704, 716800, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 858112, 0, 1192, 563200, 563200, 563200,
  563200, 0, 0, 563200, 563200, 563200, 563200, 563200, 0, 563200, 118784, 0, 0, 0, 0, 0, 894, 0, 0, 162, 162, 162, 162,
  162, 162, 162, 162, 769, 162, 162, 162, 162, 162, 563200, 671744, 563200, 563200, 563200, 563200, 833536, 671744,
  563200, 563200, 563200, 563200, 833536, 563200, 745472, 821248, 563200, 563200, 745472, 821248, 563200, 714752,
  563200, 714752, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 825344, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 162, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 864, 0, 0, 0, 0, 235, 0, 235, 235, 6145, 0, 3, 4,
  0, 0, 0, 0, 0, 160, 160, 0, 160, 0, 160, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 14655, 161, 563200, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 96456, 0, 0, 361, 0, 0, 0, 0, 0, 0, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152,
  561152, 561152, 0, 0, 131072, 0, 0, 0, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 160, 160, 0, 0, 0, 0, 0, 57545, 28672,
  0, 0, 0, 0, 0, 24576, 0, 0, 0, 0, 57344, 0, 0, 160, 57344, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 808960, 0, 561152, 561152,
  561152, 561152, 6145, 0, 569497, 4, 155, 0, 0, 0, 0, 0, 0, 0, 0, 0, 155, 0, 0, 0, 401, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 162, 162, 162, 162, 600, 0, 307, 0, 0, 0, 0, 307, 0, 0, 0, 307, 0, 0, 0, 0, 0, 0, 404, 0, 406, 407, 0, 0, 0, 364,
  411, 412, 177, 177, 177, 0, 71680, 0, 0, 0, 0, 0, 0, 532480, 0, 0, 0, 0, 0, 351, 0, 0, 0, 218, 218, 218, 218, 372,
  218, 218, 521, 0, 0, 675840, 688128, 0, 765952, 804864, 0, 0, 0, 177, 177, 0, 0, 679936, 0, 0, 0, 534528, 0, 0, 0, 0,
  0, 0, 534528, 0, 543, 0, 0, 0, 0, 162, 1081, 162, 1083, 162, 162, 162, 162, 162, 1088, 162, 162, 6145, 0, 3, 4, 0,
  65536, 0, 0, 0, 0, 0, 0, 0, 65536, 0, 0, 0, 0, 65536, 65536, 0, 0, 0, 65536, 0, 0, 0, 0, 0, 26624, 28672, 0, 0, 0, 0,
  0, 24576, 0, 0, 0, 0, 532480, 198, 0, 0, 0, 0, 0, 0, 22528, 0, 0, 0, 0, 166, 166, 0, 0, 166, 166, 69798, 166, 166,
  166, 166, 166, 69798, 69798, 181, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 178, 166, 166, 166, 0,
  0, 0, 65536, 0, 0, 0, 65536, 0, 65536, 0, 0, 0, 65536, 65536, 65536, 65536, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  112851, 0, 0, 65536, 65536, 0, 65536, 0, 65536, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 160, 321, 563200, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 110592, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 161, 161, 0, 0, 0, 0, 532480, 198, 0, 0, 0, 0,
  0, 358400, 0, 0, 0, 0, 162, 162, 162, 162, 162, 162, 1086, 162, 162, 162, 162, 162, 162, 794, 162, 162, 162, 162, 162,
  162, 801, 162, 803, 0, 0, 67584, 0, 0, 161, 67584, 0, 0, 0, 0, 0, 0, 0, 0, 0, 160, 0, 0, 0, 160, 160, 160, 161, 161,
  0, 161, 0, 161, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 160, 14658, 563200, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 563200,
  0, 161, 0, 675840, 688128, 0, 765952, 804864, 0, 0, 0, 177, 177, 0, 0, 679936, 6145, 0, 3, 4, 0, 0, 156, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 161, 0, 0, 0, 161, 161, 161, 0, 166, 166, 166, 166, 166, 26624, 28672, 166, 166, 166, 166, 69798,
  24576, 166, 166, 0, 69798, 69798, 166, 69798, 69798, 69798, 69798, 69798, 166, 166, 0, 0, 0, 0, 167, 0, 6145, 0, 3, 4,
  0, 0, 0, 0, 0, 160, 0, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 0, 0, 166,
  166, 166, 166, 166, 166, 69632, 69798, 166, 166, 69798, 69813, 69813, 69798, 69813, 69798, 69798, 6145, 0, 3, 4, 0, 0,
  0, 0, 0, 160, 567628, 567628, 177, 0, 0, 0, 0, 0, 0, 0, 0, 532480, 0, 0, 0, 0, 0, 536, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  348, 0, 0, 0, 0, 0, 0, 0, 0, 675840, 688128, 0, 765952, 804864, 0, 0, 0, 567628, 177, 0, 0, 679936, 0, 75776, 0,
  75776, 75776, 0, 26624, 28672, 0, 0, 75776, 0, 75776, 24576, 75776, 75776, 0, 75776, 75776, 75776, 75776, 75776,
  75776, 75776, 75776, 0, 0, 0, 0, 0, 0, 75776, 75776, 75776, 0, 0, 0, 0, 0, 0, 0, 0, 354304, 354304, 354304, 354304,
  354304, 354304, 354304, 354304, 0, 0, 0, 75776, 75776, 75776, 75776, 75776, 75776, 75776, 75776, 75776, 75776, 75776,
  75776, 75776, 0, 0, 75776, 75776, 75776, 75776, 6145, 0, 0, 4, 59392, 0, 0, 0, 0, 160, 177, 177, 104448, 0, 0, 0, 0,
  0, 0, 0, 0, 532480, 0, 0, 0, 0, 0, 552, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 408, 0, 0, 0, 0, 162, 0, 0, 0, 675840, 688128,
  0, 765952, 804864, 0, 0, 0, 177, 0, 0, 0, 679936, 79872, 77824, 0, 79872, 77824, 77824, 77824, 77824, 77824, 77824,
  77824, 0, 0, 0, 0, 51486, 51486, 77824, 51486, 77824, 51486, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 160, 83968, 81920, 0,
  83968, 81920, 81920, 81920, 81920, 81920, 81920, 81920, 0, 0, 0, 0, 0, 0, 537, 0, 0, 0, 0, 0, 545, 0, 0, 0, 0, 0, 0,
  534528, 0, 0, 0, 0, 0, 0, 534528, 541, 0, 0, 0, 0, 0, 556, 0, 0, 0, 0, 0, 0, 218, 218, 218, 218, 218, 739, 218, 218,
  218, 218, 218, 218, 218, 218, 218, 0, 0, 0, 0, 0, 996, 162, 0, 86016, 86016, 86016, 0, 86016, 26624, 28672, 86016, 0,
  0, 86016, 0, 24576, 86016, 86016, 0, 86016, 86016, 86016, 86016, 86016, 86016, 86016, 86016, 0, 0, 0, 0, 0, 0, 591, 0,
  593, 594, 591, 162, 162, 598, 162, 162, 0, 0, 0, 86016, 0, 86016, 86016, 86016, 86016, 86016, 86016, 86016, 86016,
  86016, 86016, 86016, 0, 0, 86016, 0, 86016, 86016, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 160, 151, 0, 3, 4, 0, 0, 0, 157, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 870, 0, 0, 0, 874, 218, 218, 88064, 88064, 0, 88064, 88064, 88064, 88064, 88064, 88064, 88064,
  88064, 0, 0, 0, 0, 0, 0, 716, 0, 0, 0, 0, 0, 0, 0, 0, 723, 161, 162, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  563523, 177, 177, 177, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 114688, 0, 162, 162, 51843, 287, 287, 287, 287, 287,
  287, 287, 287, 287, 287, 287, 287, 287, 0, 0, 0, 1024, 162, 162, 162, 287, 287, 287, 287, 287, 287, 287, 287, 287,
  287, 287, 287, 287, 1257, 287, 287, 1039, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287,
  287, 954, 162, 1102, 162, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 0, 0, 559, 162, 162, 162,
  1240, 162, 1241, 162, 162, 162, 162, 162, 162, 162, 162, 162, 287, 162, 162, 162, 162, 162, 287, 287, 287, 287, 287,
  287, 287, 287, 287, 0, 1299, 0, 0, 1192, 218, 162, 1262, 162, 162, 162, 162, 162, 1267, 162, 162, 162, 287, 287, 287,
  287, 287, 287, 287, 287, 287, 1113, 287, 287, 287, 1271, 287, 287, 287, 287, 287, 1276, 287, 287, 287, 0, 1192, 1280,
  162, 162, 162, 162, 162, 620, 162, 162, 162, 162, 162, 162, 626, 162, 162, 630, 287, 0, 162, 1319, 162, 162, 162, 162,
  162, 162, 162, 287, 1327, 287, 287, 287, 287, 287, 1346, 162, 162, 162, 162, 162, 1352, 287, 287, 287, 287, 287, 1043,
  287, 287, 287, 287, 287, 287, 1050, 287, 287, 287, 196, 0, 0, 0, 0, 0, 26624, 28672, 0, 0, 0, 0, 0, 24576, 0, 0, 0, 0,
  532480, 198, 0, 0, 0, 0, 352256, 0, 0, 0, 0, 0, 198, 0, 0, 0, 354, 0, 0, 0, 0, 0, 0, 0, 717, 0, 0, 0, 0, 0, 0, 0, 0,
  162, 162, 162, 162, 899, 162, 162, 162, 92474, 92474, 0, 92474, 0, 92474, 6145, 41112, 3, 4, 0, 0, 0, 0, 0, 160, 177,
  177, 177, 0, 0, 0, 0, 0, 0, 0, 0, 340, 0, 0, 0, 0, 0, 0, 347, 542, 0, 0, 0, 548, 0, 0, 1192, 218, 162, 162, 162, 162,
  162, 162, 162, 162, 162, 162, 162, 287, 162, 162, 162, 162, 162, 287, 313, 287, 287, 287, 0, 96456, 0, 0, 96456,
  96456, 96456, 96456, 96456, 96456, 96456, 0, 0, 0, 0, 0, 0, 857, 0, 0, 0, 0, 862, 0, 0, 0, 0, 96456, 96456, 96456,
  96456, 96456, 0, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 160, 0, 0, 116736, 0, 0, 0, 0, 0, 0, 561152, 561152, 561152, 561152,
  561152, 561152, 561152, 561152, 561152, 561152, 0, 118784, 0, 0, 0, 0, 197, 0, 0, 0, 0, 0, 26624, 28672, 0, 0, 0, 0,
  0, 24576, 0, 0, 0, 0, 532480, 198, 0, 0, 0, 352, 0, 0, 0, 0, 0, 0, 0, 0, 350208, 350208, 350208, 0, 0, 0, 0, 0, 197,
  197, 0, 197, 0, 197, 6145, 41112, 3, 4, 0, 0, 0, 0, 0, 160, 177, 177, 177, 0, 0, 0, 0, 0, 0, 0, 340, 188, 0, 0, 0, 0,
  0, 590, 590, 0, 0, 0, 590, 162, 162, 162, 162, 162, 162, 921, 922, 162, 162, 162, 162, 162, 162, 162, 162, 611, 162,
  162, 162, 162, 162, 162, 162, 287, 0, 0, 162, 287, 0, 695, 851, 0, 0, 0, 0, 701, 853, 0, 0, 0, 0, 532480, 198, 0, 0,
  20480, 0, 0, 0, 0, 0, 0, 0, 0, 560, 0, 808960, 0, 561152, 561152, 561152, 561152, 721, 867, 0, 0, 0, 0, 0, 728, 0, 0,
  0, 0, 0, 218, 218, 218, 1072, 218, 218, 218, 218, 218, 218, 218, 0, 0, 851, 0, 853, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 177, 162, 0, 162, 0, 0, 867, 0, 0, 0, 0, 0, 0, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218,
  218, 218, 218, 0, 168, 0, 0, 0, 0, 26624, 28672, 0, 0, 167, 0, 167, 24576, 0, 0, 0, 0, 532480, 198, 0, 98304, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 65536, 0, 0, 0, 0, 0, 0, 0, 0, 168, 0, 0, 168, 0, 167, 0, 167, 0, 0, 0, 0, 102400, 0, 0, 0, 0, 171,
  0, 0, 0, 0, 0, 0, 0, 177, 162, 0, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 0, 0, 162, 162, 162,
  162, 162, 162, 162, 162, 162, 0, 287, 287, 161, 563523, 0, 0, 0, 73728, 106496, 0, 0, 0, 0, 0, 0, 0, 0, 0, 176, 0, 0,
  177, 162, 0, 162, 567629, 73728, 567629, 0, 73728, 0, 0, 0, 0, 0, 0, 532480, 0, 0, 0, 0, 0, 715, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 527, 561, 562, 218, 218, 218, 0, 0, 0, 675840, 688128, 0, 765952, 804864, 0, 0, 0, 0, 567629, 0, 0, 679936,
  788803, 563523, 796995, 809283, 563523, 563523, 563523, 563523, 563523, 563523, 563523, 852291, 563523, 563523,
  563523, 563523, 0, 563664, 674256, 563664, 563664, 563664, 563664, 563664, 563664, 563664, 563664, 563664, 719312,
  563664, 756176, 563664, 762320, 563664, 563664, 774608, 563664, 782800, 788944, 563664, 797136, 563664, 809424,
  563664, 563664, 563664, 563664, 835584, 563523, 563523, 563523, 563523, 731459, 563523, 563523, 835907, 563664,
  563664, 731600, 0, 0, 563523, 674115, 563523, 563523, 563523, 563523, 563523, 563523, 563523, 719171, 563523, 563523,
  563523, 563523, 696643, 563523, 563523, 563523, 563523, 563523, 729411, 737603, 563523, 563523, 563523, 563523,
  563523, 563523, 727363, 563523, 563523, 563523, 563523, 760131, 563523, 563523, 563523, 563523, 563523, 563523,
  563523, 563523, 563523, 563523, 563523, 563523, 563523, 563523, 563523, 563523, 563664, 563664, 563664, 563664,
  563664, 563664, 563664, 563664, 563664, 0, 563523, 759808, 0, 0, 0, 0, 0, 0, 692224, 563523, 563523, 690499, 692547,
  563523, 563523, 563523, 563523, 747843, 563523, 563523, 563523, 563523, 786755, 790851, 563523, 563523, 563523,
  563523, 563523, 563523, 563523, 735555, 563523, 563523, 563523, 751939, 756035, 563523, 563523, 563523, 774467,
  782659, 803139, 563523, 563523, 848195, 563523, 563664, 563664, 563664, 690640, 692688, 563664, 563664, 563664,
  563664, 563664, 563664, 747984, 563664, 563664, 563664, 563664, 563664, 786896, 790992, 563664, 563664, 561152,
  561152, 811008, 561152, 561152, 561152, 854016, 860160, 870400, 860160, 0, 0, 0, 854016, 0, 563523, 0, 563523, 563523,
  563523, 563523, 563523, 762179, 563523, 563523, 563523, 563523, 563523, 563523, 0, 0, 563523, 563523, 563523, 563523,
  563523, 563523, 563523, 563523, 563523, 463, 563664, 563664, 811331, 563523, 563523, 563523, 563523, 563523, 854339,
  860483, 563523, 563523, 870723, 563523, 563523, 563523, 563523, 563523, 813379, 563523, 563523, 563523, 563523,
  563523, 700739, 563523, 725315, 563523, 563523, 563523, 563523, 563664, 563664, 0, 0, 0, 0, 0, 0, 0, 0, 0, 563200, 0,
  0, 0, 0, 347, 198, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53248, 53248, 0, 0, 0, 729411, 563523, 563523, 563523, 563664,
  563664, 563664, 563664, 696784, 563664, 563664, 563664, 563664, 563664, 563664, 563664, 852432, 563664, 563664,
  563664, 563664, 563664, 563664, 0, 0, 0, 753664, 0, 0, 0, 0, 0, 561152, 729552, 737744, 563664, 563664, 563664,
  563664, 563664, 563664, 811472, 563664, 563664, 563664, 563664, 563664, 563664, 563664, 838096, 840144, 563664,
  848336, 563664, 563664, 563664, 563664, 563664, 563664, 563664, 563664, 563664, 563664, 563664, 563664, 563664,
  563664, 563664, 563664, 735696, 563664, 563664, 563664, 752080, 854480, 563664, 860624, 563664, 563664, 870864,
  563664, 0, 0, 827392, 0, 0, 0, 0, 0, 0, 0, 346, 0, 218, 218, 218, 218, 218, 218, 377, 739328, 0, 0, 0, 563523, 563523,
  563523, 563523, 563523, 563523, 563523, 563523, 739651, 563523, 764227, 563523, 770371, 563523, 563523, 563523,
  563523, 864579, 563523, 721219, 563523, 563523, 563523, 563523, 563523, 670160, 563664, 0, 0, 563523, 563664, 690176,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 143360, 143360, 0, 0, 0, 563664, 764368, 563664, 563664, 793040, 563664, 817616,
  563664, 563664, 827856, 563664, 563664, 842192, 563664, 563664, 563664, 563664, 836048, 563523, 563523, 563523,
  563523, 563523, 563523, 563664, 563664, 563664, 563664, 563664, 563664, 563664, 563664, 563664, 563664, 563664,
  563664, 739792, 872912, 0, 0, 0, 710656, 0, 724992, 0, 0, 0, 0, 0, 561152, 561152, 561152, 710656, 561152, 561152,
  561152, 561152, 0, 0, 0, 563523, 563523, 563523, 563523, 708931, 710979, 563523, 563523, 563523, 792899, 563523,
  817475, 563523, 827715, 563523, 842051, 563523, 563523, 872771, 563523, 563523, 563523, 563523, 563523, 837955,
  840003, 563523, 563523, 563523, 563523, 563523, 563523, 563523, 563523, 563523, 563523, 563523, 563523, 776515,
  694272, 561152, 561152, 770048, 561152, 561152, 0, 770048, 694272, 670019, 563523, 694595, 563523, 563523, 563523,
  721219, 563664, 694736, 563664, 563664, 563664, 721360, 563664, 563664, 770512, 563664, 563664, 563664, 563664,
  563664, 563664, 563664, 700880, 709072, 711120, 563664, 563664, 725456, 563664, 563664, 563664, 563664, 813520,
  563664, 563664, 864720, 829440, 0, 698368, 677888, 0, 1192, 677888, 698368, 561152, 772096, 829440, 772096, 563523,
  678211, 698691, 563523, 563523, 743747, 772419, 819523, 829763, 862531, 682307, 563523, 563523, 563523, 563523,
  563523, 563523, 563664, 745936, 821712, 563664, 715075, 563523, 715216, 563664, 563523, 563664, 563523, 563664,
  563523, 563664, 825667, 678352, 682448, 698832, 563664, 563664, 563664, 563664, 743888, 772560, 819664, 563664,
  829904, 563664, 563664, 563664, 862672, 0, 716800, 1192, 716800, 563523, 713027, 717123, 563523, 563523, 563523,
  563523, 563523, 563523, 563523, 858435, 563664, 0, 563523, 563523, 563523, 563523, 723267, 563523, 563523, 563523,
  563523, 563664, 563664, 723408, 563664, 563664, 727504, 563664, 563664, 563664, 563664, 760272, 563664, 563664,
  563664, 776656, 563664, 803280, 563664, 563664, 0, 0, 563523, 563523, 563523, 563664, 563664, 0, 563664, 0, 0, 0, 0,
  0, 0, 980, 0, 0, 218, 218, 218, 218, 986, 218, 218, 713168, 717264, 563664, 563664, 563664, 563664, 563664, 563664,
  563664, 858576, 0, 1192, 563523, 563523, 563523, 563523, 563664, 672067, 563523, 563523, 563523, 563523, 833859,
  672208, 563664, 563664, 563664, 563664, 834000, 563523, 745795, 821571, 825808, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 866, 0, 0, 0, 110592, 110592, 0, 26624, 28672, 0, 0, 110592, 0, 110592, 24576, 110592, 110592, 0, 110592,
  110592, 110592, 110592, 110592, 110592, 110592, 110592, 0, 0, 0, 0, 0, 0, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 160, 0, 0, 0,
  110592, 0, 110592, 110592, 110592, 110592, 110592, 110592, 110592, 110592, 110592, 110592, 110592, 0, 0, 110592,
  110592, 110592, 110592, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 160, 0, 0, 0, 34816, 0, 0, 0, 18432, 0, 0, 0, 747520, 786432, 0,
  0, 0, 0, 348, 198, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 356352, 177, 0, 0, 0, 161, 0, 727040, 0, 0, 849920, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 354304, 0, 0, 0, 0, 0, 0, 198, 0, 0, 0, 198, 0, 0, 34816, 0, 0, 0, 0, 0, 561152, 690176, 692224, 0,
  0, 198, 0, 729088, 0, 0, 870400, 0, 561152, 561152, 561152, 561152, 561152, 729088, 561152, 561152, 561152, 561152, 0,
  0, 0, 563200, 563200, 563200, 563200, 708608, 710656, 563200, 563200, 563200, 0, 0, 563200, 563200, 563200, 563200,
  563200, 0, 563200, 0, 0, 0, 160, 0, 161, 0, 811008, 0, 0, 0, 0, 0, 784384, 0, 0, 0, 0, 0, 0, 112876, 0, 112876,
  112876, 112876, 112876, 112876, 112876, 112876, 112876, 112876, 112876, 112876, 0, 112876, 112876, 112876, 112876,
  112876, 112876, 112876, 112876, 0, 0, 0, 0, 0, 0, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 320, 112948, 112948, 112876, 112948,
  112876, 112956, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 160, 6145, 0, 3, 4, 0, 0, 0, 0, 124928, 0, 0, 0, 0, 0, 0, 124928, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 177, 0, 0, 0, 0, 0, 0, 124928, 0, 124928, 124928, 124928, 124928, 124928, 124928, 124928,
  124928, 124928, 124928, 124928, 0, 124928, 124928, 124928, 124928, 124928, 124928, 124928, 124928, 0, 0, 0, 0, 0, 0,
  6145, 0, 3, 571546, 0, 0, 0, 0, 0, 160, 0, 0, 124928, 0, 124928, 124928, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 160, 161,
  563200, 0, 0, 0, 0, 0, 108544, 0, 0, 0, 0, 0, 0, 0, 0, 0, 92356, 0, 0, 0, 92474, 92474, 92474, 6145, 0, 3, 4, 0, 0, 0,
  0, 0, 126976, 0, 0, 0, 0, 0, 0, 0, 351, 0, 0, 0, 0, 0, 0, 0, 162, 0, 0, 0, 189, 0, 0, 0, 0, 0, 126976, 0, 0, 126976,
  0, 0, 0, 126976, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167, 168, 0, 0, 0, 0, 127213, 0, 127213, 127213, 127213,
  127213, 127213, 127213, 127213, 127213, 127213, 127213, 127213, 0, 127213, 127213, 127213, 127213, 127213, 127213,
  127213, 127213, 0, 0, 0, 0, 0, 0, 6145, 0, 569497, 4, 0, 71680, 0, 0, 0, 160, 0, 0, 127213, 0, 127213, 127213, 6145,
  0, 3, 0, 0, 0, 0, 135168, 0, 160, 161, 563200, 0, 100352, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133120, 0, 0, 0, 0,
  0, 0, 712704, 716800, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 858112, 0, 49152, 563200, 563200,
  563200, 563200, 0, 0, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 0, 563200, 563200,
  563200, 563200, 563200, 761856, 563200, 563200, 563200, 563200, 563200, 563200, 0, 0, 0, 753664, 0, 0, 0, 0, 0,
  561152, 6145, 0, 3, 571546, 0, 0, 0, 0, 0, 0, 158, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 547, 0, 133120, 0, 0,
  133120, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 561152, 690176, 692224, 0, 0, 122880, 0, 0, 0, 0, 0, 0, 561152, 561152,
  561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 55296, 120832, 129024, 0, 0, 0, 137216, 137216, 0,
  137216, 0, 137216, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 160, 6145, 41112, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 162, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 867, 0, 0, 0, 0, 0, 728, 0, 0, 0, 0, 0, 218, 218, 218, 737, 218, 218, 218, 218, 218, 218, 218, 218,
  218, 218, 218, 0, 0, 0, 351, 0, 0, 0, 0, 867, 0, 0, 0, 0, 0, 981, 218, 218, 218, 218, 218, 218, 218, 218, 0, 753, 0,
  0, 0, 0, 0, 0, 0, 867, 0, 0, 0, 0, 0, 728, 0, 0, 0, 0, 873, 218, 218, 218, 0, 218, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  179, 0, 0, 0, 0, 139264, 0, 0, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 0, 0, 0, 0, 0, 0, 6145, 41112,
  3, 4, 0, 0, 0, 0, 0, 160, 0, 0, 139264, 0, 139264, 0, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 160, 0, 141312, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 177, 0, 0, 0, 0, 402, 0, 0, 0, 402, 402, 0, 0, 0, 0, 402, 162, 0, 0, 0, 141312, 0, 0, 26624, 28672, 0, 0,
  0, 0, 0, 24576, 141312, 141312, 0, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 0, 0, 0, 0, 0, 0,
  26624, 28672, 0, 0, 0, 0, 0, 24576, 0, 0, 0, 0, 0, 141312, 0, 141312, 141312, 141312, 141312, 141312, 141312, 141312,
  141312, 141312, 141312, 141312, 0, 0, 141312, 0, 141312, 141312, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 160, 563200, 864256,
  829440, 0, 698368, 677888, 0, 1235, 677888, 698368, 561152, 772096, 829440, 772096, 563200, 677888, 0, 716800, 1260,
  716800, 563200, 712704, 716800, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 858112, 563200, 563200, 0,
  563200, 673792, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 718848, 563200, 0, 0, 563200,
  563200, 690176, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 177, 177, 0, 0, 0, 712704, 716800, 563200, 563200, 563200, 563200,
  563200, 563200, 563200, 858112, 0, 1260, 563200, 563200, 563200, 563200, 0, 512, 563200, 563200, 563200, 563200,
  563200, 0, 563200, 512, 0, 0, 0, 0, 0, 326, 0, 0, 0, 218, 218, 218, 218, 371, 218, 218, 143360, 143360, 0, 143360, 0,
  143360, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 160, 198, 0, 0, 0, 0, 0, 26624, 28672, 0, 0, 0, 0, 0, 24576, 0, 0, 0, 0, 532480,
  16734, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 532480, 0, 0, 0, 0, 198, 198, 0, 198, 0, 198, 6145, 0, 3, 4, 0, 0, 0, 0, 0,
  160, 0, 0, 169, 0, 0, 0, 0, 0, 0, 0, 0, 0, 177, 162, 0, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162,
  51843, 525, 0, 169, 0, 0, 0, 0, 26624, 28672, 206, 0, 0, 0, 0, 24576, 206, 217, 219, 219, 219, 217, 219, 217, 217,
  217, 217, 217, 217, 217, 217, 217, 217, 217, 254, 217, 256, 254, 217, 217, 217, 217, 217, 219, 217, 256, 256, 277,
  277, 288, 277, 277, 277, 277, 277, 288, 277, 277, 277, 277, 277, 288, 288, 288, 288, 288, 277, 288, 277, 288, 6145,
  41112, 3, 4, 0, 0, 0, 0, 318, 160, 177, 177, 177, 0, 0, 335, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 747520, 786432, 0, 0, 0,
  344, 0, 0, 0, 0, 198, 0, 0, 0, 353, 0, 0, 0, 0, 0, 0, 0, 393, 0, 0, 0, 0, 0, 0, 0, 162, 0, 0, 0, 190, 0, 0, 0, 194,
  195, 414, 162, 162, 162, 162, 162, 162, 162, 162, 162, 437, 162, 440, 162, 162, 447, 162, 162, 344, 335, 162, 414,
  162, 162, 162, 162, 437, 440, 162, 0, 287, 287, 0, 0, 0, 0, 0, 1192, 218, 218, 218, 218, 218, 0, 1237, 162, 468, 287,
  287, 287, 287, 287, 287, 287, 287, 287, 494, 287, 497, 287, 287, 507, 522, 0, 525, 0, 0, 0, 0, 0, 0, 0, 0, 177, 177,
  0, 0, 0, 0, 555, 0, 0, 0, 0, 555, 0, 0, 218, 218, 564, 218, 0, 0, 534, 0, 0, 0, 0, 0, 0, 540, 0, 0, 544, 0, 0, 0, 0,
  589, 0, 0, 0, 0, 0, 0, 595, 597, 162, 162, 162, 162, 162, 778, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 1095,
  162, 162, 1097, 162, 1099, 162, 218, 218, 218, 581, 218, 218, 218, 218, 0, 0, 0, 0, 0, 0, 0, 0, 0, 112948, 0, 0, 0,
  112948, 112948, 112948, 162, 540, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 51843, 525, 218, 218,
  218, 218, 218, 750, 218, 218, 0, 0, 0, 0, 0, 0, 0, 758, 162, 789, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162,
  162, 162, 162, 162, 802, 162, 162, 162, 51843, 287, 287, 287, 287, 287, 287, 287, 287, 287, 815, 287, 287, 287, 287,
  481, 487, 489, 287, 287, 287, 287, 287, 501, 287, 287, 287, 287, 649, 287, 287, 287, 287, 287, 287, 287, 287, 287,
  287, 287, 963, 287, 287, 287, 287, 0, 867, 0, 0, 0, 0, 0, 728, 0, 0, 0, 0, 0, 218, 218, 875, 876, 218, 218, 218, 218,
  218, 218, 881, 218, 218, 218, 218, 218, 218, 218, 218, 0, 0, 0, 0, 0, 0, 757, 0, 0, 969, 851, 0, 853, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 975, 0, 0, 0, 548, 728, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 177, 161, 161, 0, 162, 162, 1026, 162, 287,
  287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 498, 287, 287, 287, 287, 287, 287, 287, 1056, 287, 287, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 1135, 218, 218, 218, 218, 287, 287, 1182, 287, 287, 287, 0, 0, 0, 0, 0, 0, 0, 0, 0, 218, 218,
  218, 985, 218, 218, 218, 170, 0, 0, 0, 0, 0, 162, 0, 0, 0, 0, 0, 0, 0, 0, 0, 197, 0, 0, 0, 197, 197, 197, 218, 218,
  218, 218, 749, 218, 218, 218, 0, 0, 0, 0, 0, 0, 0, 0, 0, 143360, 0, 0, 0, 143360, 143360, 143360, 788, 162, 162, 162,
  162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 287, 287, 0, 0, 867, 0, 0, 0, 0, 0, 0, 218, 983, 218,
  218, 218, 218, 218, 218, 0, 0, 0, 1199, 162, 162, 162, 162, 162, 162, 162, 1160, 162, 1161, 162, 162, 162, 162, 1166,
  287, 162, 999, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 929, 162, 162, 1301, 1302, 162,
  162, 162, 1306, 162, 287, 287, 287, 287, 1312, 1313, 287, 1315, 6145, 41112, 3, 4, 0, 0, 0, 0, 0, 0, 0, 159, 162, 0,
  0, 0, 0, 728, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 218, 218, 218, 565, 0, 159, 0, 0, 0, 0, 162, 0, 0, 0, 0, 191, 0, 0,
  0, 0, 0, 350208, 350411, 350411, 0, 0, 0, 0, 0, 350411, 0, 0, 0, 0, 191, 0, 0, 191, 26624, 28672, 191, 0, 0, 0, 0,
  24576, 212, 212, 253, 257, 212, 253, 253, 253, 253, 253, 220, 253, 257, 257, 278, 278, 289, 220, 220, 220, 212, 220,
  212, 212, 212, 212, 212, 212, 212, 252, 252, 253, 253, 278, 278, 278, 278, 278, 289, 278, 278, 278, 309, 278, 289,
  289, 315, 315, 315, 278, 315, 278, 315, 6145, 41112, 3, 4, 0, 0, 0, 0, 0, 160, 177, 177, 177, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 342, 0, 0, 0, 0, 729088, 0, 0, 870400, 0, 561152, 561152, 561152, 561152, 561152, 729088, 561152, 287, 287, 510,
  0, 162, 162, 162, 287, 287, 0, 287, 0, 0, 0, 0, 0, 0, 26624, 28672, 0, 0, 139264, 0, 139264, 24576, 0, 0, 601, 162,
  605, 162, 162, 162, 162, 609, 162, 162, 162, 162, 162, 162, 162, 162, 610, 162, 162, 162, 162, 162, 162, 162, 644,
  646, 287, 287, 287, 287, 652, 287, 656, 287, 287, 287, 287, 661, 287, 287, 0, 0, 162, 162, 162, 287, 287, 0, 287, 0,
  0, 0, 0, 519, 162, 162, 51843, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 816, 287, 287, 0, 0, 162, 162, 162,
  287, 287, 347, 287, 0, 0, 0, 0, 0, 0, 869, 0, 0, 0, 0, 0, 0, 218, 218, 218, 287, 833, 834, 287, 287, 287, 287, 287,
  287, 287, 287, 287, 287, 287, 287, 287, 287, 1258, 287, 0, 0, 1078, 0, 162, 162, 162, 162, 162, 162, 162, 162, 162,
  162, 162, 1089, 287, 287, 1117, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 505, 287, 287, 218,
  218, 1141, 218, 1143, 0, 0, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 773, 162, 1155, 162, 162,
  162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 287, 934, 287, 287, 287, 287, 287, 287, 287, 287, 287, 961,
  287, 287, 287, 287, 287, 287, 162, 162, 162, 162, 1304, 162, 162, 162, 287, 287, 287, 1311, 287, 287, 287, 287, 287,
  682, 287, 287, 287, 287, 287, 287, 287, 0, 0, 0, 1060, 0, 0, 0, 0, 1065, 1367, 287, 287, 287, 1369, 162, 162, 287,
  287, 162, 287, 162, 287, 162, 287, 162, 162, 1359, 1360, 162, 162, 287, 287, 1363, 1364, 287, 287, 162, 162, 162, 162,
  1361, 162, 287, 287, 287, 287, 1365, 287, 162, 162, 162, 0, 184, 0, 0, 0, 0, 162, 0, 0, 0, 0, 0, 0, 0, 0, 0, 198, 0,
  0, 0, 198, 198, 198, 221, 221, 221, 213, 221, 213, 213, 244, 244, 244, 244, 244, 244, 244, 244, 244, 258, 244, 244,
  244, 244, 244, 244, 221, 244, 258, 258, 279, 279, 290, 279, 279, 279, 279, 279, 290, 279, 279, 279, 258, 279, 290,
  290, 290, 290, 290, 279, 290, 279, 290, 6145, 41112, 3, 4, 0, 0, 0, 0, 0, 160, 378, 218, 218, 218, 218, 218, 218, 218,
  218, 218, 0, 0, 0, 0, 0, 0, 0, 0, 287, 287, 511, 0, 162, 162, 162, 233954, 287, 0, 287, 0, 0, 0, 0, 0, 0, 26624,
  28672, 0, 195, 0, 195, 0, 24576, 216, 216, 578, 218, 218, 218, 218, 218, 218, 218, 0, 0, 0, 0, 0, 0, 0, 0, 0, 561152,
  561152, 561152, 561152, 561152, 561152, 561152, 0, 0, 587, 0, 0, 0, 0, 0, 0, 0, 0, 596, 162, 162, 162, 162, 162, 162,
  1003, 162, 162, 162, 162, 162, 162, 1008, 162, 162, 162, 617, 162, 618, 162, 162, 162, 162, 162, 162, 162, 162, 162,
  162, 162, 162, 927, 162, 162, 162, 645, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287,
  1126, 0, 0, 867, 0, 0, 979, 0, 0, 0, 982, 218, 218, 218, 218, 218, 218, 0, 0, 0, 162, 162, 162, 162, 162, 162, 162,
  162, 162, 998, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 1100, 162, 162, 1013, 162,
  162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 615, 162, 616, 0, 0, 0, 1067, 0, 218, 218, 218, 218, 1073,
  218, 218, 218, 218, 218, 218, 0, 0, 0, 162, 1200, 162, 162, 162, 162, 162, 162, 162, 1091, 162, 162, 162, 162, 162,
  162, 162, 162, 162, 162, 162, 162, 162, 627, 162, 162, 1232, 287, 0, 0, 0, 0, 0, 1192, 218, 218, 218, 218, 218, 0,
  162, 162, 0, 0, 162, 162, 162, 162, 162, 162, 162, 460, 162, 0, 287, 287, 0, 0, 0, 0, 1234, 1192, 218, 218, 1236, 218,
  218, 0, 162, 162, 0, 0, 162, 162, 162, 162, 162, 162, 162, 162, 462, 0, 287, 287, 0, 0, 162, 162, 162, 287, 287, 0,
  287, 0, 0, 0, 0, 0, 0, 0, 1132, 0, 0, 0, 218, 218, 1138, 218, 1284, 162, 162, 162, 162, 287, 287, 1291, 287, 287, 287,
  287, 287, 287, 0, 162, 162, 1336, 1337, 162, 162, 162, 162, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 1037,
  287, 0, 0, 199, 0, 0, 199, 26624, 28672, 199, 0, 0, 0, 0, 24576, 214, 214, 222, 222, 222, 238, 222, 238, 238, 238,
  238, 248, 248, 248, 248, 248, 248, 248, 259, 248, 248, 248, 248, 248, 248, 222, 248, 259, 259, 280, 280, 291, 280,
  280, 280, 280, 280, 291, 280, 280, 280, 310, 280, 291, 291, 291, 291, 291, 280, 291, 280, 291, 6145, 41112, 3, 4, 0,
  0, 0, 0, 0, 160, 161, 162, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 330, 0, 0, 0, 554, 0, 0, 0, 0, 0, 0, 0, 0, 218, 563,
  218, 218, 218, 218, 218, 218, 572, 218, 218, 218, 218, 218, 218, 218, 218, 218, 392, 0, 0, 0, 0, 0, 0, 177, 177, 177,
  0, 0, 0, 0, 337, 0, 339, 0, 0, 0, 0, 0, 0, 0, 538, 0, 0, 0, 0, 0, 0, 0, 549, 359, 0, 0, 0, 362, 0, 0, 0, 0, 218, 218,
  218, 369, 218, 218, 376, 218, 381, 218, 384, 218, 386, 218, 218, 218, 218, 0, 0, 0, 0, 394, 0, 0, 0, 699, 0, 705, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 350208, 0, 177, 0, 350208, 0, 397, 399, 0, 362, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 162, 162,
  162, 162, 162, 162, 162, 162, 162, 417, 162, 162, 426, 162, 432, 162, 435, 162, 162, 439, 441, 162, 162, 162, 162,
  162, 907, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 924, 162, 162, 162, 162, 162, 162, 162, 162, 397, 0, 162,
  162, 417, 162, 162, 435, 162, 441, 461, 0, 287, 287, 0, 0, 162, 162, 162, 483, 287, 0, 287, 0, 0, 0, 0, 0, 0, 26624,
  28672, 0, 210, 0, 210, 0, 24576, 210, 210, 287, 471, 287, 287, 480, 287, 488, 287, 491, 287, 287, 496, 499, 502, 287,
  287, 0, 0, 162, 162, 162, 485, 287, 0, 287, 0, 0, 0, 0, 0, 0, 811008, 0, 0, 0, 0, 0, 784384, 0, 0, 0, 0, 533, 0, 0,
  535, 0, 0, 0, 0, 0, 348, 0, 0, 0, 0, 0, 0, 26624, 28672, 0, 209, 0, 209, 0, 24576, 209, 209, 218, 218, 218, 218, 218,
  582, 218, 584, 0, 0, 0, 0, 0, 0, 0, 0, 0, 780288, 0, 0, 0, 536576, 0, 0, 162, 287, 287, 694, 0, 0, 0, 0, 0, 0, 0, 0,
  525, 707, 708, 0, 0, 0, 713, 714, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 542, 542, 721, 0, 218, 746, 218, 218, 218, 218,
  218, 218, 0, 0, 0, 0, 755, 756, 0, 0, 0, 164, 0, 0, 0, 164, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96456, 0, 96456, 96456, 694,
  694, 761, 162, 762, 763, 162, 162, 162, 162, 162, 162, 162, 771, 162, 162, 0, 0, 162, 162, 162, 162, 162, 162, 459,
  162, 445, 0, 287, 287, 0, 0, 162, 162, 162, 486, 287, 0, 287, 0, 0, 516, 0, 0, 0, 170, 0, 0, 0, 0, 0, 0, 0, 0, 177,
  162, 0, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 641, 162, 51843, 525, 774, 162, 162, 162, 162, 162, 779,
  162, 162, 781, 782, 162, 162, 162, 162, 787, 162, 805, 51843, 806, 287, 807, 287, 809, 287, 287, 287, 287, 287, 287,
  287, 287, 840, 287, 287, 287, 287, 287, 287, 287, 287, 819, 287, 287, 822, 287, 287, 287, 287, 287, 827, 287, 287,
  287, 830, 831, 832, 287, 287, 287, 287, 837, 287, 839, 287, 287, 287, 843, 287, 287, 287, 287, 287, 947, 287, 287,
  287, 287, 287, 287, 287, 287, 287, 287, 1045, 1046, 287, 287, 287, 287, 287, 287, 1053, 848, 0, 0, 162, 287, 0, 0,
  851, 0, 0, 0, 0, 0, 853, 0, 0, 0, 173, 174, 0, 162, 0, 0, 0, 0, 0, 0, 0, 0, 174, 0, 867, 0, 0, 0, 0, 0, 728, 0, 0,
  871, 872, 0, 218, 218, 218, 218, 0, 0, 0, 162, 1147, 162, 162, 162, 162, 162, 162, 1153, 218, 218, 878, 218, 218, 218,
  218, 218, 218, 218, 218, 218, 218, 218, 218, 889, 903, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162,
  162, 915, 162, 0, 162, 162, 162, 162, 162, 162, 162, 162, 162, 640, 162, 162, 51843, 525, 162, 930, 162, 162, 162,
  287, 287, 287, 287, 287, 287, 287, 939, 287, 287, 942, 287, 944, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287,
  287, 287, 287, 287, 663, 287, 955, 956, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 966, 287, 0, 0, 0,
  0, 1130, 0, 0, 0, 0, 0, 0, 218, 218, 218, 218, 0, 0, 0, 162, 162, 162, 162, 162, 162, 1150, 162, 162, 0, 0, 851, 0,
  853, 0, 0, 0, 0, 0, 0, 973, 0, 0, 0, 0, 0, 354304, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 765952, 563523, 563523, 563523,
  563523, 563523, 0, 978, 867, 0, 0, 0, 0, 0, 0, 218, 218, 218, 218, 218, 218, 218, 1075, 218, 218, 218, 218, 218, 218,
  218, 218, 992, 218, 218, 218, 0, 0, 0, 0, 0, 0, 162, 0, 0, 0, 0, 0, 172, 0, 0, 0, 0, 0, 0, 177, 162, 0, 162, 1011,
  162, 162, 162, 162, 1016, 162, 162, 1017, 162, 162, 162, 162, 162, 1022, 162, 0, 162, 162, 162, 162, 162, 162, 162,
  162, 639, 162, 162, 162, 51843, 525, 287, 287, 287, 1055, 287, 287, 287, 1058, 0, 0, 0, 0, 0, 0, 0, 0, 175, 0, 0, 0,
  177, 162, 0, 162, 0, 1077, 0, 0, 162, 162, 162, 162, 1084, 162, 162, 162, 162, 162, 162, 162, 162, 1094, 162, 162,
  162, 162, 162, 162, 162, 162, 1210, 162, 162, 162, 162, 162, 1216, 287, 1090, 162, 162, 162, 162, 162, 162, 162, 162,
  162, 162, 162, 162, 162, 162, 162, 1167, 287, 287, 287, 1118, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287,
  287, 689, 690, 0, 0, 287, 0, 0, 1129, 0, 0, 0, 1131, 0, 0, 0, 0, 218, 1137, 218, 218, 218, 218, 218, 218, 583, 218, 0,
  0, 0, 0, 0, 0, 0, 0, 356, 218, 366, 218, 218, 218, 218, 218, 218, 1140, 218, 1142, 0, 1144, 1145, 162, 162, 1148, 162,
  162, 162, 162, 162, 162, 162, 1209, 162, 162, 162, 162, 162, 162, 287, 287, 287, 287, 287, 287, 287, 287, 1035, 287,
  287, 287, 1154, 162, 162, 162, 1157, 1158, 1159, 162, 162, 162, 162, 1162, 162, 1165, 162, 287, 287, 0, 0, 0, 0, 700,
  0, 0, 0, 706, 525, 0, 0, 709, 287, 287, 1170, 287, 287, 287, 287, 287, 287, 287, 1175, 287, 1177, 287, 287, 287, 287,
  666, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 1253, 287, 1254, 287, 287, 287, 287, 287, 287, 287, 1181,
  1183, 287, 1185, 1186, 0, 0, 0, 0, 0, 0, 0, 0, 0, 218, 1070, 218, 218, 218, 218, 218, 218, 218, 218, 218, 0, 993, 0,
  0, 0, 0, 997, 1218, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 1231, 0, 0, 1192, 218,
  162, 162, 162, 162, 162, 162, 1266, 162, 162, 162, 162, 287, 287, 1030, 1031, 287, 287, 287, 287, 287, 287, 287, 287,
  825, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 1273, 287, 287, 287, 287, 287, 287, 1279, 1192, 162, 162, 162,
  162, 162, 428, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 625, 162, 162, 162, 162, 162, 162, 162, 162, 162,
  1288, 287, 287, 287, 287, 287, 287, 287, 287, 1297, 0, 162, 0, 162, 162, 162, 162, 162, 162, 162, 638, 162, 162, 162,
  162, 51843, 525, 162, 162, 162, 1303, 162, 162, 162, 162, 287, 287, 1310, 287, 287, 287, 287, 287, 162, 162, 162, 162,
  1350, 162, 287, 287, 287, 287, 1356, 287, 0, 1318, 162, 162, 162, 162, 1322, 162, 162, 162, 1326, 287, 287, 1328, 287,
  0, 0, 162, 287, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 724, 1357, 162, 162, 162, 162, 162, 162, 287, 287, 287,
  287, 287, 287, 162, 162, 162, 162, 162, 162, 287, 287, 287, 287, 287, 287, 162, 162, 162, 223, 223, 223, 208, 223,
  208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 260, 208, 208, 208, 208, 208, 208, 223, 208, 260, 260, 260,
  260, 292, 260, 260, 260, 260, 260, 292, 260, 260, 260, 260, 260, 292, 292, 292, 292, 292, 260, 292, 260, 292, 6145,
  41112, 3, 4, 0, 0, 0, 0, 0, 160, 161, 162, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 328, 0, 0, 0, 0, 728, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 733, 532, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 976, 566, 218, 218, 218, 218, 218, 218, 218, 218, 218,
  218, 218, 218, 218, 218, 218, 577, 218, 602, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162,
  162, 1248, 287, 0, 850, 162, 287, 0, 0, 851, 0, 0, 0, 0, 0, 853, 0, 0, 0, 235, 0, 235, 235, 235, 235, 235, 235, 235,
  235, 235, 235, 235, 0, 235, 235, 235, 235, 235, 235, 235, 235, 0, 0, 0, 0, 0, 0, 363, 0, 0, 218, 218, 218, 218, 218,
  218, 218, 218, 218, 573, 218, 218, 218, 218, 218, 218, 0, 0, 851, 0, 853, 0, 0, 0, 0, 971, 0, 0, 0, 0, 0, 0, 0, 592,
  0, 0, 0, 162, 162, 162, 162, 162, 218, 218, 218, 218, 991, 218, 218, 218, 218, 0, 0, 0, 0, 0, 0, 162, 0, 0, 0, 0, 0,
  192, 0, 0, 0, 162, 162, 162, 162, 1015, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 612, 162, 162, 162,
  162, 162, 1368, 287, 287, 287, 162, 162, 287, 287, 162, 287, 162, 287, 162, 287, 162, 1358, 162, 162, 162, 162, 287,
  1362, 287, 287, 287, 287, 162, 162, 162, 162, 162, 920, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 1243, 162,
  162, 162, 162, 287, 0, 0, 185, 0, 0, 0, 162, 0, 0, 0, 0, 0, 0, 185, 0, 0, 0, 318, 0, 0, 0, 335, 0, 218, 218, 367, 218,
  218, 218, 218, 0, 0, 0, 162, 162, 162, 162, 162, 162, 162, 1152, 162, 224, 224, 224, 239, 224, 239, 239, 239, 239,
  239, 239, 239, 239, 239, 239, 239, 261, 239, 239, 239, 239, 239, 239, 224, 239, 261, 261, 261, 261, 293, 261, 261,
  261, 261, 261, 293, 261, 261, 261, 261, 261, 293, 293, 293, 293, 293, 261, 293, 261, 293, 6145, 41112, 3, 4, 0, 0, 0,
  0, 0, 160, 523, 0, 525, 0, 0, 0, 0, 0, 0, 0, 0, 177, 177, 0, 0, 0, 0, 728, 0, 0, 0, 0, 0, 731, 0, 0, 0, 0, 0, 0,
  26624, 28672, 0, 174, 0, 174, 0, 24576, 215, 215, 1204, 162, 162, 1206, 162, 162, 162, 162, 162, 162, 162, 162, 162,
  162, 287, 1217, 162, 162, 1239, 162, 162, 162, 162, 162, 162, 162, 162, 1244, 162, 162, 162, 287, 287, 287, 287, 287,
  287, 287, 287, 1112, 287, 287, 287, 287, 287, 823, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 670, 287, 671,
  672, 287, 287, 287, 287, 287, 287, 287, 1250, 287, 287, 287, 287, 287, 1255, 287, 287, 287, 287, 287, 162, 162, 1348,
  1349, 162, 162, 287, 287, 1354, 1355, 287, 161, 162, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 331, 0, 360, 0, 0, 0, 0,
  0, 0, 0, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 743, 218, 218, 218, 415, 162, 162, 162, 162, 162, 162,
  162, 162, 162, 162, 162, 162, 162, 162, 162, 1009, 162, 448, 162, 0, 0, 162, 415, 162, 162, 162, 162, 162, 162, 162,
  0, 287, 287, 0, 0, 162, 162, 445, 287, 287, 0, 287, 0, 0, 0, 0, 0, 188, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 75776, 0, 0,
  0, 0, 469, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 675, 287, 508, 287, 0, 0, 415,
  162, 162, 287, 287, 0, 469, 0, 0, 0, 0, 0, 0, 26624, 28672, 207, 0, 0, 0, 0, 24576, 213, 213, 287, 678, 287, 287, 287,
  287, 287, 287, 287, 287, 287, 287, 287, 0, 0, 0, 0, 0, 0, 0, 1064, 0, 225, 225, 225, 240, 225, 240, 240, 245, 245,
  249, 250, 250, 250, 250, 250, 250, 255, 250, 262, 255, 250, 250, 250, 250, 250, 225, 250, 262, 262, 281, 281, 294,
  281, 281, 281, 281, 281, 294, 281, 281, 281, 262, 281, 294, 312, 294, 294, 294, 281, 294, 281, 294, 6145, 41112, 3, 4,
  0, 0, 0, 0, 0, 160, 162, 418, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 1247, 287, 287,
  472, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 1052, 287, 0, 586, 0, 588, 0, 0, 0, 0, 0,
  0, 0, 162, 162, 162, 599, 162, 0, 162, 162, 162, 162, 636, 162, 162, 162, 162, 162, 162, 642, 51843, 525, 287, 664,
  287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 1125, 287, 0, 0, 712, 0, 0, 0, 0, 0, 0, 0, 719,
  0, 0, 0, 0, 0, 0, 81920, 81920, 81920, 81920, 81920, 81920, 81920, 81920, 81920, 81920, 6145, 0, 3, 4, 0, 0, 0, 0, 0,
  160, 218, 218, 218, 748, 218, 218, 218, 218, 0, 0, 0, 0, 0, 0, 0, 0, 364, 218, 365, 218, 218, 218, 218, 218, 162, 162,
  162, 162, 792, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 783, 162, 162, 162, 162, 0, 0, 1066, 0, 0, 1069,
  218, 1071, 218, 218, 218, 218, 218, 218, 1076, 218, 218, 218, 218, 218, 571, 218, 218, 218, 218, 218, 218, 218, 218,
  218, 218, 0, 0, 0, 326, 0, 0, 162, 162, 162, 162, 1092, 162, 1093, 162, 162, 162, 162, 162, 162, 162, 162, 162, 624,
  162, 162, 162, 162, 162, 162, 162, 162, 1103, 287, 1105, 287, 287, 1108, 287, 287, 287, 287, 287, 287, 287, 287, 1121,
  287, 287, 287, 287, 287, 287, 287, 1116, 287, 287, 287, 287, 287, 287, 1120, 287, 287, 1122, 287, 287, 1124, 287, 287,
  0, 0, 162, 421, 162, 484, 287, 0, 287, 0, 0, 0, 0, 0, 0, 88064, 88064, 88064, 88064, 88064, 88064, 88064, 88064,
  88064, 88064, 0, 41112, 3, 4, 0, 0, 317, 0, 0, 160, 1139, 218, 218, 218, 0, 0, 0, 162, 162, 162, 162, 162, 162, 1151,
  162, 162, 0, 0, 162, 162, 162, 162, 456, 162, 162, 162, 162, 0, 287, 287, 0, 0, 162, 162, 162, 487, 287, 0, 287, 0, 0,
  0, 0, 0, 198, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 541, 0, 0, 0, 0, 1180, 287, 287, 287, 287, 287, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 218, 218, 736, 218, 218, 218, 218, 218, 741, 218, 218, 218, 744, 218, 218, 218, 218, 218, 218, 751, 218, 0, 0, 0,
  754, 0, 0, 0, 0, 162, 162, 162, 162, 162, 162, 162, 1087, 162, 162, 162, 162, 162, 430, 162, 162, 162, 162, 162, 162,
  162, 162, 446, 162, 162, 162, 1286, 1287, 162, 287, 287, 287, 287, 1293, 1294, 1295, 1296, 287, 0, 162, 162, 162, 162,
  162, 162, 162, 162, 162, 287, 287, 287, 287, 287, 287, 287, 287, 287, 0, 162, 1342, 1343, 287, 287, 287, 162, 162,
  162, 162, 162, 162, 287, 287, 287, 287, 287, 287, 1366, 162, 162, 162, 287, 287, 287, 287, 162, 162, 287, 287, 1372,
  1373, 162, 287, 162, 287, 162, 0, 162, 162, 162, 606, 162, 162, 162, 162, 162, 162, 162, 162, 51843, 525, 0, 0, 186,
  0, 0, 0, 162, 0, 0, 0, 0, 0, 0, 186, 193, 0, 0, 0, 725, 0, 0, 0, 0, 0, 218, 218, 218, 218, 218, 218, 218, 218, 882,
  883, 884, 218, 218, 218, 218, 218, 226, 226, 226, 241, 226, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241,
  263, 241, 241, 241, 241, 241, 241, 226, 275, 263, 263, 263, 263, 295, 263, 263, 263, 263, 263, 295, 263, 263, 263,
  263, 263, 295, 295, 295, 295, 295, 263, 295, 263, 295, 6145, 41112, 3, 4, 0, 0, 0, 0, 0, 160, 161, 162, 0, 0, 0, 0, 0,
  0, 0, 0, 326, 0, 0, 0, 0, 0, 0, 0, 162, 177, 177, 177, 0, 0, 0, 0, 0, 0, 0, 0, 0, 341, 0, 0, 0, 0, 728, 0, 0, 0, 0,
  730, 0, 0, 0, 0, 0, 0, 0, 558, 0, 0, 0, 0, 218, 218, 218, 218, 162, 162, 420, 162, 162, 162, 162, 162, 162, 162, 162,
  162, 162, 162, 162, 162, 628, 162, 162, 287, 287, 474, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287,
  287, 673, 287, 287, 287, 287, 679, 287, 287, 287, 287, 287, 287, 287, 687, 287, 287, 0, 0, 0, 0, 0, 1192, 218, 218,
  218, 218, 218, 0, 162, 162, 600, 287, 650, 0, 0, 0, 0, 0, 0, 0, 0, 0, 525, 0, 0, 0, 0, 0, 0, 0, 529, 177, 177, 0, 0,
  0, 162, 775, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 785, 162, 162, 162, 162, 51843,
  287, 287, 287, 287, 287, 811, 812, 287, 814, 287, 287, 287, 287, 287, 1119, 287, 287, 287, 287, 287, 287, 287, 287,
  287, 287, 842, 287, 287, 287, 287, 287, 162, 162, 162, 918, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162,
  162, 1020, 162, 162, 162, 0, 0, 0, 1079, 162, 162, 1082, 162, 162, 162, 162, 162, 162, 162, 162, 162, 797, 162, 162,
  162, 162, 162, 162, 162, 162, 162, 287, 287, 287, 1107, 287, 287, 287, 287, 287, 287, 287, 287, 287, 685, 287, 287,
  287, 0, 0, 0, 287, 0, 1128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 218, 218, 218, 218, 373, 218, 218, 287, 0, 162, 162, 1320,
  1321, 162, 162, 162, 162, 162, 287, 287, 287, 287, 1329, 1330, 287, 287, 287, 0, 1334, 162, 162, 162, 162, 162, 162,
  162, 1340, 287, 287, 0, 0, 162, 424, 162, 287, 287, 0, 287, 0, 0, 0, 0, 0, 198, 0, 0, 0, 0, 0, 0, 0, 356, 0, 0, 227,
  227, 227, 0, 227, 0, 0, 246, 246, 246, 246, 246, 246, 246, 246, 246, 264, 246, 246, 246, 246, 246, 246, 227, 246, 264,
  264, 264, 264, 296, 264, 264, 264, 264, 264, 296, 264, 264, 264, 264, 264, 296, 296, 296, 296, 296, 264, 296, 264,
  296, 6145, 41112, 3, 4, 0, 0, 0, 0, 0, 160, 162, 162, 421, 162, 162, 429, 162, 162, 162, 162, 162, 162, 162, 162, 162,
  162, 1212, 162, 162, 162, 287, 287, 287, 287, 475, 287, 287, 484, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287,
  686, 287, 287, 287, 0, 0, 0, 550, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 218, 218, 218, 218, 374, 218, 218, 287, 287, 287,
  680, 287, 287, 287, 287, 287, 287, 287, 287, 287, 0, 0, 0, 0, 0, 1062, 0, 0, 0, 633, 287, 651, 0, 0, 697, 0, 0, 0,
  703, 0, 0, 525, 0, 0, 0, 0, 0, 0, 528, 0, 177, 177, 0, 531, 0, 162, 162, 51843, 287, 287, 287, 287, 287, 287, 287,
  813, 287, 287, 287, 287, 287, 162, 1347, 162, 162, 162, 1351, 287, 1353, 287, 287, 287, 818, 287, 287, 287, 287, 287,
  287, 287, 287, 287, 287, 828, 287, 287, 287, 287, 287, 1222, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 0,
  1192, 162, 162, 162, 162, 162, 904, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 914, 162,
  162, 162, 162, 931, 162, 162, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 1123, 287, 287, 287, 287, 943,
  287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 1230, 287, 287, 287, 287, 287, 959, 287,
  287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 950, 287, 287, 287, 287, 287, 287, 1259, 0, 1192, 218, 162, 162,
  162, 162, 162, 162, 162, 162, 162, 1269, 162, 287, 287, 0, 0, 0, 699, 0, 0, 0, 705, 0, 525, 0, 0, 0, 0, 96456, 0,
  26624, 28672, 0, 0, 96456, 0, 96456, 24576, 0, 0, 228, 228, 228, 242, 228, 242, 242, 242, 242, 242, 242, 242, 242,
  242, 242, 242, 265, 242, 242, 242, 242, 242, 242, 228, 242, 265, 265, 282, 282, 297, 282, 282, 282, 282, 282, 297,
  282, 282, 282, 265, 282, 297, 297, 297, 297, 297, 282, 297, 282, 297, 6145, 41112, 3, 4, 0, 0, 0, 0, 0, 160, 161, 162,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 327, 0, 0, 0, 0, 161, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 177, 160, 160, 0, 379, 218, 218,
  218, 218, 218, 218, 218, 391, 218, 0, 0, 0, 0, 0, 0, 0, 858, 0, 0, 0, 0, 0, 0, 0, 0, 552, 0, 0, 0, 0, 218, 218, 218,
  162, 162, 0, 0, 412, 162, 162, 162, 430, 162, 162, 162, 162, 0, 287, 465, 710, 711, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 722, 0, 0, 890, 0, 0, 0, 0, 0, 0, 162, 897, 162, 162, 162, 162, 162, 162, 608, 162, 162, 162, 162, 162, 162,
  162, 162, 162, 436, 438, 162, 162, 445, 162, 162, 988, 218, 218, 990, 218, 218, 218, 218, 218, 0, 0, 0, 995, 0, 0,
  162, 0, 0, 0, 0, 0, 0, 218, 0, 162, 162, 162, 162, 287, 287, 287, 287, 287, 287, 1033, 287, 287, 1036, 287, 1038, 162,
  162, 162, 1014, 162, 162, 162, 162, 162, 162, 162, 162, 162, 1021, 162, 1023, 287, 1127, 0, 0, 0, 0, 0, 0, 0, 1133, 0,
  0, 1136, 218, 218, 218, 218, 0, 0, 0, 1146, 162, 162, 162, 162, 162, 162, 162, 162, 780, 162, 162, 162, 784, 162, 162,
  162, 162, 162, 162, 1156, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 287, 1290, 287, 287, 287, 287, 287,
  287, 287, 0, 162, 1168, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 1176, 287, 287, 287, 1179, 218, 1194, 1195,
  218, 218, 218, 0, 0, 0, 162, 162, 162, 1201, 1202, 1203, 162, 0, 162, 162, 162, 635, 162, 162, 637, 162, 620, 162,
  162, 162, 51843, 525, 287, 287, 1219, 1220, 1221, 287, 287, 287, 287, 287, 287, 1227, 287, 287, 287, 287, 287, 1251,
  287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 1225, 287, 287, 287, 1229, 287, 287, 162, 1285, 162, 162, 162, 287,
  287, 287, 1292, 287, 287, 287, 287, 287, 1298, 162, 0, 162, 162, 634, 162, 162, 162, 162, 162, 162, 162, 162, 162,
  51843, 525, 162, 162, 162, 162, 162, 1305, 162, 1307, 287, 287, 287, 287, 287, 287, 1314, 287, 0, 0, 162, 287, 0, 0,
  0, 0, 852, 0, 519, 0, 0, 0, 854, 1316, 0, 162, 162, 162, 162, 162, 162, 162, 162, 162, 287, 287, 287, 287, 287, 287,
  287, 287, 287, 287, 287, 287, 287, 162, 287, 287, 287, 287, 162, 162, 287, 287, 162, 287, 162, 287, 1376, 1377, 162,
  0, 162, 600, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 51843, 525, 229, 229, 229, 215, 229, 215, 215, 215,
  215, 215, 215, 215, 215, 215, 215, 215, 266, 215, 215, 215, 215, 215, 215, 229, 215, 266, 266, 266, 266, 298, 266,
  266, 266, 266, 266, 298, 266, 266, 266, 266, 266, 298, 298, 298, 298, 298, 266, 298, 266, 298, 6145, 41112, 3, 4, 0,
  0, 0, 0, 0, 160, 177, 177, 177, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 343, 0, 0, 0, 0, 0, 218, 218, 368, 218, 218, 375,
  218, 218, 218, 383, 218, 218, 218, 218, 389, 218, 218, 0, 0, 0, 0, 0, 0, 0, 970, 0, 0, 0, 0, 0, 974, 0, 0, 0, 0, 400,
  0, 0, 403, 0, 0, 0, 0, 400, 343, 343, 0, 0, 162, 162, 162, 162, 765, 766, 767, 162, 162, 162, 162, 162, 162, 162, 162,
  1308, 287, 287, 287, 287, 287, 287, 287, 0, 1059, 0, 0, 0, 0, 0, 0, 0, 0, 53248, 0, 0, 0, 0, 0, 0, 0, 0, 0, 416, 419,
  162, 425, 162, 162, 162, 434, 162, 162, 162, 162, 442, 444, 162, 162, 0, 0, 162, 162, 162, 423, 162, 162, 162, 162,
  162, 0, 287, 287, 0, 0, 414, 162, 162, 287, 287, 0, 468, 0, 0, 0, 0, 518, 470, 473, 287, 479, 287, 287, 287, 490, 492,
  287, 287, 287, 500, 503, 287, 287, 0, 1233, 0, 0, 0, 1192, 218, 218, 218, 218, 218, 0, 162, 162, 0, 0, 162, 162, 162,
  162, 428, 162, 162, 162, 162, 0, 287, 287, 0, 0, 162, 162, 162, 287, 287, 94208, 287, 0, 0, 0, 0, 0, 0, 729, 0, 354,
  0, 0, 0, 0, 0, 0, 0, 0, 75776, 0, 0, 75776, 0, 0, 0, 75776, 162, 162, 162, 162, 777, 162, 162, 162, 162, 162, 162,
  162, 162, 162, 162, 162, 799, 162, 162, 162, 162, 162, 162, 790, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162,
  162, 162, 162, 1098, 162, 162, 0, 523, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 865, 0, 162, 162, 162, 1104, 287,
  287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 844, 287, 287, 287, 287, 287, 287, 1171, 287, 287, 287, 287,
  287, 287, 287, 287, 287, 287, 287, 287, 952, 287, 287, 287, 0, 0, 1192, 218, 162, 162, 162, 162, 162, 1265, 162, 162,
  162, 162, 162, 287, 1029, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 659, 287, 287, 287, 287, 287, 287, 287,
  1272, 287, 287, 287, 287, 287, 287, 287, 0, 1192, 162, 1281, 162, 162, 0, 0, 162, 162, 162, 424, 162, 162, 162, 162,
  162, 0, 287, 287, 162, 287, 162, 287, 6145, 41112, 3, 4, 0, 0, 0, 0, 0, 160, 162, 287, 287, 287, 287, 162, 162, 287,
  287, 162, 287, 1374, 1375, 162, 287, 162, 0, 162, 633, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 51843, 525,
  0, 0, 267, 0, 0, 0, 0, 0, 0, 218, 0, 267, 267, 283, 283, 299, 283, 283, 283, 283, 283, 299, 283, 283, 283, 283, 283,
  299, 299, 299, 299, 299, 283, 299, 283, 299, 6145, 41112, 3, 4, 0, 0, 0, 0, 0, 160, 551, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 218, 218, 218, 218, 218, 218, 1074, 218, 218, 218, 218, 218, 218, 218, 570, 218, 218, 218, 218, 218, 218, 218, 218,
  218, 218, 218, 218, 886, 218, 218, 218, 162, 162, 162, 162, 607, 162, 162, 162, 162, 162, 162, 162, 613, 162, 162,
  162, 162, 162, 1002, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 925, 162, 162, 162, 162, 162, 287, 287, 287,
  665, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 964, 965, 287, 287, 692, 287, 693, 0, 0, 698, 0, 0,
  0, 704, 0, 0, 525, 0, 0, 0, 0, 0, 527, 0, 0, 177, 177, 0, 0, 0, 0, 0, 725, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 218, 218,
  218, 370, 218, 218, 218, 218, 218, 218, 218, 218, 880, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 0, 0, 0, 393,
  0, 0, 0, 0, 891, 0, 0, 0, 0, 0, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 786, 162, 162,
  162, 422, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 1164, 162, 287, 162, 449, 0, 0, 162, 162,
  162, 422, 162, 162, 162, 162, 162, 0, 287, 287, 287, 287, 681, 287, 287, 287, 287, 287, 287, 287, 287, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 218, 287, 287, 476, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 829, 287, 287, 287,
  509, 0, 0, 162, 422, 162, 287, 287, 0, 287, 0, 0, 0, 0, 520, 524, 0, 525, 0, 0, 0, 0, 0, 0, 0, 0, 177, 177, 0, 0, 0,
  0, 893, 0, 895, 895, 162, 162, 162, 898, 162, 900, 901, 162, 0, 175, 0, 0, 0, 0, 0, 0, 0, 0, 175, 0, 0, 0, 0, 0, 187,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 720, 0, 0, 0, 0, 0, 0, 175, 0, 0, 175, 26624, 28672, 175, 175, 0, 175, 0, 24576, 175,
  175, 268, 175, 175, 175, 175, 175, 175, 230, 175, 268, 268, 268, 268, 300, 230, 230, 230, 175, 230, 175, 175, 175,
  175, 175, 175, 175, 175, 175, 175, 175, 268, 268, 268, 268, 268, 300, 268, 268, 268, 268, 268, 300, 300, 300, 300,
  300, 268, 300, 268, 300, 6145, 41112, 3, 4, 0, 0, 0, 0, 0, 160, 161, 162, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 329, 0, 0,
  0, 347, 197, 198, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 110592, 0, 0, 0, 0, 0, 0, 0, 177, 177, 177, 0, 0, 0, 0, 0, 338, 0,
  0, 0, 0, 0, 0, 0, 0, 75776, 75776, 75776, 0, 0, 0, 0, 0, 218, 218, 218, 218, 385, 218, 218, 390, 218, 218, 0, 0, 0, 0,
  0, 0, 0, 86016, 0, 0, 86016, 86016, 0, 0, 0, 0, 162, 162, 162, 162, 619, 162, 162, 162, 162, 162, 162, 162, 162, 162,
  162, 162, 1006, 162, 162, 162, 162, 162, 539, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 51843, 525,
  162, 162, 162, 791, 162, 793, 162, 795, 162, 162, 162, 162, 162, 162, 162, 162, 623, 162, 162, 162, 162, 162, 629,
  162, 162, 162, 51843, 287, 287, 287, 808, 287, 287, 287, 287, 287, 287, 287, 287, 287, 1173, 287, 287, 287, 287, 287,
  287, 287, 287, 1278, 287, 0, 1192, 162, 162, 162, 162, 287, 287, 287, 821, 287, 287, 287, 287, 287, 287, 287, 287,
  287, 287, 287, 287, 1228, 287, 287, 287, 287, 849, 0, 162, 287, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 218, 218, 218, 218,
  218, 218, 218, 0, 0, 0, 892, 0, 0, 0, 0, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 770, 162, 162, 162, 287,
  287, 957, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 967, 968, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 53248, 162, 162, 162, 162, 1001, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 1019, 162, 162, 162,
  162, 0, 0, 1192, 218, 1261, 162, 162, 162, 162, 162, 162, 162, 1268, 162, 162, 1270, 1300, 162, 162, 162, 162, 162,
  162, 162, 287, 1309, 287, 287, 287, 287, 287, 287, 0, 0, 0, 0, 0, 1189, 0, 1191, 0, 218, 231, 231, 231, 216, 231, 216,
  216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 269, 216, 216, 216, 216, 216, 216, 231, 276, 269, 269, 284, 284,
  301, 284, 284, 284, 284, 284, 301, 284, 284, 284, 269, 284, 301, 301, 301, 301, 301, 284, 301, 284, 301, 6145, 41112,
  3, 4, 0, 0, 0, 0, 0, 160, 161, 162, 0, 0, 0, 0, 0, 0, 324, 0, 0, 0, 0, 0, 0, 0, 0, 86016, 0, 0, 86016, 0, 0, 0, 0,
  177, 177, 177, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 324, 380, 218, 218, 218, 218, 218, 218, 218, 218, 218, 0, 0, 0, 0,
  0, 396, 0, 0, 0, 396, 396, 0, 0, 0, 356, 396, 413, 162, 162, 0, 0, 413, 162, 162, 162, 431, 162, 162, 162, 162, 0,
  287, 466, 0, 0, 525, 0, 0, 526, 0, 0, 0, 0, 0, 177, 177, 0, 0, 0, 0, 1068, 218, 218, 218, 218, 218, 218, 218, 218,
  218, 218, 218, 885, 218, 218, 218, 218, 567, 218, 569, 218, 218, 218, 218, 218, 218, 218, 574, 218, 218, 218, 218,
  218, 218, 218, 752, 0, 0, 0, 0, 0, 0, 0, 0, 539, 0, 0, 0, 0, 0, 0, 0, 603, 162, 162, 606, 162, 162, 162, 162, 162,
  162, 162, 162, 162, 614, 162, 162, 0, 0, 162, 162, 162, 454, 162, 162, 162, 162, 162, 0, 287, 287, 0, 0, 162, 423,
  162, 287, 287, 0, 287, 0, 0, 0, 0, 0, 198, 0, 0, 0, 0, 0, 0, 0, 0, 0, 358, 287, 287, 287, 648, 287, 287, 654, 287,
  287, 658, 287, 287, 287, 287, 287, 287, 0, 0, 0, 0, 1188, 0, 0, 0, 0, 218, 917, 162, 162, 162, 162, 162, 162, 162,
  162, 162, 162, 162, 162, 162, 162, 162, 1215, 287, 287, 162, 162, 162, 162, 932, 933, 287, 287, 287, 287, 287, 287,
  287, 287, 287, 287, 1277, 287, 287, 0, 1192, 162, 162, 162, 162, 287, 287, 287, 958, 287, 287, 287, 287, 287, 287,
  962, 287, 287, 287, 287, 287, 482, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 0, 1192, 162, 162, 1282, 1283,
  218, 989, 218, 218, 218, 218, 218, 218, 218, 0, 0, 994, 0, 0, 0, 162, 0, 632, 162, 162, 162, 162, 162, 162, 162, 162,
  162, 162, 162, 51843, 525, 162, 1025, 162, 162, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 0, 0,
  1187, 0, 0, 0, 0, 0, 0, 218, 1101, 162, 162, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 1115, 287, 0, 0,
  162, 287, 0, 0, 0, 699, 0, 0, 0, 0, 0, 705, 0, 0, 0, 855, 856, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 545, 0, 0, 0, 218,
  218, 218, 218, 218, 1197, 0, 0, 0, 162, 162, 162, 162, 162, 162, 162, 768, 162, 162, 162, 162, 162, 162, 162, 162,
  162, 162, 1207, 162, 162, 162, 162, 162, 162, 162, 162, 162, 287, 287, 287, 287, 287, 287, 287, 1034, 287, 287, 287,
  287, 0, 0, 1192, 218, 162, 162, 162, 1263, 1264, 162, 162, 162, 162, 162, 162, 287, 287, 287, 287, 287, 287, 1110,
  287, 287, 287, 287, 287, 287, 0, 0, 0, 0, 0, 0, 1190, 0, 0, 1193, 287, 287, 287, 287, 1274, 1275, 287, 287, 287, 287,
  0, 1192, 162, 162, 162, 162, 162, 431, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 1018, 162, 162, 162, 162,
  162, 162, 287, 0, 162, 162, 162, 162, 162, 162, 1323, 162, 162, 287, 287, 287, 287, 287, 483, 287, 287, 287, 287, 287,
  287, 287, 287, 287, 287, 1048, 287, 287, 287, 287, 287, 287, 1331, 287, 287, 0, 162, 1335, 162, 162, 162, 162, 162,
  162, 287, 1341, 287, 0, 0, 162, 287, 0, 0, 851, 0, 0, 0, 0, 0, 853, 0, 0, 0, 0, 532480, 349, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 409, 410, 0, 0, 162, 0, 0, 180, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 172, 0, 172, 232, 232, 232, 0, 232,
  243, 243, 243, 243, 243, 243, 251, 251, 251, 251, 251, 243, 251, 270, 243, 251, 251, 251, 251, 251, 232, 251, 270,
  270, 285, 285, 302, 285, 285, 285, 285, 285, 302, 285, 285, 285, 311, 285, 302, 302, 302, 302, 302, 285, 302, 285,
  302, 6145, 41112, 3, 4, 0, 0, 0, 0, 0, 160, 177, 177, 177, 0, 0, 0, 336, 0, 0, 0, 0, 0, 0, 0, 0, 336, 0, 345, 346, 0,
  0, 198, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 765952, 563200, 563200, 563200, 563200, 563200, 218, 382, 218, 218, 218, 218,
  388, 218, 218, 218, 0, 0, 0, 0, 395, 0, 0, 0, 868, 0, 545, 0, 0, 0, 0, 0, 0, 0, 218, 218, 218, 218, 218, 218, 387,
  218, 218, 218, 0, 0, 0, 0, 0, 0, 0, 405, 0, 0, 0, 0, 0, 0, 0, 162, 175, 0, 0, 0, 175, 0, 0, 0, 175, 398, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 336, 0, 162, 162, 0, 0, 162, 162, 162, 455, 429, 162, 162, 162, 162, 0, 287, 287, 0, 0, 162,
  454, 162, 287, 287, 0, 287, 0, 0, 0, 0, 519, 162, 162, 162, 162, 427, 162, 433, 162, 162, 162, 162, 162, 443, 162,
  162, 162, 162, 162, 1208, 162, 162, 162, 162, 162, 162, 162, 162, 287, 287, 935, 287, 287, 287, 287, 287, 287, 287,
  287, 949, 287, 951, 287, 287, 287, 953, 287, 162, 162, 398, 450, 451, 162, 162, 162, 457, 162, 162, 443, 162, 0, 287,
  467, 0, 552, 0, 0, 0, 0, 557, 0, 0, 0, 0, 0, 218, 218, 218, 218, 738, 218, 218, 218, 218, 218, 218, 218, 218, 218,
  218, 0, 0, 0, 0, 0, 0, 162, 218, 579, 580, 218, 218, 218, 218, 218, 0, 0, 0, 0, 557, 0, 0, 0, 0, 1080, 162, 162, 162,
  162, 162, 162, 162, 162, 162, 162, 162, 912, 162, 162, 162, 162, 287, 287, 647, 287, 287, 287, 287, 287, 287, 287,
  287, 287, 287, 287, 287, 287, 845, 287, 847, 677, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 0, 0, 0,
  0, 1061, 0, 1063, 0, 0, 725, 0, 727, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 218, 218, 218, 218, 759, 760, 162, 162,
  162, 764, 162, 162, 162, 162, 162, 162, 162, 162, 772, 162, 162, 0, 0, 162, 162, 418, 162, 162, 162, 162, 162, 162, 0,
  287, 287, 0, 0, 162, 162, 461, 287, 514, 0, 287, 0, 0, 0, 0, 0, 0, 26624, 28672, 0, 208, 0, 208, 0, 24576, 208, 208,
  804, 162, 51843, 287, 287, 287, 287, 810, 287, 287, 287, 287, 287, 287, 287, 287, 653, 287, 287, 287, 287, 287, 287,
  287, 287, 287, 493, 495, 287, 287, 504, 287, 287, 287, 287, 820, 287, 287, 287, 287, 287, 287, 826, 287, 287, 287,
  287, 287, 287, 668, 287, 287, 287, 287, 287, 287, 287, 674, 287, 162, 162, 162, 162, 919, 162, 162, 162, 162, 162,
  162, 162, 162, 162, 162, 162, 1096, 162, 162, 162, 162, 977, 0, 0, 0, 0, 0, 0, 0, 0, 218, 218, 984, 218, 218, 218,
  987, 162, 162, 162, 1000, 162, 162, 162, 162, 162, 162, 1005, 162, 1007, 162, 162, 162, 162, 162, 1289, 287, 287, 287,
  287, 287, 287, 287, 287, 0, 162, 162, 162, 162, 162, 162, 162, 162, 287, 287, 287, 287, 287, 937, 287, 287, 287, 287,
  287, 162, 1012, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 1246, 162, 287, 162, 162, 162,
  162, 1028, 287, 287, 287, 287, 1032, 287, 287, 287, 287, 287, 287, 838, 287, 287, 287, 287, 287, 287, 287, 287, 287,
  657, 287, 287, 660, 287, 287, 287, 287, 287, 1040, 287, 1042, 287, 287, 287, 287, 1047, 287, 287, 287, 287, 287, 287,
  948, 287, 287, 287, 287, 287, 287, 287, 287, 287, 824, 287, 287, 287, 287, 287, 287, 287, 287, 960, 287, 287, 287,
  287, 287, 287, 287, 287, 655, 287, 287, 287, 287, 287, 287, 287, 287, 683, 287, 287, 287, 688, 287, 0, 691, 0, 162,
  162, 162, 287, 287, 287, 287, 287, 1109, 287, 1111, 287, 287, 1114, 287, 287, 287, 287, 836, 287, 287, 287, 287, 287,
  287, 287, 287, 287, 846, 287, 287, 1169, 287, 287, 287, 287, 287, 287, 1174, 287, 287, 287, 287, 287, 287, 287, 1044,
  287, 287, 287, 287, 1049, 287, 287, 287, 287, 287, 287, 287, 1184, 287, 287, 61440, 63488, 0, 0, 0, 0, 0, 0, 0, 218,
  734, 735, 218, 218, 218, 218, 740, 218, 742, 218, 218, 218, 745, 218, 218, 218, 218, 218, 1196, 218, 1198, 0, 0, 162,
  162, 162, 162, 162, 162, 162, 1004, 162, 162, 162, 162, 162, 162, 162, 1010, 162, 162, 1205, 162, 162, 162, 162, 162,
  162, 162, 162, 1213, 162, 162, 287, 287, 0, 0, 0, 0, 0, 0, 0, 0, 0, 525, 0, 0, 0, 0, 0, 0, 0, 0, 177, 177, 0, 0, 0,
  162, 1238, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 1245, 162, 162, 287, 287, 0, 695, 0, 0, 0, 701, 0, 0, 0,
  525, 0, 0, 0, 0, 0, 0, 0, 0, 177, 177, 530, 0, 0, 287, 287, 287, 1249, 287, 287, 287, 287, 287, 287, 287, 287, 1256,
  287, 287, 287, 287, 667, 287, 287, 669, 287, 287, 287, 287, 287, 287, 287, 676, 287, 1317, 162, 162, 162, 162, 162,
  162, 162, 162, 1325, 287, 287, 287, 287, 287, 485, 287, 287, 287, 287, 287, 287, 287, 287, 506, 287, 287, 287, 287,
  1333, 0, 162, 162, 162, 162, 162, 1338, 1339, 162, 287, 287, 287, 287, 162, 162, 287, 287, 162, 287, 162, 287, 162,
  287, 162, 287, 287, 1344, 1345, 287, 162, 162, 162, 162, 162, 162, 287, 287, 287, 287, 287, 287, 287, 287, 287, 941,
  287, 162, 287, 287, 287, 287, 162, 1370, 287, 1371, 162, 287, 162, 287, 162, 287, 162, 162, 0, 0, 162, 452, 453, 162,
  162, 458, 162, 442, 444, 0, 287, 287, 0, 0, 513, 162, 444, 287, 287, 0, 515, 0, 0, 0, 0, 0, 168, 0, 0, 168, 0, 0, 0,
  0, 0, 0, 0, 0, 718, 0, 0, 0, 0, 0, 0, 0, 0, 859, 0, 0, 0, 0, 0, 0, 0, 0, 896, 162, 162, 162, 162, 162, 162, 162, 162,
  923, 162, 162, 926, 162, 928, 162, 162, 233, 233, 233, 0, 233, 0, 0, 0, 247, 247, 247, 247, 247, 247, 247, 247, 271,
  247, 247, 247, 247, 247, 247, 233, 247, 271, 271, 271, 271, 303, 271, 271, 271, 271, 271, 303, 271, 271, 271, 271,
  271, 303, 303, 303, 303, 303, 271, 303, 271, 303, 6145, 41112, 3, 4, 0, 0, 0, 0, 0, 160, 177, 177, 177, 334, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 168, 0, 0, 0, 0, 0, 553, 0, 0, 0, 0, 0, 0, 0, 0, 0, 218, 218, 218, 218, 0, 0, 0, 162, 162,
  162, 1149, 162, 162, 162, 162, 162, 162, 908, 162, 162, 162, 162, 162, 162, 162, 162, 162, 910, 162, 162, 162, 162,
  162, 162, 631, 0, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 51843, 525, 0, 726, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 81920, 81920, 218, 218, 747, 218, 218, 218, 218, 218, 0, 0, 0, 0, 0, 0, 0, 0, 559, 0, 0, 0, 218,
  218, 218, 218, 162, 162, 51843, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 817, 287, 287, 287, 835,
  287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 1057, 0, 0, 0, 0, 0, 0, 0, 0, 0, 860, 861, 0, 0, 0, 0, 0,
  218, 877, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 888, 218, 162, 162, 162, 287, 287,
  1106, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 1223, 287, 287, 287, 287, 287, 287, 287, 287, 287, 1172, 287,
  287, 287, 287, 287, 287, 287, 287, 684, 287, 287, 287, 287, 0, 0, 0, 287, 0, 162, 162, 162, 162, 162, 162, 162, 1324,
  162, 287, 287, 287, 287, 287, 486, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 1224, 287, 287, 1226, 287, 287,
  287, 287, 287, 287, 287, 1332, 287, 0, 162, 162, 162, 162, 162, 162, 162, 162, 287, 287, 287, 287, 936, 287, 938, 287,
  940, 287, 287, 0, 0, 272, 0, 0, 0, 0, 0, 0, 218, 0, 272, 272, 272, 272, 304, 272, 272, 272, 272, 272, 304, 272, 272,
  272, 272, 272, 304, 304, 304, 304, 304, 272, 304, 272, 304, 6145, 41112, 3, 4, 0, 0, 0, 0, 0, 160, 162, 162, 423, 162,
  162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 1163, 162, 162, 287, 287, 287, 477, 287, 287, 287, 287,
  287, 287, 287, 287, 287, 287, 287, 287, 287, 1051, 287, 287, 218, 568, 218, 218, 218, 218, 218, 218, 218, 218, 218,
  218, 218, 218, 218, 218, 887, 218, 218, 585, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 162, 162, 162, 162, 162, 162, 162, 902,
  162, 604, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 1214, 162, 287, 287, 162, 162, 162,
  776, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 1211, 162, 162, 162, 162, 287, 287, 234, 234, 234,
  210, 234, 210, 210, 210, 210, 210, 210, 210, 210, 210, 210, 210, 273, 210, 210, 210, 210, 210, 210, 234, 210, 273,
  273, 273, 273, 305, 273, 273, 273, 273, 273, 305, 273, 273, 273, 273, 273, 305, 305, 305, 305, 305, 273, 305, 273,
  305, 6145, 41112, 3, 4, 0, 0, 0, 0, 0, 160, 162, 162, 162, 1027, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287,
  287, 287, 1252, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 1041, 287, 287, 287, 287, 287, 287, 287,
  287, 287, 287, 287, 287, 650, 287, 287, 287, 287, 287, 287, 287, 287, 662, 287, 287, 1054, 287, 287, 287, 287, 287, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 1134, 0, 218, 218, 218, 218, 0, 0, 274, 0, 0, 0, 0, 0, 0, 218, 0, 274, 274, 274, 274, 306,
  274, 274, 274, 274, 274, 306, 274, 274, 274, 274, 274, 306, 306, 306, 306, 306, 274, 306, 274, 306, 6145, 41112, 3, 4,
  0, 0, 0, 0, 0, 160, 162, 162, 424, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 1242, 162, 162,
  162, 162, 162, 287, 287, 287, 478, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 1178, 287, 287,
  162, 287, 287, 0, 696, 0, 0, 0, 702, 0, 0, 0, 525, 0, 0, 0, 0, 354304, 0, 26624, 28672, 0, 0, 354304, 0, 354304,
  24576, 0, 0, 161, 162, 0, 0, 0, 0, 0, 0, 0, 325, 0, 0, 0, 0, 0, 0, 173, 174, 0, 0, 0, 0, 177, 162, 0, 162, 162,
  254239, 287, 0, 0, 0, 0, 0, 0, 0, 0, 0, 525, 0, 0, 0, 0, 532480, 198, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86016, 0, 0,
  0, 287, 0, 0, 180386, 180511, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 546, 0, 0, 0, 218, 218, 218, 218, 879, 218, 218,
  218, 218, 218, 218, 218, 218, 218, 218, 218, 575, 218, 576, 218, 218, 218, 162, 162, 162, 905, 906, 162, 162, 162,
  162, 162, 162, 162, 162, 162, 162, 162, 909, 162, 911, 162, 913, 162, 162, 916, 287, 287, 287, 945, 946, 287, 287,
  287, 287, 287, 287, 287, 287, 287, 287, 287, 651, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 841, 287, 287,
  287, 287, 287, 287, 350208, 0, 0, 350208, 350208, 0, 0, 350208, 0, 0, 0, 0, 0, 350208, 350208, 0, 350208, 0, 0, 0, 0,
  0, 0, 0, 350208, 0, 0, 350208, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 732, 0, 0, 350208, 0, 350208, 0, 350208, 0,
  6145, 0, 3, 4, 0, 0, 0, 0, 0, 160, 354304, 354304, 0, 354304, 354304, 354304, 354304, 354304, 354304, 354304, 354304,
  0, 0, 0, 0, 0, 198, 0, 0, 0, 355, 0, 0, 0, 0, 0, 0, 0, 77824, 77824, 77824, 77824, 77824, 77824, 77824, 77824, 77824,
  0, 0, 354304, 0, 354304, 354304, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 160, 0, 0, 0, 356352, 0, 0, 204, 204, 0, 0, 0, 0, 0,
  204, 356352, 356352, 0, 356352, 356352, 356352, 356352, 356352, 356352, 356352, 356352, 0, 0, 0, 0, 0, 198, 351, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 532, 0, 0, 218, 218, 218, 218, 0, 0, 0, 356352, 0, 356352, 356352, 356352, 356352, 356352,
  356352, 356352, 356352, 356352, 356352, 356352, 0, 356352, 356352, 0, 356352, 356352, 6145, 0, 3, 4, 0, 0, 0, 0, 0,
  160, 0, 0, 0, 675840, 688128, 0, 765952, 804864, 0, 0, 0, 0, 0, 0, 0, 679936, 563200, 864256, 829440, 0, 698368,
  677888, 0, 0, 677888, 698368, 561152, 772096, 829440, 772096, 563200, 677888, 0, 716800, 0, 716800, 563200, 712704,
  716800, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 858112, 563200, 563200, 696320, 563200, 563200,
  563200, 563200, 563200, 729088, 737280, 563200, 563200, 563200, 563200, 563200, 563200, 811008, 563200, 563200,
  563200, 563200, 563200, 563200, 563200, 712704, 716800, 563200, 563200, 563200, 563200, 563200, 563200, 563200,
  858112, 0, 0, 563200, 563200, 563200, 563200, 0, 122880, 563200, 563200, 563200, 563200, 563200, 0, 563200, 122880, 0,
  0, 0, 0, 0, 137216, 0, 0, 0, 0, 0, 137216, 137216, 137216, 137216, 137216
);

(:~
 : The DFA-state to expected-token-set mapping.
 :)
declare variable $p:EXPECTED as xs:integer+ :=
(
  33, 80, 49, 65, 96, 112, 128, 141, 150, 150, 154, 170, 186, 202, 345, 218, 234, 250, 266, 282, 298, 314, 330, 361,
  377, 408, 393, 424, 440, 471, 456, 487, 500, 505, 509, 517, 516, 512, 521, 525, 529, 533, 537, 541, 547, 557, 561,
  665, 1113, 605, 1580, 583, 563, 590, 609, 610, 610, 599, 600, 600, 615, 624, 619, 564, 656, 610, 610, 1455, 600, 600,
  623, 631, 636, 610, 610, 675, 600, 645, 632, 657, 610, 568, 600, 572, 576, 580, 587, 564, 590, 1114, 610, 610, 596,
  600, 600, 601, 701, 600, 662, 672, 611, 600, 679, 686, 658, 600, 695, 611, 600, 682, 1457, 707, 674, 699, 705, 711,
  712, 716, 720, 725, 729, 733, 737, 741, 745, 749, 753, 757, 761, 767, 1177, 773, 846, 625, 625, 625, 625, 1013, 625,
  625, 1249, 625, 625, 625, 625, 625, 625, 1435, 625, 1077, 625, 625, 625, 625, 625, 625, 625, 625, 625, 625, 625, 625,
  625, 625, 625, 625, 920, 816, 779, 543, 785, 789, 793, 797, 801, 805, 809, 1307, 821, 1043, 625, 1055, 826, 975, 831,
  1234, 812, 836, 1264, 845, 625, 1324, 850, 625, 1351, 856, 625, 625, 887, 1522, 822, 893, 1322, 903, 625, 1549, 1206,
  907, 625, 896, 1407, 1143, 913, 1341, 919, 841, 932, 924, 1270, 944, 925, 952, 956, 966, 1040, 972, 984, 990, 1006,
  877, 874, 871, 880, 882, 883, 1010, 625, 625, 859, 625, 1017, 1021, 1025, 1029, 1033, 1037, 1301, 909, 1047, 1052,
  1059, 1065, 1069, 868, 1348, 1536, 1507, 1377, 1126, 1087, 641, 1104, 1380, 1076, 651, 627, 1081, 625, 654, 1091,
  1048, 775, 1102, 1095, 1100, 1316, 625, 1108, 625, 625, 899, 1124, 1084, 639, 1393, 626, 1112, 1118, 625, 915, 1122,
  1130, 986, 1141, 1134, 1139, 908, 1355, 1147, 1153, 1171, 1158, 781, 1433, 1168, 1172, 1176, 1203, 1181, 1566, 1135,
  1185, 1572, 1212, 1466, 1189, 1464, 996, 1196, 1200, 1192, 1210, 625, 625, 980, 1002, 1149, 1216, 1220, 1223, 1227,
  1231, 625, 1238, 1247, 648, 862, 1495, 1061, 1253, 1257, 1261, 1243, 1524, 832, 625, 1096, 553, 625, 929, 1541, 936,
  851, 1154, 940, 1072, 1548, 943, 625, 1287, 948, 1268, 1274, 625, 1560, 1280, 914, 1436, 1284, 625, 1291, 625, 625,
  1295, 625, 1386, 1299, 1305, 625, 1311, 625, 999, 1315, 1370, 1300, 774, 1320, 1328, 625, 1335, 550, 1339, 1519, 962,
  1401, 1405, 763, 1411, 1415, 1419, 1423, 1430, 1440, 1444, 1448, 1426, 1452, 689, 625, 1345, 1359, 889, 1365, 1339,
  1369, 1374, 1384, 668, 1390, 1241, 959, 1385, 1397, 1361, 1142, 1461, 1472, 1476, 1480, 1484, 1488, 1492, 625, 1353,
  827, 1499, 1501, 968, 625, 1505, 1511, 1516, 625, 1275, 1512, 625, 1164, 1160, 625, 625, 1528, 1579, 625, 1530, 1529,
  978, 898, 625, 817, 1553, 1512, 769, 1547, 592, 1557, 625, 865, 625, 625, 1276, 839, 625, 1500, 1164, 1162, 625, 993,
  1578, 625, 626, 1534, 814, 625, 1540, 1545, 625, 1468, 1564, 625, 691, 840, 1330, 625, 691, 1579, 1331, 852, 840,
  1570, 1576, 625, 625, 625, 625, 723, 1702, 1584, 1586, 1592, 1595, 1603, 1607, 1625, 1617, 1625, 1625, 1620, 1625,
  1625, 1625, 1613, 1624, 1609, 1625, 1629, 1651, 1678, 1679, 1679, 1657, 1654, 1660, 1663, 1683, 1687, 1691, 1694,
  1696, 1700, 1704, 1783, 1708, 1637, 1586, 1586, 1587, 2815, 1716, 1586, 1973, 1586, 1586, 2585, 2262, 2172, 2288,
  2256, 2142, 1726, 1734, 1971, 2139, 1586, 1741, 1742, 1742, 1742, 1742, 1828, 1777, 1777, 1867, 1762, 1778, 1666,
  1784, 1818, 1586, 2260, 2263, 1972, 1586, 2143, 2830, 1788, 2813, 2138, 1789, 1586, 2141, 1742, 1742, 1586, 1586,
  1587, 2835, 1775, 1777, 1777, 1866, 1849, 1849, 1849, 1849, 1852, 1780, 1816, 1816, 1829, 2056, 1777, 1777, 1777,
  1777, 1778, 1793, 1668, 1816, 1816, 1802, 2830, 2813, 2168, 1814, 1670, 1586, 1586, 1586, 1586, 1587, 2449, 1831,
  1586, 2168, 1742, 1742, 1742, 1742, 2171, 2150, 2484, 1586, 1586, 1783, 2455, 1849, 1850, 1854, 1586, 1586, 2714,
  1586, 1587, 2445, 1586, 1597, 1586, 1586, 1777, 1777, 1777, 1779, 1852, 1586, 2138, 1742, 1742, 1746, 1586, 1586,
  2682, 2462, 1742, 2150, 1777, 1777, 1849, 1849, 1849, 1849, 1851, 1586, 2166, 1777, 1777, 1778, 1742, 2170, 1776,
  1777, 1829, 1586, 1586, 2334, 1586, 1781, 2138, 1742, 1826, 1842, 1777, 1778, 1849, 1849, 1849, 1849, 1776, 1777,
  1848, 1849, 1841, 1849, 1864, 1778, 1849, 1864, 1848, 1846, 1862, 1862, 1782, 1642, 1871, 1586, 1599, 1872, 1876,
  1885, 1911, 1891, 1925, 1925, 1897, 1918, 1887, 1909, 1915, 1925, 1893, 1929, 1924, 1921, 1933, 1941, 1945, 1948,
  1955, 1959, 1959, 1963, 1977, 1981, 1985, 2844, 1925, 1951, 1992, 1996, 2000, 1586, 2010, 1586, 2721, 2263, 1586,
  2695, 2150, 1647, 2021, 1586, 1586, 1587, 2848, 2373, 1586, 1586, 1586, 1642, 2459, 1972, 1636, 1586, 1586, 1632,
  1586, 2060, 1586, 1586, 2310, 2814, 2308, 2796, 1900, 2064, 2067, 2070, 2072, 2076, 2087, 2089, 2079, 2082, 2083,
  2093, 2097, 2100, 2104, 1586, 1638, 2051, 1586, 1634, 1586, 1635, 1586, 1586, 1638, 1586, 1586, 1586, 1736, 2311,
  1586, 1586, 2172, 2259, 2134, 1586, 1586, 1586, 2012, 1937, 1586, 1586, 1586, 2024, 2147, 1586, 2263, 1586, 1642,
  1586, 1586, 1586, 2860, 2802, 1586, 1586, 1586, 2028, 2724, 1585, 1586, 1586, 1586, 2033, 2440, 2187, 2726, 1586,
  1642, 2372, 1586, 1729, 2579, 1586, 1737, 2836, 1586, 1765, 2405, 1586, 1769, 1586, 1768, 1586, 1767, 1586, 1830,
  1770, 1586, 1830, 1770, 1830, 1770, 1768, 2360, 2211, 2191, 1586, 1586, 1642, 2648, 1821, 2198, 1853, 1586, 1837,
  1586, 1586, 1644, 1586, 2473, 2799, 2221, 2639, 2208, 2727, 1586, 1586, 1586, 2038, 2415, 2233, 2259, 1586, 1586,
  1586, 2039, 2641, 1586, 1586, 1586, 2050, 2642, 1586, 1586, 1586, 2120, 2153, 2639, 2643, 1586, 1855, 2277, 2227,
  1585, 1856, 2461, 2229, 2262, 2291, 2256, 1586, 1857, 2751, 2642, 1586, 2257, 1586, 2153, 2640, 2293, 2259, 2151,
  2294, 2237, 1586, 2737, 1586, 1881, 2263, 1586, 1903, 2263, 2003, 1858, 2271, 1586, 1586, 1646, 1587, 2269, 2259,
  2821, 1586, 1936, 2137, 1586, 1639, 1586, 1586, 2410, 2414, 2275, 2286, 1586, 1586, 1646, 1805, 2401, 2298, 2259,
  1586, 1987, 2836, 1586, 2012, 2031, 1586, 2012, 2602, 1586, 2017, 1586, 2111, 2302, 1586, 1586, 1767, 2360, 2360,
  2362, 1586, 2037, 1966, 2043, 2315, 2326, 1586, 2429, 2332, 1901, 2850, 2339, 1749, 1752, 2346, 2350, 2352, 1755,
  2351, 1758, 2356, 2356, 2356, 2366, 2356, 2356, 2359, 1586, 2119, 2305, 2259, 2108, 2575, 2116, 2360, 1586, 1901,
  1586, 2736, 2736, 1586, 2022, 1586, 2124, 1586, 2130, 2377, 2400, 1586, 1586, 1672, 2613, 2385, 1771, 2536, 2380,
  2389, 2395, 2399, 1586, 2152, 2517, 2643, 2434, 1586, 1586, 1586, 2138, 2453, 2651, 2519, 1586, 2193, 2478, 1586,
  2194, 2747, 2433, 1645, 2038, 2474, 1770, 2509, 1586, 1586, 1586, 2149, 2489, 2467, 2480, 1586, 1586, 1820, 2534,
  2438, 1728, 2494, 2467, 2216, 2500, 1586, 1586, 1586, 2150, 1777, 1587, 2493, 2515, 2163, 1641, 1646, 1586, 1586,
  1901, 1586, 2738, 1586, 2852, 1810, 1586, 2484, 2498, 1586, 1586, 1586, 2318, 2498, 1805, 1809, 1586, 1586, 1586,
  2172, 2288, 2264, 2509, 1586, 2264, 2015, 2180, 1807, 1586, 1586, 1586, 2322, 2513, 1808, 1586, 1586, 1902, 1879,
  1586, 1586, 1987, 2813, 2595, 1810, 1586, 1730, 1586, 1586, 1587, 2523, 1810, 1586, 1586, 1637, 1586, 2023, 1809,
  1587, 2033, 1810, 2619, 1586, 2032, 2545, 2033, 2030, 2011, 2013, 1586, 2011, 2541, 1586, 2013, 2033, 2391, 1586,
  2013, 1586, 2214, 2508, 1586, 2220, 2225, 2229, 2014, 2014, 1586, 1586, 2013, 2032, 2698, 2016, 2017, 2183, 2342,
  2559, 2555, 2558, 2552, 2558, 2563, 2566, 2567, 2567, 2571, 2567, 2567, 2573, 1586, 2247, 1586, 2249, 2412, 1586,
  2262, 1586, 2260, 1586, 1586, 2264, 2413, 2140, 2690, 1586, 1586, 2140, 1586, 2583, 2126, 1586, 2590, 2400, 1586,
  1672, 2599, 2593, 1586, 1712, 1586, 2290, 2381, 1822, 1729, 2607, 1585, 1586, 2859, 1586, 2547, 1639, 1586, 1586,
  1586, 2335, 1586, 2617, 1586, 2623, 2627, 2631, 2236, 1586, 2321, 2119, 2292, 2585, 2603, 2138, 2689, 1586, 2637,
  2149, 1639, 2281, 2149, 1586, 1586, 1586, 2370, 2655, 2259, 1586, 1586, 2148, 1586, 2660, 2649, 2631, 2258, 1722,
  1586, 1586, 1586, 2499, 2666, 2282, 1586, 1586, 2157, 1586, 2799, 2441, 1586, 2656, 1586, 1586, 2204, 1586, 1586,
  2664, 2650, 2632, 2259, 2139, 2691, 1586, 1586, 2241, 2279, 1642, 2666, 2200, 1586, 2419, 2408, 1586, 2177, 1586,
  1586, 1641, 1586, 1586, 2504, 1586, 2672, 1586, 1586, 2262, 1586, 2463, 1586, 1586, 2112, 2677, 1586, 1586, 1586,
  2586, 1586, 2681, 2668, 1586, 2427, 2361, 1586, 2193, 2451, 2749, 1586, 2673, 1586, 1586, 1586, 2647, 2149, 2260,
  2138, 1586, 2488, 2515, 1809, 1881, 2469, 1586, 1718, 2141, 1586, 1586, 1904, 2686, 2160, 1586, 1586, 2321, 2260,
  2006, 1586, 1586, 1905, 2006, 2141, 1586, 2055, 2006, 1586, 2251, 1720, 2052, 2003, 2141, 2250, 2712, 2252, 2250,
  2704, 2053, 2004, 1586, 2506, 2141, 1586, 1586, 1586, 1674, 2251, 2705, 2054, 2005, 1586, 2702, 2141, 2709, 2141,
  2251, 2141, 2252, 2718, 1798, 1796, 1777, 1848, 1849, 1849, 1835, 1777, 1968, 1638, 2731, 1586, 2546, 1586, 2540,
  1586, 1586, 1988, 2837, 2172, 1970, 2734, 2244, 2173, 1586, 2742, 2745, 2755, 2758, 2762, 2765, 2769, 2773, 2768,
  2786, 2776, 2807, 2779, 2790, 2806, 2782, 2793, 1586, 2548, 1640, 1599, 1710, 2265, 1586, 1586, 1586, 2811, 2045,
  2837, 1586, 1586, 2371, 1586, 2819, 1586, 1586, 1586, 2813, 2328, 2837, 1587, 1586, 2585, 2200, 1586, 2322, 2261,
  1586, 2140, 2691, 2046, 2838, 1586, 1586, 1586, 2825, 2834, 2838, 1586, 1586, 2423, 1586, 2813, 1586, 1586, 1586,
  2858, 1987, 2843, 1588, 1586, 1586, 1586, 2859, 1586, 2835, 2839, 1586, 1640, 2839, 1586, 1645, 1586, 2611, 2667,
  2633, 2202, 2856, 1586, 1586, 2527, 1810, 1642, 2033, 1586, 1586, 2531, 1586, 1642, 1586, 1586, 1643, 1586, 1586,
  1586, 2828, 268435456, -2147483648, 0, 0, 0, 0, 1, 0, 262208, -2147483584, 268451840, 16384, 16384, 134217728, 0, 0,
  0, -2147483648, 0, 32768, 32832, 134234112, 16384, 33587200, -2147450880, 32768, 32768, 134288128, 75008, 1048576,
  294976, 32832, 33849344, 32768, 32792, 33849344, -2147450880, -2147450880, -2147450880, -2147450880, -2147483400,
  32768, 32768, 32768, 32768, 32768, 8456448, 32768, 32768, 2, 0, 0, 512, 32768, 0, 0, 0, 2, 0, 0, 0, 4, 0, 0, 0, 8,
  262144, 131072, 163840, 163840, 67141632, 67141632, -2080342016, 67141632, 67141632, 262144, 67141632, 67272704,
  67141632, -2113634304, 262144, 278528, 17039360, 48, 17039360, 0, 64, 64, 0, 0, 1, 6, 16, 128, 163904, 67141632,
  67141632, 67141632, 67141632, 294912, 1610874880, 278528, -2147188736, 294912, 17072128, 1610907648, -2147188736,
  294912, -2147221256, 1610907648, 17072128, -2130411272, -2130411272, -2130411272, 67403776, -2130411272, 67403776,
  -2063302408, 4, 524288, 2097152, 4194304, 268435456, 0, 64, 262144, 16384, 0, 0, 0, -1610612736, 0, 1048576, 1048576,
  1048576, 0, 8388608, 0, 8388608, 0, 134217728, 67108864, 56, 128, 0, 0, 1, 2, 16, 0, 512, 65792, 0, 0, 1, 4, 8, 0,
  131072, 131072, 131072, 131072, 131072, 131072, 67108864, 0, -2147479540, -2147479540, -1551543988, -1551543988,
  -1576972212, -1551543988, -1550492212, -1549446836, -1551543988, -1283108532, -1550492212, -1550492212, 17039360,
  17039360, 1610612736, 0, -1342177280, 0, 0, 128, 268435456, 0, 0, 0, 33816576, 262144, 0, 262144, 262144, 262144,
  262144, 17039360, 17039360, 0, 0, 0, 64, 64, 65536, 256, 256, 256, 0, 17039360, 536870912, 1073741824, 262144, 0,
  262144, 0, 0, 65536, 128, 128, 128, 128, 256, 3072, 1048576, 8388608, 16777216, 0, 0, 0, 536870912, 1073741824, 64,
  64, 64, 64, 262144, 0, 0, 256, 256, 1024, 131072, 0, 262144, 262144, 0, 0, 0, 128, 128, 17039360, 17039360, 0,
  8388608, 8388608, 65536, 17039360, 17039360, 0, 262144, 262144, 17039360, 262144, 262144, 17039360, 17039360,
  17039360, 17039360, 536870912, 1073741824, 0, 0, 0, 192, 1024, 4096, 262144, 17039360, 262144, 17039360, 262144,
  262144, 262144, 16777216, 17039360, 17039360, 2048, 268435456, 536870912, 0, 1, 536936448, 8, 8, 1, 0, 0, 0, 4096,
  98304, 536936448, 8, 8, 10, 10, 12, 2097160, 268435464, 8, 8, 1048584, 268435464, 8, 262152, 8, 8, 0, 8, 0, 0, 0,
  98304, 262144, 1048576, 536, 2097176, 24, 520, 524296, 1048584, 520, 1048584, 8, 8, 24, 8, 8, 0, 1049112, 520, 8, 8,
  8, 8, 8, 1049112, 2097176, 24, 2097688, 2146328, 520, 0, 0, 5568, 4128768, -33554432, 1, 520, 8, 2670616, 520,
  2670618, 163577856, 2097688, 0, 8, 8, 56, 146804738, 10, -161480168, 24, -161480168, -161479016, -161478984,
  -161478984, -161478984, -161478984, -161429832, -160430248, -161429832, 0, 0, 8192, 0, 0, 1024, 0, 0, 0, 16, 24,
  -160430246, -161429830, -160905544, -161429830, -160905542, -161429830, -161429830, -161429830, 8, 131080, 0, 0, 1, 8,
  16, 2097176, 49160, 146812938, 146863246, 146863262, 146863246, 146863246, -161429830, 148960414, -160905542,
  -18860390, 0, 0, 262144, 4194304, 8388608, 0, 0, 4, 2048, 0, 0, 0, 2048, 0, 0, 524288, 0, 0, 0, 12, 0, 0, 0, 3072, 0,
  100663296, -1073741824, 0, 0, 1, 16, 0, 0, 0, 142606336, 0, 0, 0, 32768, 1073741824, 243269632, 2048, 0, 0, 1, 24, 32,
  2, 65536, 0, 0, 0, 65536, 0, 0, 262144, 262144, 512, 2048, 32768, 67174400, 605094928, 605095184, 1679230208,
  1679230208, 605095184, 1679230208, 605095184, 1678837008, 1678837008, 1678837008, 1679099152, 1679099153, 1679230224,
  1679230224, 1678839057, 1679230232, -31521312, -31521312, -29420096, -29420096, -29420096, -29420096, -29420092,
  -31521344, 1678839057, 1679230232, 1679230232, 1679230232, 1679230232, -29420096, -29420096, -29420096, -21031456,
  -29420096, -29420092, -29420092, -21031452, -21031452, -21031452, -21031452, -29420072, -21031452, -29420072,
  -21031436, 0, 1114112, 603979776, 0, 0, 524288, 1048576, 0, 1280, 1507328, 1677721600, 0, 0, 1048576, 1024, 536870912,
  0, 1677721600, 0, 0, 1, 202375168, 0, 1376256, 1507328, 3328, 0, 1472, 2031616, -33554432, 0, 0, 0, 8388608, 0, 0, 0,
  48, 32, 0, 2048, 67108864, 0, 0, 0, 262144, 192, 1024, 262144, 0, 0, 1073741824, 0, 0, 1048576, 8388608, 16777216,
  67108864, 0, 0, 8388608, 131072, 131072, 131072, 0, 0, 0, 1024, 1024, 4096, 3145728, -2147483648, 0, 0, 8388608,
  524288, 67635200, 0, 67635200, 4096, 458752, 524288, 3145728, 11534336, 65536, 0, 0, 4, 8, 64, 1024, 458752, 1048576,
  67108864, 0, 0, 4, 16, 32, 0, 939524096, 1073741824, -2147483648, 0, 0, 11534336, 0, 0, 8388608, 16777216, 67108864,
  -2147483648, 0, 192, 256, 1024, 458752, 4096, 458752, 524288, 1048576, 2097152, 33554432, 67108864, 939524096, 65536,
  393216, 1048576, 67108864, 536870912, -2147483648, 0, 0, 262144, 393216, 192, 1024, 0, 4096, 0, 0, 12517376, 0, 0,
  65536, 262144, 4194304, 0, 262144, 1048576, 67108864, 536870912, 0, 0, 0, 1048576, 0, 0, 0, 256, 0, 128, 1024,
  1048576, 402653184, 536870912, -2147483648, 0, 128, 1024, 4096, 65536, 393216, 524288, 1048576, 16777216, 33554432,
  67108864, 1048576, 402653184, 536870912, 0, 0, 1024, 536870912, 0, 1024, 262144, 1048576, 402653184, 0, 536870912,
  128, 402653184, 0, 128, 402653184, 536870912, 0, 1024, 1048576, 16, 0, 1048576, 2560, 0, 0, 2097152, 0, 2097152, 0, 0,
  16777216, 0, 0, 67108864, 0, 0, 0, 1073774592, 0, 0, 5, 24, 1073774592, 268435456, 0, 0, 16, 32, 512, -2147479552, 0,
  -2147479552, 0, 0, 68684800, 68684800, -1576972212, -1576972212, -1576710068, -1576710068, -1559932596, -1551543988,
  -1551543988, -1551543988, -1551543988, -1549446836, -1482859041, -1482859041, -1482859041, -1482859041, 0, 0, 0,
  268435456, 0, 0, -1550492210, -1482859041, -1482859041, -1348510241, 0, 4, 2097152, 0, 0, 0, 159383552, 332, 4096,
  81920, 58982400, 0, 0, 0, 603979776, 76, 81920, 33554432, -1610612736, 0, 61079552, 0, 0, 16, 2048, 0, 460, 7168,
  81920, 60030976, -1610612736, 0, 0, 0, 536870912, 0, 1, 478, 127664128, -1610612736, 0, 0, 256, 2048, 524288,
  1073741824, 0, 0, 2, 1, 478, 7168, 81920, 462, 0, 127795200, 134217728, 32768, 1073741824, 0, 2, 0, 2097152, 262144,
  25165824, 33554432, -1610612736, 0, 0, 27262976, 0, 0, 448, 1024, 458752, 6, 24, 524288, 67108864, 6, 24, 64, 128,
  256, 7168, 16384, 65536, 33554432, -1610612736, 8, 256, 4096, 262144, 524288, 1048576, 12582912, 67108864, 3072, 4096,
  262144, 1048576, 12582912, 0, 32768, 1073741824, 2, 0, 0, 256, 262144, 8388608, 16777216, -2147483648, 0, 0, 256,
  16777216, 8388608, 0, 4, 8, 128, 256, 2, 4, 24, 128, 256, 0, 1, 2, 24, 67108864, 0, 0, 256, 8388608, 16777216, 0,
  16777216, 8388608, 0, 0, 2, 16, 256, 3072, 262144, 1048576, 33554432, 67108864, -1610612736, 0, 2, 16, 3072, 8388608,
  1, 16, 3072, 8388608, 1, 16, 3072, 16777216, 25165824, 0, 0, 332, 50593792, 0, 1, 16, 2048, 0, 0, 2048, 0, 1, 16,
  -2147483648, 0, -2078798829, -2078798829, -2028348393, -2078798829, -2078798831, -2078798831, -2078798829,
  -2078798829, -2078798829, -2078798829, 68684817, -2078798829, -2078798829, -1944581101, -2028348393, -1478632297,
  -1478632297, -1478632297, -1478632297, -1478632297, -1491215337, -1478632297, -1478632297, 0, 0, 1280, 0, 3072,
  524288, 68157440, -2147483648, 118489088, -2147483648, 0, 0, 2048, 524288, 1048576, 0, 144, 376832, 131072000,
  -1610612736, 0, 0, 3072, 8388608, 144, 7168, 376832, 524288, 1073741824, 0, 1048576, 0, 3072, 524288, 1048576,
  67108864, 1, 6, 16, 7168, 114688, 524288, 0, 201326592, 0, 0, 3072, 16777216, 0, 128, 360448, 12582912, 7168, 16384,
  360448, 524288, 1048576, 12582912, 16777216, 33554432, 67108864, -2147483648, 2, 2048, 524288, 1048576, 33554432,
  67108864, 939524096, -2147483648, 0, 0, 6, 6144, 16384, 98304, 262144, 524288, 1048576, 25165824, 0, 128, 262144,
  12582912, 536870912, 0, 6, 128, 6144, 4, 128, 6144, 16384, 98304, 524288, 1048576, 67108864, 0, 262144, 12582912, 0,
  0, 0, 524288, 1048576, 67108864, 0, 4, 4096, 16384, 98304, 1048576, 4194304, 8388608, 0, 0, 134217728, 67108864, 0, 0,
  0, 98304, 1048576, 0, 0, 134217728, 67635200, 65536, 262144, 4194304, 8388608, 8388608, 0, 0, 65536, 0, 262144,
  4194304, 0, 0, 0, 3072, 68157440, 4194304, 0, 0, 65536, 0, 8, 524288, 1048576, 1040187392, 1073741824, -2147483648, 0,
  0, 1024, 1024, 4096, 1024, 1024, 0, 0, 4096, -2147483648, 0, 0, 8192, 4096, 1024, 19456, 0, 256, 4096, 16384, 65536,
  262144, 1048576, 2097152, 33554432, 256, 4096, 19456, 8448, 265, 265, 1289, 8448, 265, 8448, 8448, 12552, 12552,
  12552, 12553, 12553, 12553, 12553, 12553, 12552, 12553, 825, 825, 829, 829, 1853, 829, 829, 1853, 9021, 14141, 12553,
  13577, 13577, 13577, 1853, 829, 825, 829, 14141, 13117, 0, 0, 537920512, 0, 0, 327680, 458752, 1048576, 603979776,
  1073741824, 4925, 829, 829, 829, 829, 1, 8, 256, 0, 0, 0, 512, 512, 0, 5, 0, 0, 4096, 0, 1, 4, 24, 32, 32, 128, 128,
  0, 65536, 4, 8, 16, 32, 256, 512, 0, 0, 0, 256, 0, 8, 0, 536936448, 8, 256, 8, 0, 0, 8, 256, 8388608, 32, 512, 0, 0,
  4096, 2097152, -2147483648, 0
);

(:~
 : The token-string table.
 :)
declare variable $p:TOKEN as xs:string+ :=
(
  "EPSILON",
  "END",
  "DirCommentContents",
  "IntegerLiteral",
  "DecimalLiteral",
  "DoubleLiteral",
  "StringLiteral",
  "TextNodeLiteral",
  "PredefinedEntityRef",
  "'""""'",
  "EscapeApos",
  "ElementContentChar",
  "QuotAttrContentChar",
  "AposAttrContentChar",
  "S",
  "S",
  "CharRef",
  "NCName",
  "QName",
  "PITarget",
  "CommentContents",
  "PragmaContents",
  "DirPIContents",
  "CDataSection",
  "Wildcard",
  "EOF",
  "'!='",
  "'""'",
  "'#)'",
  "'#current'",
  "'#default'",
  "'$'",
  "''''",
  "'('",
  "'(#'",
  "'(:'",
  "')'",
  "'*'",
  "'*'",
  "'+'",
  "'+'",
  "','",
  "'-'",
  "'-->'",
  "'.'",
  "'..'",
  "'/'",
  "'//'",
  "'/>'",
  "':'",
  "':)'",
  "'::'",
  "':='",
  "';'",
  "'<'",
  "'<!--'",
  "'</'",
  "'<<'",
  "'<='",
  "'<?'",
  "'='",
  "'>'",
  "'>='",
  "'>>'",
  "'?'",
  "'?>'",
  "'@'",
  "'['",
  "']'",
  "'^'",
  "'ancestor'",
  "'ancestor-or-self'",
  "'and'",
  "'as'",
  "'ascending'",
  "'at'",
  "'attribute'",
  "'base-uri'",
  "'boundary-space'",
  "'by'",
  "'case'",
  "'cast'",
  "'castable'",
  "'child'",
  "'collation'",
  "'comment'",
  "'construction'",
  "'copy'",
  "'copy-namespaces'",
  "'declare'",
  "'default'",
  "'descendant'",
  "'descendant-or-self'",
  "'descending'",
  "'div'",
  "'document'",
  "'document-node'",
  "'element'",
  "'else'",
  "'empty'",
  "'empty-sequence'",
  "'encoding'",
  "'eq'",
  "'every'",
  "'except'",
  "'external'",
  "'following'",
  "'following-sibling'",
  "'for'",
  "'function'",
  "'ge'",
  "'greatest'",
  "'gt'",
  "'id'",
  "'idiv'",
  "'if'",
  "'import'",
  "'in'",
  "'inherit'",
  "'instance'",
  "'intersect'",
  "'is'",
  "'item'",
  "'key'",
  "'lax'",
  "'le'",
  "'least'",
  "'let'",
  "'lt'",
  "'mod'",
  "'module'",
  "'namespace'",
  "'ne'",
  "'no-inherit'",
  "'no-preserve'",
  "'node'",
  "'of'",
  "'option'",
  "'or'",
  "'order'",
  "'ordered'",
  "'ordering'",
  "'parent'",
  "'preceding'",
  "'preceding-sibling'",
  "'preserve'",
  "'processing-instruction'",
  "'return'",
  "'satisfies'",
  "'schema'",
  "'schema-attribute'",
  "'schema-element'",
  "'self'",
  "'some'",
  "'stable'",
  "'strict'",
  "'strip'",
  "'text'",
  "'then'",
  "'to'",
  "'treat'",
  "'tunnel'",
  "'typeswitch'",
  "'union'",
  "'unordered'",
  "'validate'",
  "'variable'",
  "'version'",
  "'where'",
  "'xquery'",
  "'{'",
  "'{{'",
  "'|'",
  "'}'",
  "'}}'"
);

(:~
 : Match next token in input string, starting at given index, using
 : the DFA entry state for the set of tokens that are expected in
 : the current context.
 :
 : @param $input the input string.
 : @param $begin the index where to start in input string.
 : @param $token-set the expected token set id.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:match($input as xs:string,
                         $begin as xs:integer,
                         $token-set as xs:integer) as xs:integer+
{
  let $result := $p:INITIAL[1 + $token-set]
  return p:transition($input,
                      $begin,
                      $begin,
                      $begin,
                      $result,
                      $result mod 2048,
                      0)
};

(:~
 : The DFA state transition function. If we are in a valid DFA state, save
 : it's result annotation, consume one input codepoint, calculate the next
 : state, and use tail recursion to do the same again. Otherwise, return
 : any valid result or a negative DFA state id in case of an error.
 :
 : @param $input the input string.
 : @param $begin the begin index of the current token in the input string.
 : @param $current the index of the current position in the input string.
 : @param $end the end index of the result in the input string.
 : @param $result the result code.
 : @param $current-state the current DFA state.
 : @param $previous-state the  previous DFA state.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:transition($input as xs:string,
                              $begin as xs:integer,
                              $current as xs:integer,
                              $end as xs:integer,
                              $result as xs:integer,
                              $current-state as xs:integer,
                              $previous-state as xs:integer) as xs:integer+
{
  if ($current-state = 0) then
    let $result := $result idiv 2048
    return
      if ($result != 0) then
      (
        $result mod 256 - 1,
        $begin,
        $end - $result idiv 256
      )
      else
      (
        - $previous-state,
        $begin,
        $current - 1
      )
  else
    let $c0 := (string-to-codepoints(substring($input, $current, 1)), 0)[1]
    let $c1 :=
      if ($c0 < 128) then
        $p:MAP0[1 + $c0]
      else if ($c0 < 55296) then
        let $c1 := $c0 idiv 8
        let $c2 := $c1 idiv 32
        return $p:MAP1[1 + $c0 mod 8 + $p:MAP1[1 + $c1 mod 32 + $p:MAP1[1 + $c2]]]
      else
        p:map2($c0, 1, 2)
    let $current := $current + 1
    let $i0 := 2048 * $c1 + $current-state - 1
    let $i1 := $i0 idiv 16
    let $next-state := $p:TRANSITION[$i0 mod 16 + $p:TRANSITION[$i1 + 1] + 1]
    return
      if ($next-state > 2047) then
        p:transition($input, $begin, $current, $current, $next-state, $next-state mod 2048, $current-state)
      else
        p:transition($input, $begin, $current, $end, $result, $next-state, $current-state)
};

(:~
 : Recursively translate one 32-bit chunk of an expected token bitset
 : to the corresponding sequence of token strings.
 :
 : @param $result the result of previous recursion levels.
 : @param $chunk the 32-bit chunk of the expected token bitset.
 : @param $base-token-code the token code of bit 0 in the current chunk.
 : @return the set of token strings.
 :)
declare function p:token($result as xs:string*,
                         $chunk as xs:integer,
                         $base-token-code as xs:integer) as xs:string*
{
  if ($chunk = 0) then
    $result
  else
    p:token
    (
      ($result, if ($chunk mod 2 != 0) then $p:TOKEN[$base-token-code] else ()),
      if ($chunk < 0) then $chunk idiv 2 + 2147483648 else $chunk idiv 2,
      $base-token-code + 1
    )
};

(:~
 : Calculate expected token set for a given DFA state as a sequence
 : of strings.
 :
 : @param $state the DFA state.
 : @return the set of token strings
 :)
declare function p:expected-token-set($state as xs:integer) as xs:string*
{
  if ($state > 0) then
    for $t in 0 to 5
    let $i0 := $t * 1377 + $state - 1
    let $i1 := $i0 idiv 4
    let $i2 := $i1 idiv 4
    let $i3 := $i2 idiv 16
    return p:token((), $p:EXPECTED[$i0 mod 4 + $p:EXPECTED[$i1 mod 4 + $p:EXPECTED[$i2 mod 16 + $p:EXPECTED[$i3 + 1] + 1] + 1] + 1], $t * 32 + 1)
  else
    ()
};

(:~
 : Classify codepoint by doing a tail recursive binary search for a
 : matching codepoint range entry in MAP2, the codepoint to charclass
 : map for codepoints above the surrogate block.
 :
 : @param $c the codepoint.
 : @param $lo the binary search lower bound map index.
 : @param $hi the binary search upper bound map index.
 : @return the character class.
 :)
declare function p:map2($c as xs:integer, $lo as xs:integer, $hi as xs:integer) as xs:integer
{
  if ($lo > $hi) then
    0
  else
    let $m := ($hi + $lo) idiv 2
    return
      if ($p:MAP2[$m] > $c) then
        p:map2($c, $lo, $m - 1)
      else if ($p:MAP2[2 + $m] < $c) then
        p:map2($c, $m + 1, $hi)
      else
        $p:MAP2[4 + $m]
};

(:~
 : The index of the parser state for accessing the combined
 : (i.e. level > 1) lookahead code.
 :)
declare variable $p:lk := 1;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the token that has been shifted.
 :)
declare variable $p:b0 := 2;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the token that has been shifted.
 :)
declare variable $p:e0 := 3;

(:~
 : The index of the parser state for accessing the code of the
 : level-1-lookahead token.
 :)
declare variable $p:l1 := 4;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-1-lookahead token.
 :)
declare variable $p:b1 := 5;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-1-lookahead token.
 :)
declare variable $p:e1 := 6;

(:~
 : The index of the parser state for accessing the code of the
 : level-2-lookahead token.
 :)
declare variable $p:l2 := 7;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-2-lookahead token.
 :)
declare variable $p:b2 := 8;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-2-lookahead token.
 :)
declare variable $p:e2 := 9;

(:~
 : The index of the parser state for accessing the code of the
 : level-3-lookahead token.
 :)
declare variable $p:l3 := 10;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-3-lookahead token.
 :)
declare variable $p:b3 := 11;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-3-lookahead token.
 :)
declare variable $p:e3 := 12;

(:~
 : The index of the parser state for accessing the token code that
 : was expected when an error was found.
 :)
declare variable $p:error := 13;

(:~
 : The index of the parser state that points to the first entry
 : used for collecting action results.
 :)
declare variable $p:result := 14;

(:~
 : Create a textual error message from a parsing error.
 :
 : @param $input the input string.
 : @param $error the parsing error descriptor.
 : @return the error message.
 :)
declare function p:error-message($input as xs:string, $error as element(error)) as xs:string
{
  let $begin := xs:integer($error/@b)
  let $context := string-to-codepoints(substring($input, 1, $begin - 1))
  let $linefeeds := index-of($context, 10)
  let $line := count($linefeeds) + 1
  let $column := ($begin - $linefeeds[last()], $begin)[1]
  return
    if ($error/@o) then
      concat
      (
        "syntax error, found ", $p:TOKEN[$error/@o + 1], "&#10;",
        "while expecting ", $p:TOKEN[$error/@x + 1], "&#10;",
        "after scanning ", string($error/@e - $begin), " characters at line ",
        string($line), ", column ", string($column), "&#10;",
        "...", substring($input, $begin, 32), "..."
      )
    else
      let $expected := p:expected-token-set($error/@s)
      return
        concat
        (
          "lexical analysis failed&#10;",
          "while expecting ",
          "["[exists($expected[2])],
          string-join($expected, ", "),
          "]"[exists($expected[2])],
          "&#10;",
          "after scanning ", string($error/@e - $begin), " characters at line ",
          string($line), ", column ", string($column), "&#10;",
          "...", substring($input, $begin, 32), "..."
        )
};

(:~
 : Shift one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : parser state.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:shift($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] = $code) then
  (
    $state[position() >= $p:l1 and position() <= $p:e3],
    0,
    $state[$p:e3],
    $state[position() >= $p:e3],
    if ($state[$p:e0] != $state[$p:b1]) then
      text {substring($input, $state[$p:e0], $state[$p:b1] - $state[$p:e0])}
    else
      (),
    let $name := $p:TOKEN[1 + $state[$p:l1]]
    let $content := substring($input, $state[$p:b1], $state[$p:e1] - $state[$p:b1])
    return
      if (starts-with($name, "'")) then
		    element TOKEN {$content}
	    else
	      element {$name} {$content}
  )
  else
  (
    $state[position() < $p:error],
    element error
    {
      attribute b {$state[$p:b1]},
      attribute e {$state[$p:e1]},
      if ($state[$p:l1] < 0) then
        attribute s {- $state[$p:l1]}
      else
        (attribute o {$state[$p:l1]}, attribute x {$code})
    },
    $state[position() > $p:error]
  )
};

(:~
 : Use p:match to fetch the next token, but skip any leading
 : whitespace.
 :
 : @param $input the input string.
 : @param $begin the index where to start.
 : @param $token-set the valid token set id.
 : @return a sequence of three values: the token code of the result
 : token, with input string positions of token begin and end.
 :)
declare function p:matchW($input as xs:string,
                          $begin as xs:integer,
                          $token-set as xs:integer) as xs:integer+
{
  let $match := p:match($input, $begin, $token-set)
  return
    if ($match[1] = 15) then                                (: S^WS :)
      p:matchW($input, $match[3], $token-set)
    else if ($match[1] = 35) then                           (: ('(' ':') :)
      let $state := p:parse-Whitespace($input, (0, 0, 0, $match, 0, $match[3], 0, 0, 0, 0, false()))
      return p:matchW($input, $state[$p:e0], $token-set)
    else
      $match
};

(:~
 : Lookahead one token on level 1 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead1W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] != 0) then
    $state
  else
    let $match := p:matchW($input, $state[$p:b1], $set)
    return
    (
      $match[1],
      $state[position() > $p:lk and position() < $p:l1],
      $match,
      0, $match[3], 0,
      $state[position() > $p:e2]
    )
};

(:~
 : Lookahead one token on level 2 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead2W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l2] != 0) then
      $state[position() >= $p:l2 and position() <= $p:e2]
    else
      p:matchW($input, $state[$p:b2], $set)
  return
  (
    $match[1] * 256 + $state[$p:l1],
    $state[position() > $p:lk and position() < $p:l2],
    $match,
    0, $match[3], 0,
    $state[position() > $p:e3]
  )
};

(:~
 : Lookahead one token on level 3 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead3W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l3] != 0) then
      $state[position() >= $p:l3 and position() <= $p:e3]
    else
      p:matchW($input, $state[$p:b3], $set)
  return
  (
    $match[1] * 65536 + $state[$p:lk],
    $state[position() > $p:lk and position() < $p:l3],
    $match,
    $state[position() > $p:e3]
  )
};

(:~
 : Lookahead one token on level 1.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead1($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] != 0) then
    $state
  else
    let $match := p:match($input, $state[$p:b1], $set)
    return
    (
      $match[1],
      $state[position() > $p:lk and position() < $p:l1],
      $match,
      0, $match[3], 0,
      $state[position() > $p:e2]
    )
};

(:~
 : Reduce the result stack. Pop $count element, wrap them in a
 : new element named $name, and push the new element.
 :
 : @param $state the parser state.
 : @param $name the name of the result node.
 : @param $count the number of child nodes.
 : @return the updated parser state.
 :)
declare function p:reduce($state as item()+, $name as xs:string, $count as xs:integer) as item()+
{
  $state[position() <= $count],
  element {$name}
  {
    $state[position() > $count]
  }
};

(:~
 : Parse the 1st loop of production Comment (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Comment-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(45, $input, $state)          (: CommentContents | ('(' ':') | (':' ')') :)
    return
      if ($state[$p:l1] = 50) then                          (: (':' ')') :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 20) then                      (: CommentContents :)
            let $state := p:shift(20, $input, $state)       (: CommentContents :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-Comment($input, $state)
            return $state
        return p:parse-Comment-1($input, $state)
};

(:~
 : Parse Comment.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Comment($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(35, $input, $state)                 (: ('(' ':') :)
  let $state := p:parse-Comment-1($input, $state)
  let $state := p:shift(50, $input, $state)                 (: (':' ')') :)
  return p:reduce($state, "Comment", $count)
};

(:~
 : Parse the 1st loop of production Whitespace (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Whitespace-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(21, $input, $state)          (: END | S^WS | ('(' ':') :)
    return
      if ($state[$p:l1] = 1) then                           (: END :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 15) then                      (: S^WS :)
            let $state := p:shift(15, $input, $state)       (: S^WS :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-Comment($input, $state)
            return $state
        return p:parse-Whitespace-1($input, $state)
};

(:~
 : Parse Whitespace.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Whitespace($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-Whitespace-1($input, $state)
  return p:reduce($state, "Whitespace", $count)
};

(:~
 : Parse Value.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Value($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(12, $input, $state)            (: StringLiteral | QName^Token :)
  let $state :=
    if ($state[$p:l1] = 6) then                             (: StringLiteral :)
      let $state := p:shift(6, $input, $state)              (: StringLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(18, $input, $state)             (: QName^Token :)
      return $state
  return p:reduce($state, "Value", $count)
};

(:~
 : Parse Key.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Key($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(18, $input, $state)                 (: QName^Token :)
  return p:reduce($state, "Key", $count)
};

(:~
 : Parse the 1st loop of production KeyValuePairs (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-KeyValuePairs-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(48, $input, $state)         (: S^WS | QName^Token | EOF | ('(' ':') :)
    return
      if ($state[$p:l1] != 18) then                         (: QName^Token :)
        $state
      else
        let $state := p:parse-Key($input, $state)
        let $state := p:lookahead1W(71, $input, $state)     (: S^WS | QName^Token | EOF | ('(' ':') | '=' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 60) then                 (: '=' :)
            let $state := p:shift(60, $input, $state)       (: '=' :)
            let $state := p:lookahead1W(46, $input, $state) (: StringLiteral | S^WS | QName^Token | ('(' ':') :)
            let $state := p:parse-Value($input, $state)
            return $state
          else
            $state
        return p:parse-KeyValuePairs-1($input, $state)
};

(:~
 : Parse KeyValuePairs.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-KeyValuePairs($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-KeyValuePairs-1($input, $state)
  let $state := p:shift(25, $input, $state)                 (: EOF :)
  return p:reduce($state, "KeyValuePairs", $count)
};

(:~
 : Parse ParamWithDefault.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParamWithDefault($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(51, $input, $state)           (: S^WS | '$' | ('(' ':') | 'tunnel' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 161) then                      (: 'tunnel' :)
      let $state := p:parse-Tunnel($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Param($input, $state)
  let $state := p:lookahead1W(73, $input, $state)           (: S^WS | ('(' ':') | ')' | ',' | ':=' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 52) then                       (: ':=' :)
      let $state := p:shift(52, $input, $state)             (: ':=' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-ExprSingle($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "ParamWithDefault", $count)
};

(:~
 : Parse the 1st loop of production RuleParamList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RuleParamList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(56, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-ParamWithDefault($input, $state)
        return p:parse-RuleParamList-1($input, $state)
};

(:~
 : Parse RuleParamList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RuleParamList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ParamWithDefault($input, $state)
  let $state := p:parse-RuleParamList-1($input, $state)
  return p:reduce($state, "RuleParamList", $count)
};

(:~
 : Parse NextPathPatternOpt.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NextPathPatternOpt($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(74, $input, $state)           (: S^WS | ('(' ':') | ')' | ';' | '|' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 172) then                      (: '|' :)
      let $state := p:shift(172, $input, $state)            (: '|' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-PathPattern($input, $state)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-NextPathPatternOpt($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "NextPathPatternOpt", $count)
};

(:~
 : Parse KeyValue.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-KeyValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(81, $input, $state)            (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | '$' :)
  let $state :=
    if ($state[$p:l1] = 31) then                            (: '$' :)
      let $state := p:parse-VarRef($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-Literal($input, $state)
      return $state
  return p:reduce($state, "KeyValue", $count)
};

(:~
 : Parse IdValue.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IdValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(13, $input, $state)            (: StringLiteral | '$' :)
  let $state :=
    if ($state[$p:l1] = 6) then                             (: StringLiteral :)
      let $state := p:shift(6, $input, $state)              (: StringLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-VarRef($input, $state)
      return $state
  return p:reduce($state, "IdValue", $count)
};

(:~
 : Parse IdKeyPattern.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IdKeyPattern($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 113) then                           (: 'id' :)
      let $state := p:shift(113, $input, $state)            (: 'id' :)
      let $state := p:lookahead1W(27, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:shift(33, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-IdValue($input, $state)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:shift(36, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(123, $input, $state)            (: 'key' :)
      let $state := p:lookahead1W(27, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:shift(33, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(22, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:shift(6, $input, $state)              (: StringLiteral :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | ',' :)
      let $state := p:shift(41, $input, $state)             (: ',' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-KeyValue($input, $state)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:shift(36, $input, $state)             (: ')' :)
      return $state
  return p:reduce($state, "IdKeyPattern", $count)
};

(:~
 : Parse PatternAxis.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PatternAxis($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 83) then                            (: 'child' :)
      let $state := p:shift(83, $input, $state)             (: 'child' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(51, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 76) then                       (: 'attribute' :)
      let $state := p:shift(76, $input, $state)             (: 'attribute' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(51, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(66, $input, $state)             (: '@' :)
      return $state
  return p:reduce($state, "PatternAxis", $count)
};

(:~
 : Parse PatternStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PatternStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(134, $input, $state)          (: S^WS | QName^Token | Wildcard | ('(' ':') | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'ne' | 'node' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 76) then                            (: 'attribute' :)
      let $state := p:lookahead2W(93, $input, $state)       (: S^WS | '(' | ('(' ':') | ')' | '/' | '//' | '::' | ';' |
                                                               '[' | '|' :)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'child' :)
      let $state := p:lookahead2W(91, $input, $state)       (: S^WS | ('(' ':') | ')' | '/' | '//' | '::' | ';' | '[' |
                                                               '|' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 66                             (: '@' :)
          or $state[$p:lk] = 13132                          (: 'attribute' '::' :)
          or $state[$p:lk] = 13139) then                    (: 'child' '::' :)
      let $state := p:parse-PatternAxis($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-NodeTest($input, $state)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-PredicateList($input, $state)
  return p:reduce($state, "PatternStep", $count)
};

(:~
 : Parse RelativePathPattern.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RelativePathPattern($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-PatternStep($input, $state)
  let $state := p:lookahead1W(85, $input, $state)           (: S^WS | ('(' ':') | ')' | '/' | '//' | ';' | '|' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 46                             (: '/' :)
          or $state[$p:l1] = 47) then                       (: '//' :)
      let $state :=
        if ($state[$p:l1] = 46) then                        (: '/' :)
          let $state := p:shift(46, $input, $state)         (: '/' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(47, $input, $state)         (: '//' :)
          return $state
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-RelativePathPattern($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "RelativePathPattern", $count)
};

(:~
 : Parse PathPattern.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PathPattern($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(141, $input, $state)          (: S^WS | QName^Token | Wildcard | ('(' ':') | '/' | '//' |
                                                               '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'id' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'key' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 46) then                            (: '/' :)
      let $state := p:shift(46, $input, $state)             (: '/' :)
      let $state := p:lookahead1W(140, $input, $state)      (: S^WS | QName^Token | Wildcard | ('(' ':') | ')' | ';' |
                                                               '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '|' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 36                        (: ')' :)
             and $state[$p:l1] != 53                        (: ';' :)
             and $state[$p:l1] != 172) then                 (: '|' :)
          let $state := p:parse-RelativePathPattern($input, $state)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 47) then                       (: '//' :)
      let $state := p:shift(47, $input, $state)             (: '//' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-RelativePathPattern($input, $state)
      return $state
    else if ($state[$p:l1] = 113                            (: 'id' :)
          or $state[$p:l1] = 123) then                      (: 'key' :)
      let $state := p:parse-IdKeyPattern($input, $state)
      let $state := p:lookahead1W(85, $input, $state)       (: S^WS | ('(' ':') | ')' | '/' | '//' | ';' | '|' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 46                         (: '/' :)
              or $state[$p:l1] = 47) then                   (: '//' :)
          let $state :=
            if ($state[$p:l1] = 46) then                    (: '/' :)
              let $state := p:shift(46, $input, $state)     (: '/' :)
              return $state
            else if ($state[$p:error]) then
              $state
            else
              let $state := p:shift(47, $input, $state)     (: '//' :)
              return $state
          let $state := p:lookahead1W(20, $input, $state)   (: EPSILON | S^WS | ('(' ':') :)
          let $state := p:parse-RelativePathPattern($input, $state)
          return $state
        else
          $state
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-RelativePathPattern($input, $state)
      return $state
  return p:reduce($state, "PathPattern", $count)
};

(:~
 : Parse Pattern.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Pattern($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-PathPattern($input, $state)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-NextPathPatternOpt($input, $state)
  return p:reduce($state, "Pattern", $count)
};

(:~
 : Parse the 1st loop of production RuleDecl (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RuleDecl-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(54, $input, $state)         (: S^WS | '(' | ('(' ':') | '|' :)
    return
      if ($state[$p:l1] != 172) then                        (: '|' :)
        $state
      else
        let $state := p:shift(172, $input, $state)          (: '|' :)
        let $state := p:lookahead1W(135, $input, $state)    (: S^WS | QName^Token | '#current' | '#default' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
        let $state := p:parse-ModeName($input, $state)
        return p:parse-RuleDecl-1($input, $state)
};

(:~
 : Parse RuleDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RuleDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(69, $input, $state)                 (: '^' :)
  let $state := p:lookahead1W(139, $input, $state)          (: S^WS | QName^Token | '#current' | '#default' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 33) then                      (: '(' :)
      let $state := p:parse-ModeName($input, $state)
      let $state := p:parse-RuleDecl-1($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Pattern($input, $state)
  let $state := p:lookahead1W(57, $input, $state)           (: S^WS | ('(' ':') | ')' | ';' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 53) then                       (: ';' :)
      let $state := p:shift(53, $input, $state)             (: ';' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-RuleParamList($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(70, $input, $state)           (: IntegerLiteral | DecimalLiteral | S^WS | ('(' ':') | ':=' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 52) then                      (: ':=' :)
      let $state :=
        if ($state[$p:l1] = 3) then                         (: IntegerLiteral :)
          let $state := p:shift(3, $input, $state)          (: IntegerLiteral :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(4, $input, $state)          (: DecimalLiteral :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(31, $input, $state)           (: S^WS | ('(' ':') | ':=' :)
  let $state := p:shift(52, $input, $state)                 (: ':=' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  return p:reduce($state, "RuleDecl", $count)
};

(:~
 : Parse the 1st loop of production ParamList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParamList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(56, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-Param($input, $state)
        return p:parse-ParamList-1($input, $state)
};

(:~
 : Parse ParamList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParamList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-Param($input, $state)
  let $state := p:parse-ParamList-1($input, $state)
  return p:reduce($state, "ParamList", $count)
};

(:~
 : Parse FunctionDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-FunctionName($input, $state)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(49, $input, $state)           (: S^WS | '$' | ('(' ':') | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:parse-ParamList($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(61, $input, $state)           (: S^WS | ('(' ':') | ':=' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 73) then                       (: 'as' :)
      let $state := p:shift(73, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(31, $input, $state)           (: S^WS | ('(' ':') | ':=' :)
  let $state := p:shift(52, $input, $state)                 (: ':=' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  return p:reduce($state, "FunctionDecl", $count)
};

(:~
 : Parse NodeComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NodeComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 121) then                           (: 'is' :)
      let $state := p:shift(121, $input, $state)            (: 'is' :)
      return $state
    else if ($state[$p:l1] = 57) then                       (: '<<' :)
      let $state := p:shift(57, $input, $state)             (: '<<' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(63, $input, $state)             (: '>>' :)
      return $state
  return p:reduce($state, "NodeComp", $count)
};

(:~
 : Parse GeneralComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-GeneralComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 60) then                            (: '=' :)
      let $state := p:shift(60, $input, $state)             (: '=' :)
      return $state
    else if ($state[$p:l1] = 26) then                       (: '!=' :)
      let $state := p:shift(26, $input, $state)             (: '!=' :)
      return $state
    else if ($state[$p:l1] = 54) then                       (: '<' :)
      let $state := p:shift(54, $input, $state)             (: '<' :)
      return $state
    else if ($state[$p:l1] = 58) then                       (: '<=' :)
      let $state := p:shift(58, $input, $state)             (: '<=' :)
      return $state
    else if ($state[$p:l1] = 61) then                       (: '>' :)
      let $state := p:shift(61, $input, $state)             (: '>' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(62, $input, $state)             (: '>=' :)
      return $state
  return p:reduce($state, "GeneralComp", $count)
};

(:~
 : Parse ValueComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValueComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 102) then                           (: 'eq' :)
      let $state := p:shift(102, $input, $state)            (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 132) then                      (: 'ne' :)
      let $state := p:shift(132, $input, $state)            (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 128) then                      (: 'lt' :)
      let $state := p:shift(128, $input, $state)            (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 125) then                      (: 'le' :)
      let $state := p:shift(125, $input, $state)            (: 'le' :)
      return $state
    else if ($state[$p:l1] = 112) then                      (: 'gt' :)
      let $state := p:shift(112, $input, $state)            (: 'gt' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(110, $input, $state)            (: 'ge' :)
      return $state
  return p:reduce($state, "ValueComp", $count)
};

(:~
 : Parse SingleType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SingleType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(126, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-AtomicType($input, $state)
  let $state := p:lookahead1W(110, $input, $state)          (: S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | '?' |
                                                               ']' | 'and' | 'ascending' | 'case' | 'castable' |
                                                               'collation' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'eq' | 'except' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'to' | 'treat' | 'union' |
                                                               'where' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 64) then                       (: '?' :)
      let $state := p:shift(64, $input, $state)             (: '?' :)
      return $state
    else
      $state
  return p:reduce($state, "SingleType", $count)
};

(:~
 : Parse Pragma.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Pragma($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(6, $input, $state)             (: '(#' :)
  let $state := p:shift(34, $input, $state)                 (: '(#' :)
  let $state := p:lookahead1(127, $input, $state)           (: S | QName^Token | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 14) then                       (: S :)
      let $state := p:shift(14, $input, $state)             (: S :)
      return $state
    else
      $state
  let $state := p:lookahead1(126, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-QName($input, $state)
  let $state := p:lookahead1(14, $input, $state)            (: S | '#)' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 14) then                       (: S :)
      let $state := p:shift(14, $input, $state)             (: S :)
      let $state := p:lookahead1(2, $input, $state)         (: PragmaContents :)
      let $state := p:shift(21, $input, $state)             (: PragmaContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(4, $input, $state)             (: '#)' :)
  let $state := p:shift(28, $input, $state)                 (: '#)' :)
  return p:reduce($state, "Pragma", $count)
};

(:~
 : Parse the 1st loop of production ExtensionExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ExtensionExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:parse-Pragma($input, $state)
    let $state := p:lookahead1W(55, $input, $state)         (: S^WS | '(#' | ('(' ':') | '{' :)
    return
      if ($state[$p:l1] != 34) then                         (: '(#' :)
        $state
      else
        p:parse-ExtensionExpr-1($input, $state)
};

(:~
 : Parse ExtensionExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ExtensionExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ExtensionExpr-1($input, $state)
  let $state := p:shift(170, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(146, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               '^' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 173) then                     (: '}' :)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(173, $input, $state)                (: '}' :)
  return p:reduce($state, "ExtensionExpr", $count)
};

(:~
 : Parse AbbrevForwardStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AbbrevForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 66) then                       (: '@' :)
      let $state := p:shift(66, $input, $state)             (: '@' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-NodeTest($input, $state)
  return p:reduce($state, "AbbrevForwardStep", $count)
};

(:~
 : Parse ForwardAxis.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForwardAxis($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 83) then                            (: 'child' :)
      let $state := p:shift(83, $input, $state)             (: 'child' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(51, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 91) then                       (: 'descendant' :)
      let $state := p:shift(91, $input, $state)             (: 'descendant' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(51, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 76) then                       (: 'attribute' :)
      let $state := p:shift(76, $input, $state)             (: 'attribute' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(51, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 152) then                      (: 'self' :)
      let $state := p:shift(152, $input, $state)            (: 'self' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(51, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 92) then                       (: 'descendant-or-self' :)
      let $state := p:shift(92, $input, $state)             (: 'descendant-or-self' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(51, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 107) then                      (: 'following-sibling' :)
      let $state := p:shift(107, $input, $state)            (: 'following-sibling' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(51, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(106, $input, $state)            (: 'following' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(51, $input, $state)             (: '::' :)
      return $state
  return p:reduce($state, "ForwardAxis", $count)
};

(:~
 : Parse ForwardStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 76) then                            (: 'attribute' :)
      let $state := p:lookahead2W(120, $input, $state)      (: S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 83                             (: 'descendant' :)
          or $state[$p:l1] = 91                             (: 'descendant-or-self' :)
          or $state[$p:l1] = 92                             (: 'following' :)
          or $state[$p:l1] = 106                            (: 'following-sibling' :)
          or $state[$p:l1] = 107                            (: 'self' :)
          or $state[$p:l1] = 152) then                      (: 'self' :)
      let $state := p:lookahead2W(118, $input, $state)      (: S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                               '/' | '//' | '::' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 13132                               (: 'attribute' '::' :)
     or $state[$p:lk] = 13139                               (: 'child' '::' :)
     or $state[$p:lk] = 13147                               (: 'descendant' '::' :)
     or $state[$p:lk] = 13148                               (: 'descendant-or-self' '::' :)
     or $state[$p:lk] = 13162                               (: 'following' '::' :)
     or $state[$p:lk] = 13163                               (: 'following-sibling' '::' :)
     or $state[$p:lk] = 13208) then                         (: 'self' '::' :)
      let $state := p:parse-ForwardAxis($input, $state)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-NodeTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AbbrevForwardStep($input, $state)
      return $state
  return p:reduce($state, "ForwardStep", $count)
};

(:~
 : Parse AbbrevReverseStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AbbrevReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(45, $input, $state)                 (: '..' :)
  return p:reduce($state, "AbbrevReverseStep", $count)
};

(:~
 : Parse NameTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NameTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 24) then                            (: Wildcard :)
      let $state := p:shift(24, $input, $state)             (: Wildcard :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-QName($input, $state)
      return $state
  return p:reduce($state, "NameTest", $count)
};

(:~
 : Parse NodeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NodeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(128, $input, $state)           (: QName^Token | Wildcard | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 76                                  (: 'comment' :)
     or $state[$p:l1] = 85                                  (: 'document-node' :)
     or $state[$p:l1] = 96                                  (: 'element' :)
     or $state[$p:l1] = 97                                  (: 'node' :)
     or $state[$p:l1] = 135                                 (: 'processing-instruction' :)
     or $state[$p:l1] = 146                                 (: 'schema-attribute' :)
     or $state[$p:l1] = 150                                 (: 'schema-element' :)
     or $state[$p:l1] = 151                                 (: 'text' :)
     or $state[$p:l1] = 157) then                           (: 'text' :)
      let $state := p:lookahead2W(117, $input, $state)      (: S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 8524                                (: 'attribute' '(' :)
     or $state[$p:lk] = 8533                                (: 'comment' '(' :)
     or $state[$p:lk] = 8544                                (: 'document-node' '(' :)
     or $state[$p:lk] = 8545                                (: 'element' '(' :)
     or $state[$p:lk] = 8583                                (: 'node' '(' :)
     or $state[$p:lk] = 8594                                (: 'processing-instruction' '(' :)
     or $state[$p:lk] = 8598                                (: 'schema-attribute' '(' :)
     or $state[$p:lk] = 8599                                (: 'schema-element' '(' :)
     or $state[$p:lk] = 8605) then                          (: 'text' '(' :)
      let $state := p:parse-KindTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NameTest($input, $state)
      return $state
  return p:reduce($state, "NodeTest", $count)
};

(:~
 : Parse ReverseAxis.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ReverseAxis($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 142) then                           (: 'parent' :)
      let $state := p:shift(142, $input, $state)            (: 'parent' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(51, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 70) then                       (: 'ancestor' :)
      let $state := p:shift(70, $input, $state)             (: 'ancestor' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(51, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 144) then                      (: 'preceding-sibling' :)
      let $state := p:shift(144, $input, $state)            (: 'preceding-sibling' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(51, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'preceding' :)
      let $state := p:shift(143, $input, $state)            (: 'preceding' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(51, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(71, $input, $state)             (: 'ancestor-or-self' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(51, $input, $state)             (: '::' :)
      return $state
  return p:reduce($state, "ReverseAxis", $count)
};

(:~
 : Parse ReverseStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 45) then                            (: '..' :)
      let $state := p:parse-AbbrevReverseStep($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ReverseAxis($input, $state)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-NodeTest($input, $state)
      return $state
  return p:reduce($state, "ReverseStep", $count)
};

(:~
 : Parse AxisStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AxisStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 70                                  (: 'ancestor-or-self' :)
     or $state[$p:l1] = 71                                  (: 'parent' :)
     or $state[$p:l1] = 142                                 (: 'preceding' :)
     or $state[$p:l1] = 143                                 (: 'preceding-sibling' :)
     or $state[$p:l1] = 144) then                           (: 'preceding-sibling' :)
      let $state := p:lookahead2W(118, $input, $state)      (: S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                               '/' | '//' | '::' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 45                                  (: '..' :)
     or $state[$p:lk] = 13126                               (: 'ancestor' '::' :)
     or $state[$p:lk] = 13127                               (: 'ancestor-or-self' '::' :)
     or $state[$p:lk] = 13198                               (: 'parent' '::' :)
     or $state[$p:lk] = 13199                               (: 'preceding' '::' :)
     or $state[$p:lk] = 13200) then                         (: 'preceding-sibling' '::' :)
      let $state := p:parse-ReverseStep($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ForwardStep($input, $state)
      return $state
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-PredicateList($input, $state)
  return p:reduce($state, "AxisStep", $count)
};

(:~
 : Parse Predicate.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Predicate($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(67, $input, $state)                 (: '[' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(34, $input, $state)           (: S^WS | ('(' ':') | ']' :)
  let $state := p:shift(68, $input, $state)                 (: ']' :)
  return p:reduce($state, "Predicate", $count)
};

(:~
 : Parse the 1st loop of production PredicateList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PredicateList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(114, $input, $state)        (: S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                               '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
    return
      if ($state[$p:l1] != 67) then                         (: '[' :)
        $state
      else
        let $state := p:parse-Predicate($input, $state)
        return p:parse-PredicateList-1($input, $state)
};

(:~
 : Parse PredicateList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PredicateList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-PredicateList-1($input, $state)
  return p:reduce($state, "PredicateList", $count)
};

(:~
 : Parse Param.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Param($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(5, $input, $state)             (: '$' :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(129, $input, $state)          (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-QName($input, $state)
  let $state := p:lookahead1W(82, $input, $state)           (: S^WS | ('(' ':') | ')' | ',' | ':=' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 73) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "Param", $count)
};

(:~
 : Parse Tunnel.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Tunnel($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(161, $input, $state)                (: 'tunnel' :)
  return p:reduce($state, "Tunnel", $count)
};

(:~
 : Parse InitializedParam.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InitializedParam($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(51, $input, $state)           (: S^WS | '$' | ('(' ':') | 'tunnel' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 161) then                      (: 'tunnel' :)
      let $state := p:parse-Tunnel($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Param($input, $state)
  let $state := p:lookahead1W(31, $input, $state)           (: S^WS | ('(' ':') | ':=' :)
  let $state := p:shift(52, $input, $state)                 (: ':=' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "InitializedParam", $count)
};

(:~
 : Parse the 1st loop of production RulesetCallParamList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RulesetCallParamList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(56, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-InitializedParam($input, $state)
        return p:parse-RulesetCallParamList-1($input, $state)
};

(:~
 : Parse RulesetCallParamList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RulesetCallParamList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-InitializedParam($input, $state)
  let $state := p:parse-RulesetCallParamList-1($input, $state)
  return p:reduce($state, "RulesetCallParamList", $count)
};

(:~
 : Parse ModeName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ModeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(130, $input, $state)           (: QName^Token | '#current' | '#default' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 29) then                            (: '#current' :)
      let $state := p:shift(29, $input, $state)             (: '#current' :)
      return $state
    else if ($state[$p:l1] = 30) then                       (: '#default' :)
      let $state := p:shift(30, $input, $state)             (: '#default' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-QName($input, $state)
      return $state
  return p:reduce($state, "ModeName", $count)
};

(:~
 : Parse RulesetCall.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RulesetCall($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(69, $input, $state)                 (: '^' :)
  let $state := p:lookahead1W(139, $input, $state)          (: S^WS | QName^Token | '#current' | '#default' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 33) then                      (: '(' :)
      let $state := p:parse-ModeName($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(148, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | ('(' ':') | ')' | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | ';' | '<' | '<!--' |
                                                               '<?' | '@' | '^' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36                            (: ')' :)
         and $state[$p:l1] != 53) then                      (: ';' :)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(57, $input, $state)           (: S^WS | ('(' ':') | ')' | ';' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 53) then                       (: ';' :)
      let $state := p:shift(53, $input, $state)             (: ';' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-RulesetCallParamList($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "RulesetCall", $count)
};

(:~
 : Parse CompCopyConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompCopyConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(87, $input, $state)                 (: 'copy' :)
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(170, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(173, $input, $state)                (: '}' :)
  return p:reduce($state, "CompCopyConstructor", $count)
};

(:~
 : Parse CompPIConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(146, $input, $state)                (: 'processing-instruction' :)
  let $state := p:lookahead1W(99, $input, $state)           (: S^WS | NCName^Token | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '{' :)
  let $state :=
    if ($state[$p:l1] = 170) then                           (: '{' :)
      let $state := p:shift(170, $input, $state)            (: '{' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-Expr($input, $state)
      let $state := p:lookahead1W(44, $input, $state)       (: S^WS | ('(' ':') | '}' :)
      let $state := p:shift(173, $input, $state)            (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NCName($input, $state)
      return $state
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(170, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(146, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               '^' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 173) then                     (: '}' :)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(173, $input, $state)                (: '}' :)
  return p:reduce($state, "CompPIConstructor", $count)
};

(:~
 : Parse CompCommentConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(85, $input, $state)                 (: 'comment' :)
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(170, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(173, $input, $state)                (: '}' :)
  return p:reduce($state, "CompCommentConstructor", $count)
};

(:~
 : Parse CompTextConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompTextConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(157, $input, $state)                (: 'text' :)
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(170, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(173, $input, $state)                (: '}' :)
  return p:reduce($state, "CompTextConstructor", $count)
};

(:~
 : Parse CompAttrConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompAttrConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(76, $input, $state)                 (: 'attribute' :)
  let $state := p:lookahead1W(133, $input, $state)          (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
  let $state :=
    if ($state[$p:l1] = 170) then                           (: '{' :)
      let $state := p:shift(170, $input, $state)            (: '{' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-Expr($input, $state)
      let $state := p:lookahead1W(44, $input, $state)       (: S^WS | ('(' ':') | '}' :)
      let $state := p:shift(173, $input, $state)            (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-QName($input, $state)
      return $state
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(170, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(146, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               '^' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 173) then                     (: '}' :)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(173, $input, $state)                (: '}' :)
  return p:reduce($state, "CompAttrConstructor", $count)
};

(:~
 : Parse ContentExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ContentExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-Expr($input, $state)
  return p:reduce($state, "ContentExpr", $count)
};

(:~
 : Parse CompElemConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(97, $input, $state)                 (: 'element' :)
  let $state := p:lookahead1W(133, $input, $state)          (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
  let $state :=
    if ($state[$p:l1] = 170) then                           (: '{' :)
      let $state := p:shift(170, $input, $state)            (: '{' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-Expr($input, $state)
      let $state := p:lookahead1W(44, $input, $state)       (: S^WS | ('(' ':') | '}' :)
      let $state := p:shift(173, $input, $state)            (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-QName($input, $state)
      return $state
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(170, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(146, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               '^' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 173) then                     (: '}' :)
      let $state := p:parse-ContentExpr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(173, $input, $state)                (: '}' :)
  return p:reduce($state, "CompElemConstructor", $count)
};

(:~
 : Parse CompDocConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompDocConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(95, $input, $state)                 (: 'document' :)
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(170, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(173, $input, $state)                (: '}' :)
  return p:reduce($state, "CompDocConstructor", $count)
};

(:~
 : Parse ComputedConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ComputedConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 95) then                            (: 'document' :)
      let $state := p:parse-CompDocConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 97) then                       (: 'element' :)
      let $state := p:parse-CompElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 76) then                       (: 'attribute' :)
      let $state := p:parse-CompAttrConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 157) then                      (: 'text' :)
      let $state := p:parse-CompTextConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 85) then                       (: 'comment' :)
      let $state := p:parse-CompCommentConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 146) then                      (: 'processing-instruction' :)
      let $state := p:parse-CompPIConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CompCopyConstructor($input, $state)
      return $state
  return p:reduce($state, "ComputedConstructor", $count)
};

(:~
 : Parse DirPIConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(59, $input, $state)                 (: '<?' :)
  let $state := p:lookahead1(1, $input, $state)             (: PITarget :)
  let $state := p:shift(19, $input, $state)                 (: PITarget :)
  let $state := p:lookahead1(17, $input, $state)            (: S | '?>' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 14) then                       (: S :)
      let $state := p:shift(14, $input, $state)             (: S :)
      let $state := p:lookahead1(3, $input, $state)         (: DirPIContents :)
      let $state := p:shift(22, $input, $state)             (: DirPIContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(10, $input, $state)            (: '?>' :)
  let $state := p:shift(65, $input, $state)                 (: '?>' :)
  return p:reduce($state, "DirPIConstructor", $count)
};

(:~
 : Parse DirCommentConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(55, $input, $state)                 (: '<!--' :)
  let $state := p:lookahead1(0, $input, $state)             (: DirCommentContents :)
  let $state := p:shift(2, $input, $state)                  (: DirCommentContents :)
  let $state := p:lookahead1(7, $input, $state)             (: '-->' :)
  let $state := p:shift(43, $input, $state)                 (: '-->' :)
  return p:reduce($state, "DirCommentConstructor", $count)
};

(:~
 : Parse DirElemContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirElemContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 54                                  (: '<' :)
     or $state[$p:l1] = 55                                  (: '<!--' :)
     or $state[$p:l1] = 59) then                            (: '<?' :)
      let $state := p:parse-DirectConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 23) then                       (: CDataSection :)
      let $state := p:shift(23, $input, $state)             (: CDataSection :)
      return $state
    else if ($state[$p:l1] = 11) then                       (: ElementContentChar :)
      let $state := p:shift(11, $input, $state)             (: ElementContentChar :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CommonContent($input, $state)
      return $state
  return p:reduce($state, "DirElemContent", $count)
};

(:~
 : Parse AposAttrValueContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AposAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 13) then                            (: AposAttrContentChar :)
      let $state := p:shift(13, $input, $state)             (: AposAttrContentChar :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CommonContent($input, $state)
      return $state
  return p:reduce($state, "AposAttrValueContent", $count)
};

(:~
 : Parse EnclosedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EnclosedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(170, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(173, $input, $state)                (: '}' :)
  return p:reduce($state, "EnclosedExpr", $count)
};

(:~
 : Parse CommonContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CommonContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 8) then                             (: PredefinedEntityRef :)
      let $state := p:shift(8, $input, $state)              (: PredefinedEntityRef :)
      return $state
    else if ($state[$p:l1] = 16) then                       (: CharRef :)
      let $state := p:shift(16, $input, $state)             (: CharRef :)
      return $state
    else if ($state[$p:l1] = 171) then                      (: '{{' :)
      let $state := p:shift(171, $input, $state)            (: '{{' :)
      return $state
    else if ($state[$p:l1] = 174) then                      (: '}}' :)
      let $state := p:shift(174, $input, $state)            (: '}}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-EnclosedExpr($input, $state)
      return $state
  return p:reduce($state, "CommonContent", $count)
};

(:~
 : Parse QuotAttrValueContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QuotAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 12) then                            (: QuotAttrContentChar :)
      let $state := p:shift(12, $input, $state)             (: QuotAttrContentChar :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CommonContent($input, $state)
      return $state
  return p:reduce($state, "QuotAttrValueContent", $count)
};

(:~
 : Parse the 1st loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeValue-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(87, $input, $state)          (: PredefinedEntityRef | EscapeQuot | QuotAttrContentChar |
                                                               CharRef | '"' | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 27) then                          (: '"' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 9) then                       (: EscapeQuot :)
            let $state := p:shift(9, $input, $state)        (: EscapeQuot :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-QuotAttrValueContent($input, $state)
            return $state
        return p:parse-DirAttributeValue-1($input, $state)
};

(:~
 : Parse the 2nd loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeValue-2($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(88, $input, $state)          (: PredefinedEntityRef | EscapeApos | AposAttrContentChar |
                                                               CharRef | "'" | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 32) then                          (: "'" :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 10) then                      (: EscapeApos :)
            let $state := p:shift(10, $input, $state)       (: EscapeApos :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-AposAttrValueContent($input, $state)
            return $state
        return p:parse-DirAttributeValue-2($input, $state)
};

(:~
 : Parse DirAttributeValue.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(18, $input, $state)            (: '"' | "'" :)
  let $state :=
    if ($state[$p:l1] = 27) then                            (: '"' :)
      let $state := p:shift(27, $input, $state)             (: '"' :)
      let $state := p:parse-DirAttributeValue-1($input, $state)
      let $state := p:shift(27, $input, $state)             (: '"' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(32, $input, $state)             (: "'" :)
      let $state := p:parse-DirAttributeValue-2($input, $state)
      let $state := p:shift(32, $input, $state)             (: "'" :)
      return $state
  return p:reduce($state, "DirAttributeValue", $count)
};

(:~
 : Parse the 1st loop of production DirAttributeList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(24, $input, $state)          (: S | '/>' | '>' :)
    return
      if ($state[$p:l1] != 14) then                         (: S :)
        $state
      else
        let $state := p:shift(14, $input, $state)           (: S :)
        let $state := p:lookahead1(131, $input, $state)     (: S | QName^Token | '/>' | '>' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] != 14                      (: S :)
               and $state[$p:l1] != 48                      (: '/>' :)
               and $state[$p:l1] != 61) then                (: '>' :)
            let $state := p:parse-QName($input, $state)
            let $state := p:lookahead1(15, $input, $state)  (: S | '=' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 14) then             (: S :)
                let $state := p:shift(14, $input, $state)   (: S :)
                return $state
              else
                $state
            let $state := p:lookahead1(8, $input, $state)   (: '=' :)
            let $state := p:shift(60, $input, $state)       (: '=' :)
            let $state := p:lookahead1(23, $input, $state)  (: S | '"' | "'" :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 14) then             (: S :)
                let $state := p:shift(14, $input, $state)   (: S :)
                return $state
              else
                $state
            let $state := p:parse-DirAttributeValue($input, $state)
            return $state
          else
            $state
        return p:parse-DirAttributeList-1($input, $state)
};

(:~
 : Parse DirAttributeList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-DirAttributeList-1($input, $state)
  return p:reduce($state, "DirAttributeList", $count)
};

(:~
 : Parse the 1st loop of production DirElemConstructor (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirElemConstructor-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(94, $input, $state)          (: PredefinedEntityRef | ElementContentChar | CharRef |
                                                               CDataSection | '<' | '<!--' | '</' | '<?' | '{' | '{{' |
                                                               '}}' :)
    return
      if ($state[$p:l1] = 56) then                          (: '</' :)
        $state
      else
        let $state := p:parse-DirElemContent($input, $state)
        return p:parse-DirElemConstructor-1($input, $state)
};

(:~
 : Parse DirElemConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(54, $input, $state)                 (: '<' :)
  let $state := p:lookahead1(126, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-QName($input, $state)
  let $state := p:parse-DirAttributeList($input, $state)
  let $state := p:lookahead1(19, $input, $state)            (: '/>' | '>' :)
  let $state :=
    if ($state[$p:l1] = 48) then                            (: '/>' :)
      let $state := p:shift(48, $input, $state)             (: '/>' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(61, $input, $state)             (: '>' :)
      let $state := p:parse-DirElemConstructor-1($input, $state)
      let $state := p:shift(56, $input, $state)             (: '</' :)
      let $state := p:lookahead1(126, $input, $state)       (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
      let $state := p:parse-QName($input, $state)
      let $state := p:lookahead1(16, $input, $state)        (: S | '>' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 14) then                   (: S :)
          let $state := p:shift(14, $input, $state)         (: S :)
          return $state
        else
          $state
      let $state := p:lookahead1(9, $input, $state)         (: '>' :)
      let $state := p:shift(61, $input, $state)             (: '>' :)
      return $state
  return p:reduce($state, "DirElemConstructor", $count)
};

(:~
 : Parse DirectConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirectConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 54) then                            (: '<' :)
      let $state := p:parse-DirElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 55) then                       (: '<!--' :)
      let $state := p:parse-DirCommentConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-DirPIConstructor($input, $state)
      return $state
  return p:reduce($state, "DirectConstructor", $count)
};

(:~
 : Parse Constructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Constructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 54                                  (: '<' :)
     or $state[$p:l1] = 55                                  (: '<!--' :)
     or $state[$p:l1] = 59) then                            (: '<?' :)
      let $state := p:parse-DirectConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ComputedConstructor($input, $state)
      return $state
  return p:reduce($state, "Constructor", $count)
};

(:~
 : Parse UnorderedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnorderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(164, $input, $state)                (: 'unordered' :)
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(170, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(173, $input, $state)                (: '}' :)
  return p:reduce($state, "UnorderedExpr", $count)
};

(:~
 : Parse OrderedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(140, $input, $state)                (: 'ordered' :)
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(170, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(173, $input, $state)                (: '}' :)
  return p:reduce($state, "OrderedExpr", $count)
};

(:~
 : Parse the 1st loop of production FunctionCall (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionCall-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(56, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-ExprSingle($input, $state)
        return p:parse-FunctionCall-1($input, $state)
};

(:~
 : Parse FunctionCall.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionCall($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-FunctionName($input, $state)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(144, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | ('(' ':') | ')' | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | '^' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36) then                      (: ')' :)
      let $state := p:parse-ExprSingle($input, $state)
      let $state := p:parse-FunctionCall-1($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "FunctionCall", $count)
};

(:~
 : Parse ContextItemExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ContextItemExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(44, $input, $state)                 (: '.' :)
  return p:reduce($state, "ContextItemExpr", $count)
};

(:~
 : Parse ParenthesizedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParenthesizedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(144, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | ('(' ':') | ')' | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | '^' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36) then                      (: ')' :)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "ParenthesizedExpr", $count)
};

(:~
 : Parse VarRef.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarRef($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(129, $input, $state)          (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  return p:reduce($state, "VarRef", $count)
};

(:~
 : Parse NumericLiteral.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NumericLiteral($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 3) then                             (: IntegerLiteral :)
      let $state := p:shift(3, $input, $state)              (: IntegerLiteral :)
      return $state
    else if ($state[$p:l1] = 4) then                        (: DecimalLiteral :)
      let $state := p:shift(4, $input, $state)              (: DecimalLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(5, $input, $state)              (: DoubleLiteral :)
      return $state
  return p:reduce($state, "NumericLiteral", $count)
};

(:~
 : Parse Literal.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Literal($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 6) then                             (: StringLiteral :)
      let $state := p:shift(6, $input, $state)              (: StringLiteral :)
      return $state
    else if ($state[$p:l1] = 7) then                        (: TextNodeLiteral :)
      let $state := p:shift(7, $input, $state)              (: TextNodeLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NumericLiteral($input, $state)
      return $state
  return p:reduce($state, "Literal", $count)
};

(:~
 : Parse PrimaryExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PrimaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(138, $input, $state)           (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | QName^Token | '$' |
                                                               '(' | '.' | '<' | '<!--' | '<?' | '^' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'element' | 'else' | 'empty' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'le' |
                                                               'let' | 'lt' | 'mod' | 'module' | 'ne' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'self' | 'some' | 'stable' |
                                                               'text' | 'to' | 'treat' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 95                                  (: 'ordered' :)
     or $state[$p:l1] = 140                                 (: 'unordered' :)
     or $state[$p:l1] = 164) then                           (: 'unordered' :)
      let $state := p:lookahead2W(53, $input, $state)       (: S^WS | '(' | ('(' ':') | '{' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 3                                   (: IntegerLiteral :)
     or $state[$p:lk] = 4                                   (: DecimalLiteral :)
     or $state[$p:lk] = 5                                   (: DoubleLiteral :)
     or $state[$p:lk] = 6                                   (: StringLiteral :)
     or $state[$p:lk] = 7) then                             (: TextNodeLiteral :)
      let $state := p:parse-Literal($input, $state)
      return $state
    else if ($state[$p:lk] = 31) then                       (: '$' :)
      let $state := p:parse-VarRef($input, $state)
      return $state
    else if ($state[$p:lk] = 33) then                       (: '(' :)
      let $state := p:parse-ParenthesizedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 44) then                       (: '.' :)
      let $state := p:parse-ContextItemExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 43660) then                    (: 'ordered' '{' :)
      let $state := p:parse-OrderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 43684) then                    (: 'unordered' '{' :)
      let $state := p:parse-UnorderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 54                             (: '<' :)
          or $state[$p:lk] = 55                             (: '<!--' :)
          or $state[$p:lk] = 59                             (: '<?' :)
          or $state[$p:lk] = 76                             (: 'attribute' :)
          or $state[$p:lk] = 85                             (: 'comment' :)
          or $state[$p:lk] = 87                             (: 'copy' :)
          or $state[$p:lk] = 97                             (: 'element' :)
          or $state[$p:lk] = 146                            (: 'processing-instruction' :)
          or $state[$p:lk] = 157                            (: 'text' :)
          or $state[$p:lk] = 43615) then                    (: 'document' '{' :)
      let $state := p:parse-Constructor($input, $state)
      return $state
    else if ($state[$p:lk] = 69) then                       (: '^' :)
      let $state := p:parse-RulesetCall($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-FunctionCall($input, $state)
      return $state
  return p:reduce($state, "PrimaryExpr", $count)
};

(:~
 : Parse FilterExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FilterExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-PrimaryExpr($input, $state)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-PredicateList($input, $state)
  return p:reduce($state, "FilterExpr", $count)
};

(:~
 : Parse StepExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-StepExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(142, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | ('(' ':') | '.' | '..' | '<' |
                                                               '<!--' | '<?' | '@' | '^' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'ne' | 'node' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 76) then                            (: 'attribute' :)
      let $state := p:lookahead2W(149, $input, $state)      (: S^WS | QName^Token | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | '::' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' | '|' | '}' :)
      let $state :=
        if ($state[$p:lk] = 20556) then                     (: 'attribute' 'case' :)
          let $state := p:lookahead3W(136, $input, $state)  (: S^WS | QName^Token | '$' | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
          return $state
        else if ($state[$p:lk] = 21580) then                (: 'attribute' 'collation' :)
          let $state := p:lookahead3W(47, $input, $state)   (: StringLiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 23116) then                (: 'attribute' 'default' :)
          let $state := p:lookahead3W(72, $input, $state)   (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 25420) then                (: 'attribute' 'empty' :)
          let $state := p:lookahead3W(78, $input, $state)   (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] = 30540) then                (: 'attribute' 'instance' :)
          let $state := p:lookahead3W(68, $input, $state)   (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] = 35660) then                (: 'attribute' 'order' :)
          let $state := p:lookahead3W(65, $input, $state)   (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = 39500) then                (: 'attribute' 'stable' :)
          let $state := p:lookahead3W(69, $input, $state)   (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = 19020                      (: 'attribute' 'descending' :)
              or $state[$p:lk] = 23884) then                (: 'attribute' 'descending' :)
          let $state := p:lookahead3W(86, $input, $state)   (: S^WS | ('(' ':') | ',' | 'collation' | 'empty' |
                                                               'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 27724                      (: 'attribute' 'let' :)
              or $state[$p:lk] = 32588) then                (: 'attribute' 'let' :)
          let $state := p:lookahead3W(52, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 20812                      (: 'attribute' 'castable' :)
              or $state[$p:lk] = 21068                      (: 'attribute' 'treat' :)
              or $state[$p:lk] = 41036) then                (: 'attribute' 'treat' :)
          let $state := p:lookahead3W(63, $input, $state)   (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 18508                      (: 'attribute' 'div' :)
              or $state[$p:lk] = 24140                      (: 'attribute' 'else' :)
              or $state[$p:lk] = 25164                      (: 'attribute' 'eq' :)
              or $state[$p:lk] = 26188                      (: 'attribute' 'except' :)
              or $state[$p:lk] = 26700                      (: 'attribute' 'ge' :)
              or $state[$p:lk] = 28236                      (: 'attribute' 'gt' :)
              or $state[$p:lk] = 28748                      (: 'attribute' 'idiv' :)
              or $state[$p:lk] = 29260                      (: 'attribute' 'intersect' :)
              or $state[$p:lk] = 30796                      (: 'attribute' 'is' :)
              or $state[$p:lk] = 31052                      (: 'attribute' 'le' :)
              or $state[$p:lk] = 32076                      (: 'attribute' 'lt' :)
              or $state[$p:lk] = 32844                      (: 'attribute' 'mod' :)
              or $state[$p:lk] = 33100                      (: 'attribute' 'ne' :)
              or $state[$p:lk] = 33868                      (: 'attribute' 'or' :)
              or $state[$p:lk] = 35404                      (: 'attribute' 'return' :)
              or $state[$p:lk] = 37708                      (: 'attribute' 'satisfies' :)
              or $state[$p:lk] = 37964                      (: 'attribute' 'to' :)
              or $state[$p:lk] = 40780                      (: 'attribute' 'union' :)
              or $state[$p:lk] = 41804                      (: 'attribute' 'where' :)
              or $state[$p:lk] = 43084) then                (: 'attribute' 'where' :)
          let $state := p:lookahead3W(145, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               '^' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 97) then                       (: 'element' :)
      let $state := p:lookahead2W(147, $input, $state)      (: S^WS | QName^Token | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' | '|' | '}' :)
      let $state :=
        if ($state[$p:lk] = 20577) then                     (: 'element' 'case' :)
          let $state := p:lookahead3W(136, $input, $state)  (: S^WS | QName^Token | '$' | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
          return $state
        else if ($state[$p:lk] = 21601) then                (: 'element' 'collation' :)
          let $state := p:lookahead3W(47, $input, $state)   (: StringLiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 23137) then                (: 'element' 'default' :)
          let $state := p:lookahead3W(72, $input, $state)   (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 25441) then                (: 'element' 'empty' :)
          let $state := p:lookahead3W(78, $input, $state)   (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] = 30561) then                (: 'element' 'instance' :)
          let $state := p:lookahead3W(68, $input, $state)   (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] = 35681) then                (: 'element' 'order' :)
          let $state := p:lookahead3W(65, $input, $state)   (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = 39521) then                (: 'element' 'stable' :)
          let $state := p:lookahead3W(69, $input, $state)   (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = 19041                      (: 'element' 'descending' :)
              or $state[$p:lk] = 23905) then                (: 'element' 'descending' :)
          let $state := p:lookahead3W(86, $input, $state)   (: S^WS | ('(' ':') | ',' | 'collation' | 'empty' |
                                                               'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 27745                      (: 'element' 'let' :)
              or $state[$p:lk] = 32609) then                (: 'element' 'let' :)
          let $state := p:lookahead3W(52, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 20833                      (: 'element' 'castable' :)
              or $state[$p:lk] = 21089                      (: 'element' 'treat' :)
              or $state[$p:lk] = 41057) then                (: 'element' 'treat' :)
          let $state := p:lookahead3W(63, $input, $state)   (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 18529                      (: 'element' 'div' :)
              or $state[$p:lk] = 24161                      (: 'element' 'else' :)
              or $state[$p:lk] = 25185                      (: 'element' 'eq' :)
              or $state[$p:lk] = 26209                      (: 'element' 'except' :)
              or $state[$p:lk] = 26721                      (: 'element' 'ge' :)
              or $state[$p:lk] = 28257                      (: 'element' 'gt' :)
              or $state[$p:lk] = 28769                      (: 'element' 'idiv' :)
              or $state[$p:lk] = 29281                      (: 'element' 'intersect' :)
              or $state[$p:lk] = 30817                      (: 'element' 'is' :)
              or $state[$p:lk] = 31073                      (: 'element' 'le' :)
              or $state[$p:lk] = 32097                      (: 'element' 'lt' :)
              or $state[$p:lk] = 32865                      (: 'element' 'mod' :)
              or $state[$p:lk] = 33121                      (: 'element' 'ne' :)
              or $state[$p:lk] = 33889                      (: 'element' 'or' :)
              or $state[$p:lk] = 35425                      (: 'element' 'return' :)
              or $state[$p:lk] = 37729                      (: 'element' 'satisfies' :)
              or $state[$p:lk] = 37985                      (: 'element' 'to' :)
              or $state[$p:lk] = 40801                      (: 'element' 'union' :)
              or $state[$p:lk] = 41825                      (: 'element' 'where' :)
              or $state[$p:lk] = 43105) then                (: 'element' 'where' :)
          let $state := p:lookahead3W(145, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               '^' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 146) then                      (: 'processing-instruction' :)
      let $state := p:lookahead2W(122, $input, $state)      (: S^WS | NCName^Token | '!=' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'eq' | 'except' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'to' | 'treat' | 'union' |
                                                               'where' | '{' | '|' | '}' :)
      let $state :=
        if ($state[$p:lk] = 20626) then                     (: 'processing-instruction' 'case' :)
          let $state := p:lookahead3W(136, $input, $state)  (: S^WS | QName^Token | '$' | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
          return $state
        else if ($state[$p:lk] = 21650) then                (: 'processing-instruction' 'collation' :)
          let $state := p:lookahead3W(47, $input, $state)   (: StringLiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 23186) then                (: 'processing-instruction' 'default' :)
          let $state := p:lookahead3W(72, $input, $state)   (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 25490) then                (: 'processing-instruction' 'empty' :)
          let $state := p:lookahead3W(78, $input, $state)   (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] = 30610) then                (: 'processing-instruction' 'instance' :)
          let $state := p:lookahead3W(68, $input, $state)   (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] = 35730) then                (: 'processing-instruction' 'order' :)
          let $state := p:lookahead3W(65, $input, $state)   (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = 39570) then                (: 'processing-instruction' 'stable' :)
          let $state := p:lookahead3W(69, $input, $state)   (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = 19090                      (: 'processing-instruction' 'descending' :)
              or $state[$p:lk] = 23954) then                (: 'processing-instruction' 'descending' :)
          let $state := p:lookahead3W(86, $input, $state)   (: S^WS | ('(' ':') | ',' | 'collation' | 'empty' |
                                                               'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 27794                      (: 'processing-instruction' 'let' :)
              or $state[$p:lk] = 32658) then                (: 'processing-instruction' 'let' :)
          let $state := p:lookahead3W(52, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 20882                      (: 'processing-instruction' 'castable' :)
              or $state[$p:lk] = 21138                      (: 'processing-instruction' 'treat' :)
              or $state[$p:lk] = 41106) then                (: 'processing-instruction' 'treat' :)
          let $state := p:lookahead3W(63, $input, $state)   (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 18578                      (: 'processing-instruction' 'div' :)
              or $state[$p:lk] = 24210                      (: 'processing-instruction' 'else' :)
              or $state[$p:lk] = 25234                      (: 'processing-instruction' 'eq' :)
              or $state[$p:lk] = 26258                      (: 'processing-instruction' 'except' :)
              or $state[$p:lk] = 26770                      (: 'processing-instruction' 'ge' :)
              or $state[$p:lk] = 28306                      (: 'processing-instruction' 'gt' :)
              or $state[$p:lk] = 28818                      (: 'processing-instruction' 'idiv' :)
              or $state[$p:lk] = 29330                      (: 'processing-instruction' 'intersect' :)
              or $state[$p:lk] = 30866                      (: 'processing-instruction' 'is' :)
              or $state[$p:lk] = 31122                      (: 'processing-instruction' 'le' :)
              or $state[$p:lk] = 32146                      (: 'processing-instruction' 'lt' :)
              or $state[$p:lk] = 32914                      (: 'processing-instruction' 'mod' :)
              or $state[$p:lk] = 33170                      (: 'processing-instruction' 'ne' :)
              or $state[$p:lk] = 33938                      (: 'processing-instruction' 'or' :)
              or $state[$p:lk] = 35474                      (: 'processing-instruction' 'return' :)
              or $state[$p:lk] = 37778                      (: 'processing-instruction' 'satisfies' :)
              or $state[$p:lk] = 38034                      (: 'processing-instruction' 'to' :)
              or $state[$p:lk] = 40850                      (: 'processing-instruction' 'union' :)
              or $state[$p:lk] = 41874                      (: 'processing-instruction' 'where' :)
              or $state[$p:lk] = 43154) then                (: 'processing-instruction' 'where' :)
          let $state := p:lookahead3W(145, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               '^' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 85                             (: 'document' :)
          or $state[$p:l1] = 95                             (: 'ordered' :)
          or $state[$p:l1] = 140                            (: 'text' :)
          or $state[$p:l1] = 157                            (: 'unordered' :)
          or $state[$p:l1] = 164) then                      (: 'unordered' :)
      let $state := p:lookahead2W(121, $input, $state)      (: S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '{' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 70                             (: 'ancestor-or-self' :)
          or $state[$p:l1] = 71                             (: 'child' :)
          or $state[$p:l1] = 83                             (: 'descendant' :)
          or $state[$p:l1] = 91                             (: 'descendant-or-self' :)
          or $state[$p:l1] = 92                             (: 'following' :)
          or $state[$p:l1] = 106                            (: 'following-sibling' :)
          or $state[$p:l1] = 107                            (: 'parent' :)
          or $state[$p:l1] = 142                            (: 'preceding' :)
          or $state[$p:l1] = 143                            (: 'preceding-sibling' :)
          or $state[$p:l1] = 144                            (: 'self' :)
          or $state[$p:l1] = 152) then                      (: 'self' :)
      let $state := p:lookahead2W(120, $input, $state)      (: S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 18                             (: 'and' :)
          or $state[$p:l1] = 72                             (: 'ascending' :)
          or $state[$p:l1] = 74                             (: 'case' :)
          or $state[$p:l1] = 80                             (: 'cast' :)
          or $state[$p:l1] = 81                             (: 'castable' :)
          or $state[$p:l1] = 82                             (: 'collation' :)
          or $state[$p:l1] = 84                             (: 'declare' :)
          or $state[$p:l1] = 89                             (: 'default' :)
          or $state[$p:l1] = 90                             (: 'descending' :)
          or $state[$p:l1] = 93                             (: 'div' :)
          or $state[$p:l1] = 94                             (: 'else' :)
          or $state[$p:l1] = 98                             (: 'empty' :)
          or $state[$p:l1] = 99                             (: 'eq' :)
          or $state[$p:l1] = 102                            (: 'every' :)
          or $state[$p:l1] = 103                            (: 'except' :)
          or $state[$p:l1] = 104                            (: 'for' :)
          or $state[$p:l1] = 108                            (: 'ge' :)
          or $state[$p:l1] = 110                            (: 'gt' :)
          or $state[$p:l1] = 112                            (: 'idiv' :)
          or $state[$p:l1] = 114                            (: 'import' :)
          or $state[$p:l1] = 116                            (: 'instance' :)
          or $state[$p:l1] = 119                            (: 'intersect' :)
          or $state[$p:l1] = 120                            (: 'is' :)
          or $state[$p:l1] = 121                            (: 'le' :)
          or $state[$p:l1] = 125                            (: 'let' :)
          or $state[$p:l1] = 127                            (: 'lt' :)
          or $state[$p:l1] = 128                            (: 'mod' :)
          or $state[$p:l1] = 129                            (: 'module' :)
          or $state[$p:l1] = 130                            (: 'ne' :)
          or $state[$p:l1] = 132                            (: 'or' :)
          or $state[$p:l1] = 138                            (: 'order' :)
          or $state[$p:l1] = 139                            (: 'return' :)
          or $state[$p:l1] = 147                            (: 'satisfies' :)
          or $state[$p:l1] = 148                            (: 'some' :)
          or $state[$p:l1] = 153                            (: 'stable' :)
          or $state[$p:l1] = 154                            (: 'to' :)
          or $state[$p:l1] = 159                            (: 'treat' :)
          or $state[$p:l1] = 160                            (: 'union' :)
          or $state[$p:l1] = 163                            (: 'validate' :)
          or $state[$p:l1] = 165                            (: 'where' :)
          or $state[$p:l1] = 168                            (: 'xquery' :)
          or $state[$p:l1] = 169) then                      (: 'xquery' :)
      let $state := p:lookahead2W(117, $input, $state)      (: S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 3                                   (: IntegerLiteral :)
     or $state[$p:lk] = 4                                   (: DecimalLiteral :)
     or $state[$p:lk] = 5                                   (: DoubleLiteral :)
     or $state[$p:lk] = 6                                   (: StringLiteral :)
     or $state[$p:lk] = 7                                   (: TextNodeLiteral :)
     or $state[$p:lk] = 31                                  (: '$' :)
     or $state[$p:lk] = 33                                  (: '(' :)
     or $state[$p:lk] = 44                                  (: '.' :)
     or $state[$p:lk] = 54                                  (: '<' :)
     or $state[$p:lk] = 55                                  (: '<!--' :)
     or $state[$p:lk] = 59                                  (: '<?' :)
     or $state[$p:lk] = 69                                  (: '^' :)
     or $state[$p:lk] = 87                                  (: 'copy' :)
     or $state[$p:lk] = 4498                                (: 'processing-instruction' NCName^Token :)
     or $state[$p:lk] = 4684                                (: 'attribute' QName^Token :)
     or $state[$p:lk] = 4705                                (: 'element' QName^Token :)
     or $state[$p:lk] = 8466                                (: QName^Token '(' :)
     or $state[$p:lk] = 8518                                (: 'ancestor' '(' :)
     or $state[$p:lk] = 8519                                (: 'ancestor-or-self' '(' :)
     or $state[$p:lk] = 8520                                (: 'and' '(' :)
     or $state[$p:lk] = 8522                                (: 'ascending' '(' :)
     or $state[$p:lk] = 8528                                (: 'case' '(' :)
     or $state[$p:lk] = 8529                                (: 'cast' '(' :)
     or $state[$p:lk] = 8530                                (: 'castable' '(' :)
     or $state[$p:lk] = 8531                                (: 'child' '(' :)
     or $state[$p:lk] = 8532                                (: 'collation' '(' :)
     or $state[$p:lk] = 8537                                (: 'declare' '(' :)
     or $state[$p:lk] = 8538                                (: 'default' '(' :)
     or $state[$p:lk] = 8539                                (: 'descendant' '(' :)
     or $state[$p:lk] = 8540                                (: 'descendant-or-self' '(' :)
     or $state[$p:lk] = 8541                                (: 'descending' '(' :)
     or $state[$p:lk] = 8542                                (: 'div' '(' :)
     or $state[$p:lk] = 8543                                (: 'document' '(' :)
     or $state[$p:lk] = 8546                                (: 'else' '(' :)
     or $state[$p:lk] = 8547                                (: 'empty' '(' :)
     or $state[$p:lk] = 8550                                (: 'eq' '(' :)
     or $state[$p:lk] = 8551                                (: 'every' '(' :)
     or $state[$p:lk] = 8552                                (: 'except' '(' :)
     or $state[$p:lk] = 8554                                (: 'following' '(' :)
     or $state[$p:lk] = 8555                                (: 'following-sibling' '(' :)
     or $state[$p:lk] = 8556                                (: 'for' '(' :)
     or $state[$p:lk] = 8558                                (: 'ge' '(' :)
     or $state[$p:lk] = 8560                                (: 'gt' '(' :)
     or $state[$p:lk] = 8562                                (: 'idiv' '(' :)
     or $state[$p:lk] = 8564                                (: 'import' '(' :)
     or $state[$p:lk] = 8567                                (: 'instance' '(' :)
     or $state[$p:lk] = 8568                                (: 'intersect' '(' :)
     or $state[$p:lk] = 8569                                (: 'is' '(' :)
     or $state[$p:lk] = 8573                                (: 'le' '(' :)
     or $state[$p:lk] = 8575                                (: 'let' '(' :)
     or $state[$p:lk] = 8576                                (: 'lt' '(' :)
     or $state[$p:lk] = 8577                                (: 'mod' '(' :)
     or $state[$p:lk] = 8578                                (: 'module' '(' :)
     or $state[$p:lk] = 8580                                (: 'ne' '(' :)
     or $state[$p:lk] = 8586                                (: 'or' '(' :)
     or $state[$p:lk] = 8587                                (: 'order' '(' :)
     or $state[$p:lk] = 8588                                (: 'ordered' '(' :)
     or $state[$p:lk] = 8590                                (: 'parent' '(' :)
     or $state[$p:lk] = 8591                                (: 'preceding' '(' :)
     or $state[$p:lk] = 8592                                (: 'preceding-sibling' '(' :)
     or $state[$p:lk] = 8595                                (: 'return' '(' :)
     or $state[$p:lk] = 8596                                (: 'satisfies' '(' :)
     or $state[$p:lk] = 8600                                (: 'self' '(' :)
     or $state[$p:lk] = 8601                                (: 'some' '(' :)
     or $state[$p:lk] = 8602                                (: 'stable' '(' :)
     or $state[$p:lk] = 8607                                (: 'to' '(' :)
     or $state[$p:lk] = 8608                                (: 'treat' '(' :)
     or $state[$p:lk] = 8611                                (: 'union' '(' :)
     or $state[$p:lk] = 8612                                (: 'unordered' '(' :)
     or $state[$p:lk] = 8613                                (: 'validate' '(' :)
     or $state[$p:lk] = 8616                                (: 'where' '(' :)
     or $state[$p:lk] = 8617                                (: 'xquery' '(' :)
     or $state[$p:lk] = 17996                               (: 'attribute' 'ancestor' :)
     or $state[$p:lk] = 18017                               (: 'element' 'ancestor' :)
     or $state[$p:lk] = 18252                               (: 'attribute' 'ancestor-or-self' :)
     or $state[$p:lk] = 18273                               (: 'element' 'ancestor-or-self' :)
     or $state[$p:lk] = 19532                               (: 'attribute' 'attribute' :)
     or $state[$p:lk] = 19553                               (: 'element' 'attribute' :)
     or $state[$p:lk] = 21324                               (: 'attribute' 'child' :)
     or $state[$p:lk] = 21345                               (: 'element' 'child' :)
     or $state[$p:lk] = 21836                               (: 'attribute' 'comment' :)
     or $state[$p:lk] = 21857                               (: 'element' 'comment' :)
     or $state[$p:lk] = 22860                               (: 'attribute' 'declare' :)
     or $state[$p:lk] = 22881                               (: 'element' 'declare' :)
     or $state[$p:lk] = 23372                               (: 'attribute' 'descendant' :)
     or $state[$p:lk] = 23393                               (: 'element' 'descendant' :)
     or $state[$p:lk] = 23628                               (: 'attribute' 'descendant-or-self' :)
     or $state[$p:lk] = 23649                               (: 'element' 'descendant-or-self' :)
     or $state[$p:lk] = 24396                               (: 'attribute' 'document' :)
     or $state[$p:lk] = 24417                               (: 'element' 'document' :)
     or $state[$p:lk] = 24652                               (: 'attribute' 'document-node' :)
     or $state[$p:lk] = 24673                               (: 'element' 'document-node' :)
     or $state[$p:lk] = 24908                               (: 'attribute' 'element' :)
     or $state[$p:lk] = 24929                               (: 'element' 'element' :)
     or $state[$p:lk] = 25676                               (: 'attribute' 'empty-sequence' :)
     or $state[$p:lk] = 25697                               (: 'element' 'empty-sequence' :)
     or $state[$p:lk] = 26444                               (: 'attribute' 'every' :)
     or $state[$p:lk] = 26465                               (: 'element' 'every' :)
     or $state[$p:lk] = 27212                               (: 'attribute' 'following' :)
     or $state[$p:lk] = 27233                               (: 'element' 'following' :)
     or $state[$p:lk] = 27468                               (: 'attribute' 'following-sibling' :)
     or $state[$p:lk] = 27489                               (: 'element' 'following-sibling' :)
     or $state[$p:lk] = 29516                               (: 'attribute' 'if' :)
     or $state[$p:lk] = 29537                               (: 'element' 'if' :)
     or $state[$p:lk] = 29772                               (: 'attribute' 'import' :)
     or $state[$p:lk] = 29793                               (: 'element' 'import' :)
     or $state[$p:lk] = 31308                               (: 'attribute' 'item' :)
     or $state[$p:lk] = 31329                               (: 'element' 'item' :)
     or $state[$p:lk] = 33356                               (: 'attribute' 'module' :)
     or $state[$p:lk] = 33377                               (: 'element' 'module' :)
     or $state[$p:lk] = 34636                               (: 'attribute' 'node' :)
     or $state[$p:lk] = 34657                               (: 'element' 'node' :)
     or $state[$p:lk] = 35916                               (: 'attribute' 'ordered' :)
     or $state[$p:lk] = 35937                               (: 'element' 'ordered' :)
     or $state[$p:lk] = 36428                               (: 'attribute' 'parent' :)
     or $state[$p:lk] = 36449                               (: 'element' 'parent' :)
     or $state[$p:lk] = 36684                               (: 'attribute' 'preceding' :)
     or $state[$p:lk] = 36705                               (: 'element' 'preceding' :)
     or $state[$p:lk] = 36940                               (: 'attribute' 'preceding-sibling' :)
     or $state[$p:lk] = 36961                               (: 'element' 'preceding-sibling' :)
     or $state[$p:lk] = 37452                               (: 'attribute' 'processing-instruction' :)
     or $state[$p:lk] = 37473                               (: 'element' 'processing-instruction' :)
     or $state[$p:lk] = 38476                               (: 'attribute' 'schema-attribute' :)
     or $state[$p:lk] = 38497                               (: 'element' 'schema-attribute' :)
     or $state[$p:lk] = 38732                               (: 'attribute' 'schema-element' :)
     or $state[$p:lk] = 38753                               (: 'element' 'schema-element' :)
     or $state[$p:lk] = 38988                               (: 'attribute' 'self' :)
     or $state[$p:lk] = 39009                               (: 'element' 'self' :)
     or $state[$p:lk] = 39244                               (: 'attribute' 'some' :)
     or $state[$p:lk] = 39265                               (: 'element' 'some' :)
     or $state[$p:lk] = 40268                               (: 'attribute' 'text' :)
     or $state[$p:lk] = 40289                               (: 'element' 'text' :)
     or $state[$p:lk] = 41548                               (: 'attribute' 'typeswitch' :)
     or $state[$p:lk] = 41569                               (: 'element' 'typeswitch' :)
     or $state[$p:lk] = 42060                               (: 'attribute' 'unordered' :)
     or $state[$p:lk] = 42081                               (: 'element' 'unordered' :)
     or $state[$p:lk] = 42316                               (: 'attribute' 'validate' :)
     or $state[$p:lk] = 42337                               (: 'element' 'validate' :)
     or $state[$p:lk] = 43340                               (: 'attribute' 'xquery' :)
     or $state[$p:lk] = 43361                               (: 'element' 'xquery' :)
     or $state[$p:lk] = 43596                               (: 'attribute' '{' :)
     or $state[$p:lk] = 43605                               (: 'comment' '{' :)
     or $state[$p:lk] = 43615                               (: 'document' '{' :)
     or $state[$p:lk] = 43617                               (: 'element' '{' :)
     or $state[$p:lk] = 43660                               (: 'ordered' '{' :)
     or $state[$p:lk] = 43666                               (: 'processing-instruction' '{' :)
     or $state[$p:lk] = 43677                               (: 'text' '{' :)
     or $state[$p:lk] = 43684                               (: 'unordered' '{' :)
     or $state[$p:lk] = 11159628                            (: 'attribute' 'and' '{' :)
     or $state[$p:lk] = 11159649                            (: 'element' 'and' '{' :)
     or $state[$p:lk] = 11159698                            (: 'processing-instruction' 'and' '{' :)
     or $state[$p:lk] = 11160140                            (: 'attribute' 'ascending' '{' :)
     or $state[$p:lk] = 11160161                            (: 'element' 'ascending' '{' :)
     or $state[$p:lk] = 11160210                            (: 'processing-instruction' 'ascending' '{' :)
     or $state[$p:lk] = 11161676                            (: 'attribute' 'case' '{' :)
     or $state[$p:lk] = 11161697                            (: 'element' 'case' '{' :)
     or $state[$p:lk] = 11161746                            (: 'processing-instruction' 'case' '{' :)
     or $state[$p:lk] = 11161932                            (: 'attribute' 'cast' '{' :)
     or $state[$p:lk] = 11161953                            (: 'element' 'cast' '{' :)
     or $state[$p:lk] = 11162002                            (: 'processing-instruction' 'cast' '{' :)
     or $state[$p:lk] = 11162188                            (: 'attribute' 'castable' '{' :)
     or $state[$p:lk] = 11162209                            (: 'element' 'castable' '{' :)
     or $state[$p:lk] = 11162258                            (: 'processing-instruction' 'castable' '{' :)
     or $state[$p:lk] = 11162700                            (: 'attribute' 'collation' '{' :)
     or $state[$p:lk] = 11162721                            (: 'element' 'collation' '{' :)
     or $state[$p:lk] = 11162770                            (: 'processing-instruction' 'collation' '{' :)
     or $state[$p:lk] = 11164236                            (: 'attribute' 'default' '{' :)
     or $state[$p:lk] = 11164257                            (: 'element' 'default' '{' :)
     or $state[$p:lk] = 11164306                            (: 'processing-instruction' 'default' '{' :)
     or $state[$p:lk] = 11165004                            (: 'attribute' 'descending' '{' :)
     or $state[$p:lk] = 11165025                            (: 'element' 'descending' '{' :)
     or $state[$p:lk] = 11165074                            (: 'processing-instruction' 'descending' '{' :)
     or $state[$p:lk] = 11165260                            (: 'attribute' 'div' '{' :)
     or $state[$p:lk] = 11165281                            (: 'element' 'div' '{' :)
     or $state[$p:lk] = 11165330                            (: 'processing-instruction' 'div' '{' :)
     or $state[$p:lk] = 11166284                            (: 'attribute' 'else' '{' :)
     or $state[$p:lk] = 11166305                            (: 'element' 'else' '{' :)
     or $state[$p:lk] = 11166354                            (: 'processing-instruction' 'else' '{' :)
     or $state[$p:lk] = 11166540                            (: 'attribute' 'empty' '{' :)
     or $state[$p:lk] = 11166561                            (: 'element' 'empty' '{' :)
     or $state[$p:lk] = 11166610                            (: 'processing-instruction' 'empty' '{' :)
     or $state[$p:lk] = 11167308                            (: 'attribute' 'eq' '{' :)
     or $state[$p:lk] = 11167329                            (: 'element' 'eq' '{' :)
     or $state[$p:lk] = 11167378                            (: 'processing-instruction' 'eq' '{' :)
     or $state[$p:lk] = 11167820                            (: 'attribute' 'except' '{' :)
     or $state[$p:lk] = 11167841                            (: 'element' 'except' '{' :)
     or $state[$p:lk] = 11167890                            (: 'processing-instruction' 'except' '{' :)
     or $state[$p:lk] = 11168844                            (: 'attribute' 'for' '{' :)
     or $state[$p:lk] = 11168865                            (: 'element' 'for' '{' :)
     or $state[$p:lk] = 11168914                            (: 'processing-instruction' 'for' '{' :)
     or $state[$p:lk] = 11169356                            (: 'attribute' 'ge' '{' :)
     or $state[$p:lk] = 11169377                            (: 'element' 'ge' '{' :)
     or $state[$p:lk] = 11169426                            (: 'processing-instruction' 'ge' '{' :)
     or $state[$p:lk] = 11169868                            (: 'attribute' 'gt' '{' :)
     or $state[$p:lk] = 11169889                            (: 'element' 'gt' '{' :)
     or $state[$p:lk] = 11169938                            (: 'processing-instruction' 'gt' '{' :)
     or $state[$p:lk] = 11170380                            (: 'attribute' 'idiv' '{' :)
     or $state[$p:lk] = 11170401                            (: 'element' 'idiv' '{' :)
     or $state[$p:lk] = 11170450                            (: 'processing-instruction' 'idiv' '{' :)
     or $state[$p:lk] = 11171660                            (: 'attribute' 'instance' '{' :)
     or $state[$p:lk] = 11171681                            (: 'element' 'instance' '{' :)
     or $state[$p:lk] = 11171730                            (: 'processing-instruction' 'instance' '{' :)
     or $state[$p:lk] = 11171916                            (: 'attribute' 'intersect' '{' :)
     or $state[$p:lk] = 11171937                            (: 'element' 'intersect' '{' :)
     or $state[$p:lk] = 11171986                            (: 'processing-instruction' 'intersect' '{' :)
     or $state[$p:lk] = 11172172                            (: 'attribute' 'is' '{' :)
     or $state[$p:lk] = 11172193                            (: 'element' 'is' '{' :)
     or $state[$p:lk] = 11172242                            (: 'processing-instruction' 'is' '{' :)
     or $state[$p:lk] = 11173196                            (: 'attribute' 'le' '{' :)
     or $state[$p:lk] = 11173217                            (: 'element' 'le' '{' :)
     or $state[$p:lk] = 11173266                            (: 'processing-instruction' 'le' '{' :)
     or $state[$p:lk] = 11173708                            (: 'attribute' 'let' '{' :)
     or $state[$p:lk] = 11173729                            (: 'element' 'let' '{' :)
     or $state[$p:lk] = 11173778                            (: 'processing-instruction' 'let' '{' :)
     or $state[$p:lk] = 11173964                            (: 'attribute' 'lt' '{' :)
     or $state[$p:lk] = 11173985                            (: 'element' 'lt' '{' :)
     or $state[$p:lk] = 11174034                            (: 'processing-instruction' 'lt' '{' :)
     or $state[$p:lk] = 11174220                            (: 'attribute' 'mod' '{' :)
     or $state[$p:lk] = 11174241                            (: 'element' 'mod' '{' :)
     or $state[$p:lk] = 11174290                            (: 'processing-instruction' 'mod' '{' :)
     or $state[$p:lk] = 11174988                            (: 'attribute' 'ne' '{' :)
     or $state[$p:lk] = 11175009                            (: 'element' 'ne' '{' :)
     or $state[$p:lk] = 11175058                            (: 'processing-instruction' 'ne' '{' :)
     or $state[$p:lk] = 11176524                            (: 'attribute' 'or' '{' :)
     or $state[$p:lk] = 11176545                            (: 'element' 'or' '{' :)
     or $state[$p:lk] = 11176594                            (: 'processing-instruction' 'or' '{' :)
     or $state[$p:lk] = 11176780                            (: 'attribute' 'order' '{' :)
     or $state[$p:lk] = 11176801                            (: 'element' 'order' '{' :)
     or $state[$p:lk] = 11176850                            (: 'processing-instruction' 'order' '{' :)
     or $state[$p:lk] = 11178828                            (: 'attribute' 'return' '{' :)
     or $state[$p:lk] = 11178849                            (: 'element' 'return' '{' :)
     or $state[$p:lk] = 11178898                            (: 'processing-instruction' 'return' '{' :)
     or $state[$p:lk] = 11179084                            (: 'attribute' 'satisfies' '{' :)
     or $state[$p:lk] = 11179105                            (: 'element' 'satisfies' '{' :)
     or $state[$p:lk] = 11179154                            (: 'processing-instruction' 'satisfies' '{' :)
     or $state[$p:lk] = 11180620                            (: 'attribute' 'stable' '{' :)
     or $state[$p:lk] = 11180641                            (: 'element' 'stable' '{' :)
     or $state[$p:lk] = 11180690                            (: 'processing-instruction' 'stable' '{' :)
     or $state[$p:lk] = 11181900                            (: 'attribute' 'to' '{' :)
     or $state[$p:lk] = 11181921                            (: 'element' 'to' '{' :)
     or $state[$p:lk] = 11181970                            (: 'processing-instruction' 'to' '{' :)
     or $state[$p:lk] = 11182156                            (: 'attribute' 'treat' '{' :)
     or $state[$p:lk] = 11182177                            (: 'element' 'treat' '{' :)
     or $state[$p:lk] = 11182226                            (: 'processing-instruction' 'treat' '{' :)
     or $state[$p:lk] = 11182924                            (: 'attribute' 'union' '{' :)
     or $state[$p:lk] = 11182945                            (: 'element' 'union' '{' :)
     or $state[$p:lk] = 11182994                            (: 'processing-instruction' 'union' '{' :)
     or $state[$p:lk] = 11184204                            (: 'attribute' 'where' '{' :)
     or $state[$p:lk] = 11184225                            (: 'element' 'where' '{' :)
     or $state[$p:lk] = 11184274) then                      (: 'processing-instruction' 'where' '{' :)
      let $state := p:parse-FilterExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AxisStep($input, $state)
      return $state
  return p:reduce($state, "StepExpr", $count)
};

(:~
 : Parse the 1st loop of production RelativePathExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RelativePathExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(112, $input, $state)        (: S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                               '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'and' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'ne' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'to' | 'treat' |
                                                               'union' | 'where' | '|' | '}' :)
    return
      if ($state[$p:l1] != 46                               (: '/' :)
      and $state[$p:l1] != 47) then                         (: '//' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 46) then                      (: '/' :)
            let $state := p:shift(46, $input, $state)       (: '/' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(47, $input, $state)       (: '//' :)
            return $state
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-StepExpr($input, $state)
        return p:parse-RelativePathExpr-1($input, $state)
};

(:~
 : Parse RelativePathExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RelativePathExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-StepExpr($input, $state)
  let $state := p:parse-RelativePathExpr-1($input, $state)
  return p:reduce($state, "RelativePathExpr", $count)
};

(:~
 : Parse PathExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PathExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 46) then                            (: '/' :)
      let $state := p:shift(46, $input, $state)             (: '/' :)
      let $state := p:lookahead1W(150, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '!=' | '$' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '.' | '..' | ';' | '<' | '<!--' |
                                                               '<<' | '<=' | '<?' | '=' | '>' | '>=' | '>>' | '@' |
                                                               ']' | '^' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '|' | '}' :)
      let $state :=
        if ($state[$p:l1] = 26                              (: '!=' :)
         or $state[$p:l1] = 36                              (: ')' :)
         or $state[$p:l1] = 37                              (: '*' :)
         or $state[$p:l1] = 39                              (: '+' :)
         or $state[$p:l1] = 41                              (: ',' :)
         or $state[$p:l1] = 42                              (: '-' :)
         or $state[$p:l1] = 53                              (: ';' :)
         or $state[$p:l1] = 57                              (: '<<' :)
         or $state[$p:l1] = 58                              (: '<=' :)
         or $state[$p:l1] = 60                              (: '=' :)
         or $state[$p:l1] = 61                              (: '>' :)
         or $state[$p:l1] = 62                              (: '>=' :)
         or $state[$p:l1] = 63                              (: '>>' :)
         or $state[$p:l1] = 68                              (: ']' :)
         or $state[$p:l1] = 172                             (: '|' :)
         or $state[$p:l1] = 173) then                       (: '}' :)
          $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:parse-RelativePathExpr($input, $state)
          return $state
      return $state
    else if ($state[$p:l1] = 47) then                       (: '//' :)
      let $state := p:shift(47, $input, $state)             (: '//' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-RelativePathExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-RelativePathExpr($input, $state)
      return $state
  return p:reduce($state, "PathExpr", $count)
};

(:~
 : Parse ValidationMode.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValidationMode($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 124) then                           (: 'lax' :)
      let $state := p:shift(124, $input, $state)            (: 'lax' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(155, $input, $state)            (: 'strict' :)
      return $state
  return p:reduce($state, "ValidationMode", $count)
};

(:~
 : Parse ValidateExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValidateExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(165, $input, $state)                (: 'validate' :)
  let $state := p:lookahead1W(79, $input, $state)           (: S^WS | ('(' ':') | 'lax' | 'strict' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 170) then                     (: '{' :)
      let $state := p:parse-ValidationMode($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(170, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(173, $input, $state)                (: '}' :)
  return p:reduce($state, "ValidateExpr", $count)
};

(:~
 : Parse ValueExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValueExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 165) then                           (: 'validate' :)
      let $state := p:lookahead2W(123, $input, $state)      (: S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'lax' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'strict' | 'to' | 'treat' | 'union' |
                                                               'where' | '{' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 31909                               (: 'validate' 'lax' :)
     or $state[$p:lk] = 39845                               (: 'validate' 'strict' :)
     or $state[$p:lk] = 43685) then                         (: 'validate' '{' :)
      let $state := p:parse-ValidateExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 34) then                       (: '(#' :)
      let $state := p:parse-ExtensionExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-PathExpr($input, $state)
      return $state
  return p:reduce($state, "ValueExpr", $count)
};

(:~
 : Parse the 1st loop of production UnaryExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnaryExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(143, $input, $state)        (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               '^' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
    return
      if ($state[$p:l1] != 39                               (: '+' :)
      and $state[$p:l1] != 42) then                         (: '-' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 42) then                      (: '-' :)
            let $state := p:shift(42, $input, $state)       (: '-' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(39, $input, $state)       (: '+' :)
            return $state
        return p:parse-UnaryExpr-1($input, $state)
};

(:~
 : Parse UnaryExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-UnaryExpr-1($input, $state)
  let $state := p:parse-ValueExpr($input, $state)
  return p:reduce($state, "UnaryExpr", $count)
};

(:~
 : Parse CastExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CastExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-UnaryExpr($input, $state)
  let $state := p:lookahead1W(111, $input, $state)          (: S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'eq' | 'except' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'to' | 'treat' | 'union' |
                                                               'where' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 81) then                       (: 'cast' :)
      let $state := p:shift(81, $input, $state)             (: 'cast' :)
      let $state := p:lookahead1W(35, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:shift(73, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-SingleType($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "CastExpr", $count)
};

(:~
 : Parse CastableExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CastableExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-CastExpr($input, $state)
  let $state := p:lookahead1W(109, $input, $state)          (: S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'castable' | 'collation' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'eq' | 'except' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 82) then                       (: 'castable' :)
      let $state := p:shift(82, $input, $state)             (: 'castable' :)
      let $state := p:lookahead1W(35, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:shift(73, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-SingleType($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "CastableExpr", $count)
};

(:~
 : Parse TreatExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TreatExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-CastableExpr($input, $state)
  let $state := p:lookahead1W(108, $input, $state)          (: S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 160) then                      (: 'treat' :)
      let $state := p:shift(160, $input, $state)            (: 'treat' :)
      let $state := p:lookahead1W(35, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:shift(73, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "TreatExpr", $count)
};

(:~
 : Parse InstanceofExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InstanceofExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-TreatExpr($input, $state)
  let $state := p:lookahead1W(107, $input, $state)          (: S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'union' | 'where' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 119) then                      (: 'instance' :)
      let $state := p:shift(119, $input, $state)            (: 'instance' :)
      let $state := p:lookahead1W(39, $input, $state)       (: S^WS | ('(' ':') | 'of' :)
      let $state := p:shift(136, $input, $state)            (: 'of' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "InstanceofExpr", $count)
};

(:~
 : Parse the 1st loop of production IntersectExceptExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IntersectExceptExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(106, $input, $state)        (: S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'intersect' |
                                                               'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'to' |
                                                               'union' | 'where' | '|' | '}' :)
    return
      if ($state[$p:l1] != 104                              (: 'except' :)
      and $state[$p:l1] != 120) then                        (: 'intersect' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 120) then                     (: 'intersect' :)
            let $state := p:shift(120, $input, $state)      (: 'intersect' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(104, $input, $state)      (: 'except' :)
            return $state
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-InstanceofExpr($input, $state)
        return p:parse-IntersectExceptExpr-1($input, $state)
};

(:~
 : Parse IntersectExceptExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IntersectExceptExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-InstanceofExpr($input, $state)
  let $state := p:parse-IntersectExceptExpr-1($input, $state)
  return p:reduce($state, "IntersectExceptExpr", $count)
};

(:~
 : Parse the 1st loop of production UnionExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnionExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(105, $input, $state)        (: S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'to' | 'union' | 'where' | '|' | '}' :)
    return
      if ($state[$p:l1] != 163                              (: 'union' :)
      and $state[$p:l1] != 172) then                        (: '|' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 163) then                     (: 'union' :)
            let $state := p:shift(163, $input, $state)      (: 'union' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(172, $input, $state)      (: '|' :)
            return $state
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-IntersectExceptExpr($input, $state)
        return p:parse-UnionExpr-1($input, $state)
};

(:~
 : Parse UnionExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnionExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-IntersectExceptExpr($input, $state)
  let $state := p:parse-UnionExpr-1($input, $state)
  return p:reduce($state, "UnionExpr", $count)
};

(:~
 : Parse the 1st loop of production MultiplicativeExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MultiplicativeExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(104, $input, $state)        (: S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'to' | 'where' | '}' :)
    return
      if ($state[$p:l1] != 37                               (: '*' :)
      and $state[$p:l1] != 94                               (: 'div' :)
      and $state[$p:l1] != 114                              (: 'idiv' :)
      and $state[$p:l1] != 129) then                        (: 'mod' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 37) then                      (: '*' :)
            let $state := p:shift(37, $input, $state)       (: '*' :)
            return $state
          else if ($state[$p:l1] = 94) then                 (: 'div' :)
            let $state := p:shift(94, $input, $state)       (: 'div' :)
            return $state
          else if ($state[$p:l1] = 114) then                (: 'idiv' :)
            let $state := p:shift(114, $input, $state)      (: 'idiv' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(129, $input, $state)      (: 'mod' :)
            return $state
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-UnionExpr($input, $state)
        return p:parse-MultiplicativeExpr-1($input, $state)
};

(:~
 : Parse MultiplicativeExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MultiplicativeExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-UnionExpr($input, $state)
  let $state := p:parse-MultiplicativeExpr-1($input, $state)
  return p:reduce($state, "MultiplicativeExpr", $count)
};

(:~
 : Parse the 1st loop of production AdditiveExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AdditiveExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(103, $input, $state)        (: S^WS | '!=' | ('(' ':') | ')' | '+' | ',' | '-' | ';' |
                                                               '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'else' | 'empty' | 'eq' | 'for' | 'ge' |
                                                               'gt' | 'is' | 'le' | 'let' | 'lt' | 'ne' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'to' |
                                                               'where' | '}' :)
    return
      if ($state[$p:l1] != 39                               (: '+' :)
      and $state[$p:l1] != 42) then                         (: '-' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 39) then                      (: '+' :)
            let $state := p:shift(39, $input, $state)       (: '+' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(42, $input, $state)       (: '-' :)
            return $state
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-MultiplicativeExpr($input, $state)
        return p:parse-AdditiveExpr-1($input, $state)
};

(:~
 : Parse AdditiveExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AdditiveExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-MultiplicativeExpr($input, $state)
  let $state := p:parse-AdditiveExpr-1($input, $state)
  return p:reduce($state, "AdditiveExpr", $count)
};

(:~
 : Parse RangeExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RangeExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-AdditiveExpr($input, $state)
  let $state := p:lookahead1W(102, $input, $state)          (: S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' |
                                                               'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'else' | 'empty' | 'eq' | 'for' | 'ge' |
                                                               'gt' | 'is' | 'le' | 'let' | 'lt' | 'ne' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'to' |
                                                               'where' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 159) then                      (: 'to' :)
      let $state := p:shift(159, $input, $state)            (: 'to' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-AdditiveExpr($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "RangeExpr", $count)
};

(:~
 : Parse ComparisonExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ComparisonExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-RangeExpr($input, $state)
  let $state := p:lookahead1W(100, $input, $state)          (: S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' |
                                                               'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'else' | 'empty' | 'eq' | 'for' | 'ge' |
                                                               'gt' | 'is' | 'le' | 'let' | 'lt' | 'ne' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'where' |
                                                               '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 26                             (: '!=' :)
          or $state[$p:l1] = 54                             (: '<' :)
          or $state[$p:l1] = 57                             (: '<<' :)
          or $state[$p:l1] = 58                             (: '<=' :)
          or $state[$p:l1] = 60                             (: '=' :)
          or $state[$p:l1] = 61                             (: '>' :)
          or $state[$p:l1] = 62                             (: '>=' :)
          or $state[$p:l1] = 63                             (: '>>' :)
          or $state[$p:l1] = 102                            (: 'eq' :)
          or $state[$p:l1] = 110                            (: 'ge' :)
          or $state[$p:l1] = 112                            (: 'gt' :)
          or $state[$p:l1] = 121                            (: 'is' :)
          or $state[$p:l1] = 125                            (: 'le' :)
          or $state[$p:l1] = 128                            (: 'lt' :)
          or $state[$p:l1] = 132) then                      (: 'ne' :)
      let $state :=
        if ($state[$p:l1] = 102                             (: 'eq' :)
         or $state[$p:l1] = 110                             (: 'ge' :)
         or $state[$p:l1] = 112                             (: 'gt' :)
         or $state[$p:l1] = 125                             (: 'le' :)
         or $state[$p:l1] = 128                             (: 'lt' :)
         or $state[$p:l1] = 132) then                       (: 'ne' :)
          let $state := p:parse-ValueComp($input, $state)
          return $state
        else if ($state[$p:l1] = 57                         (: '<<' :)
              or $state[$p:l1] = 63                         (: '>>' :)
              or $state[$p:l1] = 121) then                  (: 'is' :)
          let $state := p:parse-NodeComp($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:parse-GeneralComp($input, $state)
          return $state
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-RangeExpr($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "ComparisonExpr", $count)
};

(:~
 : Parse the 1st loop of production AndExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AndExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(96, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' | ';' | ']' | 'and' |
                                                               'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'else' | 'empty' | 'for' | 'let' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'where' |
                                                               '}' :)
    return
      if ($state[$p:l1] != 72) then                         (: 'and' :)
        $state
      else
        let $state := p:shift(72, $input, $state)           (: 'and' :)
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-ComparisonExpr($input, $state)
        return p:parse-AndExpr-1($input, $state)
};

(:~
 : Parse AndExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AndExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ComparisonExpr($input, $state)
  let $state := p:parse-AndExpr-1($input, $state)
  return p:reduce($state, "AndExpr", $count)
};

(:~
 : Parse the 1st loop of production OrExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(95, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' | ';' | ']' | 'ascending' |
                                                               'case' | 'collation' | 'default' | 'descending' |
                                                               'else' | 'empty' | 'for' | 'let' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'where' | '}' :)
    return
      if ($state[$p:l1] != 138) then                        (: 'or' :)
        $state
      else
        let $state := p:shift(138, $input, $state)          (: 'or' :)
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-AndExpr($input, $state)
        return p:parse-OrExpr-1($input, $state)
};

(:~
 : Parse OrExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-AndExpr($input, $state)
  let $state := p:parse-OrExpr-1($input, $state)
  return p:reduce($state, "OrExpr", $count)
};

(:~
 : Parse IfExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IfExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(115, $input, $state)                (: 'if' :)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(42, $input, $state)           (: S^WS | ('(' ':') | 'then' :)
  let $state := p:shift(158, $input, $state)                (: 'then' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:lookahead1W(37, $input, $state)           (: S^WS | ('(' ':') | 'else' :)
  let $state := p:shift(98, $input, $state)                 (: 'else' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "IfExpr", $count)
};

(:~
 : Parse CaseClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CaseClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(11, $input, $state)            (: 'case' :)
  let $state := p:shift(80, $input, $state)                 (: 'case' :)
  let $state := p:lookahead1W(132, $input, $state)          (: S^WS | QName^Token | '$' | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:shift(31, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(129, $input, $state)      (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
      let $state := p:parse-VarName($input, $state)
      let $state := p:lookahead1W(35, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:shift(73, $input, $state)             (: 'as' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-SequenceType($input, $state)
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:shift(147, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "CaseClause", $count)
};

(:~
 : Parse the 1st loop of production TypeswitchExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeswitchExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(20, $input, $state)         (: EPSILON | S^WS | ('(' ':') :)
    let $state := p:parse-CaseClause($input, $state)
    let $state := p:lookahead1W(66, $input, $state)         (: S^WS | ('(' ':') | 'case' | 'default' :)
    return
      if ($state[$p:l1] != 80) then                         (: 'case' :)
        $state
      else
        p:parse-TypeswitchExpr-1($input, $state)
};

(:~
 : Parse TypeswitchExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeswitchExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(162, $input, $state)                (: 'typeswitch' :)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-TypeswitchExpr-1($input, $state)
  let $state := p:shift(90, $input, $state)                 (: 'default' :)
  let $state := p:lookahead1W(50, $input, $state)           (: S^WS | '$' | ('(' ':') | 'return' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:shift(31, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(129, $input, $state)      (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
      let $state := p:parse-VarName($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:shift(147, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "TypeswitchExpr", $count)
};

(:~
 : Parse the 1st loop of production QuantifiedExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QuantifiedExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(60, $input, $state)         (: S^WS | ('(' ':') | ',' | 'satisfies' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(26, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state := p:shift(31, $input, $state)           (: '$' :)
        let $state := p:lookahead1W(129, $input, $state)    (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
        let $state := p:parse-VarName($input, $state)
        let $state := p:lookahead1W(62, $input, $state)     (: S^WS | ('(' ':') | 'as' | 'in' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 73) then                 (: 'as' :)
            let $state := p:parse-TypeDeclaration($input, $state)
            return $state
          else
            $state
        let $state := p:lookahead1W(38, $input, $state)     (: S^WS | ('(' ':') | 'in' :)
        let $state := p:shift(117, $input, $state)          (: 'in' :)
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-ExprSingle($input, $state)
        return p:parse-QuantifiedExpr-1($input, $state)
};

(:~
 : Parse QuantifiedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QuantifiedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 153) then                           (: 'some' :)
      let $state := p:shift(153, $input, $state)            (: 'some' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(103, $input, $state)            (: 'every' :)
      return $state
  let $state := p:lookahead1W(26, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(129, $input, $state)          (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(62, $input, $state)           (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 73) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(38, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:shift(117, $input, $state)                (: 'in' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:parse-QuantifiedExpr-1($input, $state)
  let $state := p:shift(148, $input, $state)                (: 'satisfies' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "QuantifiedExpr", $count)
};

(:~
 : Parse OrderModifier.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderModifier($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(89, $input, $state)           (: S^WS | ('(' ':') | ',' | 'ascending' | 'collation' |
                                                               'descending' | 'empty' | 'return' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 74                             (: 'ascending' :)
          or $state[$p:l1] = 93) then                       (: 'descending' :)
      let $state :=
        if ($state[$p:l1] = 74) then                        (: 'ascending' :)
          let $state := p:shift(74, $input, $state)         (: 'ascending' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(93, $input, $state)         (: 'descending' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(83, $input, $state)           (: S^WS | ('(' ':') | ',' | 'collation' | 'empty' | 'return' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 99) then                       (: 'empty' :)
      let $state := p:shift(99, $input, $state)             (: 'empty' :)
      let $state := p:lookahead1W(67, $input, $state)       (: S^WS | ('(' ':') | 'greatest' | 'least' :)
      let $state :=
        if ($state[$p:l1] = 111) then                       (: 'greatest' :)
          let $state := p:shift(111, $input, $state)        (: 'greatest' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(126, $input, $state)        (: 'least' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(76, $input, $state)           (: S^WS | ('(' ':') | ',' | 'collation' | 'return' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 84) then                       (: 'collation' :)
      let $state := p:shift(84, $input, $state)             (: 'collation' :)
      let $state := p:lookahead1W(22, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:parse-URILiteral($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "OrderModifier", $count)
};

(:~
 : Parse OrderSpec.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderSpec($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-OrderModifier($input, $state)
  return p:reduce($state, "OrderSpec", $count)
};

(:~
 : Parse the 1st loop of production OrderSpecList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderSpecList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(59, $input, $state)         (: S^WS | ('(' ':') | ',' | 'return' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-OrderSpec($input, $state)
        return p:parse-OrderSpecList-1($input, $state)
};

(:~
 : Parse OrderSpecList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderSpecList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-OrderSpec($input, $state)
  let $state := p:parse-OrderSpecList-1($input, $state)
  return p:reduce($state, "OrderSpecList", $count)
};

(:~
 : Parse OrderByClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderByClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 139) then                           (: 'order' :)
      let $state := p:shift(139, $input, $state)            (: 'order' :)
      let $state := p:lookahead1W(36, $input, $state)       (: S^WS | ('(' ':') | 'by' :)
      let $state := p:shift(79, $input, $state)             (: 'by' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(154, $input, $state)            (: 'stable' :)
      let $state := p:lookahead1W(40, $input, $state)       (: S^WS | ('(' ':') | 'order' :)
      let $state := p:shift(139, $input, $state)            (: 'order' :)
      let $state := p:lookahead1W(36, $input, $state)       (: S^WS | ('(' ':') | 'by' :)
      let $state := p:shift(79, $input, $state)             (: 'by' :)
      return $state
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-OrderSpecList($input, $state)
  return p:reduce($state, "OrderByClause", $count)
};

(:~
 : Parse WhereClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-WhereClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(168, $input, $state)                (: 'where' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "WhereClause", $count)
};

(:~
 : Parse the 1st loop of production LetClause (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LetClause-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(92, $input, $state)         (: S^WS | ('(' ':') | ',' | 'for' | 'let' | 'order' |
                                                               'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(26, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state := p:shift(31, $input, $state)           (: '$' :)
        let $state := p:lookahead1W(129, $input, $state)    (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
        let $state := p:parse-VarName($input, $state)
        let $state := p:lookahead1W(61, $input, $state)     (: S^WS | ('(' ':') | ':=' | 'as' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 73) then                 (: 'as' :)
            let $state := p:parse-TypeDeclaration($input, $state)
            return $state
          else
            $state
        let $state := p:lookahead1W(31, $input, $state)     (: S^WS | ('(' ':') | ':=' :)
        let $state := p:shift(52, $input, $state)           (: ':=' :)
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-ExprSingle($input, $state)
        return p:parse-LetClause-1($input, $state)
};

(:~
 : Parse LetClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LetClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(127, $input, $state)                (: 'let' :)
  let $state := p:lookahead1W(26, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(129, $input, $state)          (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(61, $input, $state)           (: S^WS | ('(' ':') | ':=' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 73) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(31, $input, $state)           (: S^WS | ('(' ':') | ':=' :)
  let $state := p:shift(52, $input, $state)                 (: ':=' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:parse-LetClause-1($input, $state)
  return p:reduce($state, "LetClause", $count)
};

(:~
 : Parse PositionalVar.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PositionalVar($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(75, $input, $state)                 (: 'at' :)
  let $state := p:lookahead1W(26, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(129, $input, $state)          (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  return p:reduce($state, "PositionalVar", $count)
};

(:~
 : Parse VarName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-QName($input, $state)
  return p:reduce($state, "VarName", $count)
};

(:~
 : Parse the 1st loop of production ForClause (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForClause-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(92, $input, $state)         (: S^WS | ('(' ':') | ',' | 'for' | 'let' | 'order' |
                                                               'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(26, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state := p:shift(31, $input, $state)           (: '$' :)
        let $state := p:lookahead1W(129, $input, $state)    (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
        let $state := p:parse-VarName($input, $state)
        let $state := p:lookahead1W(77, $input, $state)     (: S^WS | ('(' ':') | 'as' | 'at' | 'in' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 73) then                 (: 'as' :)
            let $state := p:parse-TypeDeclaration($input, $state)
            return $state
          else
            $state
        let $state := p:lookahead1W(64, $input, $state)     (: S^WS | ('(' ':') | 'at' | 'in' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 75) then                 (: 'at' :)
            let $state := p:parse-PositionalVar($input, $state)
            return $state
          else
            $state
        let $state := p:lookahead1W(38, $input, $state)     (: S^WS | ('(' ':') | 'in' :)
        let $state := p:shift(117, $input, $state)          (: 'in' :)
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-ExprSingle($input, $state)
        return p:parse-ForClause-1($input, $state)
};

(:~
 : Parse ForClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(108, $input, $state)                (: 'for' :)
  let $state := p:lookahead1W(26, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(129, $input, $state)          (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(77, $input, $state)           (: S^WS | ('(' ':') | 'as' | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 73) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(64, $input, $state)           (: S^WS | ('(' ':') | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 75) then                       (: 'at' :)
      let $state := p:parse-PositionalVar($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(38, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:shift(117, $input, $state)                (: 'in' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:parse-ForClause-1($input, $state)
  return p:reduce($state, "ForClause", $count)
};

(:~
 : Parse the 1st loop of production FLWORExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FLWORExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:l1] = 108) then                         (: 'for' :)
        let $state := p:parse-ForClause($input, $state)
        return $state
      else if ($state[$p:error]) then
        $state
      else
        let $state := p:parse-LetClause($input, $state)
        return $state
    let $state := p:lookahead1W(90, $input, $state)         (: S^WS | ('(' ':') | 'for' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' :)
    return
      if ($state[$p:l1] != 108                              (: 'for' :)
      and $state[$p:l1] != 127) then                        (: 'let' :)
        $state
      else
        p:parse-FLWORExpr-1($input, $state)
};

(:~
 : Parse FLWORExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FLWORExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-FLWORExpr-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 168) then                      (: 'where' :)
      let $state := p:parse-WhereClause($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | 'order' | 'return' | 'stable' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 147) then                     (: 'return' :)
      let $state := p:parse-OrderByClause($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:shift(147, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "FLWORExpr", $count)
};

(:~
 : Parse ExprSingle.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ExprSingle($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(143, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               '^' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 115                                 (: 'typeswitch' :)
     or $state[$p:l1] = 162) then                           (: 'typeswitch' :)
      let $state := p:lookahead2W(117, $input, $state)      (: S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 103                            (: 'for' :)
          or $state[$p:l1] = 108                            (: 'let' :)
          or $state[$p:l1] = 127                            (: 'some' :)
          or $state[$p:l1] = 153) then                      (: 'some' :)
      let $state := p:lookahead2W(119, $input, $state)      (: S^WS | '!=' | '$' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 8044                                (: 'for' '$' :)
     or $state[$p:lk] = 8063) then                          (: 'let' '$' :)
      let $state := p:parse-FLWORExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 8039                           (: 'every' '$' :)
          or $state[$p:lk] = 8089) then                     (: 'some' '$' :)
      let $state := p:parse-QuantifiedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 8610) then                     (: 'typeswitch' '(' :)
      let $state := p:parse-TypeswitchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 8563) then                     (: 'if' '(' :)
      let $state := p:parse-IfExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-OrExpr($input, $state)
      return $state
  return p:reduce($state, "ExprSingle", $count)
};

(:~
 : Parse the 1st loop of production Expr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Expr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(84, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' | ';' | ']' | '}' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-ExprSingle($input, $state)
        return p:parse-Expr-1($input, $state)
};

(:~
 : Parse Expr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Expr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:parse-Expr-1($input, $state)
  return p:reduce($state, "Expr", $count)
};

(:~
 : Parse OccurrenceIndicator.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OccurrenceIndicator($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 64) then                            (: '?' :)
      let $state := p:shift(64, $input, $state)             (: '?' :)
      return $state
    else if ($state[$p:l1] = 38) then                       (: '*' :)
      let $state := p:shift(38, $input, $state)             (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(40, $input, $state)             (: '+' :)
      return $state
  return p:reduce($state, "OccurrenceIndicator", $count)
};

(:~
 : Parse AtomicType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AtomicType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-QName($input, $state)
  return p:reduce($state, "AtomicType", $count)
};

(:~
 : Parse AnyKindTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AnyKindTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(135, $input, $state)                (: 'node' :)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "AnyKindTest", $count)
};

(:~
 : Parse TextTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TextTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(157, $input, $state)                (: 'text' :)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "TextTest", $count)
};

(:~
 : Parse CommentTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CommentTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(85, $input, $state)                 (: 'comment' :)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "CommentTest", $count)
};

(:~
 : Parse PITest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PITest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(146, $input, $state)                (: 'processing-instruction' :)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(101, $input, $state)          (: StringLiteral | S^WS | NCName^Token | ('(' ':') | ')' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'eq' | 'except' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'to' | 'treat' | 'union' |
                                                               'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36) then                      (: ')' :)
      let $state :=
        if ($state[$p:l1] = 6) then                         (: StringLiteral :)
          let $state := p:shift(6, $input, $state)          (: StringLiteral :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:parse-NCName($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "PITest", $count)
};

(:~
 : Parse AttributeDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttributeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-AttributeName($input, $state)
  return p:reduce($state, "AttributeDeclaration", $count)
};

(:~
 : Parse SchemaAttributeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaAttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(150, $input, $state)                (: 'schema-attribute' :)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(129, $input, $state)          (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-AttributeDeclaration($input, $state)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "SchemaAttributeTest", $count)
};

(:~
 : Parse AttributeName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttributeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-QName($input, $state)
  return p:reduce($state, "AttributeName", $count)
};

(:~
 : Parse AttribNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttribNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 37) then                            (: '*' :)
      let $state := p:shift(37, $input, $state)             (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AttributeName($input, $state)
      return $state
  return p:reduce($state, "AttribNameOrWildcard", $count)
};

(:~
 : Parse AttributeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(76, $input, $state)                 (: 'attribute' :)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(137, $input, $state)          (: S^WS | QName^Token | ('(' ':') | ')' | '*' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36) then                      (: ')' :)
      let $state := p:parse-AttribNameOrWildcard($input, $state)
      let $state := p:lookahead1W(56, $input, $state)       (: S^WS | ('(' ':') | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 41) then                   (: ',' :)
          let $state := p:shift(41, $input, $state)         (: ',' :)
          let $state := p:lookahead1W(129, $input, $state)  (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
          let $state := p:parse-TypeName($input, $state)
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "AttributeTest", $count)
};

(:~
 : Parse ElementDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ElementName($input, $state)
  return p:reduce($state, "ElementDeclaration", $count)
};

(:~
 : Parse SchemaElementTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaElementTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(151, $input, $state)                (: 'schema-element' :)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(129, $input, $state)          (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-ElementDeclaration($input, $state)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "SchemaElementTest", $count)
};

(:~
 : Parse TypeName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-QName($input, $state)
  return p:reduce($state, "TypeName", $count)
};

(:~
 : Parse ElementName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-QName($input, $state)
  return p:reduce($state, "ElementName", $count)
};

(:~
 : Parse ElementNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 37) then                            (: '*' :)
      let $state := p:shift(37, $input, $state)             (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ElementName($input, $state)
      return $state
  return p:reduce($state, "ElementNameOrWildcard", $count)
};

(:~
 : Parse ElementTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(97, $input, $state)                 (: 'element' :)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(137, $input, $state)          (: S^WS | QName^Token | ('(' ':') | ')' | '*' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36) then                      (: ')' :)
      let $state := p:parse-ElementNameOrWildcard($input, $state)
      let $state := p:lookahead1W(56, $input, $state)       (: S^WS | ('(' ':') | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 41) then                   (: ',' :)
          let $state := p:shift(41, $input, $state)         (: ',' :)
          let $state := p:lookahead1W(129, $input, $state)  (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
          let $state := p:parse-TypeName($input, $state)
          let $state := p:lookahead1W(58, $input, $state)   (: S^WS | ('(' ':') | ')' | '?' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 64) then               (: '?' :)
              let $state := p:shift(64, $input, $state)     (: '?' :)
              return $state
            else
              $state
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "ElementTest", $count)
};

(:~
 : Parse DocumentTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DocumentTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(96, $input, $state)                 (: 'document-node' :)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(75, $input, $state)           (: S^WS | ('(' ':') | ')' | 'element' | 'schema-element' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36) then                      (: ')' :)
      let $state :=
        if ($state[$p:l1] = 97) then                        (: 'element' :)
          let $state := p:parse-ElementTest($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:parse-SchemaElementTest($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "DocumentTest", $count)
};

(:~
 : Parse KindTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-KindTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 96) then                            (: 'document-node' :)
      let $state := p:parse-DocumentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 97) then                       (: 'element' :)
      let $state := p:parse-ElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 76) then                       (: 'attribute' :)
      let $state := p:parse-AttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 151) then                      (: 'schema-element' :)
      let $state := p:parse-SchemaElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 150) then                      (: 'schema-attribute' :)
      let $state := p:parse-SchemaAttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 146) then                      (: 'processing-instruction' :)
      let $state := p:parse-PITest($input, $state)
      return $state
    else if ($state[$p:l1] = 85) then                       (: 'comment' :)
      let $state := p:parse-CommentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 157) then                      (: 'text' :)
      let $state := p:parse-TextTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AnyKindTest($input, $state)
      return $state
  return p:reduce($state, "KindTest", $count)
};

(:~
 : Parse ItemType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ItemType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 76                                  (: 'comment' :)
     or $state[$p:l1] = 85                                  (: 'document-node' :)
     or $state[$p:l1] = 96                                  (: 'element' :)
     or $state[$p:l1] = 97                                  (: 'item' :)
     or $state[$p:l1] = 122                                 (: 'node' :)
     or $state[$p:l1] = 135                                 (: 'processing-instruction' :)
     or $state[$p:l1] = 146                                 (: 'schema-attribute' :)
     or $state[$p:l1] = 150                                 (: 'schema-element' :)
     or $state[$p:l1] = 151                                 (: 'text' :)
     or $state[$p:l1] = 157) then                           (: 'text' :)
      let $state := p:lookahead2W(116, $input, $state)      (: S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '*' | '+' |
                                                               '+' | ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '?' | ']' | 'and' | 'ascending' |
                                                               'at' | 'case' | 'collation' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'in' | 'instance' | 'intersect' |
                                                               'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'to' |
                                                               'union' | 'where' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 8524                                (: 'attribute' '(' :)
     or $state[$p:lk] = 8533                                (: 'comment' '(' :)
     or $state[$p:lk] = 8544                                (: 'document-node' '(' :)
     or $state[$p:lk] = 8545                                (: 'element' '(' :)
     or $state[$p:lk] = 8583                                (: 'node' '(' :)
     or $state[$p:lk] = 8594                                (: 'processing-instruction' '(' :)
     or $state[$p:lk] = 8598                                (: 'schema-attribute' '(' :)
     or $state[$p:lk] = 8599                                (: 'schema-element' '(' :)
     or $state[$p:lk] = 8605) then                          (: 'text' '(' :)
      let $state := p:parse-KindTest($input, $state)
      return $state
    else if ($state[$p:lk] = 8570) then                     (: 'item' '(' :)
      let $state := p:shift(122, $input, $state)            (: 'item' :)
      let $state := p:lookahead1W(27, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:shift(33, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:shift(36, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AtomicType($input, $state)
      return $state
  return p:reduce($state, "ItemType", $count)
};

(:~
 : Parse SequenceType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SequenceType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(126, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 100) then                           (: 'empty-sequence' :)
      let $state := p:lookahead2W(116, $input, $state)      (: S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '*' | '+' |
                                                               '+' | ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '?' | ']' | 'and' | 'ascending' |
                                                               'at' | 'case' | 'collation' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'in' | 'instance' | 'intersect' |
                                                               'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'to' |
                                                               'union' | 'where' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 8548) then                          (: 'empty-sequence' '(' :)
      let $state := p:shift(100, $input, $state)            (: 'empty-sequence' :)
      let $state := p:lookahead1W(27, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:shift(33, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:shift(36, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ItemType($input, $state)
      let $state := p:lookahead1W(113, $input, $state)      (: S^WS | '!=' | ('(' ':') | ')' | '*' | '*' | '+' | '+' |
                                                               ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '?' | ']' | 'and' | 'ascending' | 'at' |
                                                               'case' | 'collation' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'gt' | 'idiv' | 'in' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'ne' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'to' | 'union' |
                                                               'where' | '|' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 38                         (: '*' :)
              or $state[$p:l1] = 40                         (: '+' :)
              or $state[$p:l1] = 64) then                   (: '?' :)
          let $state := p:parse-OccurrenceIndicator($input, $state)
          return $state
        else
          $state
      return $state
  return p:reduce($state, "SequenceType", $count)
};

(:~
 : Parse TypeDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(73, $input, $state)                 (: 'as' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-SequenceType($input, $state)
  return p:reduce($state, "TypeDeclaration", $count)
};

(:~
 : Parse FunctionName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(115, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'else' | 'empty' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'module' | 'ne' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'return' |
                                                               'satisfies' | 'self' | 'some' | 'stable' | 'to' |
                                                               'treat' | 'union' | 'unordered' | 'validate' | 'where' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:l1] = 70) then                            (: 'ancestor' :)
      let $state := p:shift(70, $input, $state)             (: 'ancestor' :)
      return $state
    else if ($state[$p:l1] = 71) then                       (: 'ancestor-or-self' :)
      let $state := p:shift(71, $input, $state)             (: 'ancestor-or-self' :)
      return $state
    else if ($state[$p:l1] = 72) then                       (: 'and' :)
      let $state := p:shift(72, $input, $state)             (: 'and' :)
      return $state
    else if ($state[$p:l1] = 74) then                       (: 'ascending' :)
      let $state := p:shift(74, $input, $state)             (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 80) then                       (: 'case' :)
      let $state := p:shift(80, $input, $state)             (: 'case' :)
      return $state
    else if ($state[$p:l1] = 81) then                       (: 'cast' :)
      let $state := p:shift(81, $input, $state)             (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 82) then                       (: 'castable' :)
      let $state := p:shift(82, $input, $state)             (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'child' :)
      let $state := p:shift(83, $input, $state)             (: 'child' :)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'collation' :)
      let $state := p:shift(84, $input, $state)             (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 89) then                       (: 'declare' :)
      let $state := p:shift(89, $input, $state)             (: 'declare' :)
      return $state
    else if ($state[$p:l1] = 90) then                       (: 'default' :)
      let $state := p:shift(90, $input, $state)             (: 'default' :)
      return $state
    else if ($state[$p:l1] = 91) then                       (: 'descendant' :)
      let $state := p:shift(91, $input, $state)             (: 'descendant' :)
      return $state
    else if ($state[$p:l1] = 92) then                       (: 'descendant-or-self' :)
      let $state := p:shift(92, $input, $state)             (: 'descendant-or-self' :)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'descending' :)
      let $state := p:shift(93, $input, $state)             (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 94) then                       (: 'div' :)
      let $state := p:shift(94, $input, $state)             (: 'div' :)
      return $state
    else if ($state[$p:l1] = 95) then                       (: 'document' :)
      let $state := p:shift(95, $input, $state)             (: 'document' :)
      return $state
    else if ($state[$p:l1] = 98) then                       (: 'else' :)
      let $state := p:shift(98, $input, $state)             (: 'else' :)
      return $state
    else if ($state[$p:l1] = 99) then                       (: 'empty' :)
      let $state := p:shift(99, $input, $state)             (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 102) then                      (: 'eq' :)
      let $state := p:shift(102, $input, $state)            (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 103) then                      (: 'every' :)
      let $state := p:shift(103, $input, $state)            (: 'every' :)
      return $state
    else if ($state[$p:l1] = 104) then                      (: 'except' :)
      let $state := p:shift(104, $input, $state)            (: 'except' :)
      return $state
    else if ($state[$p:l1] = 106) then                      (: 'following' :)
      let $state := p:shift(106, $input, $state)            (: 'following' :)
      return $state
    else if ($state[$p:l1] = 107) then                      (: 'following-sibling' :)
      let $state := p:shift(107, $input, $state)            (: 'following-sibling' :)
      return $state
    else if ($state[$p:l1] = 108) then                      (: 'for' :)
      let $state := p:shift(108, $input, $state)            (: 'for' :)
      return $state
    else if ($state[$p:l1] = 110) then                      (: 'ge' :)
      let $state := p:shift(110, $input, $state)            (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 112) then                      (: 'gt' :)
      let $state := p:shift(112, $input, $state)            (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 114) then                      (: 'idiv' :)
      let $state := p:shift(114, $input, $state)            (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 116) then                      (: 'import' :)
      let $state := p:shift(116, $input, $state)            (: 'import' :)
      return $state
    else if ($state[$p:l1] = 119) then                      (: 'instance' :)
      let $state := p:shift(119, $input, $state)            (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 120) then                      (: 'intersect' :)
      let $state := p:shift(120, $input, $state)            (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 121) then                      (: 'is' :)
      let $state := p:shift(121, $input, $state)            (: 'is' :)
      return $state
    else if ($state[$p:l1] = 125) then                      (: 'le' :)
      let $state := p:shift(125, $input, $state)            (: 'le' :)
      return $state
    else if ($state[$p:l1] = 127) then                      (: 'let' :)
      let $state := p:shift(127, $input, $state)            (: 'let' :)
      return $state
    else if ($state[$p:l1] = 128) then                      (: 'lt' :)
      let $state := p:shift(128, $input, $state)            (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 129) then                      (: 'mod' :)
      let $state := p:shift(129, $input, $state)            (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 130) then                      (: 'module' :)
      let $state := p:shift(130, $input, $state)            (: 'module' :)
      return $state
    else if ($state[$p:l1] = 132) then                      (: 'ne' :)
      let $state := p:shift(132, $input, $state)            (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 138) then                      (: 'or' :)
      let $state := p:shift(138, $input, $state)            (: 'or' :)
      return $state
    else if ($state[$p:l1] = 139) then                      (: 'order' :)
      let $state := p:shift(139, $input, $state)            (: 'order' :)
      return $state
    else if ($state[$p:l1] = 140) then                      (: 'ordered' :)
      let $state := p:shift(140, $input, $state)            (: 'ordered' :)
      return $state
    else if ($state[$p:l1] = 142) then                      (: 'parent' :)
      let $state := p:shift(142, $input, $state)            (: 'parent' :)
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'preceding' :)
      let $state := p:shift(143, $input, $state)            (: 'preceding' :)
      return $state
    else if ($state[$p:l1] = 144) then                      (: 'preceding-sibling' :)
      let $state := p:shift(144, $input, $state)            (: 'preceding-sibling' :)
      return $state
    else if ($state[$p:l1] = 147) then                      (: 'return' :)
      let $state := p:shift(147, $input, $state)            (: 'return' :)
      return $state
    else if ($state[$p:l1] = 148) then                      (: 'satisfies' :)
      let $state := p:shift(148, $input, $state)            (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 152) then                      (: 'self' :)
      let $state := p:shift(152, $input, $state)            (: 'self' :)
      return $state
    else if ($state[$p:l1] = 153) then                      (: 'some' :)
      let $state := p:shift(153, $input, $state)            (: 'some' :)
      return $state
    else if ($state[$p:l1] = 154) then                      (: 'stable' :)
      let $state := p:shift(154, $input, $state)            (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 159) then                      (: 'to' :)
      let $state := p:shift(159, $input, $state)            (: 'to' :)
      return $state
    else if ($state[$p:l1] = 160) then                      (: 'treat' :)
      let $state := p:shift(160, $input, $state)            (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 163) then                      (: 'union' :)
      let $state := p:shift(163, $input, $state)            (: 'union' :)
      return $state
    else if ($state[$p:l1] = 164) then                      (: 'unordered' :)
      let $state := p:shift(164, $input, $state)            (: 'unordered' :)
      return $state
    else if ($state[$p:l1] = 165) then                      (: 'validate' :)
      let $state := p:shift(165, $input, $state)            (: 'validate' :)
      return $state
    else if ($state[$p:l1] = 168) then                      (: 'where' :)
      let $state := p:shift(168, $input, $state)            (: 'where' :)
      return $state
    else if ($state[$p:l1] = 169) then                      (: 'xquery' :)
      let $state := p:shift(169, $input, $state)            (: 'xquery' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(18, $input, $state)             (: QName^Token :)
      return $state
  return p:reduce($state, "FunctionName", $count)
};

(:~
 : Parse QName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(126, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 76) then                            (: 'attribute' :)
      let $state := p:shift(76, $input, $state)             (: 'attribute' :)
      return $state
    else if ($state[$p:l1] = 85) then                       (: 'comment' :)
      let $state := p:shift(85, $input, $state)             (: 'comment' :)
      return $state
    else if ($state[$p:l1] = 96) then                       (: 'document-node' :)
      let $state := p:shift(96, $input, $state)             (: 'document-node' :)
      return $state
    else if ($state[$p:l1] = 97) then                       (: 'element' :)
      let $state := p:shift(97, $input, $state)             (: 'element' :)
      return $state
    else if ($state[$p:l1] = 100) then                      (: 'empty-sequence' :)
      let $state := p:shift(100, $input, $state)            (: 'empty-sequence' :)
      return $state
    else if ($state[$p:l1] = 115) then                      (: 'if' :)
      let $state := p:shift(115, $input, $state)            (: 'if' :)
      return $state
    else if ($state[$p:l1] = 122) then                      (: 'item' :)
      let $state := p:shift(122, $input, $state)            (: 'item' :)
      return $state
    else if ($state[$p:l1] = 135) then                      (: 'node' :)
      let $state := p:shift(135, $input, $state)            (: 'node' :)
      return $state
    else if ($state[$p:l1] = 146) then                      (: 'processing-instruction' :)
      let $state := p:shift(146, $input, $state)            (: 'processing-instruction' :)
      return $state
    else if ($state[$p:l1] = 150) then                      (: 'schema-attribute' :)
      let $state := p:shift(150, $input, $state)            (: 'schema-attribute' :)
      return $state
    else if ($state[$p:l1] = 151) then                      (: 'schema-element' :)
      let $state := p:shift(151, $input, $state)            (: 'schema-element' :)
      return $state
    else if ($state[$p:l1] = 157) then                      (: 'text' :)
      let $state := p:shift(157, $input, $state)            (: 'text' :)
      return $state
    else if ($state[$p:l1] = 162) then                      (: 'typeswitch' :)
      let $state := p:shift(162, $input, $state)            (: 'typeswitch' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-FunctionName($input, $state)
      return $state
  return p:reduce($state, "QName", $count)
};

(:~
 : Parse VarDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(129, $input, $state)          (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-QName($input, $state)
  let $state := p:lookahead1W(61, $input, $state)           (: S^WS | ('(' ':') | ':=' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 73) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(31, $input, $state)           (: S^WS | ('(' ':') | ':=' :)
  let $state := p:shift(52, $input, $state)                 (: ':=' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  return p:reduce($state, "VarDecl", $count)
};

(:~
 : Parse Separator.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Separator($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(53, $input, $state)                 (: ';' :)
  return p:reduce($state, "Separator", $count)
};

(:~
 : Parse URILiteral.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-URILiteral($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(6, $input, $state)                  (: StringLiteral :)
  return p:reduce($state, "URILiteral", $count)
};

(:~
 : Parse NCName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NCName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(97, $input, $state)            (: NCName^Token | 'and' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'ne' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'to' | 'treat' |
                                                               'union' | 'where' :)
  let $state :=
    if ($state[$p:l1] = 72) then                            (: 'and' :)
      let $state := p:shift(72, $input, $state)             (: 'and' :)
      return $state
    else if ($state[$p:l1] = 74) then                       (: 'ascending' :)
      let $state := p:shift(74, $input, $state)             (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 80) then                       (: 'case' :)
      let $state := p:shift(80, $input, $state)             (: 'case' :)
      return $state
    else if ($state[$p:l1] = 81) then                       (: 'cast' :)
      let $state := p:shift(81, $input, $state)             (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 82) then                       (: 'castable' :)
      let $state := p:shift(82, $input, $state)             (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'collation' :)
      let $state := p:shift(84, $input, $state)             (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 90) then                       (: 'default' :)
      let $state := p:shift(90, $input, $state)             (: 'default' :)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'descending' :)
      let $state := p:shift(93, $input, $state)             (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 94) then                       (: 'div' :)
      let $state := p:shift(94, $input, $state)             (: 'div' :)
      return $state
    else if ($state[$p:l1] = 98) then                       (: 'else' :)
      let $state := p:shift(98, $input, $state)             (: 'else' :)
      return $state
    else if ($state[$p:l1] = 99) then                       (: 'empty' :)
      let $state := p:shift(99, $input, $state)             (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 102) then                      (: 'eq' :)
      let $state := p:shift(102, $input, $state)            (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 104) then                      (: 'except' :)
      let $state := p:shift(104, $input, $state)            (: 'except' :)
      return $state
    else if ($state[$p:l1] = 108) then                      (: 'for' :)
      let $state := p:shift(108, $input, $state)            (: 'for' :)
      return $state
    else if ($state[$p:l1] = 110) then                      (: 'ge' :)
      let $state := p:shift(110, $input, $state)            (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 112) then                      (: 'gt' :)
      let $state := p:shift(112, $input, $state)            (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 114) then                      (: 'idiv' :)
      let $state := p:shift(114, $input, $state)            (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 119) then                      (: 'instance' :)
      let $state := p:shift(119, $input, $state)            (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 120) then                      (: 'intersect' :)
      let $state := p:shift(120, $input, $state)            (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 121) then                      (: 'is' :)
      let $state := p:shift(121, $input, $state)            (: 'is' :)
      return $state
    else if ($state[$p:l1] = 125) then                      (: 'le' :)
      let $state := p:shift(125, $input, $state)            (: 'le' :)
      return $state
    else if ($state[$p:l1] = 127) then                      (: 'let' :)
      let $state := p:shift(127, $input, $state)            (: 'let' :)
      return $state
    else if ($state[$p:l1] = 128) then                      (: 'lt' :)
      let $state := p:shift(128, $input, $state)            (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 129) then                      (: 'mod' :)
      let $state := p:shift(129, $input, $state)            (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 132) then                      (: 'ne' :)
      let $state := p:shift(132, $input, $state)            (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 138) then                      (: 'or' :)
      let $state := p:shift(138, $input, $state)            (: 'or' :)
      return $state
    else if ($state[$p:l1] = 139) then                      (: 'order' :)
      let $state := p:shift(139, $input, $state)            (: 'order' :)
      return $state
    else if ($state[$p:l1] = 147) then                      (: 'return' :)
      let $state := p:shift(147, $input, $state)            (: 'return' :)
      return $state
    else if ($state[$p:l1] = 148) then                      (: 'satisfies' :)
      let $state := p:shift(148, $input, $state)            (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 154) then                      (: 'stable' :)
      let $state := p:shift(154, $input, $state)            (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 159) then                      (: 'to' :)
      let $state := p:shift(159, $input, $state)            (: 'to' :)
      return $state
    else if ($state[$p:l1] = 160) then                      (: 'treat' :)
      let $state := p:shift(160, $input, $state)            (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 163) then                      (: 'union' :)
      let $state := p:shift(163, $input, $state)            (: 'union' :)
      return $state
    else if ($state[$p:l1] = 168) then                      (: 'where' :)
      let $state := p:shift(168, $input, $state)            (: 'where' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(17, $input, $state)             (: NCName^Token :)
      return $state
  return p:reduce($state, "NCName", $count)
};

(:~
 : Parse NamespaceDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NamespaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(49, $input, $state)                 (: ':' :)
  let $state := p:lookahead1W(98, $input, $state)           (: S^WS | NCName^Token | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' :)
  let $state := p:parse-NCName($input, $state)
  let $state := p:lookahead1W(33, $input, $state)           (: S^WS | ('(' ':') | '=' :)
  let $state := p:shift(60, $input, $state)                 (: '=' :)
  let $state := p:lookahead1W(22, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:parse-URILiteral($input, $state)
  return p:reduce($state, "NamespaceDecl", $count)
};

(:~
 : Parse the 1st loop of production CarrotModule (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CarrotModule-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(125, $input, $state)        (: S^WS | QName^Token | EOF | '$' | ('(' ':') | ':' | '^' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'else' | 'empty' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'module' | 'ne' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'return' |
                                                               'satisfies' | 'self' | 'some' | 'stable' | 'to' |
                                                               'treat' | 'union' | 'unordered' | 'validate' | 'where' |
                                                               'xquery' :)
    return
      if ($state[$p:l1] != 49) then                         (: ':' :)
        $state
      else
        let $state := p:parse-NamespaceDecl($input, $state)
        let $state := p:lookahead1W(32, $input, $state)     (: S^WS | ('(' ':') | ';' :)
        let $state := p:parse-Separator($input, $state)
        return p:parse-CarrotModule-1($input, $state)
};

(:~
 : Parse the 2nd loop of production CarrotModule (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CarrotModule-2($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(124, $input, $state)        (: S^WS | QName^Token | EOF | '$' | ('(' ':') | '^' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'else' | 'empty' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'module' | 'ne' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'return' |
                                                               'satisfies' | 'self' | 'some' | 'stable' | 'to' |
                                                               'treat' | 'union' | 'unordered' | 'validate' | 'where' |
                                                               'xquery' :)
    return
      if ($state[$p:l1] = 25) then                          (: EOF :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 31) then                      (: '$' :)
            let $state := p:parse-VarDecl($input, $state)
            return $state
          else if ($state[$p:l1] = 69) then                 (: '^' :)
            let $state := p:parse-RuleDecl($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-FunctionDecl($input, $state)
            return $state
        let $state := p:lookahead1W(32, $input, $state)     (: S^WS | ('(' ':') | ';' :)
        let $state := p:parse-Separator($input, $state)
        return p:parse-CarrotModule-2($input, $state)
};

(:~
 : Parse CarrotModule.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CarrotModule($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-CarrotModule-1($input, $state)
  let $state := p:parse-CarrotModule-2($input, $state)
  return p:reduce($state, "CarrotModule", $count)
};

(:~
 : Parse Carrot.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Carrot($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-CarrotModule($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | EOF | ('(' ':') :)
  let $state := p:shift(25, $input, $state)                 (: EOF :)
  return p:reduce($state, "Carrot", $count)
};

(:~
 : Parse start symbol Carrot from given string.
 :
 : @param $s the string to be parsed.
 : @return the result as generated by parser actions.
 :)
declare function p:parse-Carrot($s as xs:string) as item()*
{
  let $state := p:parse-Carrot($s, (0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, false()))
  let $error := $state[$p:error]
  return
    if ($error) then
      element ERROR {$error/@*, p:error-message($s, $error)}
    else
      $state[position() >= $p:result]
};

(:~
 : Parse start symbol KeyValuePairs from given string.
 :
 : @param $s the string to be parsed.
 : @return the result as generated by parser actions.
 :)
declare function p:parse-KeyValuePairs($s as xs:string) as item()*
{
  let $state := p:parse-KeyValuePairs($s, (0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, false()))
  let $error := $state[$p:error]
  return
    if ($error) then
      element ERROR {$error/@*, p:error-message($s, $error)}
    else
      $state[position() >= $p:result]
};

(: End :)
