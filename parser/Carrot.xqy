xquery version "1.0" encoding "UTF-8";

(: This file was generated on Sun Feb 12, 2012 09:25 by REx v5.11 which is Copyright (c) 1979-2012 by Gunther Rademacher <grd@gmx.net> :)
(: REx command line: Carrot.ebnf -tree -xquery :)

(:~
 : The parser that was generated for the Carrot grammar.
 :)
module namespace p="Carrot";

(: EDL: Manually added to make this work in MarkLogic Server :)
declare default function namespace "http://www.w3.org/2005/xpath-functions";

(:~
 : The codepoint to charclass mapping for 7 bit codepoints.
 :)
declare variable $p:MAP0 as xs:integer+ :=
(
  64, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7,
  8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,
  29, 26, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 31, 30, 30, 30, 30, 30, 30, 32, 6, 33, 34, 30, 35, 36, 37,
  38, 39, 40, 41, 42, 43, 44, 30, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 30, 60, 61, 62, 6, 6
);

(:~
 : The codepoint to charclass mapping for codepoints below the surrogate block.
 :)
declare variable $p:MAP1 as xs:integer+ :=
(
  216, 291, 323, 383, 415, 908, 351, 815, 815, 447, 479, 511, 543, 575, 621, 882, 589, 681, 815, 815, 815, 815, 815,
  815, 815, 815, 815, 815, 815, 815, 713, 745, 821, 649, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815,
  815, 815, 777, 809, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815,
  815, 815, 815, 815, 815, 815, 815, 815, 815, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 259, 815,
  815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 853, 940, 949, 941, 941, 957, 965, 973, 979, 987, 1259, 1010, 1027, 1045,
  1053, 1061, 1069, 1267, 1267, 1267, 1267, 1267, 1267, 1425, 1267, 1259, 1259, 1260, 1259, 1259, 1259, 1260, 1259,
  1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259,
  1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1261, 1267, 1267, 1267, 1267, 1267, 1267,
  1267, 1267, 1267, 1267, 1267, 1259, 1259, 1259, 1259, 1259, 1259, 1347, 1260, 1258, 1257, 1259, 1259, 1259, 1259,
  1259, 1260, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1263, 1083, 1259, 1259, 1259, 1259, 1188, 1086, 1259,
  1259, 1259, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259,
  1259, 1266, 1267, 1085, 1265, 1267, 1393, 1267, 1267, 1267, 1267, 1267, 1258, 1259, 1259, 1264, 1125, 1313, 1392,
  1267, 1387, 1393, 1125, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1349, 1259, 1260, 1136, 1387, 1302, 1201,
  1387, 1393, 1387, 1387, 1387, 1387, 1387, 1387, 1387, 1387, 1389, 1267, 1267, 1267, 1393, 1267, 1267, 1267, 1372,
  1236, 1259, 1259, 1256, 1259, 1259, 1259, 1259, 1260, 1260, 1412, 1257, 1259, 1263, 1267, 1258, 1094, 1259, 1259,
  1259, 1259, 1259, 1259, 1259, 1259, 1258, 1094, 1259, 1259, 1259, 1259, 1103, 1267, 1259, 1259, 1259, 1259, 1259,
  1259, 1116, 1034, 1259, 1259, 1259, 1117, 1261, 1265, 1438, 1259, 1259, 1259, 1259, 1259, 1259, 1154, 1387, 1389,
  1202, 1259, 1172, 1387, 1267, 1267, 1438, 1116, 1348, 1259, 1259, 1257, 1186, 1197, 1163, 1175, 1425, 1212, 1172,
  1387, 1265, 1267, 1223, 1246, 1348, 1259, 1259, 1257, 1402, 1197, 1178, 1175, 1267, 1234, 1426, 1387, 1244, 1267,
  1438, 1235, 1256, 1259, 1259, 1257, 1254, 1154, 1277, 1108, 1267, 1267, 994, 1387, 1267, 1267, 1438, 1116, 1348, 1259,
  1259, 1257, 1345, 1154, 1203, 1175, 1426, 1212, 1037, 1387, 1267, 1267, 1002, 1015, 1290, 1286, 1189, 1015, 1127,
  1037, 1204, 1201, 1425, 1267, 1425, 1387, 1267, 1267, 1438, 1094, 1257, 1259, 1259, 1257, 1095, 1037, 1278, 1201,
  1427, 1267, 1037, 1387, 1267, 1267, 1002, 1094, 1257, 1259, 1259, 1257, 1095, 1037, 1278, 1201, 1427, 1269, 1037,
  1387, 1267, 1267, 1002, 1094, 1257, 1259, 1259, 1257, 1259, 1037, 1164, 1201, 1425, 1267, 1037, 1387, 1267, 1267,
  1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1259,
  1259, 1259, 1259, 1261, 1267, 1259, 1259, 1259, 1259, 1260, 1267, 1258, 1259, 1259, 1259, 1259, 1260, 1298, 1392,
  1310, 1388, 1387, 1393, 1267, 1267, 1267, 1267, 1215, 1322, 1084, 1258, 1332, 1342, 1298, 1146, 1357, 1389, 1387,
  1393, 1267, 1267, 1267, 1267, 1269, 1019, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1264, 1267,
  1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1254, 1401, 1264, 1267, 1267,
  1267, 1267, 1410, 1266, 1410, 1188, 1081, 1334, 1187, 1214, 1267, 1267, 1267, 1267, 1269, 1267, 1324, 1268, 1288,
  1264, 1267, 1267, 1267, 1267, 1421, 1266, 1423, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259,
  1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1263, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259,
  1259, 1265, 1259, 1259, 1261, 1261, 1259, 1259, 1259, 1259, 1261, 1261, 1259, 1413, 1259, 1259, 1259, 1261, 1259,
  1259, 1259, 1259, 1259, 1259, 1094, 1128, 1226, 1262, 1117, 1263, 1259, 1262, 1226, 1262, 1075, 1267, 1267, 1267,
  1258, 1314, 1162, 1267, 1258, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1262, 999, 1258, 1259, 1259, 1259,
  1259, 1259, 1259, 1259, 1259, 1259, 1259, 1435, 1083, 1259, 1259, 1259, 1259, 1262, 1267, 1267, 1267, 1267, 1267,
  1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267,
  1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1387, 1390, 1370, 1267, 1267, 1267, 1259, 1259, 1259, 1259, 1259,
  1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1263, 1267, 1267, 1267,
  1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1393, 1387, 1393, 1380, 1362, 1259, 1258, 1259, 1259, 1259, 1265,
  1386, 1387, 1278, 1391, 1277, 1386, 1387, 1389, 1386, 1370, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1258,
  1259, 1259, 1259, 1260, 1423, 1258, 1259, 1259, 1259, 1260, 1267, 1386, 1387, 1160, 1387, 1387, 1142, 1367, 1267,
  1259, 1259, 1259, 1264, 1264, 1267, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
  11, 12, 13, 14, 15, 16, 17, 17, 17, 17, 17, 17, 17, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 26, 30, 6, 6,
  6, 6, 6, 63, 63, 6, 6, 63, 63, 6, 30, 30, 30, 30, 30, 30, 30, 31, 30, 30, 30, 6, 6, 6, 30, 30, 6, 6, 30, 6, 30, 30,
  30, 32, 6, 33, 34, 30, 6, 6, 30, 30, 6, 6, 6, 6, 63, 63, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 30, 45, 46, 47, 48,
  49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 30, 60, 61, 62, 6, 6, 6, 6, 6, 63, 6, 30, 6, 6, 6, 6, 6, 30, 30, 30, 30,
  30, 30, 30, 30, 30, 30, 30, 6, 30, 30, 30, 30, 30, 6, 63, 63, 63, 63, 6, 63, 63, 63, 6, 6, 30, 30, 30, 30, 30, 6, 6,
  30, 30, 63, 30, 30, 30, 30, 30, 30, 30, 6, 30, 6, 30, 30, 30, 30, 6, 30, 63, 63, 6, 63, 63, 63, 6, 63, 63, 30, 6, 6,
  30, 30, 6, 6, 63, 30, 63, 63, 6, 63, 63, 63, 63, 63, 6, 6, 63, 63, 30, 30, 63, 63, 6, 6, 63, 63, 63, 6, 6, 6, 6, 63,
  30, 6, 30, 6, 6, 6, 30, 30, 6, 6, 6, 30, 30, 6, 6, 63, 6, 63, 63, 63, 63, 6, 6, 6, 63, 63, 6, 6, 6, 6, 30, 30, 6, 30,
  6, 6, 30, 6, 6, 63, 6, 6, 30, 30, 30, 6, 30, 30, 6, 30, 30, 30, 30, 6, 30, 6, 30, 30, 63, 63, 30, 30, 30, 6, 6, 6, 6,
  30, 30, 6, 30, 30, 6, 30, 30, 30, 30, 30, 30, 30, 30, 6, 6, 6, 6, 6, 6, 6, 6, 30, 6, 63, 63, 63, 63, 63, 63, 6, 63,
  63, 6, 30, 30, 6, 30, 6, 30, 30, 30, 30, 6, 6, 30, 63, 30, 30, 63, 63, 63, 63, 63, 30, 30, 63, 30, 30, 30, 30, 30, 30,
  63, 63, 63, 63, 63, 63, 30, 6, 30, 6, 6, 30, 6, 6, 30, 30, 6, 30, 30, 30, 6, 30, 6, 30, 6, 30, 6, 6, 30, 30, 6, 30,
  30, 6, 6, 30, 30, 30, 30, 30, 6, 30, 30, 30, 30, 30, 6, 63, 6, 6, 6, 6, 63, 63, 6, 63, 6, 6, 6, 6, 6, 6, 30, 63, 6, 6,
  6, 6, 6, 63, 6, 63, 63, 63, 63, 63, 63, 63, 63, 6, 6, 6, 6, 6, 6, 6, 30, 6, 30, 30, 6, 30, 30, 6, 6, 6, 6, 6, 30, 6,
  30, 6, 30, 6, 30, 6, 6, 6, 30, 6, 6, 6, 6, 6, 6, 6, 63, 63, 6, 30, 30, 30, 6, 63, 63, 63, 6, 30, 30, 30
);

(:~
 : The codepoint to charclass mapping for codepoints above the surrogate block.
 :)
declare variable $p:MAP2 as xs:integer+ :=
(
  57344, 65536, 65533, 1114111, 6, 6
);

(:~
 : The token-set-id to DFA-initial-state mapping.
 :)
declare variable $p:INITIAL as xs:integer+ :=
(
  6145, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 2069, 4117, 22, 23, 24, 25, 26, 27, 28, 29,
  30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58,
  59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87,
  88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113,
  114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136,
  137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153
);

(:~
 : The DFA transition table.
 :)
declare variable $p:TRANSITION as xs:integer+ :=
(
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9468, 8320, 8367, 8344, 8344,
  8392, 8363, 8347, 8383, 8328, 8408, 12762, 12455, 18088, 16526, 9585, 8956, 8801, 8957, 9331, 13356, 8432, 22759,
  11861, 8484, 8500, 8773, 8538, 9022, 8804, 8554, 8570, 8514, 10444, 8598, 8619, 8648, 19518, 8664, 8976, 9169, 8752,
  8673, 8679, 19751, 9585, 12379, 8834, 8695, 11794, 19527, 8723, 8789, 11803, 16401, 8820, 8860, 8928, 8890, 8919,
  8933, 9109, 10090, 8949, 9216, 8974, 9211, 8992, 8446, 9008, 9050, 9066, 8903, 9094, 9146, 9162, 9185, 9201, 9232,
  9261, 12350, 8958, 8976, 8874, 8738, 9282, 9304, 9320, 9347, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 16115, 9585, 9795, 9585, 9585, 10960, 9365, 9374,
  9585, 16106, 9390, 12762, 12455, 16514, 16526, 9585, 8956, 8801, 8957, 9078, 13356, 8432, 22759, 11861, 8484, 8500,
  8773, 8538, 9022, 8804, 8554, 8570, 8514, 10444, 8598, 8619, 8648, 19518, 8664, 8976, 9169, 8752, 8673, 8679, 19751,
  9585, 12379, 8834, 8695, 11794, 19527, 8723, 8789, 11803, 16401, 8820, 8860, 8928, 8890, 8919, 8933, 9109, 10090,
  8949, 9216, 8974, 9211, 8992, 8446, 9008, 9050, 9066, 8903, 9094, 9146, 9162, 9185, 9201, 9232, 9261, 12350, 8958,
  8976, 8874, 8738, 9282, 9304, 9320, 9347, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9757, 9411, 9893, 9585, 9585, 10741, 9434, 9585, 9395, 9459, 9484,
  12762, 22655, 18088, 16526, 9585, 8956, 8801, 8957, 9331, 9505, 8432, 22759, 11861, 8484, 8500, 8773, 8538, 9022,
  8804, 8554, 8570, 8514, 10444, 8598, 8619, 8648, 19518, 8664, 8976, 9169, 8752, 8673, 8679, 19751, 9585, 12379, 8834,
  8695, 11794, 19527, 8723, 8789, 11803, 16401, 8820, 8860, 8928, 8890, 8919, 8933, 9109, 10090, 8949, 9216, 8974, 9211,
  8992, 8446, 9008, 9050, 9066, 8903, 9094, 9146, 9162, 9185, 9201, 9232, 9261, 12350, 8958, 8976, 8874, 8738, 9282,
  9304, 9320, 9347, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9532, 9585, 9795, 9585, 9585, 10960, 9584, 9585, 16387, 8844, 9390, 19335, 11831, 18088,
  16526, 9585, 8956, 8801, 8957, 9331, 9602, 9637, 22759, 11861, 8484, 8500, 8773, 8538, 9022, 8804, 8554, 8570, 8514,
  10444, 8598, 8619, 8648, 19518, 8664, 8976, 9169, 8752, 8673, 8679, 19751, 9585, 12379, 8834, 8695, 11794, 19527,
  8723, 8789, 11803, 16401, 8820, 8860, 8928, 8890, 8919, 8933, 9109, 10090, 8949, 9216, 8974, 9211, 8992, 8446, 9008,
  9050, 9066, 8903, 9094, 9146, 9162, 9185, 9201, 9232, 9261, 12350, 8958, 8976, 8874, 8738, 9282, 9304, 9320, 9347,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9653, 12816, 9795, 9676, 12815, 9701, 9584, 15725, 9660, 9748, 9390, 12762, 12455, 18088, 16526, 9585, 8956,
  8801, 8957, 9331, 13356, 8432, 22759, 11861, 8484, 8500, 8773, 8538, 9022, 8804, 8554, 8570, 8514, 10444, 8598, 8619,
  8648, 19518, 8664, 8976, 9169, 8752, 8673, 8679, 19751, 9585, 12379, 8834, 8695, 11794, 19527, 8723, 8789, 11803,
  16401, 8820, 8860, 8928, 8890, 8919, 8933, 9109, 10090, 8949, 9216, 8974, 9211, 8992, 8446, 9008, 9050, 9066, 8903,
  9094, 9146, 9162, 9185, 9201, 9232, 9261, 12350, 8958, 8976, 8874, 8738, 9282, 9304, 9320, 9347, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 16115, 9585,
  9795, 9585, 9585, 10960, 9584, 9585, 9585, 20511, 9390, 12762, 12455, 18088, 16526, 9585, 8956, 8801, 8957, 9331,
  13356, 8432, 22759, 11861, 8484, 8500, 8773, 8538, 9022, 8804, 8554, 8570, 8514, 10444, 8598, 8619, 8648, 19518, 8664,
  8976, 9169, 8752, 8673, 8679, 19751, 9585, 12379, 8834, 8695, 11794, 19527, 8723, 8789, 11803, 16401, 8820, 8860,
  8928, 8890, 8919, 8933, 9109, 10090, 8949, 9216, 8974, 9211, 8992, 8446, 9008, 9050, 9066, 8903, 9094, 9146, 9162,
  9185, 9201, 9232, 9261, 12350, 8958, 8976, 8874, 8738, 9282, 9304, 9320, 9347, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 16115, 9585, 9795, 9585, 9585,
  16155, 9773, 9585, 9585, 20511, 9790, 12762, 16211, 18088, 16526, 9585, 8956, 8801, 8957, 9331, 13356, 8432, 22759,
  11861, 8484, 8500, 8773, 8538, 9022, 8804, 8554, 8570, 8514, 10444, 8598, 8619, 8648, 19518, 8664, 8976, 9169, 8752,
  8673, 8679, 19751, 9585, 12379, 8834, 8695, 11794, 19527, 8723, 8789, 11803, 16401, 8820, 8860, 8928, 8890, 8919,
  8933, 9109, 10090, 8949, 9216, 8974, 9211, 8992, 8446, 9008, 9050, 9066, 8903, 9094, 9146, 9162, 9185, 9201, 9232,
  9261, 12350, 8958, 8976, 8874, 8738, 9282, 9304, 9320, 9347, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 20520, 9811, 21410, 9585, 9585, 15572, 9834, 9585,
  9489, 9859, 9888, 12762, 16413, 18088, 16526, 9585, 8956, 8801, 8957, 9331, 12751, 8432, 22759, 11861, 8484, 8500,
  8773, 8538, 9022, 8804, 8554, 8570, 8514, 10444, 8598, 8619, 8648, 19518, 8664, 8976, 9169, 8752, 8673, 8679, 19751,
  9585, 12379, 8834, 8695, 11794, 19527, 8723, 8789, 11803, 16401, 8820, 8860, 8928, 8890, 8919, 8933, 9109, 10090,
  8949, 9216, 8974, 9211, 8992, 8446, 9008, 9050, 9066, 8903, 9094, 9146, 9162, 9185, 9201, 9232, 9261, 12350, 8958,
  8976, 8874, 8738, 9282, 9304, 9320, 9347, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9909, 13044, 9942, 16963, 9938, 13057, 9932, 16973, 16948, 9958, 9390,
  9983, 12455, 18088, 16526, 9585, 8956, 8801, 8957, 9331, 13828, 8432, 22759, 11861, 8484, 8500, 8773, 8538, 9022,
  8804, 8554, 8570, 8514, 10444, 8598, 8619, 8648, 19518, 8664, 8976, 9169, 8752, 8673, 8679, 19751, 9585, 12379, 8834,
  8695, 11794, 19527, 8723, 8789, 11803, 16401, 8820, 8860, 8928, 8890, 8919, 8933, 9109, 10090, 8949, 9216, 8974, 9211,
  8992, 8446, 9008, 9050, 9066, 8903, 9094, 9146, 9162, 9185, 9201, 9232, 9261, 12350, 8958, 8976, 8874, 8738, 9282,
  9304, 9320, 9347, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 16115, 13252, 9795, 10025, 16897, 20936, 10053, 10060, 16002, 10076, 9390, 19387, 12455,
  18088, 16526, 9585, 8956, 8801, 8957, 9331, 12644, 8432, 22759, 11861, 8484, 8500, 8773, 8538, 9022, 8804, 8554, 8570,
  8514, 10444, 8598, 8619, 8648, 19518, 8664, 8976, 9169, 8752, 8673, 8679, 19751, 9585, 12379, 8834, 8695, 11794,
  19527, 8723, 8789, 11803, 16401, 8820, 8860, 8928, 8890, 8919, 8933, 9109, 10090, 8949, 9216, 8974, 9211, 8992, 8446,
  9008, 9050, 9066, 8903, 9094, 9146, 9162, 9185, 9201, 9232, 9261, 12350, 8958, 8976, 8874, 8738, 9282, 9304, 9320,
  9347, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 16115, 9585, 9795, 9585, 9585, 10960, 10106, 10118, 10134, 10148, 9390, 12762, 12455, 18088, 16526, 9585,
  8956, 8801, 8957, 9331, 13356, 8432, 22759, 11861, 8484, 8500, 8773, 8538, 9022, 8766, 8554, 8570, 8514, 10444, 8598,
  8619, 8648, 19518, 8664, 8976, 9169, 8752, 8673, 8679, 19751, 9585, 12379, 8834, 8695, 11794, 19527, 8723, 8789,
  11803, 16401, 8820, 8860, 8928, 8890, 8919, 8933, 9109, 10090, 8949, 9216, 8974, 9211, 8992, 8446, 9008, 9050, 9066,
  8903, 9094, 9146, 9162, 9185, 9201, 9232, 9261, 12350, 8958, 8976, 8874, 8738, 9282, 9304, 9320, 9347, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 16115,
  9585, 9795, 9585, 9585, 10960, 10195, 10220, 9585, 10204, 9390, 12762, 12455, 18088, 16526, 9585, 8956, 8801, 8957,
  9331, 13356, 10256, 22759, 11861, 8484, 8500, 8773, 8538, 9022, 8804, 8554, 8570, 8514, 10444, 8598, 8619, 8648,
  19518, 8664, 8976, 9169, 8752, 8673, 8679, 19751, 9585, 12379, 8834, 8695, 11794, 19527, 8723, 8789, 11803, 16401,
  8820, 8860, 8928, 8890, 8919, 8933, 9109, 10090, 8949, 9216, 8974, 9211, 8992, 8446, 9008, 9050, 9066, 8903, 9094,
  9146, 9162, 9185, 9201, 9232, 9261, 12350, 8958, 8976, 8874, 8738, 9282, 9304, 9320, 9347, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 16115, 12055, 9795,
  20446, 11283, 10271, 10352, 10361, 9585, 21218, 9390, 12762, 12455, 18088, 16526, 9585, 8956, 8801, 8957, 9331, 13356,
  8432, 22759, 11861, 8484, 8500, 8773, 8538, 9022, 8804, 8554, 8570, 8514, 10444, 8598, 8619, 8648, 19518, 8664, 8976,
  9169, 8752, 8673, 8679, 19751, 9585, 12379, 8834, 8695, 11794, 19527, 8723, 8789, 11803, 16401, 8820, 8860, 8928,
  8890, 8919, 8933, 9109, 10090, 8949, 9216, 8974, 9211, 8992, 8446, 9008, 9050, 9066, 8903, 9094, 9146, 9162, 9185,
  9201, 9232, 9261, 12350, 8958, 8976, 8874, 8738, 9282, 9304, 9320, 9347, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 10377, 9585, 9795, 9585, 9585, 10960,
  10401, 10426, 9585, 10410, 10460, 13367, 9712, 22709, 17163, 9585, 14320, 13466, 10684, 15290, 11700, 21084, 22947,
  17160, 17165, 10483, 14322, 14322, 17207, 10681, 10527, 10527, 13244, 10481, 9585, 10499, 17163, 19624, 14322, 14322,
  20543, 10527, 10527, 15134, 9585, 9585, 22715, 17167, 14321, 14322, 14322, 10526, 10527, 10685, 9585, 22713, 10240,
  14322, 14322, 10521, 10544, 10616, 10563, 14641, 14322, 21522, 10527, 10583, 15051, 14322, 13013, 10527, 10590, 21007,
  14932, 10612, 13105, 10634, 19107, 15189, 10667, 15280, 13014, 15980, 15611, 15643, 15647, 15490, 12915, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 16115,
  9585, 9795, 9585, 12806, 19998, 9584, 9585, 12107, 10701, 10460, 9613, 16029, 22709, 17163, 9585, 14320, 13466, 10684,
  20846, 11700, 9585, 9586, 17160, 17165, 10483, 14322, 14322, 17207, 10681, 10527, 10527, 15994, 10481, 9585, 22715,
  17163, 19624, 14322, 14322, 20543, 10527, 10527, 15134, 9585, 9585, 22715, 17167, 14321, 14322, 14322, 10526, 10527,
  10685, 9585, 22713, 10240, 14322, 14322, 13274, 10527, 10616, 22711, 14641, 14322, 13013, 10527, 10618, 15051, 14322,
  13013, 10527, 10590, 14316, 13011, 10527, 13105, 14323, 10527, 13544, 17740, 14117, 13014, 14111, 15611, 15643, 15647,
  15490, 12915, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 16115, 16889, 9795, 9585, 9585, 14245, 9584, 10726, 14237, 10786, 9390, 12762, 14597, 22311, 16526,
  9585, 8956, 8801, 8957, 9331, 13356, 8432, 22759, 11861, 8484, 8500, 8773, 8538, 9022, 8804, 8554, 8570, 8514, 10444,
  8598, 8619, 8648, 19518, 8664, 8976, 9169, 8752, 8673, 8679, 19751, 9585, 12379, 8834, 8695, 11794, 19527, 8723, 8789,
  11803, 16401, 8820, 8860, 8928, 8890, 8919, 8933, 9109, 10090, 8949, 9216, 8974, 9211, 8992, 8446, 9008, 9050, 9066,
  8903, 9094, 9146, 9162, 9185, 9201, 9232, 9261, 12350, 8958, 8976, 8874, 8738, 9282, 9304, 9320, 9347, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 16115,
  9585, 9795, 9585, 10752, 22460, 9584, 9585, 22068, 10815, 10460, 17510, 11754, 22709, 17163, 9585, 14320, 13466,
  10684, 14165, 11700, 9621, 10840, 17160, 17165, 10483, 14322, 14322, 17207, 10681, 10527, 10527, 15403, 10481, 10859,
  22715, 17163, 19624, 14322, 14322, 20543, 10527, 10527, 14531, 10885, 17904, 10908, 17167, 14321, 14322, 14322, 10526,
  10527, 10685, 10930, 9730, 10240, 14322, 14322, 13274, 10527, 10616, 22711, 14641, 14322, 13013, 10527, 10618, 15051,
  14322, 13013, 10527, 10590, 14316, 13011, 10527, 13105, 14323, 10527, 13544, 17740, 14117, 13014, 14111, 15611, 15643,
  15647, 15490, 12915, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 16115, 10934, 10179, 12917, 20764, 14274, 9584, 17884, 9585, 15032, 10950, 12595, 12455,
  18088, 16526, 9585, 11142, 11137, 10976, 11682, 12583, 8432, 22759, 11861, 8484, 10998, 11245, 11028, 11125, 11012,
  11598, 11044, 11275, 10444, 8598, 8619, 8648, 8459, 11082, 11144, 8468, 11186, 11056, 10982, 19751, 9585, 12379, 8834,
  11113, 11160, 11468, 11356, 11660, 11672, 16401, 8820, 11202, 11459, 11232, 11175, 11261, 11524, 10090, 11299, 11327,
  11372, 11066, 11399, 8446, 11569, 11097, 11415, 11428, 11444, 11216, 11513, 11484, 11342, 11500, 11540, 11556, 11311,
  11308, 11645, 11383, 11585, 11614, 11630, 11698, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 16115, 23046, 9795, 12213, 12211, 21984, 11716, 11725, 23047,
  22034, 9390, 12762, 12455, 18088, 16526, 9585, 8956, 8801, 8957, 9331, 13356, 8432, 22759, 11861, 8484, 8500, 8773,
  8538, 9022, 8804, 8554, 8570, 8514, 10444, 11741, 8619, 8648, 19518, 8664, 8976, 9169, 8752, 8673, 9288, 15557, 9685,
  11779, 8834, 8695, 11794, 19527, 8723, 8789, 11803, 11819, 11847, 8860, 8928, 8890, 8919, 8933, 9109, 10090, 8949,
  9216, 8974, 9211, 8992, 8446, 9008, 9050, 9066, 8903, 9094, 9146, 9162, 9185, 9201, 9232, 9261, 12350, 8958, 8976,
  8874, 8738, 9282, 9304, 9320, 9347, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 16115, 9585, 9795, 9585, 9585, 9585, 11877, 11886, 14346, 11902, 9390,
  12762, 12455, 18088, 22551, 9585, 8956, 8801, 8957, 8582, 13356, 8432, 22759, 11861, 8484, 8500, 8773, 8538, 9022,
  8804, 8554, 8570, 8514, 10444, 8598, 8619, 8648, 19518, 8664, 8976, 9169, 8752, 8673, 8679, 19751, 9585, 12379, 8834,
  8695, 11794, 19527, 8723, 8789, 11803, 16401, 8820, 8860, 8928, 8890, 8919, 8933, 9109, 10090, 8949, 9216, 8974, 9211,
  8992, 8446, 9008, 9050, 9066, 8903, 9094, 9146, 9162, 9185, 9201, 9232, 9261, 12350, 8958, 8976, 8874, 8738, 9282,
  9304, 9320, 9347, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9967, 9585, 21250, 9585, 21241, 10960, 11938, 11947, 9585, 22594, 11963, 12762, 12455, 18088,
  8632, 9585, 8956, 8801, 8957, 8707, 13356, 8432, 22759, 11861, 8484, 8500, 8773, 8538, 9022, 8804, 8554, 8570, 8514,
  10444, 8598, 8619, 8648, 19518, 8664, 8976, 9169, 8752, 8673, 8679, 19751, 9585, 12379, 8834, 8695, 11794, 19527,
  8723, 8789, 11803, 16401, 8820, 8860, 8928, 8890, 8919, 8933, 9109, 10090, 8949, 9216, 8974, 9211, 8992, 8446, 9008,
  9050, 9066, 8903, 9094, 9146, 9162, 9185, 9201, 9232, 9261, 12350, 8958, 8976, 8874, 8738, 9282, 9304, 9320, 9347,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9868, 11999, 9795, 9585, 9585, 10960, 12023, 12032, 9872, 22643, 12048, 12762, 12455, 18088, 22323, 9585, 8956,
  8801, 8957, 9034, 13356, 8432, 22759, 11861, 8484, 8500, 8773, 8538, 9022, 8804, 8554, 8570, 8514, 10444, 8598, 8619,
  8648, 19518, 8664, 8976, 9169, 8752, 8673, 8679, 19751, 9585, 12379, 8834, 8695, 11794, 19527, 8723, 8789, 11803,
  16401, 8820, 8860, 8928, 8890, 8919, 8933, 9109, 10090, 8949, 9216, 8974, 9211, 8992, 8446, 9008, 9050, 9066, 8903,
  9094, 9146, 9162, 9185, 9201, 9232, 9261, 12071, 8958, 8976, 8874, 8738, 9282, 9304, 9320, 9347, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 20970, 20979,
  9795, 12007, 9585, 10960, 9584, 12100, 9585, 20961, 9390, 12762, 12455, 22539, 16526, 9585, 8956, 8801, 8957, 12084,
  13356, 8432, 22759, 11861, 8484, 8500, 8773, 8538, 9022, 8804, 8554, 8570, 8514, 10444, 8598, 8619, 8648, 19518, 8664,
  8976, 9169, 8752, 8673, 8679, 19751, 9585, 12379, 8834, 8695, 11794, 19527, 8723, 8789, 11803, 16401, 8820, 8860,
  8928, 8890, 8919, 8933, 9109, 10090, 8949, 9216, 8974, 9211, 8992, 8446, 9008, 9050, 9066, 8903, 9094, 9146, 9162,
  9185, 9201, 9232, 9261, 12350, 8958, 8976, 8874, 8738, 9282, 9304, 9320, 9347, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 16115, 9585, 9795, 9585, 9585,
  10960, 9584, 9585, 13951, 12123, 9390, 12762, 12455, 18088, 16526, 9585, 8956, 8801, 8957, 9331, 13356, 8432, 22759,
  11861, 8484, 8500, 8773, 8538, 9022, 8804, 8554, 8570, 8514, 10444, 8598, 8619, 8648, 19518, 8664, 8976, 9169, 8752,
  8673, 8679, 19751, 9585, 12379, 8834, 8695, 11794, 19527, 8723, 8789, 11803, 16401, 8820, 8860, 8928, 8890, 8919,
  8933, 9109, 10090, 8949, 9216, 8974, 9211, 8992, 8446, 9008, 9050, 9066, 8903, 9094, 9146, 9162, 9185, 9201, 9232,
  9261, 12350, 8958, 8976, 8874, 8738, 9282, 9304, 9320, 9347, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 10710, 9585, 20608, 10464, 10761, 10960, 12159,
  10843, 16249, 16741, 10460, 13367, 9712, 22709, 17163, 9585, 14320, 13466, 10684, 15290, 17499, 9585, 9586, 17160,
  17165, 10483, 14322, 14322, 17207, 12184, 10527, 10527, 15994, 10481, 12415, 22715, 17163, 19624, 14322, 14322, 20543,
  10527, 10527, 15134, 12204, 9721, 10908, 17167, 14321, 14322, 14322, 10526, 10527, 10685, 10930, 19227, 10240, 14322,
  14322, 13274, 10527, 10616, 22711, 14641, 14322, 13013, 10527, 10618, 10235, 14322, 13013, 10527, 10590, 14316, 13011,
  10527, 13105, 14323, 10527, 13544, 17740, 14117, 13014, 14111, 15611, 15643, 15647, 15490, 12915, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 10710, 9585,
  20608, 10464, 10761, 10960, 12159, 10843, 16249, 16741, 10460, 13367, 9712, 22709, 17163, 9585, 14320, 13466, 10684,
  15290, 17499, 9585, 9586, 17160, 17165, 10483, 14322, 14322, 17207, 12184, 10527, 10527, 15994, 10481, 12415, 22715,
  17163, 19624, 14322, 14322, 20543, 10527, 10527, 15134, 12204, 9721, 10908, 17167, 14321, 14322, 14322, 10526, 10527,
  10685, 10930, 9730, 10240, 14322, 14322, 13274, 10527, 10616, 22711, 14641, 14322, 13013, 10527, 10618, 15051, 14322,
  13013, 10527, 10590, 14316, 13011, 10527, 13105, 14323, 10527, 13544, 17740, 14117, 13014, 14111, 15611, 15643, 15647,
  15490, 12915, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 10710, 9585, 20608, 10464, 10761, 10960, 12159, 10843, 16249, 16741, 10460, 13367, 9712, 22709,
  17163, 9585, 14320, 13466, 10684, 15290, 17499, 9585, 9586, 17160, 17165, 10483, 14322, 14322, 17207, 12184, 10527,
  10527, 15994, 10481, 12415, 9124, 17163, 19624, 14322, 14322, 20543, 10527, 10527, 15134, 12204, 9721, 10908, 17167,
  14321, 14322, 14322, 10526, 10527, 10685, 10930, 9730, 10240, 14322, 14322, 13274, 10527, 10616, 22711, 14641, 14322,
  13013, 10527, 10618, 15051, 14322, 13013, 10527, 10590, 14316, 13011, 10527, 13105, 14323, 10527, 13544, 17740, 14117,
  13014, 14111, 15611, 15643, 15647, 15490, 12915, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 10710, 9585, 20608, 10464, 10761, 10960, 12159, 10843, 16249,
  16741, 10460, 13367, 9712, 22709, 17163, 9585, 14320, 13466, 10684, 15290, 17499, 9585, 9586, 17160, 17165, 10483,
  14322, 14322, 17207, 12184, 10527, 10527, 15994, 10481, 12415, 22715, 17163, 19624, 14322, 14322, 20543, 10527, 10527,
  15134, 12204, 9721, 12229, 17167, 14321, 14322, 14322, 10526, 10527, 10685, 10930, 9730, 10240, 14322, 14322, 13274,
  10527, 10616, 22711, 14641, 14322, 13013, 10527, 10618, 15051, 14322, 13013, 10527, 10590, 14316, 13011, 10527, 13105,
  14323, 10527, 13544, 17740, 14117, 13014, 14111, 15611, 15643, 15647, 15490, 12915, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 10710, 9585, 20608, 10464,
  10761, 10960, 12159, 10843, 16249, 16741, 10460, 13367, 17110, 22709, 17163, 9585, 14320, 13466, 10684, 15290, 17499,
  15786, 9586, 17160, 17165, 10483, 14322, 14322, 17207, 12184, 10527, 10527, 15994, 10481, 12415, 22715, 17163, 19624,
  14322, 14322, 20543, 10527, 10527, 15134, 12204, 9721, 10908, 17167, 14321, 14322, 14322, 10526, 10527, 10685, 10930,
  9730, 10240, 14322, 14322, 13274, 10527, 10616, 22711, 14641, 14322, 13013, 10527, 10618, 15051, 14322, 13013, 10527,
  10590, 14316, 13011, 10527, 13105, 14323, 10527, 13544, 17740, 14117, 13014, 14111, 15611, 15643, 15647, 15490, 12915,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 10710, 9585, 20608, 10464, 10761, 10960, 12159, 10843, 16249, 16741, 10460, 13367, 9712, 22709, 17163, 9585,
  14320, 13466, 10684, 15290, 17499, 9585, 9586, 17160, 17165, 10483, 14322, 14322, 17207, 12184, 10527, 10527, 15994,
  10481, 9585, 22715, 17163, 19624, 14322, 14322, 20543, 10527, 10527, 15134, 9585, 9585, 22715, 17167, 14321, 14322,
  14322, 10526, 10527, 10685, 9585, 22713, 10240, 14322, 14322, 13274, 10527, 10616, 22711, 14641, 14322, 13013, 10527,
  10618, 15051, 14322, 13013, 10527, 10590, 14316, 13011, 10527, 13105, 14323, 10527, 13544, 17740, 14117, 13014, 14111,
  15611, 15643, 15647, 15490, 12915, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 10710, 9585, 20608, 10464, 10761, 10960, 12159, 10843, 16249, 16741, 10460, 13367,
  9712, 22709, 17163, 9585, 14320, 13466, 10684, 15290, 17499, 9585, 9586, 17160, 17165, 10483, 14322, 14322, 17207,
  12184, 10527, 10527, 15994, 10481, 9585, 22715, 17163, 19624, 14322, 14322, 20543, 10527, 10527, 15134, 9585, 9585,
  22715, 17167, 14321, 14322, 14322, 10526, 10527, 10685, 9585, 22713, 10240, 14322, 14322, 13274, 10527, 10616, 20117,
  14641, 14322, 13013, 10527, 10618, 15051, 14322, 13013, 10527, 10590, 14316, 13011, 10527, 13105, 14323, 10527, 13544,
  17740, 14117, 13014, 14111, 15611, 15643, 15647, 15490, 12915, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 16115, 9585, 9795, 9585, 9585, 12842, 9584, 22976,
  9585, 22788, 9390, 12762, 12455, 18088, 16526, 9585, 8956, 8801, 8957, 9331, 13356, 8432, 8416, 11861, 8484, 8500,
  8773, 8538, 9022, 8804, 8554, 8570, 8514, 10444, 8598, 8619, 8648, 19518, 8664, 8976, 9169, 8752, 8673, 8679, 19751,
  9585, 12379, 8834, 8695, 11794, 19527, 8723, 8789, 11803, 16401, 8820, 8860, 8928, 8890, 8919, 8933, 9109, 10090,
  8949, 9216, 8974, 9211, 8992, 8446, 9008, 9050, 9066, 9245, 9094, 9146, 9162, 9185, 9201, 9232, 9261, 12350, 8958,
  8976, 8874, 8738, 9282, 9304, 9320, 9347, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 16115, 9585, 12251, 9585, 9585, 12277, 12304, 12313, 9585, 10312,
  9390, 12762, 12455, 18088, 16526, 9585, 8956, 8801, 8957, 9331, 13356, 8432, 22759, 11861, 8484, 8500, 8773, 8538,
  9022, 8804, 8554, 8570, 8514, 10444, 8598, 8619, 8648, 19518, 8664, 8976, 9169, 8752, 8673, 8679, 19751, 9585, 12379,
  8834, 8695, 11794, 19527, 8723, 8789, 11803, 16401, 8820, 8860, 8928, 8890, 8919, 8933, 9109, 10090, 8949, 9216, 8974,
  9211, 8992, 8446, 9008, 9050, 9066, 8903, 9094, 9146, 9162, 12329, 9201, 9232, 12345, 23084, 8958, 8976, 8874, 8738,
  9282, 9304, 9320, 9347, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 16115, 9585, 9795, 9585, 9585, 10960, 9584, 9349, 11922, 12366, 9390, 12762, 12455,
  18088, 16526, 9585, 8956, 8801, 8957, 9331, 13356, 8432, 22759, 11861, 8484, 8500, 8773, 8538, 9022, 8804, 8554, 8570,
  8514, 10444, 8598, 8619, 8648, 19518, 8664, 8976, 9169, 8752, 8673, 8679, 19751, 9585, 12379, 8834, 8695, 11794,
  19527, 8723, 8789, 11803, 16401, 8820, 8860, 8928, 8890, 8919, 8933, 9109, 10090, 8949, 9216, 8974, 9211, 8992, 8446,
  9008, 9050, 9066, 8903, 9094, 9146, 9162, 9185, 9201, 9232, 9261, 12350, 8958, 8976, 8874, 8738, 9282, 9304, 9320,
  9347, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 16115, 9585, 9795, 9585, 9585, 12395, 9584, 9585, 9682, 12431, 9390, 12762, 17641, 18088, 16526, 9585,
  8956, 8801, 8957, 9331, 13356, 8432, 12463, 11861, 8484, 8500, 8773, 8538, 9022, 8804, 8554, 8570, 8514, 10444, 8598,
  8619, 8648, 19518, 8664, 8976, 9169, 8752, 8673, 8679, 19751, 9585, 12379, 8834, 8695, 11794, 19527, 8723, 8789,
  11803, 16401, 8820, 8860, 8928, 8890, 8919, 8933, 9109, 10090, 8949, 9216, 8974, 9211, 8992, 8446, 9008, 9050, 9066,
  8903, 9094, 9146, 9162, 9185, 9201, 9232, 9261, 12350, 8958, 8976, 8874, 8738, 9282, 9304, 9320, 9347, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 10710,
  9585, 12479, 12615, 12512, 14585, 12528, 12540, 12556, 12570, 12611, 16146, 12631, 22047, 19422, 20981, 12660, 12676,
  12721, 12737, 12785, 18629, 9586, 17160, 20147, 10483, 14322, 18148, 9562, 12184, 10527, 19916, 15994, 12832, 12415,
  15449, 12235, 9547, 14322, 12858, 20543, 12883, 17269, 12903, 12204, 22801, 12933, 12968, 12983, 13007, 14322, 21877,
  19909, 10685, 13030, 9730, 10240, 14322, 14080, 13073, 10527, 13094, 22711, 14641, 15210, 13013, 17720, 10618, 15051,
  21566, 13882, 13121, 10590, 14316, 13011, 10527, 13105, 14323, 10527, 13544, 17740, 14117, 13014, 14111, 15611, 15643,
  15647, 15490, 12915, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 10710, 9585, 17870, 10464, 18461, 10960, 12159, 10843, 16249, 16741, 10460, 13367, 9712,
  22709, 17163, 9585, 14320, 13466, 10684, 15290, 17499, 9585, 9586, 17160, 17165, 10483, 14322, 14322, 17207, 12184,
  10527, 10527, 15994, 10481, 13137, 22715, 20632, 19624, 14322, 21490, 20543, 10527, 10527, 13163, 12204, 9721, 10908,
  17167, 14321, 14322, 14322, 10526, 10527, 10685, 10930, 22810, 17083, 13212, 19870, 15619, 10527, 10616, 22711, 14641,
  14322, 13013, 10527, 10618, 15051, 14322, 13013, 10527, 10590, 14316, 13011, 10527, 13105, 14323, 10527, 13544, 17740,
  14117, 13229, 13268, 15611, 15643, 15647, 15490, 12915, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 10824, 9585, 20608, 10464, 15417, 15427, 13295, 13311,
  13327, 13343, 10460, 13367, 13389, 22709, 17163, 9585, 14320, 15112, 13414, 13531, 17499, 9585, 22607, 13430, 17165,
  22851, 13455, 13488, 21481, 13505, 13565, 10527, 15994, 10481, 21612, 10596, 17163, 22368, 14322, 13590, 16578, 13609,
  21706, 15134, 12204, 19218, 10908, 17167, 14321, 14322, 14322, 10526, 10527, 10685, 10930, 9730, 10240, 14322, 14322,
  13274, 10527, 10616, 22711, 13630, 13654, 13013, 22105, 10618, 20738, 16337, 13013, 22429, 10590, 14316, 16700, 13758,
  13105, 14323, 10527, 13544, 17740, 14117, 13676, 14111, 15611, 15643, 15647, 13741, 12915, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 10710, 9585, 20608,
  10464, 18735, 18745, 13774, 13785, 13801, 13815, 10460, 13367, 9712, 22709, 13844, 21745, 13865, 13725, 13898, 13689,
  18539, 9585, 21430, 17160, 13940, 19490, 14322, 13967, 19779, 13991, 19650, 14012, 15994, 10481, 12415, 22715, 17163,
  19624, 14322, 14322, 20543, 10527, 10527, 15134, 12204, 9721, 10908, 17167, 14999, 14322, 14030, 14771, 10527, 13996,
  10930, 14050, 13849, 15826, 14075, 10643, 17559, 10616, 20158, 17534, 22206, 13013, 14096, 10618, 15051, 14322, 13013,
  10527, 10590, 14316, 14133, 14014, 13105, 14323, 10527, 13544, 17740, 14155, 13014, 14111, 15611, 15643, 15647, 15490,
  12915, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 10710, 9585, 18721, 10464, 11763, 16199, 14181, 14194, 14210, 14224, 10460, 14261, 17110, 14290, 14306,
  14339, 18176, 12705, 14362, 14378, 17839, 18707, 16220, 17160, 13439, 9843, 19631, 21014, 14418, 14455, 14485, 14512,
  14547, 14572, 18564, 10799, 14633, 14665, 14692, 14708, 14745, 13924, 14794, 14835, 14874, 9998, 14890, 12943, 14649,
  15085, 14918, 18284, 22868, 14973, 15021, 15048, 15067, 22394, 15101, 15128, 15150, 15226, 22711, 15266, 15306, 13013,
  15329, 17141, 15357, 15373, 15389, 22235, 15443, 14316, 15465, 13907, 14987, 18130, 18914, 13702, 15506, 15542, 15599,
  17429, 15611, 16588, 15635, 15490, 12915, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 10710, 9585, 20608, 10464, 10761, 18471, 15663, 15672, 15688, 15702,
  15741, 13367, 9712, 22709, 17163, 9585, 14320, 14402, 15757, 20249, 17499, 15782, 9818, 15802, 17165, 10483, 15822,
  14322, 17207, 15842, 10527, 10527, 15994, 10481, 12415, 22715, 17163, 19624, 14322, 14433, 20543, 10527, 17376, 19278,
  12204, 9721, 10908, 17167, 14321, 14322, 14322, 10526, 10527, 10685, 15869, 9730, 15894, 14322, 15519, 13274, 10527,
  15940, 22711, 14641, 14322, 13013, 10527, 10618, 15051, 14322, 13013, 10527, 10590, 14316, 13011, 10527, 13105, 14323,
  10527, 13544, 17740, 14117, 13014, 14111, 15611, 13518, 16917, 15965, 12915, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 10710, 9585, 20608, 10464, 15239, 16018,
  16054, 16063, 16079, 16093, 10460, 13367, 15583, 22709, 17163, 9585, 14320, 13466, 10684, 15290, 16135, 9774, 9586,
  17160, 17165, 10483, 14322, 14322, 17207, 12184, 10527, 10527, 15994, 10481, 9585, 22715, 17163, 19624, 14322, 14322,
  20543, 10527, 10527, 15134, 9585, 9585, 22715, 17167, 14321, 14322, 14322, 10526, 10527, 10685, 9585, 22713, 10240,
  14322, 14322, 13274, 10527, 10616, 22711, 14641, 14322, 13013, 10527, 10618, 15051, 14322, 13013, 10527, 16794, 20184,
  16171, 19097, 13176, 16236, 16277, 13544, 17740, 14117, 13014, 14111, 15611, 15643, 18833, 15490, 12915, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 10710,
  9585, 20608, 10464, 10761, 10960, 12159, 10843, 16249, 16741, 10460, 16305, 9712, 17318, 18600, 9585, 16332, 16327,
  16353, 16373, 17499, 17895, 9586, 17160, 17165, 10483, 14322, 14322, 17986, 12184, 10527, 17262, 15994, 10481, 9585,
  22715, 17163, 19624, 14322, 14322, 20543, 10527, 10527, 15134, 9585, 9585, 22715, 17167, 14321, 14322, 14322, 10526,
  10527, 10685, 9585, 22713, 10240, 14322, 14322, 13274, 10527, 10616, 22711, 14641, 14322, 13013, 10527, 10618, 15051,
  14322, 13013, 10527, 10590, 14316, 13011, 10527, 13105, 20379, 19149, 13544, 17740, 14117, 13014, 14111, 15611, 15643,
  15647, 15490, 12915, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 10710, 9585, 16439, 10464, 16429, 10960, 16455, 16469, 16485, 16501, 10460, 13367, 9712,
  13373, 17163, 11915, 16695, 16690, 16542, 15290, 17499, 9585, 9586, 10505, 20486, 19617, 16563, 14322, 16604, 16625,
  14525, 21375, 15994, 16650, 9585, 22715, 14059, 19624, 14322, 16666, 20543, 10527, 16357, 16634, 9585, 9585, 22715,
  17167, 14321, 14322, 22199, 22264, 10527, 10685, 9585, 22713, 10240, 14322, 14322, 13274, 10527, 12188, 19402, 16716,
  16757, 14729, 18011, 16787, 16810, 14722, 15915, 16836, 10590, 14316, 13011, 10527, 13105, 14323, 10527, 13544, 13614,
  16874, 13014, 14111, 16289, 16913, 15647, 21913, 12915, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 10710, 9585, 20608, 10464, 10761, 10960, 12159, 10843,
  21790, 16741, 10460, 13367, 9712, 22709, 17163, 9585, 14320, 13466, 10684, 15290, 17499, 9585, 9586, 17160, 17165,
  10483, 14322, 14322, 17207, 12184, 10527, 10527, 15994, 10481, 9585, 22715, 17163, 19624, 14322, 14322, 20543, 10527,
  10527, 15134, 9585, 9585, 22715, 17167, 14321, 14322, 14322, 10526, 10527, 10685, 9585, 22713, 10240, 14322, 14322,
  13274, 10527, 10616, 22711, 14641, 14322, 13013, 10527, 10618, 15051, 14322, 13013, 10527, 10590, 14316, 13011, 10527,
  13105, 14323, 10527, 13544, 17740, 14117, 13014, 14111, 15611, 15643, 15647, 15490, 12915, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 10710, 9585, 20608,
  10464, 15715, 16933, 16989, 16998, 17014, 17028, 17057, 9516, 15583, 17062, 17078, 17099, 15079, 13714, 17135, 15341,
  16135, 12952, 9586, 17157, 17165, 10483, 17183, 14034, 17228, 17252, 17285, 15766, 19573, 17304, 9585, 11983, 17163,
  10009, 21320, 14322, 13196, 17340, 17375, 15134, 9585, 12406, 22715, 21603, 14321, 17771, 14322, 10526, 21167, 20836,
  20436, 22614, 10240, 17392, 14322, 14139, 10527, 10616, 17580, 19191, 14322, 13660, 10527, 20690, 15051, 14322, 13013,
  10527, 18242, 14316, 18365, 18304, 13105, 14323, 10527, 13544, 17740, 14117, 13014, 15480, 17414, 15643, 18821, 15490,
  12915, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 10710, 9585, 20608, 10464, 10761, 10960, 17445, 17456, 17472, 17486, 10460, 13367, 14608, 22471, 17526,
  14617, 15906, 16678, 17550, 15853, 17499, 9585, 17575, 17160, 17165, 10483, 14322, 12691, 15202, 17596, 20561, 17700,
  20409, 17629, 21405, 22715, 17163, 19624, 14322, 13213, 17666, 17692, 17716, 15134, 9585, 20077, 22715, 17167, 13472,
  13975, 17236, 13078, 22268, 17736, 9585, 22713, 10240, 14322, 14322, 13274, 10527, 10616, 22711, 14641, 14322, 13013,
  10527, 10618, 15051, 14322, 13013, 10527, 10590, 14316, 13011, 10527, 13105, 14323, 10527, 17756, 22690, 14117, 13014,
  14111, 15611, 15643, 15647, 15490, 12915, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 10710, 9585, 20608, 10464, 10761, 10960, 17787, 17796, 17812, 17826,
  17855, 13367, 9712, 20308, 17920, 14556, 17949, 17974, 18002, 18035, 17499, 18064, 9586, 17160, 17165, 10483, 14322,
  14322, 17207, 12184, 10527, 10527, 15994, 18081, 9585, 22715, 17163, 19624, 14322, 14322, 20543, 10527, 10527, 15134,
  9585, 9585, 18104, 21734, 18127, 15526, 18146, 13755, 17288, 22345, 12264, 20213, 18164, 18776, 18991, 18192, 18208,
  18233, 22711, 14641, 18258, 18275, 18300, 19814, 18320, 18344, 15005, 21848, 15949, 16820, 22129, 18381, 13105, 20361,
  21351, 13544, 17740, 18408, 16771, 18424, 15611, 21887, 15647, 20810, 12915, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 10710, 9585, 10161, 10464, 21231, 18446,
  18487, 18496, 18512, 18526, 10460, 13367, 18555, 18580, 18616, 17041, 18645, 18661, 18677, 18693, 17499, 9585, 9586,
  17160, 17165, 10483, 14322, 14322, 18761, 12184, 10527, 18806, 15994, 10481, 10385, 22715, 9130, 18861, 21573, 15313,
  20543, 10528, 10527, 15176, 18884, 10892, 22715, 17167, 17212, 14322, 14322, 10526, 18911, 10685, 9585, 22713, 10240,
  14322, 14322, 13274, 10527, 10616, 22711, 18938, 14322, 20668, 10527, 10618, 18930, 18954, 9568, 10527, 10590, 14316,
  13011, 10527, 20717, 18259, 10527, 14391, 18976, 20239, 13014, 14111, 15611, 15643, 15647, 14819, 12915, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 10710,
  9585, 20608, 10464, 10761, 10960, 12159, 16311, 19007, 19021, 10460, 13367, 9712, 22709, 17163, 9585, 14320, 13466,
  10684, 15290, 17499, 9585, 19059, 19415, 17165, 10483, 12867, 14322, 21128, 19082, 13916, 19669, 21820, 10481, 22840,
  22715, 17163, 19624, 14322, 14322, 20543, 10527, 10527, 15134, 19123, 8522, 9732, 18111, 16609, 14322, 14322, 10526,
  19147, 10685, 9585, 22713, 10240, 14322, 19165, 13274, 16547, 10616, 22711, 14641, 14322, 13013, 10527, 10618, 15051,
  14322, 13013, 10527, 10590, 14316, 13011, 10527, 13105, 14323, 10527, 13544, 17740, 14117, 13014, 14111, 15611, 15643,
  15647, 15490, 12915, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 10710, 9585, 20608, 10464, 10761, 10960, 12159, 10843, 16249, 16741, 10460, 13367, 20009,
  22709, 19183, 19207, 19256, 19251, 19272, 19294, 19324, 10465, 9586, 17160, 17165, 10483, 14322, 14322, 17207, 12184,
  10527, 10527, 15994, 10481, 9585, 22715, 17163, 19624, 14322, 14322, 20543, 10527, 10527, 15134, 9585, 9585, 22715,
  17167, 14321, 14322, 14322, 10526, 10527, 10685, 9585, 22713, 10240, 14322, 14322, 13274, 10527, 10616, 22711, 14641,
  14322, 13013, 10527, 10618, 15051, 14322, 13013, 10527, 10590, 14316, 17958, 19351, 13105, 14323, 10527, 13544, 17740,
  14117, 13014, 14111, 15611, 15643, 15647, 15490, 12915, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 10710, 9585, 12496, 12492, 17119, 19372, 19438, 19447,
  19463, 19477, 10460, 19506, 9712, 13398, 14902, 21034, 20784, 19543, 19559, 19603, 17499, 12143, 11974, 19692, 17165,
  10483, 13549, 12991, 20662, 12184, 19647, 19666, 15994, 10481, 9585, 19685, 10914, 19624, 19708, 14439, 21453, 21189,
  10527, 17676, 9916, 9585, 22715, 19730, 14321, 19767, 18359, 10526, 19795, 19830, 9585, 22713, 10240, 19846, 14322,
  18430, 10527, 10616, 22711, 14641, 13489, 13013, 10527, 18217, 15051, 19868, 19714, 10527, 10590, 14316, 13011, 10527,
  13105, 14323, 10527, 18048, 19886, 14117, 19932, 14111, 15611, 19967, 19959, 15490, 12915, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 10710, 9585, 20608,
  10770, 12168, 19983, 20025, 20034, 20050, 20064, 20099, 13367, 20108, 20133, 20174, 20200, 20229, 17195, 20265, 20587,
  20290, 9585, 18895, 20324, 17165, 15878, 20354, 20377, 21310, 20395, 10651, 10527, 15994, 20425, 9585, 22715, 17163,
  19624, 14322, 14322, 20543, 10527, 10527, 15134, 9585, 20462, 20479, 20502, 20536, 14858, 14322, 20559, 17359, 20577,
  20603, 20624, 20648, 19167, 14322, 20684, 17613, 20706, 20733, 14641, 14322, 19899, 21678, 20754, 15051, 14322, 13013,
  10527, 14945, 20780, 20800, 21649, 13105, 14323, 10527, 14848, 21553, 14117, 20826, 14809, 20862, 15643, 15647, 15490,
  12915, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 10710, 9585, 17650, 10174, 10761, 10960, 20878, 20893, 20909, 20923, 10460, 12796, 20952, 16858, 20997,
  21030, 21050, 18790, 21066, 14496, 17933, 21082, 19308, 15806, 21100, 12288, 14322, 21116, 13189, 21160, 18019, 21183,
  14469, 10481, 19743, 19043, 21205, 21266, 21298, 14322, 21336, 14778, 21373, 21391, 9585, 21426, 22715, 20338, 14321,
  14322, 21446, 10526, 10527, 22739, 22173, 19066, 19235, 21469, 21514, 16729, 21538, 10616, 21589, 18328, 14322, 21628,
  21644, 13574, 15051, 13874, 21665, 21700, 21722, 21761, 18868, 20274, 13105, 21777, 21806, 13544, 17740, 14117, 13014,
  21836, 21864, 21903, 15647, 16261, 12915, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 10710, 9585, 20608, 10464, 10761, 10960, 21929, 21941, 21957, 21971,
  10460, 20301, 9712, 22709, 17163, 9585, 14320, 13466, 10684, 15290, 17499, 9585, 19034, 17160, 17165, 10483, 14322,
  14322, 22000, 12184, 10527, 10527, 22021, 22063, 12136, 22715, 14957, 19624, 22084, 22121, 22145, 17606, 15163, 15134,
  9585, 22171, 17324, 17167, 13638, 22189, 14322, 15924, 17353, 10685, 9585, 22713, 10240, 14322, 14322, 13274, 10527,
  12887, 22711, 14641, 14322, 22222, 10527, 10618, 15051, 14322, 13013, 10527, 10590, 14316, 13011, 10527, 13105, 19852,
  22422, 13544, 17740, 14117, 13014, 14760, 22251, 15643, 18845, 15490, 12915, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 10710, 9585, 20608, 10464, 10761, 10960,
  12159, 20083, 22284, 22298, 10460, 13367, 9712, 22709, 17163, 9585, 21144, 21139, 22339, 18392, 17499, 9585, 9586,
  18595, 17165, 22361, 22384, 14322, 17207, 22410, 10527, 10527, 15994, 10481, 9585, 22715, 22445, 19624, 21498, 14322,
  20543, 10547, 10527, 15134, 9585, 9585, 22715, 17167, 14321, 14322, 14322, 10526, 10527, 10685, 9585, 22713, 10240,
  14322, 14322, 13274, 10527, 10616, 22711, 14641, 14322, 13013, 10527, 10618, 15051, 14322, 13013, 10527, 10590, 14316,
  13011, 10527, 13105, 14323, 10527, 13544, 17740, 14117, 13014, 14111, 15611, 15643, 15647, 15490, 12915, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 10710,
  9585, 20608, 10464, 10761, 13147, 22487, 22496, 22512, 22526, 10460, 13367, 9712, 22709, 17163, 9585, 14320, 13466,
  10684, 15290, 17499, 9585, 9586, 17160, 17165, 10483, 14322, 14322, 17207, 12184, 10527, 10527, 15994, 10481, 9585,
  22715, 17163, 19624, 14322, 14322, 20543, 10527, 10527, 15134, 9585, 9585, 22715, 17167, 14321, 14322, 14322, 10526,
  10527, 10685, 9585, 22713, 10240, 18960, 14322, 22099, 19808, 22155, 22711, 14641, 14322, 13013, 10527, 10618, 15051,
  14322, 13013, 10527, 10590, 14316, 13011, 10527, 13105, 14323, 10527, 13544, 17740, 14117, 13014, 14111, 15611, 15643,
  15647, 15490, 12915, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 10710, 9585, 20608, 10464, 10761, 10960, 12159, 9418, 22567, 22581, 10460, 13367, 9712, 22709,
  22630, 22914, 21282, 21277, 22683, 19943, 17499, 9443, 22706, 17160, 17165, 10483, 14322, 14322, 17207, 22731, 10527,
  21684, 16185, 10481, 22755, 22715, 17163, 19624, 14322, 14322, 20543, 10527, 10527, 15134, 9585, 9585, 22715, 17167,
  14321, 14322, 14322, 10526, 10527, 10685, 9585, 22713, 10240, 14322, 14322, 13274, 10527, 10616, 22711, 14641, 14322,
  13013, 10527, 10618, 15051, 14322, 13013, 10527, 10590, 14316, 13011, 10527, 13105, 14323, 10527, 13544, 17740, 14117,
  13014, 14111, 15611, 15643, 15647, 15490, 12915, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 10710, 9585, 20608, 10464, 10761, 10960, 12159, 10843, 16249,
  16741, 22775, 13367, 9712, 22709, 17163, 9585, 14320, 14676, 10684, 22826, 17499, 9585, 9586, 17160, 17165, 10483,
  14322, 14322, 17207, 12184, 10527, 10527, 16850, 10481, 9585, 22715, 17163, 19624, 14322, 14322, 20543, 10527, 10527,
  21357, 9585, 18065, 10567, 17167, 22005, 14322, 17398, 13279, 22867, 10685, 9585, 22713, 10240, 14322, 13593, 13274,
  10527, 19356, 22711, 14641, 14322, 13013, 10527, 10618, 15051, 14322, 13013, 10527, 10590, 14316, 13011, 10527, 13105,
  14323, 10527, 13544, 17740, 14117, 13014, 14111, 15611, 15643, 15647, 15490, 12915, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 16115, 9585, 16038, 19587,
  22884, 22930, 22940, 19581, 22895, 22963, 9390, 12762, 10037, 18088, 16526, 9585, 8956, 8801, 8957, 9331, 13356, 8432,
  22759, 11861, 8484, 8500, 8773, 8538, 9022, 8804, 8554, 8570, 8514, 10444, 8598, 8619, 8648, 19518, 8664, 8976, 9169,
  8752, 8673, 8679, 19751, 9585, 12379, 8834, 8695, 11794, 19527, 8723, 8789, 11803, 16401, 8820, 8860, 8928, 8890,
  8919, 8933, 9109, 10090, 8949, 9216, 8974, 9211, 8992, 8446, 9008, 9050, 9066, 8903, 9094, 9146, 9162, 9185, 9201,
  9232, 9261, 12350, 8958, 8976, 8874, 8738, 9282, 9304, 9320, 9347, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 16115, 9585, 9795, 22906, 8603, 10336, 22992,
  23004, 8601, 10299, 9390, 12762, 12455, 18088, 16526, 9585, 8956, 8801, 8957, 9331, 13356, 8432, 22759, 11861, 8484,
  8500, 8773, 8538, 9022, 8804, 8554, 8570, 8514, 10444, 8598, 8619, 8648, 19518, 8664, 8976, 9169, 8752, 8673, 8679,
  19751, 9585, 12379, 8834, 8695, 11794, 19527, 8723, 8789, 11803, 16401, 8820, 8860, 8928, 8890, 8919, 8933, 9109,
  10090, 8949, 9216, 8974, 9211, 8992, 8446, 9008, 9050, 9066, 8903, 9094, 9146, 9162, 9185, 9201, 9232, 9261, 12350,
  8958, 8976, 8874, 8738, 9282, 9304, 9320, 9347, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 16115, 9585, 19131, 9585, 9585, 10325, 23020, 23029, 9585,
  10286, 9390, 12762, 22667, 18088, 16526, 9585, 8956, 8801, 8957, 9331, 13356, 8432, 22759, 11861, 8484, 8500, 8773,
  8538, 9022, 8804, 8554, 8570, 8514, 10444, 8598, 8619, 8648, 19518, 8664, 8976, 9169, 8752, 8673, 8679, 19751, 9585,
  12379, 8834, 8695, 11794, 19527, 8723, 8789, 11803, 16401, 8820, 8860, 8928, 8890, 8919, 8933, 9109, 10090, 8949,
  9216, 8974, 9211, 8992, 8446, 9008, 9050, 9066, 8903, 9094, 9146, 9162, 9185, 9201, 9232, 9261, 12350, 8958, 8976,
  8874, 8738, 9282, 9304, 9320, 9347, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 16115, 9585, 9795, 9585, 9585, 10960, 9584, 9585, 9585, 10869, 10460, 13367,
  9712, 22709, 17163, 9585, 14320, 13466, 10684, 15290, 11700, 9585, 9586, 17160, 17165, 10483, 14322, 14322, 17207,
  10681, 10527, 10527, 15994, 10481, 9585, 22715, 17163, 19624, 14322, 14322, 20543, 10527, 10527, 15134, 9585, 9585,
  22715, 17167, 14321, 14322, 14322, 10526, 10527, 10685, 9585, 22713, 10240, 14322, 14322, 13274, 10527, 10616, 22711,
  14641, 14322, 13013, 10527, 10618, 15051, 14322, 13013, 10527, 10590, 14316, 13011, 10527, 13105, 14323, 10527, 13544,
  17740, 14117, 13014, 14111, 15611, 15643, 15647, 15490, 12915, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 15250, 9585, 23045, 15249, 9585, 9585, 20463,
  9585, 9585, 10441, 16119, 12769, 18088, 16526, 9585, 8956, 8801, 8957, 9331, 12444, 8432, 22759, 11861, 8484, 8500,
  8773, 8538, 9022, 8804, 8554, 8570, 8514, 10444, 8598, 8619, 8648, 19518, 8664, 8976, 9169, 8752, 8673, 8679, 19751,
  9585, 12379, 8834, 8695, 11794, 19527, 8723, 8789, 11803, 16401, 8820, 8860, 8928, 8890, 8919, 8933, 9109, 10090,
  8949, 9216, 8974, 9211, 8992, 8446, 9008, 9050, 9066, 8903, 9094, 9146, 9162, 23063, 9201, 9232, 23079, 9266, 8958,
  8976, 8874, 8738, 9282, 9304, 9320, 9347, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585,
  9585, 9585, 9585, 9585, 9585, 9585, 9585, 9585, 30886, 30886, 0, 0, 32936, 32936, 30886, 30886, 32936, 32936, 32936,
  32936, 32936, 32936, 32936, 32936, 32936, 6145, 0, 3, 4, 0, 0, 0, 32936, 32936, 32936, 32936, 32936, 32936, 32936,
  32936, 32936, 32936, 32936, 32936, 32936, 32936, 32936, 32936, 0, 32936, 32936, 24576, 32936, 32936, 0, 32936, 32936,
  32936, 32936, 32936, 32936, 32936, 32936, 32936, 32936, 32936, 32936, 180, 32936, 32936, 32936, 0, 30886, 0, 32936, 0,
  30886, 32936, 32936, 32936, 32936, 32936, 32936, 0, 32936, 32936, 32936, 32936, 32936, 26624, 28672, 32936, 32936,
  32936, 32936, 32936, 0, 0, 163, 164, 563200, 30886, 0, 32936, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 565, 0, 808960, 0,
  561152, 0, 0, 677888, 0, 0, 0, 534528, 0, 0, 0, 0, 0, 0, 534528, 0, 0, 0, 0, 0, 561152, 561152, 561152, 708608,
  561152, 561152, 561152, 561152, 0, 0, 0, 0, 0, 0, 0, 563526, 672070, 563526, 563526, 563526, 563526, 563526, 563526,
  563526, 563526, 563526, 0, 563668, 672212, 563668, 563668, 563668, 563668, 788480, 561152, 796672, 808960, 561152,
  561152, 561152, 854016, 561152, 561152, 561152, 733184, 749568, 753664, 774144, 782336, 788480, 796672, 854016, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 763904, 563200, 563200, 0, 0, 0, 563200, 563200, 563200, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 734,
  0, 0, 0, 0, 563200, 774144, 782336, 788480, 563200, 563200, 796672, 808960, 563200, 563200, 563200, 563200, 563200,
  563200, 563200, 854016, 563200, 563200, 563200, 749568, 753664, 563200, 759808, 563200, 563200, 774144, 563200,
  782336, 788480, 563200, 563200, 796672, 563200, 808960, 563200, 563200, 563200, 563200, 563200, 563200, 563200,
  563200, 563200, 854016, 563200, 563200, 563200, 563200, 563200, 0, 0, 563200, 563200, 563200, 563200, 563200, 0,
  563200, 116736, 0, 0, 0, 536576, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 356352, 0, 0, 0, 745472, 786432, 0, 0, 0,
  671744, 671744, 561152, 561152, 561152, 561152, 561152, 716800, 561152, 561152, 561152, 561152, 561152, 561152,
  561152, 561152, 561152, 561152, 561152, 561152, 561152, 55296, 118784, 126976, 745472, 561152, 561152, 561152, 786432,
  790528, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 716800, 0, 790528, 716800, 563200, 563200, 563200,
  563200, 563200, 563200, 745472, 563200, 563200, 563200, 563200, 563200, 786432, 790528, 563200, 563200, 563200,
  563200, 563200, 563200, 563200, 563200, 563200, 563200, 0, 0, 563200, 563200, 688128, 0, 690176, 563200, 563200,
  688128, 690176, 563200, 563200, 563200, 563200, 563200, 563200, 724992, 563200, 563200, 563200, 563200, 563200, 0, 0,
  563200, 563200, 563200, 563200, 563200, 0, 563200, 118784, 0, 563200, 563200, 563200, 563200, 688128, 690176, 563200,
  563200, 563200, 563200, 563200, 563200, 563200, 563200, 724992, 563200, 563200, 563200, 563200, 563200, 837632,
  563200, 563200, 563200, 563200, 729088, 563200, 563200, 837632, 563200, 563200, 563200, 563200, 563200, 716800,
  563200, 563200, 563200, 563200, 563200, 563200, 563200, 745472, 563200, 563200, 0, 51200, 563200, 563200, 563200,
  563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 733184, 563200, 563200, 563200, 749568, 753664,
  563200, 563200, 563200, 563200, 563200, 757760, 563200, 563200, 563200, 563200, 776192, 563200, 563200, 802816,
  563200, 563200, 563200, 563200, 563200, 0, 0, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200,
  563200, 563200, 733184, 0, 0, 0, 727040, 0, 0, 872448, 0, 561152, 561152, 561152, 561152, 561152, 727040, 561152,
  561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 757760, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6145, 0, 569500, 4,
  0, 71680, 0, 561152, 811008, 561152, 561152, 561152, 856064, 862208, 872448, 862208, 0, 0, 0, 856064, 0, 563200,
  563200, 0, 563200, 563200, 563200, 563200, 720896, 563200, 563200, 563200, 563200, 563200, 563200, 720896, 563200,
  563200, 811008, 817152, 563200, 563200, 563200, 563200, 563200, 856064, 862208, 563200, 563200, 872448, 563200,
  563200, 563200, 0, 0, 0, 751616, 0, 0, 0, 0, 0, 561152, 692224, 561152, 561152, 563200, 563200, 727040, 563200,
  563200, 563200, 563200, 563200, 563200, 563200, 694272, 563200, 563200, 563200, 563200, 563200, 727040, 735232,
  563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 811008, 817152, 563200, 563200, 561152, 561152,
  829440, 561152, 843776, 737280, 0, 0, 0, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200,
  563200, 563200, 563200, 563200, 563200, 563200, 0, 563200, 874496, 563200, 563200, 563200, 563200, 563200, 563200,
  563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 829440, 563200,
  563200, 843776, 563200, 563200, 563200, 874496, 0, 0, 0, 708608, 0, 722944, 563200, 563200, 563200, 563200, 706560,
  708608, 563200, 563200, 563200, 765952, 563200, 563200, 563200, 813056, 563200, 563200, 563200, 563200, 563200, 0,
  563200, 563200, 563200, 563200, 563200, 759808, 563200, 563200, 563200, 563200, 563200, 0, 0, 563200, 563200, 563200,
  563200, 563200, 0, 563200, 0, 90112, 563200, 563200, 563200, 698368, 563200, 722944, 563200, 563200, 563200, 563200,
  563200, 563200, 563200, 563200, 563200, 698368, 706560, 708608, 563200, 563200, 722944, 563200, 563200, 765952,
  563200, 563200, 563200, 813056, 563200, 563200, 563200, 563200, 563200, 0, 517, 563200, 563200, 563200, 563200,
  563200, 0, 563200, 517, 0, 770048, 561152, 561152, 0, 770048, 692224, 667648, 563200, 692224, 563200, 563200, 563200,
  718848, 563200, 770048, 563200, 563200, 563200, 563200, 563200, 856064, 563200, 862208, 563200, 563200, 872448,
  563200, 0, 0, 829440, 0, 0, 0, 0, 742, 0, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 760, 221, 0, 0, 0,
  563200, 563200, 563200, 563200, 866304, 563200, 718848, 563200, 563200, 563200, 563200, 563200, 667648, 563200,
  563200, 692224, 563200, 563200, 563200, 718848, 563200, 563200, 770048, 563200, 563200, 563200, 563200, 563200,
  563200, 563200, 563200, 563200, 0, 563200, 671744, 563200, 563200, 563200, 563200, 866304, 831488, 0, 696320, 675840,
  0, 1223, 675840, 696320, 561152, 772096, 831488, 772096, 563200, 675840, 696320, 563200, 563200, 741376, 772096,
  794624, 821248, 831488, 864256, 679936, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 737280, 563200,
  761856, 563200, 563200, 563200, 792576, 563200, 563200, 819200, 563200, 829440, 563200, 843776, 563200, 675840,
  679936, 696320, 563200, 563200, 563200, 563200, 741376, 772096, 794624, 821248, 563200, 831488, 563200, 563200,
  563200, 0, 0, 0, 751616, 0, 0, 0, 0, 1223, 561152, 692224, 561152, 561152, 864256, 0, 714752, 1223, 714752, 563200,
  710656, 714752, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 860160, 0, 0, 563200, 563200, 563200, 729088,
  563200, 563200, 563200, 563200, 837632, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200,
  563200, 0, 0, 563200, 563200, 688128, 163, 563200, 563200, 669696, 563200, 563200, 563200, 563200, 835584, 669696,
  563200, 563200, 563200, 563200, 835584, 563200, 743424, 823296, 563200, 563200, 743424, 823296, 563200, 712704,
  563200, 712704, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 0, 0, 563200, 563200, 563200, 563200, 563200,
  0, 563200, 0, 0, 827392, 827392, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 141312, 24576, 0, 0, 0, 0, 0, 0, 238, 0,
  238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 0, 238, 0, 0, 0, 163, 164, 563200, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 163, 0, 0, 0, 0, 0, 57344, 0, 0, 163, 57344, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 221, 277, 0, 277,
  24576, 0, 0, 0, 0, 0, 0, 0, 163, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 543, 0, 0, 0, 0, 0, 163, 163, 163, 163, 163, 0, 163, 0,
  163, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 30886, 30886, 0, 0, 14658, 164, 563200, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 164, 0, 0, 0, 0, 163, 0, 0, 0, 0, 673792, 686080, 0, 763904, 804864, 0, 0, 0, 180, 180, 180, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 344, 6145, 0, 569500, 4, 158, 0, 0, 0, 0, 0, 0, 0, 0, 0, 158, 0, 0, 0, 0, 767, 0, 0, 165, 165, 165, 165,
  165, 165, 165, 777, 165, 165, 165, 165, 165, 545, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 290, 290, 290,
  290, 1201, 290, 24576, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 221, 0, 0, 522, 526, 0, 0, 673792, 686080, 0,
  763904, 804864, 0, 0, 0, 180, 180, 180, 0, 0, 0, 0, 0, 0, 0, 0, 343, 0, 0, 0, 0, 0, 0, 350, 547, 0, 0, 0, 677888, 0,
  0, 0, 534528, 0, 0, 0, 0, 0, 0, 534528, 0, 548, 6145, 0, 3, 4, 0, 65536, 0, 0, 0, 0, 0, 0, 0, 65536, 0, 0, 0, 65536,
  0, 65536, 0, 0, 0, 0, 65536, 65536, 65536, 65536, 65536, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 201, 0, 0, 0, 201, 0, 0,
  0, 0, 0, 65536, 0, 0, 0, 0, 0, 26624, 28672, 0, 0, 0, 0, 0, 0, 0, 0, 201, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 882, 0, 0, 0,
  0, 0, 0, 221, 221, 221, 221, 221, 221, 221, 221, 895, 221, 65536, 65536, 65536, 65536, 65536, 0, 65536, 0, 65536,
  6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 163, 163, 0, 0, 205, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 550, 0, 0,
  323, 324, 563200, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 180, 0, 0, 0, 0, 0, 67584, 0, 0, 164, 67584, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 537, 0, 0, 221, 24576, 0, 0, 0, 0, 0, 0, 0, 164, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 597, 0, 0, 0, 165,
  165, 164, 164, 164, 164, 164, 0, 164, 0, 164, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 124928, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 163, 14661, 563200, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 180, 163, 163, 163, 6145, 0, 3, 4, 0, 0, 159, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 870, 871, 0, 0, 24576, 169, 169, 0, 169, 69801, 169, 169, 169, 169, 169, 169, 169, 169, 169,
  169, 169, 169, 169, 169, 169, 169, 181, 169, 69801, 169, 69801, 69816, 69816, 69816, 69816, 69801, 69816, 69801,
  69801, 6145, 0, 3, 4, 0, 0, 0, 0, 122880, 0, 0, 0, 0, 0, 0, 122880, 0, 0, 0, 567631, 567631, 180, 0, 0, 0, 0, 0, 0, 0,
  0, 532480, 0, 0, 0, 0, 877, 0, 0, 0, 0, 0, 882, 0, 0, 0, 0, 0, 0, 0, 165, 165, 165, 165, 774, 775, 776, 165, 165, 0,
  0, 75776, 0, 0, 0, 0, 0, 0, 75776, 75776, 75776, 0, 0, 0, 0, 0, 0, 0, 532480, 201, 0, 0, 0, 0, 354304, 0, 0, 24576,
  75776, 75776, 0, 0, 0, 0, 75776, 75776, 75776, 75776, 75776, 75776, 75776, 75776, 75776, 75776, 75776, 75776, 75776,
  0, 75776, 0, 0, 0, 75776, 0, 0, 75776, 75776, 75776, 75776, 6145, 0, 0, 4, 59392, 0, 0, 0, 0, 0, 845824, 843776, 0, 0,
  0, 561152, 561152, 561152, 561152, 561152, 737280, 24576, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 77824, 77824, 77824, 77824,
  77824, 79872, 77824, 79872, 77824, 77824, 77824, 77824, 77824, 77824, 0, 77824, 0, 0, 0, 51489, 0, 0, 0, 0, 0, 51489,
  0, 0, 77824, 0, 0, 51489, 51489, 51489, 51489, 51489, 77824, 51489, 77824, 51489, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0,
  176, 177, 0, 0, 0, 0, 180, 165, 0, 0, 0, 183, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 182, 0, 0, 0, 24576, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 81920, 81920, 81920, 81920, 81920, 81920, 81920, 81920, 6145, 0, 3, 4, 0, 0, 0, 81920, 81920, 81920,
  81920, 83968, 81920, 83968, 81920, 81920, 81920, 81920, 81920, 81920, 0, 81920, 0, 0, 0, 0, 1164, 221, 221, 221, 221,
  221, 221, 221, 221, 0, 0, 0, 0, 0, 0, 165, 165, 0, 0, 677888, 0, 0, 0, 534528, 0, 0, 0, 0, 0, 0, 534528, 546, 0, 0, 0,
  0, 86016, 86016, 86016, 0, 86016, 26624, 28672, 86016, 0, 0, 86016, 0, 0, 0, 0, 358400, 358400, 0, 358400, 358400,
  6145, 0, 3, 4, 0, 0, 0, 0, 0, 356352, 0, 356352, 356352, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 139264, 0, 139264, 139264,
  6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 358400, 0, 0, 207, 207, 0, 0, 0, 0, 0, 0, 0, 356352, 0, 26624, 28672, 0, 0, 356352,
  0, 356352, 24576, 86016, 86016, 0, 0, 0, 0, 86016, 0, 86016, 86016, 86016, 86016, 86016, 86016, 86016, 86016, 86016,
  86016, 86016, 86016, 86016, 0, 86016, 0, 154, 0, 3, 4, 0, 0, 0, 160, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 738, 0, 357, 0,
  0, 24576, 0, 0, 0, 0, 0, 0, 0, 0, 0, 88064, 88064, 88064, 88064, 88064, 88064, 88064, 88064, 0, 41115, 3, 4, 0, 0,
  320, 88064, 88064, 88064, 88064, 88064, 88064, 88064, 88064, 88064, 88064, 88064, 88064, 88064, 0, 88064, 0, 0, 0, 0,
  563200, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 780288, 0, 0, 0, 163, 164, 165, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 551, 0, 530, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 165, 165, 0, 0, 0, 112640, 0, 0, 221, 221, 221, 221, 221,
  221, 221, 221, 221, 221, 221, 221, 578, 221, 221, 221, 165, 165, 1047, 165, 165, 165, 290, 290, 290, 290, 290, 290,
  290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 837, 290, 290, 1062, 290, 290, 290, 290, 290, 290, 290, 290, 290,
  290, 290, 290, 290, 290, 836, 290, 0, 0, 0, 1089, 0, 0, 0, 0, 0, 0, 221, 221, 221, 221, 221, 221, 221, 894, 221, 221,
  290, 290, 290, 290, 1152, 290, 290, 290, 290, 290, 0, 0, 0, 0, 0, 0, 0, 0, 0, 221, 221, 221, 221, 221, 748, 221, 221,
  221, 221, 290, 290, 290, 1254, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 0, 0, 0, 0, 0, 0, 165, 165,
  1273, 165, 165, 1274, 165, 165, 165, 165, 165, 165, 165, 165, 165, 290, 1052, 290, 290, 290, 290, 290, 290, 290, 290,
  674, 290, 290, 290, 290, 290, 290, 290, 290, 1304, 290, 290, 290, 290, 290, 1309, 290, 290, 290, 0, 1223, 1313, 165,
  165, 0, 0, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 0, 92477, 92477, 92477, 92477,
  92477, 0, 92477, 0, 92477, 6145, 41115, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 165, 0, 0, 0, 0, 0, 0, 96459, 0, 96459, 0,
  96459, 96459, 96459, 96459, 96459, 96459, 0, 96459, 0, 0, 0, 163, 0, 0, 0, 0, 0, 57548, 28672, 0, 0, 0, 0, 0, 0, 0, 0,
  191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 165, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 185, 0, 0, 0, 96459, 96459, 96459, 96459,
  96459, 96459, 96459, 0, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 221, 743, 744, 221, 221, 221, 221, 749, 221, 751, 200, 200,
  200, 200, 200, 0, 200, 0, 200, 6145, 41115, 3, 4, 0, 0, 0, 0, 0, 0, 0, 162, 165, 0, 0, 0, 0, 0, 553, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 221, 165, 0, 165, 0, 547, 547, 730, 0, 0, 0, 0, 553, 737, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6145, 41115, 3,
  4, 0, 0, 0, 866, 0, 0, 0, 0, 710, 868, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 883, 0, 550, 0, 737, 0, 0, 0, 0, 0, 221,
  221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 761, 0, 0, 0, 0, 866, 0, 868, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 170, 171, 0, 0, 0, 163, 164, 563526, 0, 0, 0, 73728, 104448, 0, 0, 0, 0, 0, 0, 0, 0, 0, 26624, 28672, 0, 0, 0,
  0, 0, 467, 563668, 563668, 563668, 563668, 563668, 563668, 563668, 563668, 563668, 563668, 563668, 563668, 563668,
  563668, 563668, 0, 0, 563526, 563668, 688128, 0, 788480, 796672, 854016, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 763904, 563526,
  563526, 0, 0, 563668, 563668, 563668, 563668, 563668, 563668, 563668, 563668, 563668, 563668, 563668, 733652, 563526,
  774470, 782662, 788806, 563526, 563526, 796998, 809286, 563526, 563526, 563526, 563526, 563526, 563526, 563526,
  854342, 563668, 809428, 563668, 563668, 563668, 563668, 563668, 563668, 563668, 563668, 563668, 854484, 563668,
  563668, 563668, 563668, 786900, 790996, 563668, 563668, 563668, 563668, 563668, 563668, 563668, 563668, 563668,
  563668, 737748, 563668, 762324, 563668, 563668, 563668, 793044, 563668, 563668, 819668, 717126, 563526, 563526,
  563526, 563526, 563526, 563526, 745798, 563526, 563526, 563526, 563526, 563526, 786758, 790854, 563526, 563526,
  563526, 698694, 563526, 723270, 563526, 563526, 563526, 563526, 563668, 563668, 563668, 563668, 563668, 698836,
  690176, 563526, 563526, 688454, 690502, 563526, 563526, 563526, 563526, 563526, 563526, 725318, 563526, 563526,
  563526, 563526, 563526, 0, 563526, 563526, 563526, 563526, 563526, 760134, 563526, 563526, 563526, 563526, 563526, 0,
  0, 563526, 563526, 563526, 563526, 563526, 563526, 563526, 563526, 563526, 563526, 563526, 563526, 563526, 563526,
  563526, 563526, 758086, 563526, 563526, 563526, 563526, 563526, 563526, 563526, 563526, 563526, 563526, 563526,
  563526, 840006, 842054, 563526, 563526, 727366, 563526, 563526, 563526, 563668, 563668, 563668, 563668, 694740,
  563668, 563668, 563668, 563668, 563668, 717268, 563668, 563668, 563668, 563668, 563668, 563668, 563668, 745940,
  563668, 563668, 561152, 811008, 561152, 561152, 561152, 856064, 862208, 872448, 862208, 0, 0, 0, 856064, 0, 563526,
  563526, 563526, 563526, 866630, 563526, 719174, 563526, 563526, 563526, 563526, 563526, 668116, 563668, 563668,
  692692, 563526, 811334, 817478, 563526, 563526, 563526, 563526, 563526, 856390, 862534, 563526, 563526, 872774,
  563526, 563526, 563526, 563526, 563526, 563526, 563526, 563526, 733510, 563526, 563526, 563526, 749894, 753990,
  563526, 563526, 563668, 563668, 727508, 735700, 563668, 563668, 563668, 563668, 563668, 563668, 563668, 563668,
  811476, 817620, 563668, 563668, 0, 0, 0, 563526, 563668, 563668, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86016, 0, 0, 86016,
  0, 561152, 561152, 829440, 561152, 843776, 737280, 0, 0, 0, 563526, 563526, 563526, 563526, 563526, 563526, 563526,
  563526, 563526, 563668, 563668, 563668, 563668, 563668, 563668, 563668, 563668, 563668, 0, 563526, 737606, 563526,
  762182, 563526, 563526, 563526, 792902, 563526, 563526, 819526, 563526, 829766, 563526, 844102, 563526, 563526,
  741702, 772422, 794950, 821574, 831814, 864582, 680262, 563526, 563526, 563526, 563526, 563526, 563526, 563668,
  563668, 563668, 688596, 690644, 563668, 563668, 563668, 563668, 563668, 563668, 563668, 563668, 725460, 563668,
  563526, 874822, 563526, 563526, 563526, 563526, 563526, 563526, 563526, 563526, 563668, 563668, 563668, 563668,
  563668, 563668, 837632, 563526, 563526, 563526, 563526, 729414, 563526, 563526, 837958, 563668, 563668, 563668,
  563668, 829908, 563668, 563668, 844244, 563668, 563668, 563668, 874964, 0, 0, 0, 708608, 0, 722944, 707028, 709076,
  563668, 563668, 723412, 563668, 563668, 766420, 563668, 563668, 563668, 813524, 563668, 563668, 563668, 563668, 0, 0,
  0, 751616, 0, 0, 0, 0, 0, 561152, 692224, 561152, 561152, 770048, 561152, 561152, 0, 770048, 692224, 667974, 563526,
  692550, 563526, 563526, 563526, 719174, 563526, 770374, 563526, 694598, 563526, 563526, 563526, 563526, 563526,
  727366, 735558, 563526, 563526, 563526, 563526, 563526, 563526, 563526, 563526, 563526, 563526, 563526, 776518,
  803142, 563526, 563526, 850246, 866772, 831488, 0, 696320, 675840, 0, 1223, 675840, 696320, 561152, 772096, 831488,
  772096, 563526, 676166, 696646, 676308, 680404, 696788, 563668, 563668, 563668, 563668, 741844, 772564, 795092,
  821716, 563668, 831956, 563668, 563668, 563668, 719316, 563668, 563668, 770516, 563668, 563668, 563668, 563668,
  563668, 563668, 563668, 563668, 563668, 856532, 563668, 862676, 563668, 563668, 872916, 563668, 0, 0, 829440, 0,
  864724, 0, 714752, 1223, 714752, 563526, 710982, 715078, 563526, 563526, 563526, 563526, 563526, 563526, 563526,
  860486, 563668, 711124, 715220, 563668, 563668, 563668, 563668, 563668, 563668, 563668, 860628, 0, 1223, 563526,
  563526, 563526, 563526, 706886, 708934, 563526, 563526, 563526, 766278, 563526, 563526, 563526, 813382, 563526,
  563526, 729556, 563668, 563668, 563668, 563668, 838100, 563526, 563526, 563526, 563526, 563526, 563526, 563668,
  563668, 563668, 563668, 750036, 754132, 563668, 760276, 563668, 563668, 774612, 563668, 782804, 788948, 563668,
  563668, 797140, 563668, 563668, 670022, 563526, 563526, 563526, 563526, 835910, 670164, 563668, 563668, 563668,
  563668, 836052, 563526, 743750, 823622, 563526, 563668, 743892, 823764, 563668, 713030, 563526, 713172, 563668,
  563526, 563668, 563526, 563668, 563526, 563668, 563668, 0, 563526, 563526, 563526, 563526, 721222, 563526, 563526,
  563526, 563526, 563668, 563668, 721364, 563668, 563668, 563668, 758228, 563668, 563668, 563668, 563668, 776660,
  563668, 563668, 803284, 563668, 563668, 563668, 563668, 840148, 842196, 563668, 850388, 563668, 563668, 563668,
  563668, 563668, 563668, 563668, 0, 0, 563526, 563526, 563526, 563668, 563668, 0, 563668, 0, 0, 827718, 827860, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 180, 180, 24576, 108544, 108544, 0, 0, 0, 0, 108544, 0, 108544, 108544, 108544,
  108544, 108544, 108544, 108544, 108544, 108544, 108544, 108544, 108544, 108544, 0, 108544, 0, 0, 0, 536576, 0, 0, 0,
  0, 0, 34816, 0, 0, 0, 18432, 0, 0, 0, 0, 0, 0, 350, 200, 201, 0, 0, 0, 0, 0, 0, 0, 0, 0, 165, 0, 0, 0, 192, 0, 0,
  34816, 0, 0, 0, 0, 0, 561152, 688128, 690176, 561152, 561152, 561152, 724992, 561152, 561152, 757760, 563200, 563200,
  563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 839680, 841728, 563200, 849920,
  563200, 563200, 563200, 563200, 563200, 563200, 563200, 0, 0, 163, 0, 164, 0, 811008, 0, 0, 0, 0, 0, 784384, 0, 0, 0,
  0, 0, 0, 0, 532480, 201, 0, 0, 0, 355, 0, 0, 0, 0, 201, 0, 727040, 0, 0, 872448, 0, 561152, 561152, 561152, 561152,
  561152, 727040, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 733184, 561152, 561152, 749568, 753664,
  561152, 561152, 774144, 782336, 110806, 0, 0, 0, 0, 0, 0, 110831, 0, 110831, 110831, 110831, 110831, 110831, 110831,
  110831, 110831, 110831, 110831, 110831, 110831, 110831, 0, 110831, 0, 110903, 110903, 110903, 110903, 110903, 110831,
  110903, 110831, 110911, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 404, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 141312, 0, 0, 0,
  24576, 0, 0, 0, 0, 0, 0, 122880, 0, 122880, 122880, 122880, 122880, 122880, 122880, 122880, 122880, 122880, 122880,
  122880, 122880, 122880, 0, 122880, 0, 0, 0, 163, 164, 563200, 0, 0, 0, 0, 0, 106496, 0, 0, 0, 0, 0, 0, 0, 0, 561, 0,
  0, 0, 0, 0, 0, 221, 221, 221, 746, 221, 221, 221, 221, 221, 221, 124928, 0, 0, 124928, 0, 0, 0, 124928, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 131072, 0, 0, 0, 0, 24576, 0, 0, 0, 0, 0, 0, 125168, 0, 125168, 125168, 125168, 125168, 125168,
  125168, 125168, 125168, 125168, 125168, 125168, 125168, 125168, 0, 125168, 0, 133120, 0, 163, 164, 563200, 0, 100352,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86016, 0, 0, 0, 563200, 710656, 714752, 563200, 563200, 563200, 563200, 563200,
  563200, 563200, 860160, 0, 49152, 563200, 563200, 563200, 563200, 563200, 0, 120832, 563200, 563200, 563200, 563200,
  563200, 0, 563200, 120832, 0, 0, 131072, 0, 0, 131072, 0, 131072, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 92359, 0, 0, 0,
  135168, 135168, 135168, 135168, 135168, 0, 135168, 0, 135168, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 735, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 544, 0, 0, 0, 0, 24576, 0, 0, 221, 221, 221, 221, 0, 221, 0, 0, 0, 0, 0, 0, 0, 0, 0, 165, 0, 0, 0, 193,
  0, 0, 165, 165, 51850, 530, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 0, 0, 0, 1085, 866, 0, 0, 0,
  0, 0, 868, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 108544, 0, 0, 0, 108544, 0, 737, 0, 0, 0, 0, 888, 221, 221, 221, 221,
  221, 221, 221, 221, 221, 221, 759, 221, 221, 0, 0, 0, 0, 139264, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 180, 0, 0, 0, 0, 0, 0,
  991, 0, 0, 0, 0, 0, 995, 0, 0, 0, 0, 0, 0, 139264, 0, 0, 26624, 28672, 0, 0, 0, 0, 0, 0, 0, 0, 595, 595, 0, 0, 0, 595,
  165, 165, 24576, 139264, 139264, 0, 0, 0, 0, 139264, 0, 139264, 139264, 139264, 139264, 139264, 139264, 139264,
  139264, 139264, 139264, 139264, 139264, 139264, 0, 139264, 0, 866304, 831488, 0, 696320, 675840, 0, 1268, 675840,
  696320, 561152, 772096, 831488, 772096, 563200, 675840, 696320, 864256, 0, 714752, 1293, 714752, 563200, 710656,
  714752, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 860160, 0, 1223, 563200, 563200, 563200, 141312,
  141312, 141312, 141312, 141312, 0, 141312, 0, 141312, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 561152, 688128, 690176, 561152,
  561152, 561152, 724992, 561152, 561152, 757760, 0, 0, 0, 201, 0, 0, 0, 0, 0, 26624, 28672, 0, 0, 0, 0, 0, 0, 0, 0,
  881, 0, 0, 0, 0, 0, 0, 0, 0, 0, 737, 0, 0, 0, 0, 0, 0, 201, 201, 201, 201, 201, 0, 201, 0, 201, 6145, 0, 3, 4, 0, 0,
  0, 0, 0, 0, 673792, 686080, 0, 763904, 804864, 0, 0, 0, 0, 0, 0, 0, 532480, 201, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  808960, 0, 561152, 0, 0, 172, 0, 0, 0, 0, 0, 0, 0, 0, 0, 180, 165, 0, 0, 178, 0, 0, 0, 0, 0, 0, 0, 0, 178, 0, 0, 0,
  180, 165, 0, 0, 172, 172, 186, 0, 0, 0, 0, 0, 0, 165, 0, 0, 0, 0, 0, 195, 24576, 209, 220, 222, 222, 222, 222, 220,
  222, 220, 220, 220, 220, 220, 220, 220, 257, 220, 257, 220, 220, 220, 220, 220, 222, 259, 220, 259, 280, 280, 291,
  280, 280, 280, 280, 280, 291, 280, 280, 280, 280, 280, 291, 291, 291, 291, 291, 280, 291, 280, 291, 6145, 41115, 3, 4,
  0, 0, 0, 0, 0, 0, 673792, 686080, 0, 763904, 804864, 0, 0, 0, 0, 567632, 73728, 567632, 0, 73728, 0, 0, 0, 0, 0, 0,
  532480, 0, 0, 321, 163, 164, 165, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 172, 0, 0, 0, 347, 0, 0, 0, 0, 201, 0, 0,
  0, 356, 0, 0, 0, 0, 0, 0, 673792, 686080, 0, 763904, 804864, 0, 0, 0, 180, 0, 0, 0, 165, 417, 165, 165, 165, 165, 165,
  165, 165, 438, 165, 441, 165, 444, 165, 165, 451, 165, 165, 347, 338, 165, 417, 165, 165, 165, 438, 441, 444, 165,
  165, 165, 165, 165, 624, 165, 165, 165, 165, 165, 165, 165, 631, 165, 165, 165, 165, 165, 400, 0, 165, 165, 420, 165,
  165, 439, 165, 445, 465, 0, 290, 290, 472, 290, 290, 290, 290, 290, 290, 290, 495, 290, 499, 290, 502, 290, 290, 512,
  290, 290, 0, 0, 417, 165, 165, 290, 290, 0, 472, 0, 0, 0, 0, 164, 0, 673792, 686080, 0, 763904, 804864, 0, 0, 0, 180,
  180, 180, 0, 0, 0, 0, 0, 0, 0, 0, 532480, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 523, 527, 0, 530, 0, 0, 0, 0, 0, 0, 0, 0, 180,
  180, 180, 0, 0, 0, 339, 0, 0, 0, 0, 0, 0, 0, 0, 190, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 65536, 0, 0, 0, 0, 0, 0, 0, 530, 0,
  0, 0, 0, 0, 0, 722, 723, 0, 0, 0, 0, 0, 0, 0, 0, 0, 26624, 28672, 0, 0, 137216, 0, 137216, 165, 793, 165, 165, 165,
  165, 165, 165, 801, 165, 165, 165, 165, 165, 165, 165, 612, 165, 165, 165, 165, 165, 165, 165, 618, 290, 290, 290,
  827, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 0, 1084, 0, 0, 290, 290, 290, 857, 290, 290, 290,
  290, 290, 290, 0, 0, 165, 290, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 171, 171, 737, 0, 0, 0, 0, 0, 221, 221, 890,
  891, 221, 221, 221, 221, 221, 221, 221, 221, 904, 0, 0, 0, 0, 0, 0, 0, 0, 0, 542, 0, 0, 0, 0, 0, 550, 896, 221, 221,
  221, 221, 221, 221, 221, 221, 0, 0, 0, 0, 908, 0, 910, 165, 165, 165, 913, 165, 915, 916, 165, 165, 165, 165, 165,
  165, 165, 165, 626, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 926, 165, 165, 165, 165, 165, 165, 165, 165,
  165, 165, 165, 165, 290, 290, 290, 290, 290, 290, 290, 990, 866, 0, 868, 0, 0, 0, 0, 0, 0, 0, 0, 0, 996, 0, 0, 0, 0,
  169, 169, 0, 0, 169, 169, 69801, 169, 169, 169, 169, 169, 0, 169, 169, 169, 169, 169, 26624, 28672, 169, 169, 169,
  169, 69801, 165, 165, 165, 165, 1049, 165, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 961, 290, 290, 290,
  290, 290, 290, 1077, 290, 290, 290, 290, 290, 1081, 290, 290, 0, 0, 0, 0, 0, 1223, 221, 221, 221, 221, 221, 0, 165,
  165, 165, 290, 290, 1202, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 1213, 729, 0, 0, 0, 0, 0, 0, 0,
  0, 737, 0, 0, 0, 0, 0, 0, 0, 0, 0, 26624, 28672, 0, 213, 0, 213, 0, 290, 855, 290, 290, 290, 290, 290, 290, 290, 290,
  0, 0, 165, 290, 0, 0, 0, 0, 1267, 1223, 221, 221, 1269, 221, 221, 0, 165, 165, 165, 165, 165, 0, 639, 165, 165, 165,
  165, 165, 165, 165, 165, 165, 51850, 290, 290, 290, 290, 290, 823, 1020, 165, 165, 165, 165, 165, 165, 165, 165, 165,
  165, 165, 165, 165, 165, 165, 808, 165, 165, 1334, 1335, 165, 165, 165, 1339, 165, 290, 290, 290, 290, 1345, 1346,
  290, 290, 0, 0, 564, 165, 290, 290, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 75776, 0, 0, 0, 0, 1348, 290, 0, 165, 165, 165,
  165, 165, 165, 165, 165, 165, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 963, 24576, 215,
  215, 223, 223, 223, 223, 215, 223, 215, 215, 215, 215, 215, 215, 215, 255, 255, 256, 256, 215, 256, 215, 256, 256,
  256, 256, 256, 223, 260, 256, 260, 281, 281, 292, 281, 281, 281, 281, 281, 292, 281, 281, 281, 312, 281, 292, 292,
  318, 318, 318, 318, 318, 281, 318, 281, 318, 6145, 41115, 3, 4, 0, 0, 0, 0, 0, 0, 673792, 686080, 0, 763904, 804864,
  0, 0, 0, 180, 180, 180, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 221, 221, 221, 373, 345, 0, 0, 0, 0, 0, 0, 0, 201, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 366, 0, 0, 221, 221, 221, 221, 0, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290,
  290, 290, 503, 568, 221, 221, 221, 221, 221, 221, 221, 576, 221, 221, 221, 221, 221, 221, 221, 221, 587, 221, 589, 0,
  0, 0, 0, 0, 165, 165, 165, 606, 165, 610, 165, 165, 165, 165, 614, 165, 165, 165, 165, 165, 0, 0, 165, 165, 165, 165,
  165, 165, 165, 165, 165, 919, 165, 165, 165, 165, 165, 619, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165,
  165, 165, 165, 165, 1121, 165, 165, 51850, 530, 651, 653, 290, 290, 290, 290, 659, 290, 663, 290, 290, 290, 290, 290,
  290, 1379, 165, 165, 165, 165, 165, 1385, 290, 290, 290, 290, 290, 515, 0, 165, 165, 165, 290, 290, 0, 290, 0, 0,
  1223, 221, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 616, 165, 165, 165, 165, 290, 668, 290, 290, 290,
  290, 290, 290, 673, 290, 290, 290, 290, 290, 290, 290, 290, 1155, 290, 0, 0, 0, 0, 1159, 0, 165, 165, 795, 165, 165,
  165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 1042, 165, 165, 290, 290, 290, 290, 828, 290, 290, 290, 290,
  290, 290, 290, 290, 290, 290, 290, 0, 1223, 165, 165, 1315, 1099, 221, 221, 221, 221, 0, 0, 1103, 0, 165, 165, 165,
  165, 165, 165, 165, 917, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 1115, 165, 165, 165, 165, 165,
  165, 165, 165, 165, 165, 290, 290, 290, 1134, 290, 290, 165, 165, 165, 165, 165, 1337, 165, 165, 165, 290, 290, 290,
  1344, 290, 290, 290, 290, 290, 516, 0, 165, 165, 165, 231910, 290, 0, 290, 0, 0, 1223, 221, 165, 165, 165, 165, 165,
  165, 1299, 165, 165, 165, 165, 165, 0, 0, 165, 165, 165, 458, 165, 165, 165, 165, 165, 0, 0, 165, 165, 165, 165, 431,
  165, 165, 165, 165, 165, 1400, 290, 290, 290, 1402, 165, 165, 290, 290, 165, 290, 165, 290, 165, 290, 952, 290, 290,
  290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 1264, 290, 24576, 216, 216, 224, 224, 224, 224, 216, 224,
  216, 216, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 224, 261, 247, 261, 282, 282, 293, 282, 282,
  282, 282, 282, 293, 282, 282, 282, 261, 282, 293, 293, 293, 293, 293, 282, 293, 282, 293, 6145, 41115, 3, 4, 0, 0, 0,
  0, 0, 0, 673792, 686080, 0, 763904, 804864, 0, 0, 0, 567631, 180, 221, 221, 221, 381, 221, 221, 221, 221, 221, 221,
  221, 221, 221, 0, 0, 0, 0, 0, 0, 165, 1019, 0, 405, 165, 165, 165, 165, 165, 165, 431, 165, 165, 165, 165, 165, 165,
  165, 1181, 165, 165, 165, 165, 165, 165, 165, 165, 1194, 165, 290, 290, 290, 290, 290, 290, 0, 290, 290, 290, 290,
  290, 290, 290, 486, 290, 290, 290, 290, 290, 290, 290, 290, 1258, 290, 290, 290, 290, 290, 290, 290, 672, 290, 290,
  290, 290, 290, 290, 290, 290, 831, 290, 290, 834, 290, 290, 290, 290, 221, 582, 221, 583, 221, 221, 221, 221, 221,
  221, 221, 0, 0, 0, 0, 0, 0, 0, 0, 135168, 0, 0, 0, 0, 0, 135168, 135168, 165, 165, 165, 165, 623, 165, 165, 625, 165,
  165, 165, 165, 165, 165, 165, 165, 931, 165, 165, 165, 165, 165, 165, 165, 165, 165, 51850, 530, 652, 290, 290, 290,
  290, 290, 290, 290, 290, 290, 290, 290, 985, 986, 290, 290, 0, 680, 681, 290, 290, 290, 290, 290, 290, 290, 290, 290,
  290, 290, 290, 290, 290, 290, 1265, 165, 165, 939, 940, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165,
  630, 165, 165, 165, 0, 882, 0, 0, 1000, 0, 0, 0, 1003, 221, 221, 221, 221, 221, 221, 221, 221, 757, 221, 221, 221,
  221, 0, 0, 0, 165, 165, 165, 165, 1036, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 1041, 165, 165, 165,
  165, 290, 290, 1139, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 1148, 290, 290, 0, 165, 165, 165, 165,
  165, 165, 165, 165, 165, 290, 290, 290, 290, 290, 290, 290, 290, 290, 0, 165, 165, 165, 1240, 165, 165, 165, 165, 165,
  165, 165, 165, 290, 290, 290, 290, 290, 290, 290, 290, 1058, 290, 165, 1317, 165, 165, 165, 165, 290, 290, 1324, 290,
  290, 290, 290, 290, 290, 0, 0, 165, 165, 165, 290, 290, 350, 290, 0, 0, 24576, 217, 217, 225, 225, 225, 225, 241, 225,
  241, 241, 241, 241, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 225, 262, 251, 262, 283, 283, 294,
  283, 283, 283, 283, 283, 294, 283, 283, 283, 313, 283, 294, 294, 294, 294, 294, 283, 294, 283, 294, 6145, 41115, 3, 4,
  0, 0, 0, 0, 0, 167, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96459, 0, 26624, 28672, 0, 0, 96459, 0, 96459, 0, 333, 0, 180, 180,
  180, 0, 0, 0, 0, 340, 0, 342, 0, 0, 0, 0, 0, 171, 0, 0, 0, 26624, 28672, 0, 0, 170, 0, 170, 0, 360, 0, 362, 0, 0, 0,
  365, 0, 0, 0, 0, 221, 221, 221, 372, 221, 221, 379, 221, 384, 221, 387, 221, 389, 221, 221, 221, 221, 0, 0, 0, 165,
  165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 290, 0, 397, 0, 400, 402, 0, 365, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 110903, 0, 0, 0, 0, 290, 290, 290, 475, 290, 290, 484, 290, 492, 290, 496, 290, 290, 501,
  504, 507, 290, 290, 290, 290, 0, 0, 165, 165, 465, 290, 519, 0, 290, 0, 0, 1223, 221, 165, 165, 165, 165, 165, 1298,
  165, 165, 165, 165, 165, 0, 0, 165, 165, 165, 165, 460, 165, 165, 165, 165, 633, 165, 165, 637, 165, 0, 165, 165, 165,
  642, 165, 165, 644, 165, 627, 165, 165, 165, 165, 165, 798, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 803,
  165, 805, 165, 807, 165, 165, 165, 51850, 530, 290, 290, 290, 290, 290, 290, 290, 290, 290, 664, 290, 290, 0, 0, 0,
  165, 290, 290, 0, 0, 0, 708, 0, 0, 0, 714, 667, 290, 290, 290, 290, 290, 290, 290, 290, 290, 676, 290, 290, 290, 290,
  290, 0, 0, 165, 165, 165, 491, 290, 0, 290, 0, 0, 290, 290, 290, 683, 290, 290, 290, 290, 290, 290, 290, 290, 692,
  290, 290, 290, 290, 290, 671, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 0, 0, 165, 290, 0, 704, 697, 290, 0,
  700, 0, 165, 290, 290, 703, 0, 0, 0, 0, 0, 0, 0, 0, 0, 407, 0, 409, 410, 0, 0, 0, 0, 530, 716, 717, 0, 0, 0, 0, 0, 0,
  0, 0, 726, 0, 0, 0, 0, 0, 172, 0, 0, 0, 26624, 28672, 209, 0, 0, 0, 0, 0, 0, 0, 532480, 201, 0, 98304, 0, 0, 0, 0, 0,
  0, 0, 0, 201, 354, 0, 0, 0, 0, 0, 0, 0, 0, 0, 354, 0, 0, 0, 0, 0, 221, 221, 221, 754, 221, 221, 755, 221, 221, 221,
  221, 221, 221, 0, 0, 0, 0, 165, 165, 165, 165, 165, 165, 165, 165, 918, 165, 165, 165, 165, 165, 165, 0, 764, 765, 0,
  0, 703, 703, 770, 165, 771, 772, 165, 165, 165, 165, 165, 0, 0, 165, 165, 165, 165, 165, 165, 165, 165, 466, 165, 165,
  780, 165, 165, 783, 165, 165, 165, 165, 165, 165, 789, 165, 165, 791, 792, 794, 165, 165, 165, 165, 799, 165, 165,
  165, 165, 165, 165, 806, 165, 165, 165, 165, 165, 165, 1180, 165, 165, 165, 165, 165, 165, 165, 165, 165, 1130, 290,
  1132, 290, 290, 1135, 290, 165, 165, 165, 165, 813, 165, 815, 165, 817, 51850, 818, 290, 819, 290, 821, 290, 290, 0,
  165, 165, 165, 165, 165, 165, 165, 1357, 165, 290, 290, 290, 290, 290, 955, 290, 290, 290, 290, 290, 290, 290, 290,
  290, 832, 290, 290, 290, 290, 290, 290, 290, 290, 840, 290, 290, 290, 843, 844, 845, 847, 290, 290, 290, 290, 852,
  290, 290, 0, 165, 165, 165, 165, 165, 165, 1356, 165, 165, 290, 290, 290, 290, 165, 165, 290, 290, 165, 290, 1407,
  1408, 165, 290, 854, 290, 290, 290, 858, 290, 290, 290, 290, 863, 0, 0, 165, 290, 0, 0, 1223, 221, 165, 165, 165,
  1296, 1297, 165, 165, 165, 165, 165, 165, 929, 165, 165, 165, 165, 165, 935, 165, 165, 165, 866, 0, 0, 0, 0, 0, 868,
  0, 0, 0, 0, 0, 0, 0, 0, 872, 737, 0, 0, 886, 887, 0, 221, 221, 221, 221, 221, 893, 221, 221, 221, 221, 221, 221, 221,
  388, 221, 221, 393, 221, 221, 0, 0, 0, 165, 165, 165, 165, 941, 165, 165, 944, 165, 946, 165, 165, 165, 948, 165, 165,
  165, 165, 165, 165, 1242, 165, 165, 165, 165, 165, 1248, 290, 290, 290, 0, 0, 1218, 0, 0, 0, 0, 0, 0, 221, 221, 221,
  221, 221, 221, 221, 756, 221, 221, 221, 221, 221, 0, 0, 0, 977, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290,
  290, 987, 290, 0, 1266, 0, 0, 0, 1223, 221, 221, 221, 221, 221, 0, 165, 165, 165, 165, 914, 165, 165, 165, 165, 165,
  165, 165, 165, 165, 165, 290, 1198, 290, 290, 290, 290, 0, 866, 0, 868, 0, 0, 0, 0, 0, 0, 994, 0, 0, 0, 0, 0, 0, 0,
  170, 0, 6145, 0, 3, 4, 0, 0, 0, 999, 882, 0, 0, 0, 0, 0, 0, 221, 221, 221, 221, 221, 221, 221, 221, 0, 0, 0, 221, 221,
  221, 221, 1013, 221, 221, 221, 0, 0, 0, 0, 0, 0, 165, 165, 165, 423, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165,
  933, 165, 165, 165, 165, 165, 165, 1034, 165, 165, 165, 165, 165, 1039, 165, 165, 1040, 165, 165, 165, 165, 165, 0, 0,
  165, 165, 165, 165, 165, 165, 165, 464, 165, 1045, 165, 165, 165, 165, 165, 290, 290, 290, 290, 290, 290, 290, 290,
  290, 290, 0, 0, 165, 290, 0, 0, 1060, 290, 290, 290, 290, 290, 290, 290, 290, 290, 1069, 290, 1071, 290, 290, 290,
  290, 290, 842, 290, 290, 290, 290, 290, 290, 850, 290, 290, 290, 290, 290, 859, 290, 290, 290, 290, 0, 0, 165, 290, 0,
  0, 1223, 221, 165, 1295, 165, 165, 165, 165, 165, 1300, 165, 165, 165, 165, 165, 0, 165, 640, 165, 165, 165, 165, 165,
  165, 165, 165, 1117, 165, 165, 165, 165, 165, 165, 165, 290, 290, 290, 290, 1078, 290, 290, 290, 1080, 290, 290, 290,
  1083, 0, 0, 0, 0, 0, 188, 0, 0, 0, 165, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53248, 0, 0, 0, 0, 0, 0, 0, 221, 1100, 221, 221,
  221, 0, 1102, 0, 0, 165, 165, 165, 165, 1109, 165, 165, 165, 165, 165, 165, 1322, 290, 290, 290, 290, 290, 290, 290,
  290, 0, 0, 165, 165, 165, 290, 290, 0, 290, 0, 0, 165, 165, 165, 165, 1114, 165, 1116, 165, 165, 165, 165, 165, 165,
  165, 165, 165, 802, 165, 165, 165, 165, 165, 165, 1137, 290, 290, 290, 290, 290, 290, 290, 290, 1144, 290, 1146, 290,
  290, 290, 290, 290, 0, 0, 165, 458, 165, 290, 290, 0, 290, 0, 0, 1160, 0, 0, 0, 0, 221, 1166, 221, 221, 221, 1169,
  221, 1171, 0, 1173, 1174, 165, 165, 1177, 165, 165, 165, 165, 165, 165, 165, 1183, 165, 165, 165, 165, 1187, 1188,
  1189, 165, 165, 165, 165, 1192, 165, 1195, 165, 290, 290, 290, 1200, 290, 290, 0, 0, 0, 165, 290, 290, 0, 704, 0, 0,
  0, 710, 0, 0, 0, 0, 162, 0, 0, 0, 0, 165, 0, 0, 0, 0, 194, 0, 0, 0, 194, 26624, 28672, 194, 0, 0, 0, 0, 290, 1216,
  1217, 0, 0, 0, 0, 0, 0, 0, 0, 0, 221, 221, 221, 221, 747, 221, 221, 221, 221, 221, 1237, 165, 165, 165, 165, 1241,
  165, 165, 165, 165, 165, 165, 290, 290, 1250, 290, 290, 0, 165, 165, 1353, 1354, 165, 165, 165, 165, 165, 290, 290,
  290, 290, 165, 165, 290, 290, 165, 290, 165, 290, 165, 290, 290, 290, 290, 290, 1306, 290, 290, 290, 290, 290, 290,
  1312, 1223, 165, 165, 165, 165, 165, 165, 1038, 165, 165, 165, 165, 165, 165, 165, 165, 165, 932, 165, 165, 165, 165,
  165, 165, 165, 165, 165, 165, 165, 1321, 290, 290, 290, 290, 290, 290, 290, 290, 1330, 0, 0, 0, 163, 0, 164, 0, 0, 0,
  164, 0, 724992, 0, 0, 851968, 0, 0, 0, 164, 0, 0, 0, 0, 0, 26624, 67792, 0, 0, 0, 0, 0, 0, 0, 0, 201, 0, 0, 0, 357, 0,
  0, 0, 165, 165, 165, 165, 1336, 165, 165, 165, 165, 290, 290, 1343, 290, 290, 290, 290, 290, 0, 165, 165, 165, 165,
  165, 165, 165, 165, 290, 290, 1053, 1054, 290, 290, 290, 290, 290, 290, 290, 1390, 165, 165, 165, 165, 165, 165, 290,
  290, 290, 290, 290, 290, 165, 165, 165, 165, 165, 165, 290, 290, 290, 290, 290, 290, 165, 165, 24576, 211, 211, 226,
  226, 226, 226, 211, 226, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 226, 263, 211, 263, 263, 263,
  295, 263, 263, 263, 263, 263, 295, 263, 263, 263, 263, 263, 295, 295, 295, 295, 295, 263, 295, 263, 295, 6145, 41115,
  3, 4, 0, 0, 0, 0, 0, 189, 0, 0, 0, 165, 0, 0, 0, 0, 0, 0, 0, 0, 0, 65536, 0, 0, 0, 0, 0, 65536, 0, 0, 163, 164, 165,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 331, 0, 290, 290, 290, 290, 290, 290, 290, 487, 290, 290, 290, 290, 290, 290, 290, 688,
  290, 290, 290, 290, 290, 290, 290, 696, 0, 0, 0, 537, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 351, 0, 0, 221, 221, 221,
  571, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 580, 221, 581, 165, 165, 165, 607, 165, 165,
  165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 1029, 165, 165, 165, 165, 165, 51850, 530, 290, 290, 290, 290, 290,
  290, 660, 290, 290, 290, 290, 290, 0, 0, 165, 424, 165, 488, 290, 0, 290, 0, 0, 0, 866, 0, 868, 0, 0, 0, 0, 992, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 596, 0, 598, 599, 596, 165, 165, 221, 221, 221, 1012, 221, 221, 221, 221, 0, 0, 0, 0, 0, 0, 165,
  165, 165, 424, 165, 165, 432, 165, 165, 165, 165, 165, 165, 165, 1193, 165, 165, 290, 290, 290, 290, 290, 290, 290,
  290, 290, 959, 290, 290, 290, 290, 290, 290, 290, 1076, 290, 290, 290, 290, 290, 290, 290, 290, 290, 0, 0, 0, 0, 0,
  1220, 0, 1222, 0, 221, 221, 1225, 1226, 165, 165, 1401, 290, 290, 290, 165, 165, 290, 290, 165, 290, 165, 290, 165,
  290, 290, 0, 165, 1352, 165, 165, 165, 165, 165, 165, 165, 290, 1360, 290, 290, 0, 0, 0, 165, 290, 290, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 75776, 0, 0, 75776, 0, 188, 0, 0, 0, 0, 0, 0, 0, 0, 26624, 28672, 0, 0, 0, 0, 0, 0, 0, 350, 201, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 352256, 0, 180, 0, 0, 352256, 24576, 0, 0, 227, 227, 227, 227, 242, 227, 242, 242, 242,
  242, 242, 242, 242, 242, 242, 242, 242, 242, 227, 264, 242, 264, 264, 264, 296, 264, 264, 264, 264, 264, 296, 264,
  264, 264, 264, 264, 296, 296, 296, 296, 296, 264, 296, 264, 296, 6145, 41115, 3, 4, 0, 0, 0, 0, 0, 238, 0, 238, 238,
  6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 532480, 0, 0, 0, 524, 528, 0, 530, 0, 0, 0, 0, 0, 0, 0, 0,
  180, 180, 180, 0, 0, 338, 0, 0, 0, 0, 0, 0, 0, 0, 0, 205, 205, 0, 0, 0, 0, 0, 165, 1238, 165, 165, 165, 165, 165, 165,
  165, 165, 165, 165, 290, 1249, 290, 290, 0, 0, 0, 165, 290, 290, 0, 705, 0, 0, 0, 711, 0, 0, 0, 0, 202, 0, 0, 0, 202,
  26624, 28672, 202, 0, 0, 0, 0, 0, 0, 0, 532480, 352, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 563, 0, 0, 0, 0, 221, 165, 1272,
  165, 165, 165, 165, 165, 165, 165, 165, 165, 1277, 165, 165, 165, 290, 165, 165, 165, 165, 165, 290, 165, 165, 165,
  165, 165, 290, 290, 290, 290, 165, 1403, 290, 1404, 165, 290, 165, 290, 165, 290, 290, 290, 290, 290, 1283, 290, 290,
  290, 290, 290, 290, 1288, 290, 290, 290, 290, 290, 0, 165, 165, 1369, 1370, 165, 165, 165, 165, 290, 290, 0, 0, 334,
  180, 180, 180, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 221, 270, 0, 270, 165, 165, 165, 452, 165, 0, 0, 165, 418, 165,
  165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 1184, 1185, 165, 165, 165, 0, 290, 290, 473, 290, 290, 290,
  290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 851, 290, 290, 290, 290, 290, 513, 290, 0, 0, 418, 165, 165, 290,
  290, 0, 473, 0, 0, 0, 0, 310, 0, 0, 0, 0, 310, 0, 0, 0, 310, 0, 0, 0, 0, 0, 811008, 0, 0, 0, 0, 0, 784384, 0, 0, 0, 0,
  0, 0, 0, 532480, 201, 0, 0, 0, 0, 0, 0, 22528, 175, 0, 175, 0, 0, 0, 0, 0, 0, 165, 0, 0, 0, 0, 0, 175, 0, 0, 0, 0, 0,
  0, 180, 165, 0, 0, 24576, 0, 0, 228, 228, 228, 228, 243, 228, 243, 243, 248, 248, 252, 253, 253, 253, 253, 258, 253,
  258, 253, 253, 253, 253, 253, 228, 265, 253, 265, 284, 284, 297, 284, 284, 284, 284, 284, 297, 284, 284, 284, 265,
  284, 297, 315, 297, 297, 297, 297, 297, 284, 297, 284, 297, 6145, 41115, 3, 4, 0, 0, 0, 0, 0, 364, 0, 0, 0, 0, 0, 0,
  561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 0, 0, 0, 0,
  290, 290, 290, 476, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 1070, 290, 290, 290, 290, 165, 604, 165,
  165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 617, 165, 165, 165, 165, 165, 814, 165, 165, 165, 51850, 290,
  290, 290, 290, 290, 290, 165, 1380, 165, 165, 165, 1384, 290, 1386, 290, 290, 165, 634, 165, 165, 165, 0, 165, 165,
  165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 922, 165, 165, 165, 51850, 530, 290, 290, 290, 290, 656, 290,
  290, 290, 290, 290, 290, 290, 861, 290, 290, 0, 0, 165, 290, 0, 0, 0, 530, 0, 0, 0, 0, 0, 721, 0, 0, 0, 0, 0, 0, 0,
  728, 165, 165, 165, 165, 797, 165, 165, 165, 165, 165, 165, 804, 165, 165, 165, 165, 165, 0, 0, 165, 165, 165, 459,
  432, 165, 165, 165, 165, 165, 0, 0, 165, 165, 421, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 1247, 290,
  290, 290, 290, 221, 221, 221, 1101, 221, 0, 0, 0, 0, 165, 1106, 165, 1108, 165, 165, 165, 165, 165, 165, 1051, 290,
  290, 290, 290, 1055, 290, 290, 290, 290, 290, 165, 290, 165, 290, 6145, 41115, 3, 4, 0, 0, 0, 165, 165, 1113, 165,
  165, 165, 165, 165, 165, 165, 165, 1119, 165, 1120, 165, 165, 165, 165, 165, 165, 1338, 165, 1340, 290, 290, 290, 290,
  290, 290, 1347, 1149, 290, 290, 1151, 290, 290, 1153, 290, 290, 290, 0, 0, 0, 0, 0, 0, 1221, 0, 0, 1224, 221, 221,
  221, 0, 0, 0, 1163, 0, 221, 221, 221, 221, 1168, 221, 221, 221, 0, 0, 0, 165, 165, 165, 1232, 1233, 1234, 165, 165,
  165, 165, 290, 290, 1203, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 1211, 290, 290, 0, 0, 0, 165, 254242, 290,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 349, 0, 221, 221, 221, 221, 1316, 165, 165, 1319, 1320, 165, 290, 290, 290, 290, 1326,
  1327, 1328, 1329, 290, 0, 0, 0, 167, 0, 0, 0, 167, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 75776, 75776, 75776, 0, 0, 290,
  1375, 1376, 290, 290, 290, 165, 165, 165, 165, 165, 165, 290, 290, 290, 290, 290, 290, 1399, 165, 189, 196, 0, 0, 0,
  0, 0, 0, 0, 26624, 28672, 0, 212, 0, 212, 0, 0, 0, 169, 0, 0, 169, 169, 169, 169, 169, 169, 69632, 69801, 169, 169,
  69801, 169, 169, 169, 169, 69801, 69801, 184, 169, 169, 169, 169, 169, 169, 169, 69801, 69801, 169, 69801, 69801,
  69801, 69801, 0, 69801, 169, 24576, 212, 212, 229, 229, 229, 229, 244, 229, 244, 244, 244, 244, 244, 244, 244, 244,
  244, 244, 244, 244, 229, 266, 278, 266, 266, 266, 298, 266, 266, 266, 266, 266, 298, 266, 266, 266, 266, 266, 298,
  298, 298, 298, 298, 266, 298, 266, 298, 6145, 41115, 3, 4, 0, 0, 0, 0, 0, 403, 0, 0, 406, 0, 0, 0, 0, 403, 346, 346,
  0, 0, 163, 164, 165, 0, 0, 0, 0, 0, 0, 0, 0, 329, 0, 0, 0, 221, 221, 221, 221, 374, 221, 221, 221, 221, 221, 221, 221,
  221, 221, 221, 221, 221, 0, 0, 0, 0, 0, 1017, 165, 165, 329, 0, 0, 0, 0, 0, 0, 0, 0, 0, 329, 0, 0, 0, 0, 0, 0, 0, 351,
  201, 0, 0, 0, 0, 0, 0, 0, 0, 0, 165, 178, 0, 0, 0, 178, 0, 0, 290, 290, 290, 290, 478, 290, 290, 290, 290, 290, 290,
  290, 290, 290, 290, 0, 0, 1158, 0, 0, 0, 221, 221, 570, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221,
  221, 221, 221, 221, 0, 0, 0, 0, 0, 0, 0, 165, 165, 605, 165, 165, 165, 165, 165, 165, 165, 165, 615, 165, 165, 165,
  165, 165, 0, 0, 416, 165, 165, 165, 434, 165, 165, 165, 165, 165, 0, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165,
  165, 165, 165, 165, 923, 165, 165, 636, 165, 165, 0, 165, 605, 165, 165, 165, 165, 165, 165, 165, 165, 945, 165, 165,
  165, 165, 165, 949, 165, 165, 165, 51850, 530, 290, 290, 290, 290, 290, 657, 290, 290, 290, 290, 290, 290, 687, 290,
  290, 290, 290, 290, 290, 290, 290, 290, 846, 290, 290, 290, 290, 290, 290, 290, 290, 669, 290, 290, 290, 290, 290,
  290, 290, 290, 290, 290, 290, 290, 290, 290, 975, 290, 0, 530, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 727, 0, 0, 0, 0, 363,
  0, 0, 0, 0, 0, 0, 0, 221, 221, 221, 221, 892, 221, 221, 221, 221, 221, 824, 290, 826, 290, 290, 290, 290, 290, 290,
  290, 290, 290, 835, 290, 290, 290, 290, 290, 968, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 972, 290, 290,
  290, 290, 290, 838, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 853, 165, 165, 165,
  165, 1023, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 947, 165, 165, 165, 165, 165, 1362, 1363, 290, 290,
  290, 0, 1367, 165, 165, 165, 165, 165, 165, 165, 1373, 290, 290, 0, 1351, 165, 165, 165, 165, 1355, 165, 165, 165,
  1359, 290, 290, 1361, 24576, 0, 0, 230, 230, 230, 230, 0, 230, 0, 0, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249,
  249, 249, 230, 267, 249, 267, 267, 267, 299, 267, 267, 267, 267, 267, 299, 267, 267, 267, 267, 267, 299, 299, 299,
  299, 299, 267, 299, 267, 299, 6145, 41115, 3, 4, 0, 0, 0, 0, 0, 530, 0, 0, 0, 0, 0, 0, 0, 0, 180, 180, 180, 0, 0, 0,
  0, 0, 0, 0, 343, 191, 0, 375, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 0, 0, 0, 0, 165, 165, 165,
  165, 165, 165, 1111, 0, 290, 290, 290, 290, 479, 290, 290, 488, 290, 290, 290, 290, 290, 290, 290, 1066, 290, 290,
  290, 290, 290, 290, 290, 1073, 0, 0, 0, 555, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 221, 1095, 221, 221, 221, 221, 165, 165,
  51850, 530, 290, 290, 290, 290, 290, 658, 290, 290, 290, 290, 290, 290, 829, 290, 290, 290, 290, 290, 290, 290, 290,
  290, 1068, 290, 290, 290, 290, 290, 290, 0, 530, 0, 0, 0, 0, 0, 0, 0, 0, 0, 725, 0, 0, 0, 0, 0, 0, 0, 532480, 16737,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 179, 0, 0, 180, 165, 0, 0, 165, 810, 165, 812, 165, 165, 165, 165, 165, 51850, 290, 290,
  290, 290, 290, 290, 860, 290, 862, 290, 864, 0, 165, 290, 0, 0, 290, 825, 290, 290, 290, 290, 290, 830, 290, 290, 290,
  290, 290, 290, 290, 290, 689, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 841, 290, 290, 290, 290, 290, 290,
  290, 290, 290, 290, 290, 290, 290, 1147, 290, 290, 290, 290, 290, 980, 290, 290, 290, 290, 290, 290, 290, 290, 290,
  290, 290, 0, 1223, 165, 165, 165, 290, 1292, 0, 1223, 221, 165, 165, 165, 165, 165, 165, 165, 165, 165, 1302, 165,
  165, 165, 165, 165, 928, 165, 165, 165, 165, 165, 165, 165, 165, 165, 936, 24576, 0, 0, 231, 231, 231, 231, 245, 231,
  245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 231, 268, 245, 268, 285, 285, 300, 285, 285, 285, 285,
  285, 300, 285, 285, 285, 268, 285, 300, 300, 300, 300, 300, 285, 300, 285, 300, 6145, 41115, 3, 4, 0, 0, 0, 0, 0, 530,
  0, 0, 0, 0, 0, 0, 0, 534, 180, 180, 0, 0, 163, 164, 165, 0, 0, 0, 0, 0, 0, 0, 0, 0, 330, 0, 0, 0, 173, 0, 0, 0, 0, 0,
  0, 0, 0, 180, 165, 0, 0, 0, 0, 171, 0, 171, 0, 170, 0, 170, 0, 0, 0, 0, 0, 0, 0, 0, 541, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  730, 882, 0, 0, 0, 0, 0, 221, 221, 221, 382, 221, 221, 221, 221, 221, 221, 221, 394, 221, 0, 0, 0, 0, 0, 530, 0, 0, 0,
  0, 0, 0, 533, 0, 180, 180, 367, 414, 415, 165, 165, 165, 165, 165, 433, 165, 165, 165, 165, 165, 165, 165, 1243, 165,
  165, 165, 165, 290, 290, 290, 290, 165, 450, 165, 165, 165, 0, 0, 415, 165, 165, 165, 433, 165, 165, 165, 165, 165, 0,
  165, 165, 165, 165, 165, 165, 165, 165, 165, 647, 0, 290, 469, 290, 290, 290, 290, 290, 489, 290, 290, 290, 290, 290,
  290, 290, 1143, 290, 290, 290, 290, 290, 290, 290, 290, 675, 290, 290, 677, 290, 290, 290, 290, 290, 511, 290, 290,
  290, 0, 0, 165, 165, 165, 489, 290, 0, 290, 0, 0, 1223, 221, 1294, 165, 165, 165, 165, 165, 165, 165, 1301, 165, 165,
  535, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 884, 0, 530, 0, 0, 0, 719, 720, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  561152, 561152, 561152, 561152, 0, 0, 885, 0, 0, 0, 889, 221, 221, 221, 221, 221, 221, 221, 221, 221, 0, 0, 906, 0, 0,
  0, 0, 0, 165, 912, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 1279, 165, 290, 165, 938, 165,
  165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 632, 165, 221, 221, 1011, 221, 221, 221, 221, 221, 0,
  0, 0, 1016, 0, 0, 165, 165, 420, 165, 165, 429, 165, 435, 165, 439, 165, 165, 443, 445, 165, 1046, 165, 165, 165, 165,
  290, 290, 290, 290, 290, 290, 1056, 290, 290, 1059, 290, 1061, 290, 290, 290, 290, 290, 290, 1067, 290, 290, 290, 290,
  290, 290, 290, 1154, 290, 290, 0, 0, 0, 0, 0, 0, 290, 1075, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 0, 0, 0,
  0, 1219, 0, 0, 0, 0, 221, 221, 221, 221, 1112, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165,
  165, 1281, 165, 165, 165, 165, 1125, 165, 165, 165, 165, 165, 290, 290, 290, 290, 290, 290, 290, 957, 290, 290, 960,
  290, 962, 290, 290, 290, 290, 290, 1140, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 1263, 290,
  290, 0, 0, 1162, 0, 0, 1165, 221, 221, 221, 221, 221, 221, 221, 0, 0, 0, 0, 165, 165, 165, 165, 165, 1110, 165, 165,
  1176, 165, 165, 165, 165, 165, 165, 1182, 165, 165, 165, 165, 165, 1186, 165, 165, 165, 165, 165, 942, 165, 165, 165,
  165, 165, 165, 165, 165, 165, 165, 1246, 165, 290, 290, 290, 290, 1251, 1252, 1253, 290, 290, 290, 290, 290, 290, 290,
  1260, 290, 290, 290, 290, 290, 0, 0, 165, 426, 165, 290, 290, 0, 290, 0, 0, 165, 165, 1318, 165, 165, 165, 290, 290,
  290, 1325, 290, 290, 290, 290, 290, 1331, 290, 1349, 0, 165, 165, 165, 165, 165, 165, 165, 165, 165, 290, 290, 290,
  290, 290, 290, 290, 1057, 290, 290, 0, 0, 177, 0, 0, 0, 0, 0, 0, 26624, 28672, 0, 177, 0, 177, 0, 0, 0, 173, 0, 0, 0,
  0, 0, 165, 0, 0, 0, 0, 0, 0, 0, 0, 0, 26624, 28672, 0, 211, 0, 211, 0, 24576, 218, 218, 232, 232, 232, 232, 218, 232,
  218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 232, 269, 218, 269, 269, 269, 301, 269, 269, 269, 269,
  269, 301, 269, 269, 269, 269, 269, 301, 301, 301, 301, 301, 269, 301, 269, 301, 6145, 41115, 3, 4, 0, 0, 0, 0, 0, 530,
  0, 0, 0, 0, 0, 532, 0, 0, 180, 180, 0, 346, 0, 0, 0, 0, 0, 0, 201, 0, 0, 0, 0, 0, 0, 0, 0, 0, 737, 0, 0, 0, 0, 739, 0,
  0, 0, 361, 0, 0, 0, 346, 0, 0, 0, 0, 0, 221, 221, 371, 221, 221, 221, 221, 573, 221, 221, 221, 221, 221, 221, 221,
  221, 221, 221, 221, 221, 395, 0, 0, 0, 221, 378, 221, 221, 221, 386, 221, 221, 221, 221, 392, 221, 221, 0, 0, 0, 0, 0,
  539, 0, 0, 0, 0, 0, 0, 545, 0, 0, 549, 0, 0, 165, 419, 422, 165, 428, 165, 165, 165, 437, 165, 165, 165, 165, 446,
  448, 165, 165, 165, 165, 0, 0, 165, 456, 457, 165, 165, 462, 165, 446, 448, 0, 290, 290, 474, 477, 290, 483, 290, 290,
  290, 494, 497, 290, 290, 290, 505, 508, 290, 290, 290, 290, 0, 0, 518, 165, 448, 290, 290, 0, 520, 0, 0, 0, 0, 538, 0,
  0, 540, 0, 0, 0, 0, 0, 351, 0, 0, 0, 0, 174, 0, 0, 0, 0, 0, 0, 0, 180, 165, 0, 0, 0, 0, 187, 0, 0, 0, 0, 165, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 26624, 28672, 210, 0, 0, 0, 0, 165, 635, 165, 165, 165, 0, 165, 165, 165, 165, 165, 165, 165, 165,
  646, 165, 165, 165, 165, 165, 1024, 165, 165, 165, 165, 165, 165, 165, 1030, 165, 165, 165, 165, 165, 401, 454, 455,
  165, 165, 165, 461, 165, 165, 447, 165, 290, 290, 290, 684, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 695,
  290, 290, 165, 1391, 165, 165, 165, 165, 290, 1395, 290, 290, 290, 290, 165, 165, 1392, 1393, 165, 165, 290, 290,
  1396, 1397, 290, 290, 165, 165, 165, 165, 1394, 165, 290, 290, 290, 290, 1398, 290, 165, 165, 763, 0, 0, 0, 0, 0, 0,
  165, 165, 165, 165, 165, 165, 165, 165, 165, 1245, 165, 165, 290, 290, 290, 290, 0, 0, 867, 0, 524, 0, 0, 0, 869, 0,
  528, 0, 0, 0, 0, 0, 0, 0, 560, 0, 0, 0, 0, 560, 0, 0, 221, 290, 290, 966, 290, 290, 290, 290, 290, 290, 290, 290, 290,
  290, 290, 290, 290, 290, 1290, 290, 0, 1161, 0, 0, 0, 221, 221, 1167, 221, 221, 221, 221, 221, 0, 0, 0, 0, 1105, 165,
  165, 165, 165, 165, 165, 165, 165, 165, 1178, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 1027, 165,
  165, 165, 165, 165, 290, 290, 290, 1305, 290, 290, 290, 290, 290, 290, 290, 0, 1223, 165, 1314, 165, 165, 165, 165,
  165, 1037, 165, 165, 165, 165, 165, 165, 165, 165, 165, 1044, 286, 286, 302, 286, 286, 286, 286, 286, 302, 286, 286,
  286, 286, 286, 302, 302, 302, 302, 302, 286, 302, 286, 302, 6145, 41115, 3, 4, 0, 0, 0, 0, 0, 558, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 221, 221, 745, 221, 221, 221, 221, 221, 750, 221, 0, 552, 0, 556, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 221, 221,
  1005, 221, 221, 221, 1008, 221, 165, 649, 51850, 530, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 666, 290, 290,
  290, 290, 290, 1256, 290, 290, 290, 1259, 290, 290, 290, 290, 290, 290, 290, 1286, 290, 290, 1287, 290, 290, 290, 290,
  290, 0, 708, 0, 0, 0, 0, 0, 714, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 358400, 180, 0, 0, 0, 290, 965, 290, 290, 290, 290,
  290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 1291, 1033, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165,
  165, 165, 165, 165, 165, 1031, 165, 376, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 0, 0, 0, 1104,
  165, 165, 1107, 165, 165, 165, 165, 396, 0, 0, 0, 0, 0, 0, 0, 0, 0, 396, 0, 0, 0, 0, 0, 0, 0, 880, 0, 0, 882, 0, 0, 0,
  0, 0, 1002, 221, 221, 221, 221, 221, 221, 221, 221, 0, 1014, 0, 0, 0, 0, 1018, 165, 165, 165, 165, 165, 453, 0, 0,
  165, 165, 165, 425, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 0, 290, 290, 290, 290, 480, 290, 290, 290, 290,
  290, 290, 290, 290, 290, 290, 0, 865, 165, 290, 0, 0, 290, 290, 290, 290, 514, 0, 0, 165, 425, 165, 290, 290, 0, 290,
  0, 0, 0, 0, 557, 0, 0, 0, 0, 562, 0, 0, 0, 0, 0, 221, 0, 0, 525, 529, 0, 530, 0, 0, 0, 0, 0, 0, 0, 0, 180, 180, 180,
  0, 71680, 0, 0, 0, 0, 0, 0, 532480, 0, 290, 290, 290, 290, 1255, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290,
  290, 1082, 0, 0, 0, 0, 0, 0, 178, 0, 178, 0, 0, 0, 178, 26624, 28672, 178, 178, 0, 178, 0, 0, 0, 180, 180, 102400, 0,
  0, 0, 0, 0, 0, 0, 0, 532480, 0, 0, 0, 0, 1090, 0, 0, 1091, 0, 0, 1094, 221, 1096, 221, 221, 221, 221, 221, 221, 575,
  221, 221, 221, 221, 221, 221, 221, 221, 221, 390, 221, 221, 221, 0, 0, 0, 24576, 178, 178, 233, 233, 233, 233, 178,
  233, 178, 178, 178, 178, 178, 178, 178, 178, 178, 178, 178, 178, 233, 271, 178, 271, 271, 271, 303, 271, 271, 271,
  271, 271, 303, 271, 271, 271, 271, 271, 303, 303, 303, 303, 303, 271, 303, 271, 303, 6145, 41115, 3, 4, 0, 0, 0, 0, 0,
  592, 0, 0, 0, 0, 0, 0, 0, 0, 601, 165, 332, 0, 0, 180, 180, 180, 0, 0, 0, 0, 0, 341, 0, 0, 0, 0, 0, 0, 0, 563200,
  671744, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 776192, 802816,
  563200, 563200, 849920, 449, 165, 165, 165, 165, 0, 0, 165, 165, 165, 165, 165, 165, 463, 165, 449, 0, 290, 290, 290,
  290, 290, 290, 290, 290, 290, 290, 290, 498, 500, 290, 290, 0, 0, 0, 605, 290, 657, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  352256, 352256, 0, 352256, 0, 0, 0, 0, 0, 0, 0, 509, 290, 290, 290, 290, 0, 0, 165, 165, 449, 290, 290, 0, 290, 0, 0,
  0, 0, 591, 0, 593, 0, 0, 0, 0, 0, 0, 0, 165, 165, 165, 165, 165, 165, 165, 165, 165, 613, 165, 165, 165, 165, 165,
  165, 290, 290, 670, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 678, 290, 290, 290, 290, 682,
  290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 693, 290, 290, 0, 0, 741, 0, 0, 0, 221, 221, 221,
  221, 221, 221, 221, 221, 221, 221, 577, 221, 221, 221, 221, 221, 221, 165, 165, 165, 165, 782, 165, 165, 165, 165,
  165, 165, 165, 165, 165, 165, 165, 1197, 290, 290, 290, 290, 290, 221, 897, 898, 899, 221, 221, 221, 221, 221, 0, 0,
  0, 907, 0, 0, 0, 0, 0, 734, 0, 736, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 724992, 0, 0, 851968, 0, 165, 924, 165, 165, 927,
  165, 165, 930, 165, 165, 165, 934, 165, 165, 165, 165, 165, 0, 165, 165, 165, 165, 165, 165, 165, 645, 165, 165, 290,
  290, 290, 290, 967, 290, 290, 970, 290, 290, 290, 290, 973, 290, 290, 290, 290, 290, 1064, 290, 290, 290, 290, 290,
  290, 290, 290, 290, 290, 1156, 0, 0, 0, 0, 0, 290, 978, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290,
  988, 989, 165, 165, 165, 1022, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 1276, 165, 165, 165, 165,
  290, 1175, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 1043, 165, 1303, 290, 290, 290,
  290, 290, 290, 290, 1310, 290, 290, 0, 1223, 165, 165, 165, 165, 165, 165, 1127, 1128, 165, 165, 290, 290, 290, 290,
  290, 290, 969, 290, 290, 290, 290, 290, 290, 290, 290, 290, 690, 290, 290, 290, 290, 290, 290, 165, 1333, 165, 165,
  165, 165, 165, 165, 165, 290, 1342, 290, 290, 290, 290, 290, 0, 0, 165, 427, 165, 290, 290, 0, 290, 0, 0, 1389, 290,
  165, 165, 165, 165, 165, 165, 290, 290, 290, 290, 290, 290, 165, 165, 165, 165, 1383, 165, 290, 290, 290, 290, 0, 197,
  198, 0, 0, 0, 0, 0, 0, 26624, 28672, 0, 198, 0, 198, 0, 0, 0, 199, 0, 0, 0, 0, 0, 26624, 28672, 0, 0, 0, 0, 0, 0, 0,
  0, 201, 0, 0, 0, 358, 0, 0, 0, 24576, 219, 219, 234, 234, 234, 234, 219, 234, 219, 219, 219, 219, 219, 219, 219, 219,
  219, 219, 219, 219, 234, 272, 279, 272, 287, 287, 304, 287, 287, 287, 287, 287, 304, 287, 287, 287, 272, 287, 304,
  304, 304, 304, 304, 287, 304, 287, 304, 6145, 41115, 3, 4, 0, 0, 0, 0, 0, 878, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  221, 275, 0, 275, 0, 0, 163, 164, 165, 0, 0, 0, 0, 0, 0, 327, 0, 0, 0, 0, 0, 201, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1093,
  221, 221, 221, 221, 221, 221, 359, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 359, 221, 369, 221, 221, 221, 221, 221, 221, 586,
  221, 221, 221, 221, 0, 0, 0, 0, 0, 0, 0, 0, 1092, 0, 221, 221, 221, 221, 1098, 221, 221, 221, 221, 383, 221, 221, 221,
  221, 221, 221, 221, 221, 221, 0, 0, 0, 165, 1231, 165, 165, 165, 165, 165, 1235, 165, 165, 0, 0, 399, 0, 0, 0, 0, 399,
  0, 0, 0, 399, 399, 0, 0, 0, 0, 0, 1001, 0, 0, 221, 221, 221, 221, 1007, 221, 221, 1009, 359, 399, 416, 165, 165, 165,
  165, 165, 434, 165, 165, 165, 165, 165, 165, 165, 290, 1323, 290, 290, 290, 290, 290, 290, 290, 0, 0, 165, 165, 165,
  487, 290, 0, 290, 0, 0, 0, 290, 470, 290, 290, 290, 290, 290, 490, 290, 290, 290, 290, 290, 290, 290, 1257, 290, 290,
  290, 290, 1262, 290, 290, 290, 521, 0, 0, 0, 0, 530, 0, 0, 531, 0, 0, 0, 0, 0, 180, 180, 180, 337, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 367, 221, 368, 221, 221, 221, 569, 221, 572, 221, 574, 221, 221, 221, 221, 221, 221, 221, 579, 221,
  221, 221, 221, 221, 221, 902, 221, 221, 0, 0, 0, 0, 0, 909, 0, 603, 165, 165, 608, 165, 165, 611, 165, 165, 165, 165,
  165, 165, 165, 165, 165, 1275, 165, 165, 165, 165, 165, 290, 620, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165,
  165, 165, 165, 165, 165, 1280, 290, 165, 165, 51850, 530, 290, 290, 290, 655, 290, 290, 661, 290, 290, 665, 290, 290,
  0, 0, 0, 640, 290, 658, 0, 0, 706, 0, 0, 0, 712, 0, 0, 530, 0, 0, 0, 0, 0, 0, 0, 0, 724, 0, 0, 0, 0, 0, 0, 0, 333824,
  0, 993, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86016, 0, 0, 86016, 86016, 0, 0, 873, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  53248, 0, 557, 0, 0, 0, 0, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 588, 221, 0, 0, 0, 0, 0, 221, 221, 221,
  221, 900, 221, 221, 221, 221, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 164, 164, 0, 0, 0,
  911, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 51850, 290, 290, 290, 290, 290, 290, 950,
  951, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 679, 290, 290, 290, 979, 290, 290, 290,
  290, 290, 290, 983, 290, 290, 290, 290, 290, 0, 0, 165, 165, 165, 490, 290, 0, 290, 0, 0, 0, 0, 708, 0, 714, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 180, 165, 0, 0, 0, 0, 734, 0, 0, 0, 0, 0, 221, 221, 221, 221, 221, 221, 221, 221, 221, 758,
  221, 221, 221, 0, 0, 0, 1010, 221, 221, 221, 221, 221, 221, 221, 0, 0, 1015, 0, 0, 0, 165, 165, 165, 165, 165, 544,
  165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 1131, 290, 290, 290, 290, 290, 165, 165, 165, 1048, 165, 165, 290,
  290, 290, 290, 290, 290, 290, 290, 290, 290, 0, 1157, 0, 0, 0, 0, 1074, 290, 290, 290, 290, 290, 290, 290, 290, 290,
  290, 290, 0, 0, 0, 0, 0, 1223, 221, 221, 221, 221, 221, 0, 1270, 165, 165, 0, 1087, 0, 0, 0, 0, 0, 0, 0, 0, 221, 221,
  221, 221, 221, 221, 1170, 221, 1172, 0, 0, 290, 1150, 290, 290, 290, 290, 290, 290, 290, 290, 0, 0, 0, 0, 0, 0, 0, 0,
  171, 0, 0, 171, 0, 0, 0, 0, 221, 221, 1228, 0, 0, 0, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 440, 442, 165,
  165, 165, 165, 1239, 165, 165, 165, 165, 165, 165, 165, 165, 165, 290, 290, 290, 290, 165, 165, 290, 290, 165, 290,
  165, 290, 1409, 1410, 1332, 165, 165, 165, 165, 165, 165, 165, 165, 1341, 290, 290, 290, 290, 290, 290, 981, 290, 290,
  290, 290, 290, 290, 290, 290, 0, 0, 165, 165, 165, 290, 290, 94208, 290, 0, 0, 290, 290, 1364, 290, 290, 0, 165, 1368,
  165, 165, 165, 165, 165, 165, 290, 1374, 24576, 0, 0, 235, 235, 235, 235, 0, 235, 246, 246, 246, 246, 246, 246, 254,
  254, 254, 254, 246, 254, 246, 254, 254, 254, 254, 254, 235, 273, 254, 273, 288, 288, 305, 288, 288, 288, 288, 288,
  305, 288, 288, 288, 314, 288, 305, 305, 305, 305, 305, 288, 305, 288, 305, 6145, 41115, 3, 4, 0, 0, 0, 0, 0, 75776,
  75776, 75776, 0, 26624, 28672, 0, 0, 75776, 0, 75776, 0, 0, 339, 0, 348, 349, 0, 0, 201, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  6145, 0, 3, 571549, 0, 0, 0, 0, 0, 0, 161, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 412, 413, 221, 221, 380, 221,
  385, 221, 221, 221, 221, 391, 221, 221, 221, 0, 0, 0, 1230, 165, 165, 165, 165, 165, 165, 165, 165, 165, 627, 165,
  165, 165, 165, 165, 165, 0, 398, 0, 401, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 411, 0, 0, 339, 0, 165, 165, 165, 165,
  165, 430, 165, 436, 165, 165, 165, 165, 165, 447, 0, 290, 471, 290, 290, 290, 290, 485, 491, 493, 290, 290, 290, 290,
  290, 506, 0, 536, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 546, 0, 221, 221, 221, 221, 584, 585, 221, 221, 221, 221,
  221, 0, 0, 0, 0, 562, 621, 165, 622, 165, 165, 165, 165, 165, 165, 165, 628, 629, 165, 165, 165, 165, 165, 0, 165,
  165, 165, 165, 643, 165, 165, 165, 165, 165, 0, 0, 165, 165, 165, 426, 165, 165, 165, 165, 165, 165, 165, 165, 165,
  165, 165, 165, 51850, 530, 290, 290, 654, 290, 290, 290, 290, 290, 290, 290, 290, 290, 971, 290, 290, 290, 290, 290,
  290, 290, 290, 290, 290, 685, 686, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 833, 290, 290, 290, 290, 290,
  221, 221, 753, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 0, 0, 0, 0, 0, 86016, 0, 86016, 86016, 6145, 0, 3, 4,
  0, 0, 0, 0, 0, 0, 176, 177, 0, 165, 0, 0, 0, 0, 0, 0, 0, 0, 0, 122880, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 180, 0, 0, 0,
  0, 0, 0, 766, 0, 768, 769, 165, 165, 165, 773, 165, 165, 165, 165, 165, 0, 0, 165, 165, 165, 427, 165, 165, 165, 165,
  165, 165, 165, 165, 165, 165, 165, 165, 165, 781, 165, 165, 165, 165, 165, 165, 165, 788, 165, 165, 165, 165, 165, 0,
  165, 165, 165, 611, 165, 165, 165, 165, 165, 165, 784, 165, 165, 165, 787, 165, 165, 165, 165, 165, 165, 165, 811,
  165, 165, 165, 165, 816, 165, 51850, 290, 290, 290, 290, 822, 290, 290, 290, 290, 290, 1284, 290, 290, 290, 290, 290,
  290, 290, 290, 290, 290, 0, 0, 178341, 178466, 0, 0, 290, 839, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290,
  290, 290, 290, 694, 290, 290, 290, 856, 290, 290, 290, 290, 290, 290, 290, 0, 0, 165, 290, 0, 0, 0, 0, 732, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 180, 164, 164, 164, 0, 0, 875, 876, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 532, 566, 567,
  937, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 51850, 290, 290, 290, 820, 290, 290,
  165, 165, 1021, 165, 165, 165, 165, 165, 165, 1026, 165, 1028, 165, 165, 165, 165, 165, 0, 165, 165, 641, 165, 165,
  165, 165, 165, 165, 165, 800, 165, 165, 165, 165, 165, 165, 165, 165, 785, 165, 165, 165, 165, 165, 165, 165, 165,
  165, 165, 1035, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 1129, 165, 290, 290, 290, 290, 290, 290,
  290, 290, 290, 290, 1063, 290, 1065, 290, 290, 290, 290, 290, 290, 290, 1072, 290, 290, 290, 290, 290, 1307, 1308,
  290, 290, 290, 290, 0, 1223, 165, 165, 165, 165, 165, 165, 1179, 165, 165, 165, 165, 165, 165, 165, 165, 165, 786,
  165, 165, 165, 165, 165, 165, 1086, 0, 1088, 0, 0, 0, 0, 0, 0, 0, 221, 221, 221, 1097, 221, 221, 221, 221, 221, 901,
  221, 221, 221, 0, 0, 0, 0, 0, 0, 0, 0, 0, 737, 0, 0, 0, 0, 0, 740, 1122, 165, 165, 1124, 165, 1126, 165, 165, 165,
  165, 290, 290, 290, 290, 290, 1136, 290, 1138, 290, 290, 1141, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290,
  1261, 290, 290, 290, 290, 165, 165, 1190, 165, 1191, 165, 165, 165, 165, 1196, 290, 290, 1199, 290, 290, 290, 290,
  290, 1142, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 691, 290, 290, 290, 290, 290, 290, 290, 290, 1204, 290,
  290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 848, 849, 290, 290, 290, 290, 1215, 290, 290, 61440, 63488, 0,
  0, 0, 0, 0, 0, 0, 221, 221, 221, 221, 221, 221, 221, 903, 221, 0, 905, 0, 0, 0, 0, 0, 0, 0, 405, 0, 0, 0, 405, 405, 0,
  0, 0, 221, 1227, 221, 1229, 0, 0, 165, 165, 165, 165, 165, 165, 165, 165, 165, 1236, 1271, 165, 165, 165, 165, 165,
  165, 165, 165, 165, 165, 165, 1278, 165, 165, 290, 165, 165, 165, 165, 165, 290, 165, 165, 165, 165, 165, 290, 316,
  290, 290, 290, 1282, 290, 290, 290, 290, 290, 290, 290, 290, 290, 1289, 290, 290, 0, 0, 0, 701, 290, 702, 0, 0, 707,
  0, 0, 0, 713, 0, 290, 290, 1350, 165, 165, 165, 165, 165, 165, 165, 165, 1358, 290, 290, 290, 290, 290, 290, 1206,
  290, 290, 290, 290, 290, 1210, 290, 290, 290, 290, 290, 290, 290, 1366, 0, 165, 165, 165, 165, 165, 1371, 1372, 165,
  290, 290, 290, 290, 954, 290, 956, 290, 958, 290, 290, 290, 290, 290, 290, 165, 165, 1381, 1382, 165, 165, 290, 290,
  1387, 1388, 290, 290, 290, 1377, 1378, 290, 165, 165, 165, 165, 165, 165, 290, 290, 290, 290, 165, 165, 290, 290,
  1405, 1406, 165, 290, 165, 290, 24576, 0, 0, 236, 236, 236, 236, 0, 236, 0, 0, 0, 250, 250, 250, 250, 250, 250, 250,
  250, 250, 250, 250, 250, 236, 274, 250, 274, 274, 274, 306, 274, 274, 274, 274, 274, 306, 274, 274, 274, 274, 274,
  306, 306, 306, 306, 306, 274, 306, 274, 306, 6145, 41115, 3, 4, 0, 0, 0, 0, 0, 108544, 108544, 108544, 0, 26624,
  28672, 0, 0, 108544, 0, 108544, 165, 165, 165, 165, 638, 0, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165,
  920, 921, 165, 165, 290, 698, 699, 0, 0, 165, 290, 290, 0, 0, 0, 0, 709, 0, 0, 0, 0, 0, 108544, 108544, 108544,
  108544, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 321, 0, 0, 0, 338, 0, 221, 221, 370, 221, 715, 530, 0, 0, 718, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 200, 0, 0, 0, 165, 779, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 790, 165,
  165, 165, 165, 165, 1050, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 1145, 290, 290, 290, 290, 290, 165, 165,
  165, 796, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 1244, 165, 165, 165, 290, 290, 290, 290, 809,
  165, 165, 165, 165, 165, 165, 165, 165, 51850, 290, 290, 290, 290, 290, 290, 1079, 290, 290, 290, 290, 290, 0, 0, 0,
  0, 0, 874, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 997, 998, 165, 165, 925, 165, 165, 165, 165, 165, 165, 165, 165,
  165, 165, 165, 165, 165, 943, 165, 165, 165, 165, 165, 165, 165, 165, 165, 1118, 165, 165, 165, 165, 165, 165, 165,
  165, 1123, 165, 165, 165, 165, 165, 165, 165, 290, 290, 1133, 290, 290, 290, 290, 290, 1205, 290, 290, 1207, 290, 290,
  290, 290, 290, 1212, 1214, 290, 290, 290, 1365, 290, 0, 165, 165, 165, 165, 165, 165, 165, 165, 290, 290, 953, 290,
  290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 974, 290, 290, 275, 275, 307, 275, 275, 275, 275, 275,
  307, 275, 275, 275, 275, 275, 307, 307, 307, 307, 307, 275, 307, 275, 307, 6145, 41115, 3, 4, 0, 0, 0, 0, 0, 114688,
  0, 0, 0, 0, 0, 0, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152,
  561152, 0, 0, 129024, 0, 290, 290, 290, 290, 481, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 984, 290, 290,
  290, 290, 0, 0, 0, 0, 590, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 165, 165, 165, 165, 165, 165, 165, 165, 778, 165, 165, 165,
  165, 609, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 1025, 165, 165, 165, 165, 165, 165, 165, 165, 1032,
  165, 165, 51850, 530, 290, 290, 290, 290, 290, 290, 290, 662, 290, 290, 290, 290, 290, 290, 1285, 290, 290, 290, 290,
  290, 290, 290, 290, 290, 1208, 1209, 290, 290, 290, 290, 290, 221, 752, 221, 221, 221, 221, 221, 221, 221, 221, 221,
  221, 221, 0, 762, 0, 0, 0, 200, 0, 0, 0, 0, 0, 26624, 28672, 0, 0, 0, 0, 0, 0, 0, 0, 354, 0, 0, 0, 221, 221, 221, 221,
  24576, 213, 213, 237, 237, 237, 237, 213, 237, 213, 213, 213, 213, 213, 213, 213, 213, 213, 213, 213, 213, 237, 276,
  213, 276, 276, 276, 308, 276, 276, 276, 276, 276, 308, 276, 276, 276, 276, 276, 308, 308, 308, 308, 308, 276, 308,
  276, 308, 6145, 41115, 3, 4, 0, 0, 0, 0, 0, 120832, 0, 0, 0, 0, 0, 0, 561152, 561152, 561152, 561152, 561152, 561152,
  561152, 561152, 561152, 561152, 561152, 561152, 561152, 0, 116736, 0, 277, 277, 309, 277, 277, 277, 277, 277, 309,
  277, 277, 277, 277, 277, 309, 309, 309, 309, 309, 277, 309, 277, 309, 6145, 41115, 3, 4, 0, 0, 0, 0, 0, 122880, 0,
  122880, 122880, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 559, 0, 0, 0, 0, 0, 0, 0, 0, 221, 221, 221, 1006, 221, 221, 221, 221,
  377, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 0, 0, 0, 0, 0, 125168, 0, 125168, 125168, 6145, 0, 3,
  0, 0, 0, 0, 0, 0, 0, 532480, 201, 0, 0, 20480, 0, 0, 0, 0, 0, 0, 0, 532480, 201, 0, 0, 0, 0, 0, 360448, 0, 0, 290,
  290, 290, 290, 482, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 1311, 290, 0, 1223, 165, 165, 165, 0, 0, 554, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 648, 165, 51850, 530, 290, 290,
  290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 982, 290, 290, 290, 290, 290, 290, 0, 0, 0, 0, 731, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 808960, 0, 561152, 0, 0, 163, 164, 165, 0, 0, 0, 0, 0, 0, 0, 328, 0, 0, 0, 0, 0, 137216, 0,
  137216, 0, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 879, 0, 0, 0, 882, 0, 0, 0, 0, 0, 0, 221, 1004, 221, 221, 221, 221, 221,
  221, 510, 290, 290, 290, 290, 0, 0, 165, 165, 165, 290, 290, 0, 290, 0, 0, 0, 0, 733, 0, 0, 0, 0, 0, 557, 0, 0, 0, 0,
  0, 0, 0, 594, 0, 0, 0, 0, 0, 0, 600, 602, 964, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290,
  290, 976, 0, 352256, 0, 352256, 0, 0, 352256, 352256, 0, 0, 352256, 0, 0, 0, 0, 0, 0, 0, 352256, 0, 0, 352256, 0, 0,
  0, 0, 0, 0, 0, 356352, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 408, 0, 0, 0, 0, 0, 352256, 352256, 0, 0, 0, 0, 0, 0, 352256,
  352462, 352462, 0, 0, 0, 0, 0, 352256, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 564, 0, 0, 0, 221, 0, 0, 0, 352256, 0, 352256,
  0, 352256, 0, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 137216, 0, 137216, 137216, 137216, 137216, 137216, 137216, 0, 137216, 0,
  24576, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 356352, 356352, 356352, 356352, 356352, 356352, 356352, 356352, 356352,
  356352, 356352, 356352, 356352, 0, 356352, 0, 207, 358400, 358400, 0, 0, 0, 0, 358400, 0, 358400, 358400, 358400,
  358400, 358400, 358400, 358400, 358400, 358400, 358400, 358400, 358400, 358400, 0, 358400, 0, 53248, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 108544, 0, 866304, 831488, 0, 696320, 675840, 0, 0, 675840, 696320, 561152, 772096, 831488,
  772096, 563200, 675840, 696320, 864256, 0, 714752, 0, 714752, 563200, 710656, 714752, 563200, 563200, 563200, 563200,
  563200, 563200, 563200, 860160, 0, 1293, 563200, 563200, 563200
);

(:~
 : The DFA-state to expected-token-set mapping.
 :)
declare variable $p:EXPECTED as xs:integer+ :=
(
  34, 65, 81, 97, 113, 129, 145, 496, 488, 488, 488, 190, 206, 222, 238, 254, 270, 286, 302, 318, 334, 350, 174, 366,
  382, 49, 398, 414, 430, 160, 446, 462, 478, 488, 512, 516, 525, 523, 519, 529, 533, 536, 540, 544, 548, 554, 592,
  1119, 620, 597, 1560, 1365, 1371, 597, 1377, 1548, 1361, 843, 597, 1522, 1324, 597, 1381, 1225, 1053, 652, 558, 564,
  678, 570, 1073, 574, 619, 1122, 1580, 642, 642, 664, 581, 565, 565, 586, 596, 603, 607, 632, 1450, 642, 642, 560, 565,
  565, 613, 589, 550, 617, 633, 641, 642, 642, 1454, 565, 566, 624, 630, 609, 642, 642, 667, 565, 582, 1608, 639, 642,
  666, 565, 1456, 637, 642, 666, 565, 647, 651, 653, 565, 657, 643, 565, 661, 671, 684, 1452, 675, 682, 688, 689, 693,
  697, 706, 710, 714, 718, 722, 726, 730, 734, 738, 745, 749, 859, 756, 597, 762, 597, 597, 597, 1098, 768, 597, 1141,
  597, 1564, 1578, 597, 752, 882, 597, 597, 1568, 597, 1547, 1132, 597, 1197, 597, 597, 836, 1242, 1251, 1265, 1269,
  1273, 1276, 1279, 1283, 1169, 1288, 597, 1292, 1297, 1261, 1571, 1335, 597, 773, 780, 784, 788, 792, 796, 1167, 800,
  804, 810, 814, 907, 819, 1367, 840, 1409, 847, 1257, 850, 856, 597, 863, 867, 597, 946, 1127, 930, 597, 1307, 994,
  1260, 852, 858, 876, 880, 597, 895, 899, 597, 597, 911, 916, 922, 597, 577, 597, 870, 926, 930, 597, 1187, 918, 935,
  940, 597, 872, 929, 597, 950, 954, 958, 871, 964, 597, 970, 1176, 871, 964, 1427, 974, 1313, 978, 1387, 984, 988, 998,
  1002, 1011, 1023, 1152, 1015, 1017, 1021, 1027, 597, 597, 1090, 597, 1516, 1031, 1035, 1039, 1043, 1047, 597, 1051,
  1057, 741, 1070, 1077, 1081, 966, 1085, 1348, 1089, 1066, 1094, 764, 1102, 1108, 1112, 1116, 769, 1131, 1136, 1140,
  1284, 1247, 1145, 1096, 1149, 700, 960, 1159, 991, 1418, 1164, 597, 597, 831, 834, 1173, 1186, 1191, 598, 993, 1201,
  597, 597, 833, 1060, 702, 1064, 1554, 1182, 597, 1434, 1205, 1062, 599, 1238, 1417, 1125, 1209, 1467, 758, 1543, 1194,
  1213, 1592, 597, 1222, 1614, 815, 1216, 1155, 1586, 1218, 1229, 1470, 1519, 1233, 1579, 1301, 1305, 1311, 1317, 1254,
  1346, 1322, 1293, 828, 597, 626, 1328, 1332, 597, 1341, 1354, 1104, 1345, 597, 1392, 905, 597, 1501, 1355, 597, 1160,
  1352, 597, 1359, 1347, 902, 931, 1385, 1391, 1396, 1400, 1407, 1413, 1391, 1422, 1373, 1443, 1426, 1431, 1442, 1416,
  1447, 1460, 1464, 1474, 1478, 1482, 1486, 1490, 1494, 1498, 597, 597, 1505, 1509, 1513, 1526, 1530, 1534, 1538, 1542,
  597, 1547, 1403, 597, 1552, 1558, 1573, 943, 1602, 1559, 1337, 597, 1437, 1006, 888, 597, 936, 1007, 806, 912, 597,
  1577, 597, 1004, 886, 597, 597, 1584, 835, 1438, 1590, 597, 1596, 597, 763, 1600, 597, 597, 1179, 884, 597, 1606, 597,
  825, 884, 776, 597, 1318, 891, 980, 597, 1612, 822, 890, 1613, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597,
  597, 597, 597, 597, 597, 1236, 597, 597, 1245, 597, 597, 597, 597, 1704, 1867, 1710, 1618, 2058, 1647, 1627, 1629,
  1629, 1644, 1629, 1638, 1640, 1629, 1629, 1629, 1634, 1630, 1629, 1833, 1629, 1659, 1669, 1676, 1677, 1677, 1672,
  1681, 1844, 1685, 1692, 1689, 1696, 1699, 1703, 1708, 1756, 1830, 1710, 1710, 1664, 1665, 2228, 1716, 1710, 1727,
  2440, 2437, 2440, 2440, 1780, 1782, 1781, 1782, 1782, 1782, 1782, 1783, 1757, 2436, 1710, 2568, 1805, 1817, 2401,
  2796, 2267, 1837, 2221, 1779, 1782, 1782, 1782, 2174, 1784, 1775, 1757, 2613, 2613, 1758, 1710, 1623, 1797, 1736,
  2436, 1710, 1710, 1710, 1710, 1711, 1747, 1802, 1665, 1815, 1817, 1710, 2532, 2405, 2405, 1710, 2438, 1782, 1782,
  1784, 1858, 1807, 2403, 2405, 2405, 2405, 2405, 1762, 2612, 1907, 1710, 1710, 1711, 2667, 1880, 2401, 2405, 2405,
  2405, 2799, 1710, 1710, 2404, 2405, 2799, 2439, 2440, 2440, 2440, 2440, 2441, 1783, 2175, 2401, 2405, 2406, 2438,
  2440, 2440, 2440, 1782, 1789, 2402, 2405, 2439, 1851, 1824, 2440, 2440, 1827, 2440, 2440, 2442, 1782, 1782, 1782,
  1782, 2444, 1841, 2445, 2440, 2440, 1782, 1773, 2442, 1788, 1782, 2446, 2440, 2442, 1782, 2444, 1782, 1777, 2440,
  1782, 1777, 2442, 1777, 1848, 1856, 1850, 1710, 1864, 1710, 1662, 2561, 1710, 1710, 2872, 1873, 1884, 1884, 1992,
  1890, 1922, 1922, 1886, 1943, 1921, 1946, 1899, 1912, 1922, 1914, 1918, 1902, 2081, 1926, 1933, 1937, 1940, 1950,
  1954, 1955, 1959, 1963, 1978, 1966, 2889, 1922, 1989, 1996, 2000, 2004, 1710, 1710, 2413, 2051, 2036, 1710, 2012,
  2204, 1710, 2373, 2024, 1710, 1710, 2467, 2471, 1710, 2647, 1710, 1710, 1712, 2552, 2032, 1710, 1710, 1710, 1718,
  2410, 2049, 1710, 1710, 1710, 1722, 2176, 2066, 2074, 1710, 1710, 2474, 1907, 2536, 1710, 2079, 2790, 2737, 2085,
  2088, 2090, 2094, 2098, 2102, 2105, 2108, 2116, 2116, 2115, 2112, 2120, 2123, 2127, 2795, 1710, 1710, 2028, 1710,
  2537, 1710, 1710, 1742, 1710, 1710, 2761, 1876, 2205, 2134, 1710, 1710, 1710, 1737, 1929, 2138, 2142, 1710, 1710,
  2475, 1710, 1710, 2493, 1710, 1710, 2645, 1720, 1710, 2069, 1710, 1742, 1710, 1710, 1710, 2177, 1710, 2245, 2148,
  1710, 1710, 2706, 2400, 2153, 1767, 2662, 1710, 1710, 2767, 1710, 2185, 2193, 1879, 2160, 2200, 1710, 1710, 1710,
  1767, 1710, 2429, 1710, 2143, 2164, 2189, 2174, 1710, 1710, 2810, 2227, 2633, 2500, 2199, 1710, 2209, 2187, 2213,
  2174, 1710, 1710, 1744, 1710, 1710, 1710, 1745, 1710, 1710, 1710, 1746, 1710, 1710, 2810, 2227, 1710, 2619, 2167,
  2218, 2225, 1710, 1710, 2810, 2690, 1718, 1710, 1710, 2236, 1710, 2233, 1710, 1710, 1710, 1798, 1710, 2249, 2202,
  1710, 2761, 2274, 1710, 2767, 2778, 2259, 1710, 2634, 1836, 2219, 2227, 1710, 1710, 1710, 1740, 1709, 1710, 1710,
  1710, 1820, 2271, 2501, 2221, 1710, 1710, 2880, 1710, 1710, 2882, 2227, 1710, 2250, 2777, 2770, 2194, 1710, 1710,
  2272, 2213, 2175, 1710, 1710, 1811, 2505, 2506, 2214, 1710, 1710, 1869, 1710, 2249, 2759, 2771, 2195, 2772, 1710,
  2271, 2278, 2635, 2279, 1710, 1710, 1905, 1710, 1860, 2303, 1710, 2413, 1755, 2300, 1867, 1710, 1711, 2510, 1710,
  1710, 1710, 2250, 1710, 2547, 2262, 2315, 1710, 2263, 1710, 1710, 1968, 1895, 1710, 1710, 1710, 2312, 2316, 2710,
  1868, 2712, 1710, 2710, 1710, 2710, 1710, 2313, 2710, 1710, 2313, 1868, 2711, 2239, 2239, 2239, 2400, 1711, 2324,
  1741, 1741, 2739, 2741, 2328, 2334, 2337, 2329, 2341, 2343, 2330, 2347, 2355, 2355, 2349, 2353, 2355, 2356, 1718,
  1717, 1710, 1710, 1981, 2400, 2130, 2242, 2548, 1740, 2542, 1710, 1790, 2876, 2555, 1710, 1710, 2129, 2242, 1710,
  2641, 2360, 1710, 1749, 1710, 1794, 1710, 2512, 2018, 2371, 2377, 2599, 2800, 2385, 2389, 1710, 1908, 2395, 2399,
  1710, 1710, 1974, 1710, 1709, 1740, 1710, 2045, 1710, 1710, 2043, 2899, 2452, 2018, 1710, 1710, 2044, 2675, 2421,
  2018, 2797, 2425, 2556, 1710, 1710, 2433, 2450, 2456, 2019, 1710, 1753, 1710, 2405, 2405, 2406, 1710, 1621, 1710,
  1710, 2166, 2171, 2464, 1710, 1710, 1710, 1972, 1722, 2479, 2451, 2015, 2491, 1710, 1710, 1710, 2008, 2070, 1709,
  1710, 1742, 1718, 2498, 2487, 1710, 1755, 2314, 1710, 1738, 1747, 1744, 2486, 1710, 1710, 1710, 2156, 2367, 2484,
  2516, 1710, 1766, 1710, 2176, 2729, 1710, 1809, 2523, 1710, 2796, 2273, 2220, 1710, 1710, 2893, 1710, 1711, 2366,
  2485, 2529, 1710, 1710, 1710, 2249, 1810, 2482, 2553, 1710, 1852, 2560, 1710, 1970, 1749, 1719, 1711, 2365, 2483,
  2525, 1710, 2541, 1790, 2561, 2543, 1754, 1710, 1769, 1768, 2554, 1710, 1746, 1710, 2295, 1710, 2026, 1745, 2544,
  1710, 2308, 1710, 1981, 2020, 2681, 1710, 2296, 1710, 1737, 1739, 1738, 1738, 1710, 2007, 1710, 1710, 1712, 2875,
  2730, 1710, 2228, 1710, 2008, 1710, 1710, 1721, 2128, 1710, 2708, 1710, 2177, 2730, 2253, 1710, 2027, 1710, 2203,
  1710, 1710, 1710, 1764, 2229, 2565, 2572, 1717, 2567, 2574, 2578, 2585, 2581, 2584, 2584, 2584, 2589, 2594, 2594,
  2593, 2594, 2594, 2598, 1710, 1710, 1710, 2400, 2254, 1710, 2555, 2682, 2603, 1710, 1710, 2381, 2689, 2617, 1710,
  1711, 2646, 2519, 2623, 1710, 2724, 1710, 2609, 1710, 1710, 2181, 1767, 2606, 2627, 2175, 1710, 2283, 1710, 2631,
  1710, 1710, 1710, 2494, 1710, 2639, 1710, 1710, 2201, 2428, 2687, 1985, 1710, 2651, 1710, 2657, 2175, 1710, 2055,
  1710, 1710, 1741, 1710, 1710, 2666, 2671, 2702, 1710, 2546, 2400, 1710, 1710, 1710, 2653, 2698, 2702, 2460, 1710,
  1710, 1710, 2694, 1710, 2729, 2254, 2679, 2400, 1710, 2865, 1984, 1710, 1710, 2244, 2147, 1710, 2694, 1710, 1710,
  2252, 1710, 2039, 2864, 2701, 2459, 2038, 2864, 2701, 2400, 2717, 2689, 1710, 2201, 2769, 2293, 2428, 1710, 1710,
  1710, 2727, 1710, 2716, 2700, 2660, 1710, 2254, 2555, 1710, 2075, 1767, 1798, 1710, 2254, 1710, 1710, 2255, 1710,
  1710, 2417, 1710, 2201, 2554, 1710, 1710, 1710, 2363, 2415, 2747, 1710, 2677, 1732, 1710, 1710, 1710, 2760, 2746,
  2554, 2734, 1710, 2128, 2243, 1710, 1972, 1710, 1710, 1718, 2251, 1710, 1710, 2721, 1710, 2745, 2553, 2545, 1710,
  2149, 2440, 2440, 2443, 1782, 1782, 1782, 1784, 1710, 2798, 1732, 1710, 2061, 2543, 1710, 2535, 2554, 1710, 1711,
  1747, 2295, 1710, 1737, 2796, 2751, 2796, 1730, 2555, 2061, 2752, 2797, 1731, 1710, 2062, 2753, 2757, 2554, 2061,
  2554, 2062, 2796, 2765, 2062, 2796, 2765, 2776, 2782, 2784, 2785, 2789, 1710, 2155, 2686, 1984, 1710, 2794, 2804,
  2034, 2815, 1710, 2044, 2804, 2808, 2817, 2806, 1710, 2229, 2320, 1710, 1739, 1737, 1710, 1740, 2863, 2688, 1650,
  1653, 1655, 2821, 2825, 2828, 2831, 2833, 2831, 2837, 2839, 2854, 2846, 2843, 2853, 2849, 2858, 1710, 1710, 1710,
  2795, 1743, 1710, 1710, 1710, 2811, 1710, 2869, 1710, 1711, 2025, 1710, 1748, 1722, 1710, 1710, 1710, 2861, 2380,
  1972, 1710, 2243, 1710, 2286, 2470, 1710, 2242, 1710, 1710, 1723, 2471, 1970, 2646, 1721, 1710, 1710, 1710, 2438,
  1819, 1894, 1739, 1710, 2473, 1710, 2886, 1719, 1710, 1710, 2305, 2554, 1968, 1895, 1710, 1744, 1893, 2472, 1710,
  1710, 2391, 2471, 2289, 1710, 1710, 1710, 2403, 2405, 2897, 1710, 1747, 1710, 1710, 2307, 262208, -2147483584,
  268451840, 16384, 1, 0, 0, 48, 56, 33587200, -2147450880, 32768, 32768, 32768, 32768, -2147483400, 1048576, 294976,
  32832, 32832, 33849344, -2147450880, -2147450880, -2147450880, 32768, 32768, 32792, 33849344, -2147450880, 32768,
  32832, 134234112, 16384, 8192, 2048, 38912, 0, 512, 8192, 38912, 16896, 8456448, 32768, 32768, 131072, 0, 0, 128, 128,
  128, 0, 163840, 163840, 163840, 67141632, -2080342016, 67141632, 67141632, 163904, 67141632, 67141632, 67141632,
  67141632, 67272704, 262144, 67141632, -2113634304, 1610874880, 278528, -2147188736, 294912, -2147221256, 1610907648,
  17072128, 17072128, 1610907648, -2147188736, 294912, -2130411272, -2130411272, -2130411272, -2130411272, 67403776,
  -2130411272, 67403776, -2063302408, 4, 524288, 2097152, 4194304, 4194304, 268435456, 0, 0, 0, 0, 1, 8, 1048576,
  1048576, 0, 0, 0, 2, 0, 0, 0, 3, 48, 0, 16, 24, 0, 0, 524288, 8388608, 16777216, 0, 65792, 0, 0, 1024, 0, 0, 0, 4, 0,
  0, 0, 8, 0, 0, 0, 16, 0, 0, 8388608, 0, 0, 0, 64, 64, 64, 0, 131072, 67108864, 0, 0, 1, 32768, 0, 0, 0, 1536, 2097152,
  17039360, 1610612736, 0, 262144, 17039360, 17039360, 262144, 262144, 16777216, 17039360, 17039360, 17039360, 17039360,
  536870912, 1073741824, 48, 17039360, 0, 0, 0, 128, 0, 48, 32, 128, 0, 0, 512, 0, 0, 32, 32, 128, 0, 65536, 256, 0, 0,
  2, 4, 64, 128, 65536, 65536, 256, 256, 0, 0, 2, 8, 16, 131072, 262144, 262144, 262144, 0, 262144, 262144, 16384, 0,
  32768, 134288128, 75008, 32768, 196608, 262144, 524288, 16777216, 8388608, 262144, 262144, 262144, 278528, 17039360,
  294912, 17039360, 17039360, 262144, 17039360, 0, 0, 8388608, 16777216, 262144, 17039360, 262144, 17039360, 0, 64, 512,
  524288, 4, 2048, 134217728, 268435456, -2147483648, 0, 0, 0, -1342177280, 0, 134217728, 268435456, 0, 0, 557056,
  301989888, 0, 128, 128, 0, 1, 268500992, 8, 8, 131080, 8, 524296, 1048584, 134217736, 8, 16, 32, 64, 512, 1024,
  1048600, -2147483624, 520, 520, 8, 8, 8, 32, 64, 0, 0, 0, 239, 1572872, 524296, 8, 8, 524296, 134217736, 8, 524824,
  1048600, 24, 8, 8, 8, 8, 1049112, 1097752, 520, 0, 0, 688128, 753664, 1, 520, 8, 1359896, 520, 1359898, 81788928,
  1049112, 0, 8, 10, 8, 8, 10, 10, 12, 536, 8, 2066743832, 24, 2066743832, 2066744984, 2066745016, 2066745016,
  2066745016, -80738632, 2066745016, 2066794168, -80214184, 2066794168, -80214182, 2066794170, 2067056312, 2066794170,
  8, 0, 0, 2, 16, 512, 0, 0, 0, 2, 1048576, 2067056314, 2066794170, 2066794170, 0, 0, 1048576, 2097152, 33554432,
  67108864, 134217728, 0, 8, 56, 73404418, 10, 24, 520, 262152, 1048600, 49160, 73412618, 73462926, 73462942, 73462926,
  73462926, 2066794170, 74511518, 2067056314, 2138060442, 0, 0, 4194304, 0, 0, 65536, 0, 8, 262144, 524288, 27262976,
  33554432, -1610612736, 0, 0, 0, 16777216, 0, 12, 0, 0, 0, 1024, 33554432, 0, 50331648, 1610612736, 0, 0, 4, 2048, 0,
  0, 4, 8, 128, 71303168, 0, 0, 0, 2048, -2147483648, 121634816, 2048, 0, 0, 6, 0, 0, 8, 256, 16384, 16384, 134217728,
  0, 0, 131072, 524288, 8388608, 256, 256, 1024, 16384, 1073741824, 1, 0, 0, 33587200, 0, 0, 0, 4096, 524288, 256, 8, 0,
  520, 1573400, 0, 302547464, 302547592, 839615104, 839615104, 839615104, 302547592, 302547592, 839418504, 839418504,
  839418504, 839418504, 839418504, 839549576, 839549576, 839615112, 839615112, 839419528, 839615116, 839419528,
  839615116, 839615116, 839615116, 839615116, 2131722976, 839615116, 2131722992, 2136967920, -14710048, -14710046,
  -14710046, -14710048, -14710048, -14710048, -14710048, -10515726, -10515726, -10515726, -10515726, -14710036,
  -10515726, -14710036, -10515718, 0, 0, 0, 16384, 1073741824, 0, 0, 640, 753664, 838860800, 1664, 0, 736, 1015808,
  2130706432, 0, 0, 0, 163840, 2064384, -16777216, 0, 0, 0, 262144, 0, 6258688, 0, 0, 6, 8, 128, 512, 229376, 524288,
  301989888, 229376, 0, 224, 512, 2048, 229376, 262144, 262144, 1572864, 520093696, 536870912, 1073741824, 0, 0, 0, 256,
  2048, 0, 5767168, 0, 5767168, 0, 128, 128, 512, 229376, 262144, 524288, 520093696, 229376, 524288, 33554432,
  268435456, 0, 0, 0, 536870912, 0, 0, 0, 524288, 0, 0, 0, 640, 0, 163840, 229376, 96, 524288, 16777216, 33554432,
  469762048, -1073741824, 524288, 1048576, 16777216, 33554432, 469762048, 1073741824, 0, 469762048, 536870912,
  -1073741824, 0, 0, 0, 1048576, 0, 4194304, 4194304, 32768, 0, 0, 838860800, 0, 0, 134217728, 0, 1, 0, 0, 0, 2784,
  2064384, 0, 33554432, 0, 0, 0, 2097152, 0, 0, 0, 6258688, 196608, 524288, 33554432, 268435456, 64, 201326592,
  268435456, -2147483648, 196608, 96, 512, 32768, 0, 131072, 96, 512, 131072, 524288, 33554432, 131072, 524288,
  201326592, 268435456, -1073741824, 0, 2048, -1073741824, 0, 1, 2, 8, 32, 64, 1024, 524288, 268435456, 0, 0, 8, 1024,
  0, 512, 2048, 524288, 201326592, 268435456, 0, 0, 8, 1536, 16777216, 0, 0, 0, 64, 134217728, 0, 0, -2147483648, 0, 0,
  1048576, 0, 0, 1073758208, 0, 1048576, 1073758208, 268435456, -2147481594, -1551718234, -1551718234, -1551718234,
  -1551718234, -1549095194, -1551718234, -1577015258, -1551718234, -1577015258, -1576884186, -1576884186, -1560106842,
  -1551718234, -1551718234, -1550669658, -1551718234, -1551718234, -1551718234, -1283282778, -1549095194, -1481724177,
  -1481724177, -1549095193, -1481724177, -1481724177, -1347440913, -1481724177, -1481724177, -1481724177, -1481724177,
  0, 40960, 58851328, -1610612736, 0, 1, 2, 12, 64, 128, 1536, 2048, 0, 33685504, 0, 0, 8, 131072, 166, 50462720,
  58851328, 0, 1, 2, 16, 3072, 3584, 40960, 61472768, -1610612736, 239, 128843776, 0, 0, 11, 48, 3584, 40960, 128843776,
  -1610612736, 128909312, 134217728, 0, 0, 0, 8388608, 131072, 131072, 131072, 131072, 0, 4, 32, 128, 2048, -2147483648,
  0, 0, 8, 4096, 196608, 2097152, 0, 32, 8192, 32768, 0, 128, 16777216, 25165824, 0, 0, 0, 536870912, 2, 4, 32, 64,
  262144, 0, 0, 262144, 262144, 262144, 262144, 17039360, 17039360, 17039360, 0, 262144, 262144, 128, 3584, 8192, 32768,
  131072, 25165824, 131072, 524288, 27262976, 33554432, 67108864, 134217728, 1073741824, 0, 12, 262144, 67108864, 0, 1,
  2, 48, 64, 512, 1024, 0, 0, 8, 32, 0, 12, 32, 64, 128, 1536, 131072, 524288, 2097152, 8388608, 16777216, -2147483648,
  0, 67108864, -1610612736, 0, 0, 32, 64, 0, 4, 128, 2048, 131072, 262144, 524288, 16777216, 1536, 2048, 131072, 524288,
  1048576, 12, 67108864, 0, 0, 38, 40960, 16777216, 67108864, -2147483648, 0, 1, 6, 24, 128, 131072, 8388608, 16777216,
  67108864, 0, 0, 128, 16777216, 8388608, 0, 131072, 131072, 0, 0, 524288, 1280, 0, 0, 128, 8388608, 16777216, 0,
  16777216, 0, 0, 268435456, 0, 0, 1536, 2097152, 8388608, 16777216, 0, 0, 0, 26214400, 0, 16777216, 8388608, 0, 0, 0,
  16777216, 1048576, 0, 0, 1048576, 1048576, 0, 268435456, 135268352, 0, 135268352, 0, 0, 137366528, 137366528,
  137366547, 137366545, 137366545, 137366547, 137366547, 137366547, 137366547, 137366545, 137366547, 238279711,
  405802003, 238279711, 1312545823, 1337711775, 1337711775, 1337711775, 1337711775, 1337711775, 0, 0, 0, 59899904, 0,
  3072, 136314880, 0, 1, 6, 152, 770048, 262144000, 1073741824, 64, 64, 64, 64, 1048576, 136314880, 0, 0, 96, 128, 7168,
  245760, 1048576, 236978176, 7168, 770048, 1048576, 262144000, 0, 1073741824, 0, 0, 96, 512, 2048, 131072, 0, 3072, 0,
  0, 166, 2048, 1, 16, 0, 0, 0, 79691776, 0, 402653184, 0, 0, 231, 0, 0, 128, 720896, 25165824, 134217728, 0, 0, 256,
  16384, 1, 6, 8, 16, 7168, 128, 7168, 49152, 720896, 1048576, -2147483648, 0, 2097152, 0, 16777216, 0, 268435456,
  134217728, 0, 0, 6144, 49152, 196608, 1048576, 2097152, 134217728, 0, 0, 128, 524288, 25165824, 1073741824, 6144,
  49152, 196608, 524288, 1048576, 2097152, 25165824, 33554432, 0, 2048, 1048576, 2097152, 0, 0, 64, 134217728,
  -2147483648, 0, 4, 8, 4096, 32768, 196608, 8, 196608, 2097152, 0, 1, 404750336, 0, 2, 2048, 1048576, -2147483648, 0,
  0, 0, 2097152, 16777216, 0, 4, 0, 4, -2147481600, 0, 0, -2147481594, 0, 8, 196608, 524288, 2097152, 25165824, 524288,
  8388608, 16777216, 16777216, 0, 0, 0, 131072, 0, 524288, 512, 268435456, 0, 0, 524288, 8388608, 0, 0, 512, 268435456,
  0, 512, 131072, 524288, 268435456, 131072, 524288, 0, 0, 512, 32768, 131072, 524288, 0, 524288, 524288, 524288,
  524288, 524288, 524288, 0, 0, 268960256, 2048, 16384, 0, 0, 0, 131072, 0, 0, 0, 230, 0, 2048, 0, 0, 2048, 2048, 0, 0,
  2048, 1048576, 0, 2048, 8192, 2048, 0, 8192, 0, 16896, 531, 531, 531, 2579, 16896, 531, 16897, 16897, 25105, 25105,
  25107, 25107, 25107, 25105, 25107, 25107, 27155, 27155, 1651, 1659, 1659, 3707, 1659, 1651, 1659, 3707, 1659, 1659,
  3707, 18043, 28283, 9851, 1659, 1659, 1659, 1659, 1659, 28283, 26235, 0, 4, 8, 6144, 16384, 32768, 196608, 1048576, 3,
  16, 512, 0, 4, 64, 128, 1536, 524288, 2097152, 8388608, 0, 11, 0, 0, 2048, 1572864, 16, 512, 16, 0, 8, 0, 268500992,
  0, 32, 64, 1024, 0, 32, 0, 0, 8192, 0
);

(:~
 : The token-string table.
 :)
declare variable $p:TOKEN as xs:string+ :=
(
  "EPSILON",
  "END",
  "DirCommentContents",
  "IntegerLiteral",
  "DecimalLiteral",
  "DoubleLiteral",
  "StringLiteral",
  "TextNodeLiteral",
  "PredefinedEntityRef",
  "'""""'",
  "EscapeApos",
  "ElementContentChar",
  "QuotAttrContentChar",
  "AposAttrContentChar",
  "S",
  "S",
  "CharRef",
  "NCName",
  "QName",
  "PITarget",
  "CommentContents",
  "PragmaContents",
  "DirPIContents",
  "CDataSection",
  "Wildcard",
  "EOF",
  "'!='",
  "'""'",
  "'#)'",
  "'#current'",
  "'#default'",
  "'$'",
  "''''",
  "'('",
  "'(#'",
  "'(:'",
  "')'",
  "'*'",
  "'*'",
  "'+'",
  "'+'",
  "','",
  "'-'",
  "'-->'",
  "'.'",
  "'..'",
  "'/'",
  "'//'",
  "'/>'",
  "':)'",
  "'::'",
  "':='",
  "';'",
  "'<'",
  "'<!--'",
  "'</'",
  "'<<'",
  "'<='",
  "'<?'",
  "'='",
  "'>'",
  "'>='",
  "'>>'",
  "'?'",
  "'?>'",
  "'@'",
  "'['",
  "']'",
  "'^'",
  "'ancestor'",
  "'ancestor-or-self'",
  "'and'",
  "'as'",
  "'ascending'",
  "'at'",
  "'attribute'",
  "'base-uri'",
  "'boundary-space'",
  "'by'",
  "'case'",
  "'cast'",
  "'castable'",
  "'child'",
  "'collation'",
  "'comment'",
  "'construction'",
  "'copy'",
  "'copy-namespaces'",
  "'declare'",
  "'default'",
  "'descendant'",
  "'descendant-or-self'",
  "'descending'",
  "'div'",
  "'document'",
  "'document-node'",
  "'element'",
  "'else'",
  "'empty'",
  "'empty-sequence'",
  "'encoding'",
  "'eq'",
  "'every'",
  "'except'",
  "'external'",
  "'following'",
  "'following-sibling'",
  "'for'",
  "'function'",
  "'ge'",
  "'greatest'",
  "'gt'",
  "'id'",
  "'idiv'",
  "'if'",
  "'import'",
  "'in'",
  "'include'",
  "'inherit'",
  "'instance'",
  "'intersect'",
  "'is'",
  "'item'",
  "'key'",
  "'lax'",
  "'le'",
  "'least'",
  "'let'",
  "'lt'",
  "'mod'",
  "'module'",
  "'namespace'",
  "'ne'",
  "'no-inherit'",
  "'no-preserve'",
  "'node'",
  "'of'",
  "'option'",
  "'or'",
  "'order'",
  "'ordered'",
  "'ordering'",
  "'param'",
  "'parent'",
  "'preceding'",
  "'preceding-sibling'",
  "'preserve'",
  "'processing-instruction'",
  "'return'",
  "'satisfies'",
  "'schema'",
  "'schema-attribute'",
  "'schema-element'",
  "'self'",
  "'some'",
  "'stable'",
  "'strict'",
  "'strip'",
  "'text'",
  "'then'",
  "'to'",
  "'treat'",
  "'tunnel'",
  "'typeswitch'",
  "'union'",
  "'unordered'",
  "'validate'",
  "'variable'",
  "'version'",
  "'where'",
  "'xquery'",
  "'{'",
  "'{{'",
  "'|'",
  "'}'",
  "'}}'"
);

(:~
 : Match next token in input string, starting at given index, using
 : the DFA entry state for the set of tokens that are expected in
 : the current context.
 :
 : @param $input the input string.
 : @param $begin the index where to start in input string.
 : @param $token-set the expected token set id.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:match($input as xs:string,
                         $begin as xs:integer,
                         $token-set as xs:integer) as xs:integer+
{
  let $result := $p:INITIAL[1 + $token-set]
  return p:transition($input,
                      $begin,
                      $begin,
                      $begin,
                      $result,
                      $result mod 2048,
                      0)
};

(:~
 : The DFA state transition function. If we are in a valid DFA state, save
 : it's result annotation, consume one input codepoint, calculate the next
 : state, and use tail recursion to do the same again. Otherwise, return
 : any valid result or a negative DFA state id in case of an error.
 :
 : @param $input the input string.
 : @param $begin the begin index of the current token in the input string.
 : @param $current the index of the current position in the input string.
 : @param $end the end index of the result in the input string.
 : @param $result the result code.
 : @param $current-state the current DFA state.
 : @param $previous-state the  previous DFA state.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:transition($input as xs:string,
                              $begin as xs:integer,
                              $current as xs:integer,
                              $end as xs:integer,
                              $result as xs:integer,
                              $current-state as xs:integer,
                              $previous-state as xs:integer) as xs:integer+
{
  if ($current-state = 0) then
    let $result := $result idiv 2048
    return
      if ($result != 0) then
      (
        $result mod 256 - 1,
        $begin,
        $end - $result idiv 256
      )
      else
      (
        - $previous-state,
        $begin,
        $current - 1
      )
  else
    let $c0 := (string-to-codepoints(substring($input, $current, 1)), 0)[1]
    let $c1 :=
      if ($c0 < 128) then
        $p:MAP0[1 + $c0]
      else if ($c0 < 55296) then
        let $c1 := $c0 idiv 8
        let $c2 := $c1 idiv 32
        return $p:MAP1[1 + $c0 mod 8 + $p:MAP1[1 + $c1 mod 32 + $p:MAP1[1 + $c2]]]
      else
        p:map2($c0, 1, 2)
    let $current := $current + 1
    let $i0 := 2048 * $c1 + $current-state - 1
    let $i1 := $i0 idiv 16
    let $next-state := $p:TRANSITION[$i0 mod 16 + $p:TRANSITION[$i1 + 1] + 1]
    return
      if ($next-state > 2047) then
        p:transition($input, $begin, $current, $current, $next-state, $next-state mod 2048, $current-state)
      else
        p:transition($input, $begin, $current, $end, $result, $next-state, $current-state)
};

(:~
 : Recursively translate one 32-bit chunk of an expected token bitset
 : to the corresponding sequence of token strings.
 :
 : @param $result the result of previous recursion levels.
 : @param $chunk the 32-bit chunk of the expected token bitset.
 : @param $base-token-code the token code of bit 0 in the current chunk.
 : @return the set of token strings.
 :)
declare function p:token($result as xs:string*,
                         $chunk as xs:integer,
                         $base-token-code as xs:integer) as xs:string*
{
  if ($chunk = 0) then
    $result
  else
    p:token
    (
      ($result, if ($chunk mod 2 != 0) then $p:TOKEN[$base-token-code] else ()),
      if ($chunk < 0) then $chunk idiv 2 + 2147483648 else $chunk idiv 2,
      $base-token-code + 1
    )
};

(:~
 : Calculate expected token set for a given DFA state as a sequence
 : of strings.
 :
 : @param $state the DFA state.
 : @return the set of token strings
 :)
declare function p:expected-token-set($state as xs:integer) as xs:string*
{
  if ($state > 0) then
    for $t in 0 to 5
    let $i0 := $t * 1410 + $state - 1
    let $i1 := $i0 idiv 4
    let $i2 := $i1 idiv 4
    let $i3 := $i2 idiv 16
    return p:token((), $p:EXPECTED[$i0 mod 4 + $p:EXPECTED[$i1 mod 4 + $p:EXPECTED[$i2 mod 16 + $p:EXPECTED[$i3 + 1] + 1] + 1] + 1], $t * 32 + 1)
  else
    ()
};

(:~
 : Classify codepoint by doing a tail recursive binary search for a
 : matching codepoint range entry in MAP2, the codepoint to charclass
 : map for codepoints above the surrogate block.
 :
 : @param $c the codepoint.
 : @param $lo the binary search lower bound map index.
 : @param $hi the binary search upper bound map index.
 : @return the character class.
 :)
declare function p:map2($c as xs:integer, $lo as xs:integer, $hi as xs:integer) as xs:integer
{
  if ($lo > $hi) then
    0
  else
    let $m := ($hi + $lo) idiv 2
    return
      if ($p:MAP2[$m] > $c) then
        p:map2($c, $lo, $m - 1)
      else if ($p:MAP2[2 + $m] < $c) then
        p:map2($c, $m + 1, $hi)
      else
        $p:MAP2[4 + $m]
};

(:~
 : The index of the parser state for accessing the combined
 : (i.e. level > 1) lookahead code.
 :)
declare variable $p:lk := 1;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the token that has been shifted.
 :)
declare variable $p:b0 := 2;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the token that has been shifted.
 :)
declare variable $p:e0 := 3;

(:~
 : The index of the parser state for accessing the code of the
 : level-1-lookahead token.
 :)
declare variable $p:l1 := 4;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-1-lookahead token.
 :)
declare variable $p:b1 := 5;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-1-lookahead token.
 :)
declare variable $p:e1 := 6;

(:~
 : The index of the parser state for accessing the code of the
 : level-2-lookahead token.
 :)
declare variable $p:l2 := 7;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-2-lookahead token.
 :)
declare variable $p:b2 := 8;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-2-lookahead token.
 :)
declare variable $p:e2 := 9;

(:~
 : The index of the parser state for accessing the code of the
 : level-3-lookahead token.
 :)
declare variable $p:l3 := 10;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-3-lookahead token.
 :)
declare variable $p:b3 := 11;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-3-lookahead token.
 :)
declare variable $p:e3 := 12;

(:~
 : The index of the parser state for accessing the token code that
 : was expected when an error was found.
 :)
declare variable $p:error := 13;

(:~
 : The index of the parser state that points to the first entry
 : used for collecting action results.
 :)
declare variable $p:result := 14;

(:~
 : Create a textual error message from a parsing error.
 :
 : @param $input the input string.
 : @param $error the parsing error descriptor.
 : @return the error message.
 :)
declare function p:error-message($input as xs:string, $error as element(error)) as xs:string
{
  let $begin := xs:integer($error/@b)
  let $context := string-to-codepoints(substring($input, 1, $begin - 1))
  let $linefeeds := index-of($context, 10)
  let $line := count($linefeeds) + 1
  let $column := ($begin - $linefeeds[last()], $begin)[1]
  return
    if ($error/@o) then
      concat
      (
        "syntax error, found ", $p:TOKEN[$error/@o + 1], "&#10;",
        "while expecting ", $p:TOKEN[$error/@x + 1], "&#10;",
        "after scanning ", string($error/@e - $begin), " characters at line ",
        string($line), ", column ", string($column), "&#10;",
        "...", substring($input, $begin, 32), "..."
      )
    else
      let $expected := p:expected-token-set($error/@s)
      return
        concat
        (
          "lexical analysis failed&#10;",
          "while expecting ",
          "["[exists($expected[2])],
          string-join($expected, ", "),
          "]"[exists($expected[2])],
          "&#10;",
          "after scanning ", string($error/@e - $begin), " characters at line ",
          string($line), ", column ", string($column), "&#10;",
          "...", substring($input, $begin, 32), "..."
        )
};

(:~
 : Shift one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : parser state.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:shift($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] = $code) then
  (
    subsequence($state, $p:l1, $p:e3 - $p:l1 + 1),
    0,
    $state[$p:e3],
    subsequence($state, $p:e3),
    if ($state[$p:e0] != $state[$p:b1]) then
      text {substring($input, $state[$p:e0], $state[$p:b1] - $state[$p:e0])}
    else
      (),
    let $name := $p:TOKEN[1 + $state[$p:l1]]
    let $content := substring($input, $state[$p:b1], $state[$p:e1] - $state[$p:b1])
    return
      if (starts-with($name, "'")) then
        element TOKEN {$content}
      else
        element {$name} {$content}
  )
  else
  (
    subsequence($state, 1, $p:error - 1),
    element error
    {
      attribute b {$state[$p:b1]},
      attribute e {$state[$p:e1]},
      if ($state[$p:l1] < 0) then
        attribute s {- $state[$p:l1]}
      else
        (attribute o {$state[$p:l1]}, attribute x {$code})
    },
    subsequence($state, $p:error + 1)
  )
};

(:~
 : Use p:match to fetch the next token, but skip any leading
 : whitespace.
 :
 : @param $input the input string.
 : @param $begin the index where to start.
 : @param $token-set the valid token set id.
 : @return a sequence of three values: the token code of the result
 : token, with input string positions of token begin and end.
 :)
declare function p:matchW($input as xs:string,
                          $begin as xs:integer,
                          $token-set as xs:integer) as xs:integer+
{
  let $match := p:match($input, $begin, $token-set)
  return
    if ($match[1] = 15) then                                (: S^WS :)
      p:matchW($input, $match[3], $token-set)
    else if ($match[1] = 35) then                           (: ('(' ':') :)
      let $state := p:parse-Whitespace($input, (0, 0, 0, $match, 0, $match[3], 0, 0, 0, 0, false()))
      return p:matchW($input, $state[$p:e0], $token-set)
    else
      $match
};

(:~
 : Lookahead one token on level 1 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead1W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] != 0) then
    $state
  else
    let $match := p:matchW($input, $state[$p:b1], $set)
    return
    (
      $match[1],
      subsequence($state, $p:lk + 1, $p:l1 - $p:lk - 1),
      $match,
      0, $match[3], 0,
      subsequence($state, $p:e2 + 1)
    )
};

(:~
 : Lookahead one token on level 2 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead2W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l2] != 0) then
      subsequence($state, $p:l2, $p:e2 - $p:l2 + 1)
    else
      p:matchW($input, $state[$p:b2], $set)
  return
  (
    $match[1] * 256 + $state[$p:l1],
    subsequence($state, $p:lk + 1, $p:l2 - $p:lk - 1),
    $match,
    0, $match[3], 0,
    subsequence($state, $p:e3 + 1)
  )
};

(:~
 : Lookahead one token on level 3 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead3W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l3] != 0) then
      subsequence($state, $p:l3, $p:e3 - $p:l3 + 1)
    else
      p:matchW($input, $state[$p:b3], $set)
  return
  (
    $match[1] * 65536 + $state[$p:lk],
    subsequence($state, $p:lk + 1, $p:l3 - $p:lk - 1),
    $match,
    subsequence($state, $p:e3 + 1)
  )
};

(:~
 : Lookahead one token on level 1.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead1($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] != 0) then
    $state
  else
    let $match := p:match($input, $state[$p:b1], $set)
    return
    (
      $match[1],
      subsequence($state, $p:lk + 1, $p:l1 - $p:lk - 1),
      $match,
      0, $match[3], 0,
      subsequence($state, $p:e2 + 1)
    )
};

(:~
 : Reduce the result stack. Pop $count element, wrap them in a
 : new element named $name, and push the new element.
 :
 : @param $state the parser state.
 : @param $name the name of the result node.
 : @param $count the number of child nodes.
 : @return the updated parser state.
 :)
declare function p:reduce($state as item()+, $name as xs:string, $count as xs:integer) as item()+
{
  subsequence($state, 1, $count),
  element {$name}
  {
    subsequence($state, $count + 1)
  }
};

(:~
 : Parse the 1st loop of production Comment (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Comment-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(45, $input, $state)          (: CommentContents | ('(' ':') | (':' ')') :)
    return
      if ($state[$p:l1] = 49) then                          (: (':' ')') :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 20) then                      (: CommentContents :)
            let $state := p:shift(20, $input, $state)       (: CommentContents :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-Comment($input, $state)
            return $state
        return p:parse-Comment-1($input, $state)
};

(:~
 : Parse Comment.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Comment($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(35, $input, $state)                 (: ('(' ':') :)
  let $state := p:parse-Comment-1($input, $state)
  let $state := p:shift(49, $input, $state)                 (: (':' ')') :)
  return p:reduce($state, "Comment", $count)
};

(:~
 : Parse the 1st loop of production Whitespace (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Whitespace-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(21, $input, $state)          (: END | S^WS | ('(' ':') :)
    return
      if ($state[$p:l1] = 1) then                           (: END :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 15) then                      (: S^WS :)
            let $state := p:shift(15, $input, $state)       (: S^WS :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-Comment($input, $state)
            return $state
        return p:parse-Whitespace-1($input, $state)
};

(:~
 : Parse Whitespace.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Whitespace($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-Whitespace-1($input, $state)
  return p:reduce($state, "Whitespace", $count)
};

(:~
 : Parse Value.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Value($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(12, $input, $state)            (: StringLiteral | QName^Token :)
  let $state :=
    if ($state[$p:l1] = 6) then                             (: StringLiteral :)
      let $state := p:shift(6, $input, $state)              (: StringLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(18, $input, $state)             (: QName^Token :)
      return $state
  return p:reduce($state, "Value", $count)
};

(:~
 : Parse Key.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Key($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(18, $input, $state)                 (: QName^Token :)
  return p:reduce($state, "Key", $count)
};

(:~
 : Parse the 1st loop of production KeyValuePairs (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-KeyValuePairs-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(49, $input, $state)         (: S^WS | QName^Token | EOF | ('(' ':') :)
    return
      if ($state[$p:l1] != 18) then                         (: QName^Token :)
        $state
      else
        let $state := p:parse-Key($input, $state)
        let $state := p:lookahead1W(74, $input, $state)     (: S^WS | QName^Token | EOF | ('(' ':') | '=' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 59) then                 (: '=' :)
            let $state := p:shift(59, $input, $state)       (: '=' :)
            let $state := p:lookahead1W(46, $input, $state) (: StringLiteral | S^WS | QName^Token | ('(' ':') :)
            let $state := p:parse-Value($input, $state)
            return $state
          else
            $state
        return p:parse-KeyValuePairs-1($input, $state)
};

(:~
 : Parse KeyValuePairs.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-KeyValuePairs($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-KeyValuePairs-1($input, $state)
  let $state := p:shift(25, $input, $state)                 (: EOF :)
  return p:reduce($state, "KeyValuePairs", $count)
};

(:~
 : Parse Priority.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Priority($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 3) then                             (: IntegerLiteral :)
      let $state := p:shift(3, $input, $state)              (: IntegerLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(4, $input, $state)              (: DecimalLiteral :)
      return $state
  return p:reduce($state, "Priority", $count)
};

(:~
 : Parse ParamWithDefault.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParamWithDefault($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(53, $input, $state)           (: S^WS | '$' | ('(' ':') | 'tunnel' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 162) then                      (: 'tunnel' :)
      let $state := p:parse-Tunnel($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Param($input, $state)
  let $state := p:lookahead1W(76, $input, $state)           (: S^WS | ('(' ':') | ')' | ',' | ':=' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 51) then                       (: ':=' :)
      let $state := p:shift(51, $input, $state)             (: ':=' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-ExprSingle($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "ParamWithDefault", $count)
};

(:~
 : Parse the 1st loop of production RuleParamList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RuleParamList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(58, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-ParamWithDefault($input, $state)
        return p:parse-RuleParamList-1($input, $state)
};

(:~
 : Parse RuleParamList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RuleParamList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ParamWithDefault($input, $state)
  let $state := p:parse-RuleParamList-1($input, $state)
  return p:reduce($state, "RuleParamList", $count)
};

(:~
 : Parse NextPathPatternOpt.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NextPathPatternOpt($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(77, $input, $state)           (: S^WS | ('(' ':') | ')' | ';' | '|' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 173) then                      (: '|' :)
      let $state := p:shift(173, $input, $state)            (: '|' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-PathPattern($input, $state)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-NextPathPatternOpt($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "NextPathPatternOpt", $count)
};

(:~
 : Parse KeyValue.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-KeyValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(84, $input, $state)            (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | '$' :)
  let $state :=
    if ($state[$p:l1] = 31) then                            (: '$' :)
      let $state := p:parse-VarRef($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-Literal($input, $state)
      return $state
  return p:reduce($state, "KeyValue", $count)
};

(:~
 : Parse IdValue.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IdValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(13, $input, $state)            (: StringLiteral | '$' :)
  let $state :=
    if ($state[$p:l1] = 6) then                             (: StringLiteral :)
      let $state := p:shift(6, $input, $state)              (: StringLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-VarRef($input, $state)
      return $state
  return p:reduce($state, "IdValue", $count)
};

(:~
 : Parse IdKeyPattern.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IdKeyPattern($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 112) then                           (: 'id' :)
      let $state := p:shift(112, $input, $state)            (: 'id' :)
      let $state := p:lookahead1W(27, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:shift(33, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-IdValue($input, $state)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:shift(36, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(123, $input, $state)            (: 'key' :)
      let $state := p:lookahead1W(27, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:shift(33, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(22, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:shift(6, $input, $state)              (: StringLiteral :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | ('(' ':') | ',' :)
      let $state := p:shift(41, $input, $state)             (: ',' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-KeyValue($input, $state)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:shift(36, $input, $state)             (: ')' :)
      return $state
  return p:reduce($state, "IdKeyPattern", $count)
};

(:~
 : Parse PatternAxis.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PatternAxis($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 82) then                            (: 'child' :)
      let $state := p:shift(82, $input, $state)             (: 'child' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 75) then                       (: 'attribute' :)
      let $state := p:shift(75, $input, $state)             (: 'attribute' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(65, $input, $state)             (: '@' :)
      return $state
  return p:reduce($state, "PatternAxis", $count)
};

(:~
 : Parse PatternStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PatternStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(137, $input, $state)          (: S^WS | QName^Token | Wildcard | ('(' ':') | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'include' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'param' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 75) then                            (: 'attribute' :)
      let $state := p:lookahead2W(96, $input, $state)       (: S^WS | '(' | ('(' ':') | ')' | '/' | '//' | '::' | ';' |
                                                               '[' | '|' :)
      return $state
    else if ($state[$p:l1] = 82) then                       (: 'child' :)
      let $state := p:lookahead2W(94, $input, $state)       (: S^WS | ('(' ':') | ')' | '/' | '//' | '::' | ';' | '[' |
                                                               '|' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 65                             (: '@' :)
          or $state[$p:lk] = 12875                          (: 'attribute' '::' :)
          or $state[$p:lk] = 12882) then                    (: 'child' '::' :)
      let $state := p:parse-PatternAxis($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-NodeTest($input, $state)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-PredicateList($input, $state)
  return p:reduce($state, "PatternStep", $count)
};

(:~
 : Parse RelativePathPattern.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RelativePathPattern($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-PatternStep($input, $state)
  let $state := p:lookahead1W(88, $input, $state)           (: S^WS | ('(' ':') | ')' | '/' | '//' | ';' | '|' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 46                             (: '/' :)
          or $state[$p:l1] = 47) then                       (: '//' :)
      let $state :=
        if ($state[$p:l1] = 46) then                        (: '/' :)
          let $state := p:shift(46, $input, $state)         (: '/' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(47, $input, $state)         (: '//' :)
          return $state
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-RelativePathPattern($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "RelativePathPattern", $count)
};

(:~
 : Parse PathPattern.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PathPattern($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(144, $input, $state)          (: S^WS | QName^Token | Wildcard | ('(' ':') | '/' | '//' |
                                                               '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'id' | 'idiv' | 'if' | 'import' | 'include' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'key' | 'le' |
                                                               'let' | 'lt' | 'mod' | 'module' | 'namespace' | 'ne' |
                                                               'node' | 'or' | 'order' | 'ordered' | 'param' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 46) then                            (: '/' :)
      let $state := p:shift(46, $input, $state)             (: '/' :)
      let $state := p:lookahead1W(143, $input, $state)      (: S^WS | QName^Token | Wildcard | ('(' ':') | ')' | ';' |
                                                               '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' | '|' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 36                        (: ')' :)
             and $state[$p:l1] != 52                        (: ';' :)
             and $state[$p:l1] != 173) then                 (: '|' :)
          let $state := p:parse-RelativePathPattern($input, $state)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 47) then                       (: '//' :)
      let $state := p:shift(47, $input, $state)             (: '//' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-RelativePathPattern($input, $state)
      return $state
    else if ($state[$p:l1] = 112                            (: 'id' :)
          or $state[$p:l1] = 123) then                      (: 'key' :)
      let $state := p:parse-IdKeyPattern($input, $state)
      let $state := p:lookahead1W(88, $input, $state)       (: S^WS | ('(' ':') | ')' | '/' | '//' | ';' | '|' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 46                         (: '/' :)
              or $state[$p:l1] = 47) then                   (: '//' :)
          let $state :=
            if ($state[$p:l1] = 46) then                    (: '/' :)
              let $state := p:shift(46, $input, $state)     (: '/' :)
              return $state
            else if ($state[$p:error]) then
              $state
            else
              let $state := p:shift(47, $input, $state)     (: '//' :)
              return $state
          let $state := p:lookahead1W(20, $input, $state)   (: EPSILON | S^WS | ('(' ':') :)
          let $state := p:parse-RelativePathPattern($input, $state)
          return $state
        else
          $state
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-RelativePathPattern($input, $state)
      return $state
  return p:reduce($state, "PathPattern", $count)
};

(:~
 : Parse Pattern.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Pattern($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-PathPattern($input, $state)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-NextPathPatternOpt($input, $state)
  return p:reduce($state, "Pattern", $count)
};

(:~
 : Parse the 1st loop of production RuleDecl (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RuleDecl-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(56, $input, $state)         (: S^WS | '(' | ('(' ':') | '|' :)
    return
      if ($state[$p:l1] != 173) then                        (: '|' :)
        $state
      else
        let $state := p:shift(173, $input, $state)          (: '|' :)
        let $state := p:lookahead1W(138, $input, $state)    (: S^WS | QName^Token | '#current' | '#default' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
        let $state := p:parse-ModeName($input, $state)
        return p:parse-RuleDecl-1($input, $state)
};

(:~
 : Parse RuleDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RuleDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(68, $input, $state)                 (: '^' :)
  let $state := p:lookahead1W(142, $input, $state)          (: S^WS | QName^Token | '#current' | '#default' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 33) then                      (: '(' :)
      let $state := p:parse-ModeName($input, $state)
      let $state := p:parse-RuleDecl-1($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Pattern($input, $state)
  let $state := p:lookahead1W(59, $input, $state)           (: S^WS | ('(' ':') | ')' | ';' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 52) then                       (: ';' :)
      let $state := p:shift(52, $input, $state)             (: ';' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-RuleParamList($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(73, $input, $state)           (: IntegerLiteral | DecimalLiteral | S^WS | ('(' ':') | ':=' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 51) then                      (: ':=' :)
      let $state := p:parse-Priority($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(31, $input, $state)           (: S^WS | ('(' ':') | ':=' :)
  let $state := p:shift(51, $input, $state)                 (: ':=' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  return p:reduce($state, "RuleDecl", $count)
};

(:~
 : Parse the 1st loop of production ParamList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParamList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(58, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-Param($input, $state)
        return p:parse-ParamList-1($input, $state)
};

(:~
 : Parse ParamList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParamList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-Param($input, $state)
  let $state := p:parse-ParamList-1($input, $state)
  return p:reduce($state, "ParamList", $count)
};

(:~
 : Parse FunctionDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-FunctionName($input, $state)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(51, $input, $state)           (: S^WS | '$' | ('(' ':') | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:parse-ParamList($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(64, $input, $state)           (: S^WS | ('(' ':') | ':=' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 72) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(31, $input, $state)           (: S^WS | ('(' ':') | ':=' :)
  let $state := p:shift(51, $input, $state)                 (: ':=' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  return p:reduce($state, "FunctionDecl", $count)
};

(:~
 : Parse VarDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(132, $input, $state)          (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state := p:parse-QName($input, $state)
  let $state := p:lookahead1W(64, $input, $state)           (: S^WS | ('(' ':') | ':=' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 72) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(31, $input, $state)           (: S^WS | ('(' ':') | ':=' :)
  let $state := p:shift(51, $input, $state)                 (: ':=' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  return p:reduce($state, "VarDecl", $count)
};

(:~
 : Parse Separator.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Separator($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(52, $input, $state)                 (: ';' :)
  return p:reduce($state, "Separator", $count)
};

(:~
 : Parse NodeComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NodeComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 121) then                           (: 'is' :)
      let $state := p:shift(121, $input, $state)            (: 'is' :)
      return $state
    else if ($state[$p:l1] = 56) then                       (: '<<' :)
      let $state := p:shift(56, $input, $state)             (: '<<' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(62, $input, $state)             (: '>>' :)
      return $state
  return p:reduce($state, "NodeComp", $count)
};

(:~
 : Parse GeneralComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-GeneralComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 59) then                            (: '=' :)
      let $state := p:shift(59, $input, $state)             (: '=' :)
      return $state
    else if ($state[$p:l1] = 26) then                       (: '!=' :)
      let $state := p:shift(26, $input, $state)             (: '!=' :)
      return $state
    else if ($state[$p:l1] = 53) then                       (: '<' :)
      let $state := p:shift(53, $input, $state)             (: '<' :)
      return $state
    else if ($state[$p:l1] = 57) then                       (: '<=' :)
      let $state := p:shift(57, $input, $state)             (: '<=' :)
      return $state
    else if ($state[$p:l1] = 60) then                       (: '>' :)
      let $state := p:shift(60, $input, $state)             (: '>' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(61, $input, $state)             (: '>=' :)
      return $state
  return p:reduce($state, "GeneralComp", $count)
};

(:~
 : Parse ValueComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValueComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 101) then                           (: 'eq' :)
      let $state := p:shift(101, $input, $state)            (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 132) then                      (: 'ne' :)
      let $state := p:shift(132, $input, $state)            (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 128) then                      (: 'lt' :)
      let $state := p:shift(128, $input, $state)            (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 125) then                      (: 'le' :)
      let $state := p:shift(125, $input, $state)            (: 'le' :)
      return $state
    else if ($state[$p:l1] = 111) then                      (: 'gt' :)
      let $state := p:shift(111, $input, $state)            (: 'gt' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(109, $input, $state)            (: 'ge' :)
      return $state
  return p:reduce($state, "ValueComp", $count)
};

(:~
 : Parse SingleType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SingleType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(129, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state := p:parse-AtomicType($input, $state)
  let $state := p:lookahead1W(114, $input, $state)          (: S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | '?' |
                                                               ']' | 'and' | 'ascending' | 'case' | 'castable' |
                                                               'collation' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'eq' | 'except' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'to' | 'treat' | 'union' |
                                                               'where' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 63) then                       (: '?' :)
      let $state := p:shift(63, $input, $state)             (: '?' :)
      return $state
    else
      $state
  return p:reduce($state, "SingleType", $count)
};

(:~
 : Parse Pragma.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Pragma($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(6, $input, $state)             (: '(#' :)
  let $state := p:shift(34, $input, $state)                 (: '(#' :)
  let $state := p:lookahead1(130, $input, $state)           (: S | QName^Token | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 14) then                       (: S :)
      let $state := p:shift(14, $input, $state)             (: S :)
      return $state
    else
      $state
  let $state := p:lookahead1(129, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state := p:parse-QName($input, $state)
  let $state := p:lookahead1(14, $input, $state)            (: S | '#)' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 14) then                       (: S :)
      let $state := p:shift(14, $input, $state)             (: S :)
      let $state := p:lookahead1(2, $input, $state)         (: PragmaContents :)
      let $state := p:shift(21, $input, $state)             (: PragmaContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(4, $input, $state)             (: '#)' :)
  let $state := p:shift(28, $input, $state)                 (: '#)' :)
  return p:reduce($state, "Pragma", $count)
};

(:~
 : Parse the 1st loop of production ExtensionExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ExtensionExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:parse-Pragma($input, $state)
    let $state := p:lookahead1W(57, $input, $state)         (: S^WS | '(#' | ('(' ':') | '{' :)
    return
      if ($state[$p:l1] != 34) then                         (: '(#' :)
        $state
      else
        p:parse-ExtensionExpr-1($input, $state)
};

(:~
 : Parse ExtensionExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ExtensionExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ExtensionExpr-1($input, $state)
  let $state := p:shift(171, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(149, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               '^' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 174) then                     (: '}' :)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(174, $input, $state)                (: '}' :)
  return p:reduce($state, "ExtensionExpr", $count)
};

(:~
 : Parse AbbrevForwardStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AbbrevForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 65) then                       (: '@' :)
      let $state := p:shift(65, $input, $state)             (: '@' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-NodeTest($input, $state)
  return p:reduce($state, "AbbrevForwardStep", $count)
};

(:~
 : Parse ForwardAxis.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForwardAxis($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 82) then                            (: 'child' :)
      let $state := p:shift(82, $input, $state)             (: 'child' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 90) then                       (: 'descendant' :)
      let $state := p:shift(90, $input, $state)             (: 'descendant' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 75) then                       (: 'attribute' :)
      let $state := p:shift(75, $input, $state)             (: 'attribute' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 153) then                      (: 'self' :)
      let $state := p:shift(153, $input, $state)            (: 'self' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 91) then                       (: 'descendant-or-self' :)
      let $state := p:shift(91, $input, $state)             (: 'descendant-or-self' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 106) then                      (: 'following-sibling' :)
      let $state := p:shift(106, $input, $state)            (: 'following-sibling' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(105, $input, $state)            (: 'following' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
  return p:reduce($state, "ForwardAxis", $count)
};

(:~
 : Parse ForwardStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 75) then                            (: 'attribute' :)
      let $state := p:lookahead2W(123, $input, $state)      (: S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 82                             (: 'descendant' :)
          or $state[$p:l1] = 90                             (: 'descendant-or-self' :)
          or $state[$p:l1] = 91                             (: 'following' :)
          or $state[$p:l1] = 105                            (: 'following-sibling' :)
          or $state[$p:l1] = 106                            (: 'self' :)
          or $state[$p:l1] = 153) then                      (: 'self' :)
      let $state := p:lookahead2W(121, $input, $state)      (: S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                               '/' | '//' | '::' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 12875                               (: 'attribute' '::' :)
     or $state[$p:lk] = 12882                               (: 'child' '::' :)
     or $state[$p:lk] = 12890                               (: 'descendant' '::' :)
     or $state[$p:lk] = 12891                               (: 'descendant-or-self' '::' :)
     or $state[$p:lk] = 12905                               (: 'following' '::' :)
     or $state[$p:lk] = 12906                               (: 'following-sibling' '::' :)
     or $state[$p:lk] = 12953) then                         (: 'self' '::' :)
      let $state := p:parse-ForwardAxis($input, $state)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-NodeTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AbbrevForwardStep($input, $state)
      return $state
  return p:reduce($state, "ForwardStep", $count)
};

(:~
 : Parse AbbrevReverseStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AbbrevReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(45, $input, $state)                 (: '..' :)
  return p:reduce($state, "AbbrevReverseStep", $count)
};

(:~
 : Parse NameTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NameTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 24) then                            (: Wildcard :)
      let $state := p:shift(24, $input, $state)             (: Wildcard :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-QName($input, $state)
      return $state
  return p:reduce($state, "NameTest", $count)
};

(:~
 : Parse NodeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NodeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(131, $input, $state)           (: QName^Token | Wildcard | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 75                                  (: 'comment' :)
     or $state[$p:l1] = 84                                  (: 'document-node' :)
     or $state[$p:l1] = 95                                  (: 'element' :)
     or $state[$p:l1] = 96                                  (: 'node' :)
     or $state[$p:l1] = 135                                 (: 'processing-instruction' :)
     or $state[$p:l1] = 147                                 (: 'schema-attribute' :)
     or $state[$p:l1] = 151                                 (: 'schema-element' :)
     or $state[$p:l1] = 152                                 (: 'text' :)
     or $state[$p:l1] = 158) then                           (: 'text' :)
      let $state := p:lookahead2W(120, $input, $state)      (: S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 8523                                (: 'attribute' '(' :)
     or $state[$p:lk] = 8532                                (: 'comment' '(' :)
     or $state[$p:lk] = 8543                                (: 'document-node' '(' :)
     or $state[$p:lk] = 8544                                (: 'element' '(' :)
     or $state[$p:lk] = 8583                                (: 'node' '(' :)
     or $state[$p:lk] = 8595                                (: 'processing-instruction' '(' :)
     or $state[$p:lk] = 8599                                (: 'schema-attribute' '(' :)
     or $state[$p:lk] = 8600                                (: 'schema-element' '(' :)
     or $state[$p:lk] = 8606) then                          (: 'text' '(' :)
      let $state := p:parse-KindTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NameTest($input, $state)
      return $state
  return p:reduce($state, "NodeTest", $count)
};

(:~
 : Parse ReverseAxis.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ReverseAxis($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 143) then                           (: 'parent' :)
      let $state := p:shift(143, $input, $state)            (: 'parent' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 69) then                       (: 'ancestor' :)
      let $state := p:shift(69, $input, $state)             (: 'ancestor' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'preceding-sibling' :)
      let $state := p:shift(145, $input, $state)            (: 'preceding-sibling' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 144) then                      (: 'preceding' :)
      let $state := p:shift(144, $input, $state)            (: 'preceding' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(70, $input, $state)             (: 'ancestor-or-self' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
  return p:reduce($state, "ReverseAxis", $count)
};

(:~
 : Parse ReverseStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 45) then                            (: '..' :)
      let $state := p:parse-AbbrevReverseStep($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ReverseAxis($input, $state)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-NodeTest($input, $state)
      return $state
  return p:reduce($state, "ReverseStep", $count)
};

(:~
 : Parse AxisStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AxisStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 69                                  (: 'ancestor-or-self' :)
     or $state[$p:l1] = 70                                  (: 'parent' :)
     or $state[$p:l1] = 143                                 (: 'preceding' :)
     or $state[$p:l1] = 144                                 (: 'preceding-sibling' :)
     or $state[$p:l1] = 145) then                           (: 'preceding-sibling' :)
      let $state := p:lookahead2W(121, $input, $state)      (: S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                               '/' | '//' | '::' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 45                                  (: '..' :)
     or $state[$p:lk] = 12869                               (: 'ancestor' '::' :)
     or $state[$p:lk] = 12870                               (: 'ancestor-or-self' '::' :)
     or $state[$p:lk] = 12943                               (: 'parent' '::' :)
     or $state[$p:lk] = 12944                               (: 'preceding' '::' :)
     or $state[$p:lk] = 12945) then                         (: 'preceding-sibling' '::' :)
      let $state := p:parse-ReverseStep($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ForwardStep($input, $state)
      return $state
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-PredicateList($input, $state)
  return p:reduce($state, "AxisStep", $count)
};

(:~
 : Parse Predicate.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Predicate($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(66, $input, $state)                 (: '[' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(34, $input, $state)           (: S^WS | ('(' ':') | ']' :)
  let $state := p:shift(67, $input, $state)                 (: ']' :)
  return p:reduce($state, "Predicate", $count)
};

(:~
 : Parse the 1st loop of production PredicateList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PredicateList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(118, $input, $state)        (: S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                               '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
    return
      if ($state[$p:l1] != 66) then                         (: '[' :)
        $state
      else
        let $state := p:parse-Predicate($input, $state)
        return p:parse-PredicateList-1($input, $state)
};

(:~
 : Parse PredicateList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PredicateList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-PredicateList-1($input, $state)
  return p:reduce($state, "PredicateList", $count)
};

(:~
 : Parse Tunnel.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Tunnel($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(162, $input, $state)                (: 'tunnel' :)
  return p:reduce($state, "Tunnel", $count)
};

(:~
 : Parse InitializedParam.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InitializedParam($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(53, $input, $state)           (: S^WS | '$' | ('(' ':') | 'tunnel' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 162) then                      (: 'tunnel' :)
      let $state := p:parse-Tunnel($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Param($input, $state)
  let $state := p:lookahead1W(31, $input, $state)           (: S^WS | ('(' ':') | ':=' :)
  let $state := p:shift(51, $input, $state)                 (: ':=' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "InitializedParam", $count)
};

(:~
 : Parse the 1st loop of production RulesetCallParamList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RulesetCallParamList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(58, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-InitializedParam($input, $state)
        return p:parse-RulesetCallParamList-1($input, $state)
};

(:~
 : Parse RulesetCallParamList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RulesetCallParamList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-InitializedParam($input, $state)
  let $state := p:parse-RulesetCallParamList-1($input, $state)
  return p:reduce($state, "RulesetCallParamList", $count)
};

(:~
 : Parse ModeName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ModeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(133, $input, $state)           (: QName^Token | '#current' | '#default' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 29) then                            (: '#current' :)
      let $state := p:shift(29, $input, $state)             (: '#current' :)
      return $state
    else if ($state[$p:l1] = 30) then                       (: '#default' :)
      let $state := p:shift(30, $input, $state)             (: '#default' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-QName($input, $state)
      return $state
  return p:reduce($state, "ModeName", $count)
};

(:~
 : Parse RulesetCall.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RulesetCall($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(68, $input, $state)                 (: '^' :)
  let $state := p:lookahead1W(142, $input, $state)          (: S^WS | QName^Token | '#current' | '#default' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 33) then                      (: '(' :)
      let $state := p:parse-ModeName($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(151, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | ('(' ':') | ')' | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | ';' | '<' | '<!--' |
                                                               '<?' | '@' | '^' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36                            (: ')' :)
         and $state[$p:l1] != 52) then                      (: ';' :)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(59, $input, $state)           (: S^WS | ('(' ':') | ')' | ';' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 52) then                       (: ';' :)
      let $state := p:shift(52, $input, $state)             (: ';' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-RulesetCallParamList($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "RulesetCall", $count)
};

(:~
 : Parse CompCopyConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompCopyConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(86, $input, $state)                 (: 'copy' :)
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(171, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(174, $input, $state)                (: '}' :)
  return p:reduce($state, "CompCopyConstructor", $count)
};

(:~
 : Parse CompPIConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(147, $input, $state)                (: 'processing-instruction' :)
  let $state := p:lookahead1W(103, $input, $state)          (: S^WS | NCName^Token | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '{' :)
  let $state :=
    if ($state[$p:l1] = 171) then                           (: '{' :)
      let $state := p:shift(171, $input, $state)            (: '{' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-Expr($input, $state)
      let $state := p:lookahead1W(44, $input, $state)       (: S^WS | ('(' ':') | '}' :)
      let $state := p:shift(174, $input, $state)            (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NCName($input, $state)
      return $state
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(171, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(149, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               '^' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 174) then                     (: '}' :)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(174, $input, $state)                (: '}' :)
  return p:reduce($state, "CompPIConstructor", $count)
};

(:~
 : Parse CompCommentConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(84, $input, $state)                 (: 'comment' :)
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(171, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(174, $input, $state)                (: '}' :)
  return p:reduce($state, "CompCommentConstructor", $count)
};

(:~
 : Parse CompTextConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompTextConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(158, $input, $state)                (: 'text' :)
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(171, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(174, $input, $state)                (: '}' :)
  return p:reduce($state, "CompTextConstructor", $count)
};

(:~
 : Parse CompAttrConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompAttrConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(75, $input, $state)                 (: 'attribute' :)
  let $state := p:lookahead1W(136, $input, $state)          (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' | '{' :)
  let $state :=
    if ($state[$p:l1] = 171) then                           (: '{' :)
      let $state := p:shift(171, $input, $state)            (: '{' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-Expr($input, $state)
      let $state := p:lookahead1W(44, $input, $state)       (: S^WS | ('(' ':') | '}' :)
      let $state := p:shift(174, $input, $state)            (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-QName($input, $state)
      return $state
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(171, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(149, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               '^' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 174) then                     (: '}' :)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(174, $input, $state)                (: '}' :)
  return p:reduce($state, "CompAttrConstructor", $count)
};

(:~
 : Parse ContentExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ContentExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-Expr($input, $state)
  return p:reduce($state, "ContentExpr", $count)
};

(:~
 : Parse CompElemConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(96, $input, $state)                 (: 'element' :)
  let $state := p:lookahead1W(136, $input, $state)          (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' | '{' :)
  let $state :=
    if ($state[$p:l1] = 171) then                           (: '{' :)
      let $state := p:shift(171, $input, $state)            (: '{' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-Expr($input, $state)
      let $state := p:lookahead1W(44, $input, $state)       (: S^WS | ('(' ':') | '}' :)
      let $state := p:shift(174, $input, $state)            (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-QName($input, $state)
      return $state
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(171, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(149, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               '^' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 174) then                     (: '}' :)
      let $state := p:parse-ContentExpr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(174, $input, $state)                (: '}' :)
  return p:reduce($state, "CompElemConstructor", $count)
};

(:~
 : Parse CompDocConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompDocConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(94, $input, $state)                 (: 'document' :)
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(171, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(174, $input, $state)                (: '}' :)
  return p:reduce($state, "CompDocConstructor", $count)
};

(:~
 : Parse ComputedConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ComputedConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 94) then                            (: 'document' :)
      let $state := p:parse-CompDocConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 96) then                       (: 'element' :)
      let $state := p:parse-CompElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 75) then                       (: 'attribute' :)
      let $state := p:parse-CompAttrConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 158) then                      (: 'text' :)
      let $state := p:parse-CompTextConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'comment' :)
      let $state := p:parse-CompCommentConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 147) then                      (: 'processing-instruction' :)
      let $state := p:parse-CompPIConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CompCopyConstructor($input, $state)
      return $state
  return p:reduce($state, "ComputedConstructor", $count)
};

(:~
 : Parse DirPIConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(58, $input, $state)                 (: '<?' :)
  let $state := p:lookahead1(1, $input, $state)             (: PITarget :)
  let $state := p:shift(19, $input, $state)                 (: PITarget :)
  let $state := p:lookahead1(17, $input, $state)            (: S | '?>' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 14) then                       (: S :)
      let $state := p:shift(14, $input, $state)             (: S :)
      let $state := p:lookahead1(3, $input, $state)         (: DirPIContents :)
      let $state := p:shift(22, $input, $state)             (: DirPIContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(10, $input, $state)            (: '?>' :)
  let $state := p:shift(64, $input, $state)                 (: '?>' :)
  return p:reduce($state, "DirPIConstructor", $count)
};

(:~
 : Parse DirCommentConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(54, $input, $state)                 (: '<!--' :)
  let $state := p:lookahead1(0, $input, $state)             (: DirCommentContents :)
  let $state := p:shift(2, $input, $state)                  (: DirCommentContents :)
  let $state := p:lookahead1(7, $input, $state)             (: '-->' :)
  let $state := p:shift(43, $input, $state)                 (: '-->' :)
  return p:reduce($state, "DirCommentConstructor", $count)
};

(:~
 : Parse DirElemContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirElemContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 53                                  (: '<' :)
     or $state[$p:l1] = 54                                  (: '<!--' :)
     or $state[$p:l1] = 58) then                            (: '<?' :)
      let $state := p:parse-DirectConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 23) then                       (: CDataSection :)
      let $state := p:shift(23, $input, $state)             (: CDataSection :)
      return $state
    else if ($state[$p:l1] = 11) then                       (: ElementContentChar :)
      let $state := p:shift(11, $input, $state)             (: ElementContentChar :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CommonContent($input, $state)
      return $state
  return p:reduce($state, "DirElemContent", $count)
};

(:~
 : Parse AposAttrValueContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AposAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 13) then                            (: AposAttrContentChar :)
      let $state := p:shift(13, $input, $state)             (: AposAttrContentChar :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CommonContent($input, $state)
      return $state
  return p:reduce($state, "AposAttrValueContent", $count)
};

(:~
 : Parse EnclosedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EnclosedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(171, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(174, $input, $state)                (: '}' :)
  return p:reduce($state, "EnclosedExpr", $count)
};

(:~
 : Parse CommonContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CommonContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 8) then                             (: PredefinedEntityRef :)
      let $state := p:shift(8, $input, $state)              (: PredefinedEntityRef :)
      return $state
    else if ($state[$p:l1] = 16) then                       (: CharRef :)
      let $state := p:shift(16, $input, $state)             (: CharRef :)
      return $state
    else if ($state[$p:l1] = 172) then                      (: '{{' :)
      let $state := p:shift(172, $input, $state)            (: '{{' :)
      return $state
    else if ($state[$p:l1] = 175) then                      (: '}}' :)
      let $state := p:shift(175, $input, $state)            (: '}}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-EnclosedExpr($input, $state)
      return $state
  return p:reduce($state, "CommonContent", $count)
};

(:~
 : Parse QuotAttrValueContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QuotAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 12) then                            (: QuotAttrContentChar :)
      let $state := p:shift(12, $input, $state)             (: QuotAttrContentChar :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CommonContent($input, $state)
      return $state
  return p:reduce($state, "QuotAttrValueContent", $count)
};

(:~
 : Parse the 1st loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeValue-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(90, $input, $state)          (: PredefinedEntityRef | EscapeQuot | QuotAttrContentChar |
                                                               CharRef | '"' | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 27) then                          (: '"' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 9) then                       (: EscapeQuot :)
            let $state := p:shift(9, $input, $state)        (: EscapeQuot :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-QuotAttrValueContent($input, $state)
            return $state
        return p:parse-DirAttributeValue-1($input, $state)
};

(:~
 : Parse the 2nd loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeValue-2($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(91, $input, $state)          (: PredefinedEntityRef | EscapeApos | AposAttrContentChar |
                                                               CharRef | "'" | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 32) then                          (: "'" :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 10) then                      (: EscapeApos :)
            let $state := p:shift(10, $input, $state)       (: EscapeApos :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-AposAttrValueContent($input, $state)
            return $state
        return p:parse-DirAttributeValue-2($input, $state)
};

(:~
 : Parse DirAttributeValue.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(18, $input, $state)            (: '"' | "'" :)
  let $state :=
    if ($state[$p:l1] = 27) then                            (: '"' :)
      let $state := p:shift(27, $input, $state)             (: '"' :)
      let $state := p:parse-DirAttributeValue-1($input, $state)
      let $state := p:shift(27, $input, $state)             (: '"' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(32, $input, $state)             (: "'" :)
      let $state := p:parse-DirAttributeValue-2($input, $state)
      let $state := p:shift(32, $input, $state)             (: "'" :)
      return $state
  return p:reduce($state, "DirAttributeValue", $count)
};

(:~
 : Parse the 1st loop of production DirAttributeList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(24, $input, $state)          (: S | '/>' | '>' :)
    return
      if ($state[$p:l1] != 14) then                         (: S :)
        $state
      else
        let $state := p:shift(14, $input, $state)           (: S :)
        let $state := p:lookahead1(134, $input, $state)     (: S | QName^Token | '/>' | '>' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] != 14                      (: S :)
               and $state[$p:l1] != 48                      (: '/>' :)
               and $state[$p:l1] != 60) then                (: '>' :)
            let $state := p:parse-QName($input, $state)
            let $state := p:lookahead1(15, $input, $state)  (: S | '=' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 14) then             (: S :)
                let $state := p:shift(14, $input, $state)   (: S :)
                return $state
              else
                $state
            let $state := p:lookahead1(8, $input, $state)   (: '=' :)
            let $state := p:shift(59, $input, $state)       (: '=' :)
            let $state := p:lookahead1(23, $input, $state)  (: S | '"' | "'" :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 14) then             (: S :)
                let $state := p:shift(14, $input, $state)   (: S :)
                return $state
              else
                $state
            let $state := p:parse-DirAttributeValue($input, $state)
            return $state
          else
            $state
        return p:parse-DirAttributeList-1($input, $state)
};

(:~
 : Parse DirAttributeList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-DirAttributeList-1($input, $state)
  return p:reduce($state, "DirAttributeList", $count)
};

(:~
 : Parse the 1st loop of production DirElemConstructor (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirElemConstructor-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(97, $input, $state)          (: PredefinedEntityRef | ElementContentChar | CharRef |
                                                               CDataSection | '<' | '<!--' | '</' | '<?' | '{' | '{{' |
                                                               '}}' :)
    return
      if ($state[$p:l1] = 55) then                          (: '</' :)
        $state
      else
        let $state := p:parse-DirElemContent($input, $state)
        return p:parse-DirElemConstructor-1($input, $state)
};

(:~
 : Parse DirElemConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(53, $input, $state)                 (: '<' :)
  let $state := p:lookahead1(129, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state := p:parse-QName($input, $state)
  let $state := p:parse-DirAttributeList($input, $state)
  let $state := p:lookahead1(19, $input, $state)            (: '/>' | '>' :)
  let $state :=
    if ($state[$p:l1] = 48) then                            (: '/>' :)
      let $state := p:shift(48, $input, $state)             (: '/>' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(60, $input, $state)             (: '>' :)
      let $state := p:parse-DirElemConstructor-1($input, $state)
      let $state := p:shift(55, $input, $state)             (: '</' :)
      let $state := p:lookahead1(129, $input, $state)       (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
      let $state := p:parse-QName($input, $state)
      let $state := p:lookahead1(16, $input, $state)        (: S | '>' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 14) then                   (: S :)
          let $state := p:shift(14, $input, $state)         (: S :)
          return $state
        else
          $state
      let $state := p:lookahead1(9, $input, $state)         (: '>' :)
      let $state := p:shift(60, $input, $state)             (: '>' :)
      return $state
  return p:reduce($state, "DirElemConstructor", $count)
};

(:~
 : Parse DirectConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirectConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 53) then                            (: '<' :)
      let $state := p:parse-DirElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 54) then                       (: '<!--' :)
      let $state := p:parse-DirCommentConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-DirPIConstructor($input, $state)
      return $state
  return p:reduce($state, "DirectConstructor", $count)
};

(:~
 : Parse Constructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Constructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 53                                  (: '<' :)
     or $state[$p:l1] = 54                                  (: '<!--' :)
     or $state[$p:l1] = 58) then                            (: '<?' :)
      let $state := p:parse-DirectConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ComputedConstructor($input, $state)
      return $state
  return p:reduce($state, "Constructor", $count)
};

(:~
 : Parse UnorderedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnorderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(165, $input, $state)                (: 'unordered' :)
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(171, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(174, $input, $state)                (: '}' :)
  return p:reduce($state, "UnorderedExpr", $count)
};

(:~
 : Parse OrderedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(140, $input, $state)                (: 'ordered' :)
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(171, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(174, $input, $state)                (: '}' :)
  return p:reduce($state, "OrderedExpr", $count)
};

(:~
 : Parse the 1st loop of production FunctionCall (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionCall-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(58, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-ExprSingle($input, $state)
        return p:parse-FunctionCall-1($input, $state)
};

(:~
 : Parse FunctionCall.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionCall($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-FunctionName($input, $state)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(147, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | ('(' ':') | ')' | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | '^' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36) then                      (: ')' :)
      let $state := p:parse-ExprSingle($input, $state)
      let $state := p:parse-FunctionCall-1($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "FunctionCall", $count)
};

(:~
 : Parse ContextItemExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ContextItemExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(44, $input, $state)                 (: '.' :)
  return p:reduce($state, "ContextItemExpr", $count)
};

(:~
 : Parse ParenthesizedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParenthesizedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(147, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | ('(' ':') | ')' | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | '^' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36) then                      (: ')' :)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "ParenthesizedExpr", $count)
};

(:~
 : Parse VarRef.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarRef($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(132, $input, $state)          (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  return p:reduce($state, "VarRef", $count)
};

(:~
 : Parse NumericLiteral.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NumericLiteral($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 3) then                             (: IntegerLiteral :)
      let $state := p:shift(3, $input, $state)              (: IntegerLiteral :)
      return $state
    else if ($state[$p:l1] = 4) then                        (: DecimalLiteral :)
      let $state := p:shift(4, $input, $state)              (: DecimalLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(5, $input, $state)              (: DoubleLiteral :)
      return $state
  return p:reduce($state, "NumericLiteral", $count)
};

(:~
 : Parse Literal.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Literal($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 6) then                             (: StringLiteral :)
      let $state := p:shift(6, $input, $state)              (: StringLiteral :)
      return $state
    else if ($state[$p:l1] = 7) then                        (: TextNodeLiteral :)
      let $state := p:shift(7, $input, $state)              (: TextNodeLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NumericLiteral($input, $state)
      return $state
  return p:reduce($state, "Literal", $count)
};

(:~
 : Parse PrimaryExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PrimaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(141, $input, $state)           (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | QName^Token | '$' |
                                                               '(' | '.' | '<' | '<!--' | '<?' | '^' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'element' | 'else' | 'empty' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'import' | 'include' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'ne' | 'or' | 'order' | 'ordered' | 'param' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'self' | 'some' | 'stable' | 'text' | 'to' | 'treat' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 94                                  (: 'ordered' :)
     or $state[$p:l1] = 140                                 (: 'unordered' :)
     or $state[$p:l1] = 165) then                           (: 'unordered' :)
      let $state := p:lookahead2W(55, $input, $state)       (: S^WS | '(' | ('(' ':') | '{' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 3                                   (: IntegerLiteral :)
     or $state[$p:lk] = 4                                   (: DecimalLiteral :)
     or $state[$p:lk] = 5                                   (: DoubleLiteral :)
     or $state[$p:lk] = 6                                   (: StringLiteral :)
     or $state[$p:lk] = 7) then                             (: TextNodeLiteral :)
      let $state := p:parse-Literal($input, $state)
      return $state
    else if ($state[$p:lk] = 31) then                       (: '$' :)
      let $state := p:parse-VarRef($input, $state)
      return $state
    else if ($state[$p:lk] = 33) then                       (: '(' :)
      let $state := p:parse-ParenthesizedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 44) then                       (: '.' :)
      let $state := p:parse-ContextItemExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 43916) then                    (: 'ordered' '{' :)
      let $state := p:parse-OrderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 43941) then                    (: 'unordered' '{' :)
      let $state := p:parse-UnorderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 53                             (: '<' :)
          or $state[$p:lk] = 54                             (: '<!--' :)
          or $state[$p:lk] = 58                             (: '<?' :)
          or $state[$p:lk] = 75                             (: 'attribute' :)
          or $state[$p:lk] = 84                             (: 'comment' :)
          or $state[$p:lk] = 86                             (: 'copy' :)
          or $state[$p:lk] = 96                             (: 'element' :)
          or $state[$p:lk] = 147                            (: 'processing-instruction' :)
          or $state[$p:lk] = 158                            (: 'text' :)
          or $state[$p:lk] = 43870) then                    (: 'document' '{' :)
      let $state := p:parse-Constructor($input, $state)
      return $state
    else if ($state[$p:lk] = 68) then                       (: '^' :)
      let $state := p:parse-RulesetCall($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-FunctionCall($input, $state)
      return $state
  return p:reduce($state, "PrimaryExpr", $count)
};

(:~
 : Parse FilterExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FilterExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-PrimaryExpr($input, $state)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-PredicateList($input, $state)
  return p:reduce($state, "FilterExpr", $count)
};

(:~
 : Parse StepExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-StepExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(145, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | ('(' ':') | '.' | '..' | '<' |
                                                               '<!--' | '<?' | '@' | '^' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'include' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'param' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 75) then                            (: 'attribute' :)
      let $state := p:lookahead2W(152, $input, $state)      (: S^WS | QName^Token | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | '::' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' | '{' | '|' | '}' :)
      let $state :=
        if ($state[$p:lk] = 20299) then                     (: 'attribute' 'case' :)
          let $state := p:lookahead3W(139, $input, $state)  (: S^WS | QName^Token | '$' | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 21323) then                (: 'attribute' 'collation' :)
          let $state := p:lookahead3W(48, $input, $state)   (: StringLiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 22859) then                (: 'attribute' 'default' :)
          let $state := p:lookahead3W(75, $input, $state)   (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 25163) then                (: 'attribute' 'empty' :)
          let $state := p:lookahead3W(81, $input, $state)   (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] = 30539) then                (: 'attribute' 'instance' :)
          let $state := p:lookahead3W(71, $input, $state)   (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] = 35659) then                (: 'attribute' 'order' :)
          let $state := p:lookahead3W(68, $input, $state)   (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = 39755) then                (: 'attribute' 'stable' :)
          let $state := p:lookahead3W(72, $input, $state)   (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = 18763                      (: 'attribute' 'descending' :)
              or $state[$p:lk] = 23627) then                (: 'attribute' 'descending' :)
          let $state := p:lookahead3W(89, $input, $state)   (: S^WS | ('(' ':') | ',' | 'collation' | 'empty' |
                                                               'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 27467                      (: 'attribute' 'let' :)
              or $state[$p:lk] = 32587) then                (: 'attribute' 'let' :)
          let $state := p:lookahead3W(54, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 20555                      (: 'attribute' 'castable' :)
              or $state[$p:lk] = 20811                      (: 'attribute' 'treat' :)
              or $state[$p:lk] = 41291) then                (: 'attribute' 'treat' :)
          let $state := p:lookahead3W(66, $input, $state)   (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 18251                      (: 'attribute' 'div' :)
              or $state[$p:lk] = 23883                      (: 'attribute' 'else' :)
              or $state[$p:lk] = 24907                      (: 'attribute' 'eq' :)
              or $state[$p:lk] = 25931                      (: 'attribute' 'except' :)
              or $state[$p:lk] = 26443                      (: 'attribute' 'ge' :)
              or $state[$p:lk] = 27979                      (: 'attribute' 'gt' :)
              or $state[$p:lk] = 28491                      (: 'attribute' 'idiv' :)
              or $state[$p:lk] = 29003                      (: 'attribute' 'intersect' :)
              or $state[$p:lk] = 30795                      (: 'attribute' 'is' :)
              or $state[$p:lk] = 31051                      (: 'attribute' 'le' :)
              or $state[$p:lk] = 32075                      (: 'attribute' 'lt' :)
              or $state[$p:lk] = 32843                      (: 'attribute' 'mod' :)
              or $state[$p:lk] = 33099                      (: 'attribute' 'ne' :)
              or $state[$p:lk] = 33867                      (: 'attribute' 'or' :)
              or $state[$p:lk] = 35403                      (: 'attribute' 'return' :)
              or $state[$p:lk] = 37963                      (: 'attribute' 'satisfies' :)
              or $state[$p:lk] = 38219                      (: 'attribute' 'to' :)
              or $state[$p:lk] = 41035                      (: 'attribute' 'union' :)
              or $state[$p:lk] = 42059                      (: 'attribute' 'where' :)
              or $state[$p:lk] = 43339) then                (: 'attribute' 'where' :)
          let $state := p:lookahead3W(148, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               '^' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 96) then                       (: 'element' :)
      let $state := p:lookahead2W(150, $input, $state)      (: S^WS | QName^Token | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' | '{' | '|' | '}' :)
      let $state :=
        if ($state[$p:lk] = 20320) then                     (: 'element' 'case' :)
          let $state := p:lookahead3W(139, $input, $state)  (: S^WS | QName^Token | '$' | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 21344) then                (: 'element' 'collation' :)
          let $state := p:lookahead3W(48, $input, $state)   (: StringLiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 22880) then                (: 'element' 'default' :)
          let $state := p:lookahead3W(75, $input, $state)   (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 25184) then                (: 'element' 'empty' :)
          let $state := p:lookahead3W(81, $input, $state)   (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] = 30560) then                (: 'element' 'instance' :)
          let $state := p:lookahead3W(71, $input, $state)   (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] = 35680) then                (: 'element' 'order' :)
          let $state := p:lookahead3W(68, $input, $state)   (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = 39776) then                (: 'element' 'stable' :)
          let $state := p:lookahead3W(72, $input, $state)   (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = 18784                      (: 'element' 'descending' :)
              or $state[$p:lk] = 23648) then                (: 'element' 'descending' :)
          let $state := p:lookahead3W(89, $input, $state)   (: S^WS | ('(' ':') | ',' | 'collation' | 'empty' |
                                                               'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 27488                      (: 'element' 'let' :)
              or $state[$p:lk] = 32608) then                (: 'element' 'let' :)
          let $state := p:lookahead3W(54, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 20576                      (: 'element' 'castable' :)
              or $state[$p:lk] = 20832                      (: 'element' 'treat' :)
              or $state[$p:lk] = 41312) then                (: 'element' 'treat' :)
          let $state := p:lookahead3W(66, $input, $state)   (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 18272                      (: 'element' 'div' :)
              or $state[$p:lk] = 23904                      (: 'element' 'else' :)
              or $state[$p:lk] = 24928                      (: 'element' 'eq' :)
              or $state[$p:lk] = 25952                      (: 'element' 'except' :)
              or $state[$p:lk] = 26464                      (: 'element' 'ge' :)
              or $state[$p:lk] = 28000                      (: 'element' 'gt' :)
              or $state[$p:lk] = 28512                      (: 'element' 'idiv' :)
              or $state[$p:lk] = 29024                      (: 'element' 'intersect' :)
              or $state[$p:lk] = 30816                      (: 'element' 'is' :)
              or $state[$p:lk] = 31072                      (: 'element' 'le' :)
              or $state[$p:lk] = 32096                      (: 'element' 'lt' :)
              or $state[$p:lk] = 32864                      (: 'element' 'mod' :)
              or $state[$p:lk] = 33120                      (: 'element' 'ne' :)
              or $state[$p:lk] = 33888                      (: 'element' 'or' :)
              or $state[$p:lk] = 35424                      (: 'element' 'return' :)
              or $state[$p:lk] = 37984                      (: 'element' 'satisfies' :)
              or $state[$p:lk] = 38240                      (: 'element' 'to' :)
              or $state[$p:lk] = 41056                      (: 'element' 'union' :)
              or $state[$p:lk] = 42080                      (: 'element' 'where' :)
              or $state[$p:lk] = 43360) then                (: 'element' 'where' :)
          let $state := p:lookahead3W(148, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               '^' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 147) then                      (: 'processing-instruction' :)
      let $state := p:lookahead2W(125, $input, $state)      (: S^WS | NCName^Token | '!=' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'eq' | 'except' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'to' | 'treat' | 'union' |
                                                               'where' | '{' | '|' | '}' :)
      let $state :=
        if ($state[$p:lk] = 20371) then                     (: 'processing-instruction' 'case' :)
          let $state := p:lookahead3W(139, $input, $state)  (: S^WS | QName^Token | '$' | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 21395) then                (: 'processing-instruction' 'collation' :)
          let $state := p:lookahead3W(48, $input, $state)   (: StringLiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 22931) then                (: 'processing-instruction' 'default' :)
          let $state := p:lookahead3W(75, $input, $state)   (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 25235) then                (: 'processing-instruction' 'empty' :)
          let $state := p:lookahead3W(81, $input, $state)   (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] = 30611) then                (: 'processing-instruction' 'instance' :)
          let $state := p:lookahead3W(71, $input, $state)   (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] = 35731) then                (: 'processing-instruction' 'order' :)
          let $state := p:lookahead3W(68, $input, $state)   (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = 39827) then                (: 'processing-instruction' 'stable' :)
          let $state := p:lookahead3W(72, $input, $state)   (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = 18835                      (: 'processing-instruction' 'descending' :)
              or $state[$p:lk] = 23699) then                (: 'processing-instruction' 'descending' :)
          let $state := p:lookahead3W(89, $input, $state)   (: S^WS | ('(' ':') | ',' | 'collation' | 'empty' |
                                                               'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 27539                      (: 'processing-instruction' 'let' :)
              or $state[$p:lk] = 32659) then                (: 'processing-instruction' 'let' :)
          let $state := p:lookahead3W(54, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 20627                      (: 'processing-instruction' 'castable' :)
              or $state[$p:lk] = 20883                      (: 'processing-instruction' 'treat' :)
              or $state[$p:lk] = 41363) then                (: 'processing-instruction' 'treat' :)
          let $state := p:lookahead3W(66, $input, $state)   (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 18323                      (: 'processing-instruction' 'div' :)
              or $state[$p:lk] = 23955                      (: 'processing-instruction' 'else' :)
              or $state[$p:lk] = 24979                      (: 'processing-instruction' 'eq' :)
              or $state[$p:lk] = 26003                      (: 'processing-instruction' 'except' :)
              or $state[$p:lk] = 26515                      (: 'processing-instruction' 'ge' :)
              or $state[$p:lk] = 28051                      (: 'processing-instruction' 'gt' :)
              or $state[$p:lk] = 28563                      (: 'processing-instruction' 'idiv' :)
              or $state[$p:lk] = 29075                      (: 'processing-instruction' 'intersect' :)
              or $state[$p:lk] = 30867                      (: 'processing-instruction' 'is' :)
              or $state[$p:lk] = 31123                      (: 'processing-instruction' 'le' :)
              or $state[$p:lk] = 32147                      (: 'processing-instruction' 'lt' :)
              or $state[$p:lk] = 32915                      (: 'processing-instruction' 'mod' :)
              or $state[$p:lk] = 33171                      (: 'processing-instruction' 'ne' :)
              or $state[$p:lk] = 33939                      (: 'processing-instruction' 'or' :)
              or $state[$p:lk] = 35475                      (: 'processing-instruction' 'return' :)
              or $state[$p:lk] = 38035                      (: 'processing-instruction' 'satisfies' :)
              or $state[$p:lk] = 38291                      (: 'processing-instruction' 'to' :)
              or $state[$p:lk] = 41107                      (: 'processing-instruction' 'union' :)
              or $state[$p:lk] = 42131                      (: 'processing-instruction' 'where' :)
              or $state[$p:lk] = 43411) then                (: 'processing-instruction' 'where' :)
          let $state := p:lookahead3W(148, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               '^' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 84                             (: 'document' :)
          or $state[$p:l1] = 94                             (: 'ordered' :)
          or $state[$p:l1] = 140                            (: 'text' :)
          or $state[$p:l1] = 158                            (: 'unordered' :)
          or $state[$p:l1] = 165) then                      (: 'unordered' :)
      let $state := p:lookahead2W(124, $input, $state)      (: S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '{' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 69                             (: 'ancestor-or-self' :)
          or $state[$p:l1] = 70                             (: 'child' :)
          or $state[$p:l1] = 82                             (: 'descendant' :)
          or $state[$p:l1] = 90                             (: 'descendant-or-self' :)
          or $state[$p:l1] = 91                             (: 'following' :)
          or $state[$p:l1] = 105                            (: 'following-sibling' :)
          or $state[$p:l1] = 106                            (: 'parent' :)
          or $state[$p:l1] = 143                            (: 'preceding' :)
          or $state[$p:l1] = 144                            (: 'preceding-sibling' :)
          or $state[$p:l1] = 145                            (: 'self' :)
          or $state[$p:l1] = 153) then                      (: 'self' :)
      let $state := p:lookahead2W(123, $input, $state)      (: S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 18                             (: 'and' :)
          or $state[$p:l1] = 71                             (: 'ascending' :)
          or $state[$p:l1] = 73                             (: 'case' :)
          or $state[$p:l1] = 79                             (: 'cast' :)
          or $state[$p:l1] = 80                             (: 'castable' :)
          or $state[$p:l1] = 81                             (: 'collation' :)
          or $state[$p:l1] = 83                             (: 'declare' :)
          or $state[$p:l1] = 88                             (: 'default' :)
          or $state[$p:l1] = 89                             (: 'descending' :)
          or $state[$p:l1] = 92                             (: 'div' :)
          or $state[$p:l1] = 93                             (: 'else' :)
          or $state[$p:l1] = 97                             (: 'empty' :)
          or $state[$p:l1] = 98                             (: 'eq' :)
          or $state[$p:l1] = 101                            (: 'every' :)
          or $state[$p:l1] = 102                            (: 'except' :)
          or $state[$p:l1] = 103                            (: 'for' :)
          or $state[$p:l1] = 107                            (: 'ge' :)
          or $state[$p:l1] = 109                            (: 'gt' :)
          or $state[$p:l1] = 111                            (: 'idiv' :)
          or $state[$p:l1] = 113                            (: 'import' :)
          or $state[$p:l1] = 115                            (: 'include' :)
          or $state[$p:l1] = 117                            (: 'instance' :)
          or $state[$p:l1] = 119                            (: 'intersect' :)
          or $state[$p:l1] = 120                            (: 'is' :)
          or $state[$p:l1] = 121                            (: 'le' :)
          or $state[$p:l1] = 125                            (: 'let' :)
          or $state[$p:l1] = 127                            (: 'lt' :)
          or $state[$p:l1] = 128                            (: 'mod' :)
          or $state[$p:l1] = 129                            (: 'module' :)
          or $state[$p:l1] = 130                            (: 'namespace' :)
          or $state[$p:l1] = 131                            (: 'ne' :)
          or $state[$p:l1] = 132                            (: 'or' :)
          or $state[$p:l1] = 138                            (: 'order' :)
          or $state[$p:l1] = 139                            (: 'param' :)
          or $state[$p:l1] = 142                            (: 'return' :)
          or $state[$p:l1] = 148                            (: 'satisfies' :)
          or $state[$p:l1] = 149                            (: 'some' :)
          or $state[$p:l1] = 154                            (: 'stable' :)
          or $state[$p:l1] = 155                            (: 'to' :)
          or $state[$p:l1] = 160                            (: 'treat' :)
          or $state[$p:l1] = 161                            (: 'union' :)
          or $state[$p:l1] = 164                            (: 'validate' :)
          or $state[$p:l1] = 166                            (: 'where' :)
          or $state[$p:l1] = 169                            (: 'xquery' :)
          or $state[$p:l1] = 170) then                      (: 'xquery' :)
      let $state := p:lookahead2W(120, $input, $state)      (: S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 3                                   (: IntegerLiteral :)
     or $state[$p:lk] = 4                                   (: DecimalLiteral :)
     or $state[$p:lk] = 5                                   (: DoubleLiteral :)
     or $state[$p:lk] = 6                                   (: StringLiteral :)
     or $state[$p:lk] = 7                                   (: TextNodeLiteral :)
     or $state[$p:lk] = 31                                  (: '$' :)
     or $state[$p:lk] = 33                                  (: '(' :)
     or $state[$p:lk] = 44                                  (: '.' :)
     or $state[$p:lk] = 53                                  (: '<' :)
     or $state[$p:lk] = 54                                  (: '<!--' :)
     or $state[$p:lk] = 58                                  (: '<?' :)
     or $state[$p:lk] = 68                                  (: '^' :)
     or $state[$p:lk] = 86                                  (: 'copy' :)
     or $state[$p:lk] = 4499                                (: 'processing-instruction' NCName^Token :)
     or $state[$p:lk] = 4683                                (: 'attribute' QName^Token :)
     or $state[$p:lk] = 4704                                (: 'element' QName^Token :)
     or $state[$p:lk] = 8466                                (: QName^Token '(' :)
     or $state[$p:lk] = 8517                                (: 'ancestor' '(' :)
     or $state[$p:lk] = 8518                                (: 'ancestor-or-self' '(' :)
     or $state[$p:lk] = 8519                                (: 'and' '(' :)
     or $state[$p:lk] = 8521                                (: 'ascending' '(' :)
     or $state[$p:lk] = 8527                                (: 'case' '(' :)
     or $state[$p:lk] = 8528                                (: 'cast' '(' :)
     or $state[$p:lk] = 8529                                (: 'castable' '(' :)
     or $state[$p:lk] = 8530                                (: 'child' '(' :)
     or $state[$p:lk] = 8531                                (: 'collation' '(' :)
     or $state[$p:lk] = 8536                                (: 'declare' '(' :)
     or $state[$p:lk] = 8537                                (: 'default' '(' :)
     or $state[$p:lk] = 8538                                (: 'descendant' '(' :)
     or $state[$p:lk] = 8539                                (: 'descendant-or-self' '(' :)
     or $state[$p:lk] = 8540                                (: 'descending' '(' :)
     or $state[$p:lk] = 8541                                (: 'div' '(' :)
     or $state[$p:lk] = 8542                                (: 'document' '(' :)
     or $state[$p:lk] = 8545                                (: 'else' '(' :)
     or $state[$p:lk] = 8546                                (: 'empty' '(' :)
     or $state[$p:lk] = 8549                                (: 'eq' '(' :)
     or $state[$p:lk] = 8550                                (: 'every' '(' :)
     or $state[$p:lk] = 8551                                (: 'except' '(' :)
     or $state[$p:lk] = 8553                                (: 'following' '(' :)
     or $state[$p:lk] = 8554                                (: 'following-sibling' '(' :)
     or $state[$p:lk] = 8555                                (: 'for' '(' :)
     or $state[$p:lk] = 8557                                (: 'ge' '(' :)
     or $state[$p:lk] = 8559                                (: 'gt' '(' :)
     or $state[$p:lk] = 8561                                (: 'idiv' '(' :)
     or $state[$p:lk] = 8563                                (: 'import' '(' :)
     or $state[$p:lk] = 8565                                (: 'include' '(' :)
     or $state[$p:lk] = 8567                                (: 'instance' '(' :)
     or $state[$p:lk] = 8568                                (: 'intersect' '(' :)
     or $state[$p:lk] = 8569                                (: 'is' '(' :)
     or $state[$p:lk] = 8573                                (: 'le' '(' :)
     or $state[$p:lk] = 8575                                (: 'let' '(' :)
     or $state[$p:lk] = 8576                                (: 'lt' '(' :)
     or $state[$p:lk] = 8577                                (: 'mod' '(' :)
     or $state[$p:lk] = 8578                                (: 'module' '(' :)
     or $state[$p:lk] = 8579                                (: 'namespace' '(' :)
     or $state[$p:lk] = 8580                                (: 'ne' '(' :)
     or $state[$p:lk] = 8586                                (: 'or' '(' :)
     or $state[$p:lk] = 8587                                (: 'order' '(' :)
     or $state[$p:lk] = 8588                                (: 'ordered' '(' :)
     or $state[$p:lk] = 8590                                (: 'param' '(' :)
     or $state[$p:lk] = 8591                                (: 'parent' '(' :)
     or $state[$p:lk] = 8592                                (: 'preceding' '(' :)
     or $state[$p:lk] = 8593                                (: 'preceding-sibling' '(' :)
     or $state[$p:lk] = 8596                                (: 'return' '(' :)
     or $state[$p:lk] = 8597                                (: 'satisfies' '(' :)
     or $state[$p:lk] = 8601                                (: 'self' '(' :)
     or $state[$p:lk] = 8602                                (: 'some' '(' :)
     or $state[$p:lk] = 8603                                (: 'stable' '(' :)
     or $state[$p:lk] = 8608                                (: 'to' '(' :)
     or $state[$p:lk] = 8609                                (: 'treat' '(' :)
     or $state[$p:lk] = 8612                                (: 'union' '(' :)
     or $state[$p:lk] = 8613                                (: 'unordered' '(' :)
     or $state[$p:lk] = 8614                                (: 'validate' '(' :)
     or $state[$p:lk] = 8617                                (: 'where' '(' :)
     or $state[$p:lk] = 8618                                (: 'xquery' '(' :)
     or $state[$p:lk] = 17739                               (: 'attribute' 'ancestor' :)
     or $state[$p:lk] = 17760                               (: 'element' 'ancestor' :)
     or $state[$p:lk] = 17995                               (: 'attribute' 'ancestor-or-self' :)
     or $state[$p:lk] = 18016                               (: 'element' 'ancestor-or-self' :)
     or $state[$p:lk] = 19275                               (: 'attribute' 'attribute' :)
     or $state[$p:lk] = 19296                               (: 'element' 'attribute' :)
     or $state[$p:lk] = 21067                               (: 'attribute' 'child' :)
     or $state[$p:lk] = 21088                               (: 'element' 'child' :)
     or $state[$p:lk] = 21579                               (: 'attribute' 'comment' :)
     or $state[$p:lk] = 21600                               (: 'element' 'comment' :)
     or $state[$p:lk] = 22603                               (: 'attribute' 'declare' :)
     or $state[$p:lk] = 22624                               (: 'element' 'declare' :)
     or $state[$p:lk] = 23115                               (: 'attribute' 'descendant' :)
     or $state[$p:lk] = 23136                               (: 'element' 'descendant' :)
     or $state[$p:lk] = 23371                               (: 'attribute' 'descendant-or-self' :)
     or $state[$p:lk] = 23392                               (: 'element' 'descendant-or-self' :)
     or $state[$p:lk] = 24139                               (: 'attribute' 'document' :)
     or $state[$p:lk] = 24160                               (: 'element' 'document' :)
     or $state[$p:lk] = 24395                               (: 'attribute' 'document-node' :)
     or $state[$p:lk] = 24416                               (: 'element' 'document-node' :)
     or $state[$p:lk] = 24651                               (: 'attribute' 'element' :)
     or $state[$p:lk] = 24672                               (: 'element' 'element' :)
     or $state[$p:lk] = 25419                               (: 'attribute' 'empty-sequence' :)
     or $state[$p:lk] = 25440                               (: 'element' 'empty-sequence' :)
     or $state[$p:lk] = 26187                               (: 'attribute' 'every' :)
     or $state[$p:lk] = 26208                               (: 'element' 'every' :)
     or $state[$p:lk] = 26955                               (: 'attribute' 'following' :)
     or $state[$p:lk] = 26976                               (: 'element' 'following' :)
     or $state[$p:lk] = 27211                               (: 'attribute' 'following-sibling' :)
     or $state[$p:lk] = 27232                               (: 'element' 'following-sibling' :)
     or $state[$p:lk] = 29259                               (: 'attribute' 'if' :)
     or $state[$p:lk] = 29280                               (: 'element' 'if' :)
     or $state[$p:lk] = 29515                               (: 'attribute' 'import' :)
     or $state[$p:lk] = 29536                               (: 'element' 'import' :)
     or $state[$p:lk] = 30027                               (: 'attribute' 'include' :)
     or $state[$p:lk] = 30048                               (: 'element' 'include' :)
     or $state[$p:lk] = 31307                               (: 'attribute' 'item' :)
     or $state[$p:lk] = 31328                               (: 'element' 'item' :)
     or $state[$p:lk] = 33355                               (: 'attribute' 'module' :)
     or $state[$p:lk] = 33376                               (: 'element' 'module' :)
     or $state[$p:lk] = 33611                               (: 'attribute' 'namespace' :)
     or $state[$p:lk] = 33632                               (: 'element' 'namespace' :)
     or $state[$p:lk] = 34635                               (: 'attribute' 'node' :)
     or $state[$p:lk] = 34656                               (: 'element' 'node' :)
     or $state[$p:lk] = 35915                               (: 'attribute' 'ordered' :)
     or $state[$p:lk] = 35936                               (: 'element' 'ordered' :)
     or $state[$p:lk] = 36427                               (: 'attribute' 'param' :)
     or $state[$p:lk] = 36448                               (: 'element' 'param' :)
     or $state[$p:lk] = 36683                               (: 'attribute' 'parent' :)
     or $state[$p:lk] = 36704                               (: 'element' 'parent' :)
     or $state[$p:lk] = 36939                               (: 'attribute' 'preceding' :)
     or $state[$p:lk] = 36960                               (: 'element' 'preceding' :)
     or $state[$p:lk] = 37195                               (: 'attribute' 'preceding-sibling' :)
     or $state[$p:lk] = 37216                               (: 'element' 'preceding-sibling' :)
     or $state[$p:lk] = 37707                               (: 'attribute' 'processing-instruction' :)
     or $state[$p:lk] = 37728                               (: 'element' 'processing-instruction' :)
     or $state[$p:lk] = 38731                               (: 'attribute' 'schema-attribute' :)
     or $state[$p:lk] = 38752                               (: 'element' 'schema-attribute' :)
     or $state[$p:lk] = 38987                               (: 'attribute' 'schema-element' :)
     or $state[$p:lk] = 39008                               (: 'element' 'schema-element' :)
     or $state[$p:lk] = 39243                               (: 'attribute' 'self' :)
     or $state[$p:lk] = 39264                               (: 'element' 'self' :)
     or $state[$p:lk] = 39499                               (: 'attribute' 'some' :)
     or $state[$p:lk] = 39520                               (: 'element' 'some' :)
     or $state[$p:lk] = 40523                               (: 'attribute' 'text' :)
     or $state[$p:lk] = 40544                               (: 'element' 'text' :)
     or $state[$p:lk] = 41803                               (: 'attribute' 'typeswitch' :)
     or $state[$p:lk] = 41824                               (: 'element' 'typeswitch' :)
     or $state[$p:lk] = 42315                               (: 'attribute' 'unordered' :)
     or $state[$p:lk] = 42336                               (: 'element' 'unordered' :)
     or $state[$p:lk] = 42571                               (: 'attribute' 'validate' :)
     or $state[$p:lk] = 42592                               (: 'element' 'validate' :)
     or $state[$p:lk] = 43595                               (: 'attribute' 'xquery' :)
     or $state[$p:lk] = 43616                               (: 'element' 'xquery' :)
     or $state[$p:lk] = 43851                               (: 'attribute' '{' :)
     or $state[$p:lk] = 43860                               (: 'comment' '{' :)
     or $state[$p:lk] = 43870                               (: 'document' '{' :)
     or $state[$p:lk] = 43872                               (: 'element' '{' :)
     or $state[$p:lk] = 43916                               (: 'ordered' '{' :)
     or $state[$p:lk] = 43923                               (: 'processing-instruction' '{' :)
     or $state[$p:lk] = 43934                               (: 'text' '{' :)
     or $state[$p:lk] = 43941                               (: 'unordered' '{' :)
     or $state[$p:lk] = 11224907                            (: 'attribute' 'and' '{' :)
     or $state[$p:lk] = 11224928                            (: 'element' 'and' '{' :)
     or $state[$p:lk] = 11224979                            (: 'processing-instruction' 'and' '{' :)
     or $state[$p:lk] = 11225419                            (: 'attribute' 'ascending' '{' :)
     or $state[$p:lk] = 11225440                            (: 'element' 'ascending' '{' :)
     or $state[$p:lk] = 11225491                            (: 'processing-instruction' 'ascending' '{' :)
     or $state[$p:lk] = 11226955                            (: 'attribute' 'case' '{' :)
     or $state[$p:lk] = 11226976                            (: 'element' 'case' '{' :)
     or $state[$p:lk] = 11227027                            (: 'processing-instruction' 'case' '{' :)
     or $state[$p:lk] = 11227211                            (: 'attribute' 'cast' '{' :)
     or $state[$p:lk] = 11227232                            (: 'element' 'cast' '{' :)
     or $state[$p:lk] = 11227283                            (: 'processing-instruction' 'cast' '{' :)
     or $state[$p:lk] = 11227467                            (: 'attribute' 'castable' '{' :)
     or $state[$p:lk] = 11227488                            (: 'element' 'castable' '{' :)
     or $state[$p:lk] = 11227539                            (: 'processing-instruction' 'castable' '{' :)
     or $state[$p:lk] = 11227979                            (: 'attribute' 'collation' '{' :)
     or $state[$p:lk] = 11228000                            (: 'element' 'collation' '{' :)
     or $state[$p:lk] = 11228051                            (: 'processing-instruction' 'collation' '{' :)
     or $state[$p:lk] = 11229515                            (: 'attribute' 'default' '{' :)
     or $state[$p:lk] = 11229536                            (: 'element' 'default' '{' :)
     or $state[$p:lk] = 11229587                            (: 'processing-instruction' 'default' '{' :)
     or $state[$p:lk] = 11230283                            (: 'attribute' 'descending' '{' :)
     or $state[$p:lk] = 11230304                            (: 'element' 'descending' '{' :)
     or $state[$p:lk] = 11230355                            (: 'processing-instruction' 'descending' '{' :)
     or $state[$p:lk] = 11230539                            (: 'attribute' 'div' '{' :)
     or $state[$p:lk] = 11230560                            (: 'element' 'div' '{' :)
     or $state[$p:lk] = 11230611                            (: 'processing-instruction' 'div' '{' :)
     or $state[$p:lk] = 11231563                            (: 'attribute' 'else' '{' :)
     or $state[$p:lk] = 11231584                            (: 'element' 'else' '{' :)
     or $state[$p:lk] = 11231635                            (: 'processing-instruction' 'else' '{' :)
     or $state[$p:lk] = 11231819                            (: 'attribute' 'empty' '{' :)
     or $state[$p:lk] = 11231840                            (: 'element' 'empty' '{' :)
     or $state[$p:lk] = 11231891                            (: 'processing-instruction' 'empty' '{' :)
     or $state[$p:lk] = 11232587                            (: 'attribute' 'eq' '{' :)
     or $state[$p:lk] = 11232608                            (: 'element' 'eq' '{' :)
     or $state[$p:lk] = 11232659                            (: 'processing-instruction' 'eq' '{' :)
     or $state[$p:lk] = 11233099                            (: 'attribute' 'except' '{' :)
     or $state[$p:lk] = 11233120                            (: 'element' 'except' '{' :)
     or $state[$p:lk] = 11233171                            (: 'processing-instruction' 'except' '{' :)
     or $state[$p:lk] = 11234123                            (: 'attribute' 'for' '{' :)
     or $state[$p:lk] = 11234144                            (: 'element' 'for' '{' :)
     or $state[$p:lk] = 11234195                            (: 'processing-instruction' 'for' '{' :)
     or $state[$p:lk] = 11234635                            (: 'attribute' 'ge' '{' :)
     or $state[$p:lk] = 11234656                            (: 'element' 'ge' '{' :)
     or $state[$p:lk] = 11234707                            (: 'processing-instruction' 'ge' '{' :)
     or $state[$p:lk] = 11235147                            (: 'attribute' 'gt' '{' :)
     or $state[$p:lk] = 11235168                            (: 'element' 'gt' '{' :)
     or $state[$p:lk] = 11235219                            (: 'processing-instruction' 'gt' '{' :)
     or $state[$p:lk] = 11235659                            (: 'attribute' 'idiv' '{' :)
     or $state[$p:lk] = 11235680                            (: 'element' 'idiv' '{' :)
     or $state[$p:lk] = 11235731                            (: 'processing-instruction' 'idiv' '{' :)
     or $state[$p:lk] = 11237195                            (: 'attribute' 'instance' '{' :)
     or $state[$p:lk] = 11237216                            (: 'element' 'instance' '{' :)
     or $state[$p:lk] = 11237267                            (: 'processing-instruction' 'instance' '{' :)
     or $state[$p:lk] = 11237451                            (: 'attribute' 'intersect' '{' :)
     or $state[$p:lk] = 11237472                            (: 'element' 'intersect' '{' :)
     or $state[$p:lk] = 11237523                            (: 'processing-instruction' 'intersect' '{' :)
     or $state[$p:lk] = 11237707                            (: 'attribute' 'is' '{' :)
     or $state[$p:lk] = 11237728                            (: 'element' 'is' '{' :)
     or $state[$p:lk] = 11237779                            (: 'processing-instruction' 'is' '{' :)
     or $state[$p:lk] = 11238731                            (: 'attribute' 'le' '{' :)
     or $state[$p:lk] = 11238752                            (: 'element' 'le' '{' :)
     or $state[$p:lk] = 11238803                            (: 'processing-instruction' 'le' '{' :)
     or $state[$p:lk] = 11239243                            (: 'attribute' 'let' '{' :)
     or $state[$p:lk] = 11239264                            (: 'element' 'let' '{' :)
     or $state[$p:lk] = 11239315                            (: 'processing-instruction' 'let' '{' :)
     or $state[$p:lk] = 11239499                            (: 'attribute' 'lt' '{' :)
     or $state[$p:lk] = 11239520                            (: 'element' 'lt' '{' :)
     or $state[$p:lk] = 11239571                            (: 'processing-instruction' 'lt' '{' :)
     or $state[$p:lk] = 11239755                            (: 'attribute' 'mod' '{' :)
     or $state[$p:lk] = 11239776                            (: 'element' 'mod' '{' :)
     or $state[$p:lk] = 11239827                            (: 'processing-instruction' 'mod' '{' :)
     or $state[$p:lk] = 11240523                            (: 'attribute' 'ne' '{' :)
     or $state[$p:lk] = 11240544                            (: 'element' 'ne' '{' :)
     or $state[$p:lk] = 11240595                            (: 'processing-instruction' 'ne' '{' :)
     or $state[$p:lk] = 11242059                            (: 'attribute' 'or' '{' :)
     or $state[$p:lk] = 11242080                            (: 'element' 'or' '{' :)
     or $state[$p:lk] = 11242131                            (: 'processing-instruction' 'or' '{' :)
     or $state[$p:lk] = 11242315                            (: 'attribute' 'order' '{' :)
     or $state[$p:lk] = 11242336                            (: 'element' 'order' '{' :)
     or $state[$p:lk] = 11242387                            (: 'processing-instruction' 'order' '{' :)
     or $state[$p:lk] = 11244619                            (: 'attribute' 'return' '{' :)
     or $state[$p:lk] = 11244640                            (: 'element' 'return' '{' :)
     or $state[$p:lk] = 11244691                            (: 'processing-instruction' 'return' '{' :)
     or $state[$p:lk] = 11244875                            (: 'attribute' 'satisfies' '{' :)
     or $state[$p:lk] = 11244896                            (: 'element' 'satisfies' '{' :)
     or $state[$p:lk] = 11244947                            (: 'processing-instruction' 'satisfies' '{' :)
     or $state[$p:lk] = 11246411                            (: 'attribute' 'stable' '{' :)
     or $state[$p:lk] = 11246432                            (: 'element' 'stable' '{' :)
     or $state[$p:lk] = 11246483                            (: 'processing-instruction' 'stable' '{' :)
     or $state[$p:lk] = 11247691                            (: 'attribute' 'to' '{' :)
     or $state[$p:lk] = 11247712                            (: 'element' 'to' '{' :)
     or $state[$p:lk] = 11247763                            (: 'processing-instruction' 'to' '{' :)
     or $state[$p:lk] = 11247947                            (: 'attribute' 'treat' '{' :)
     or $state[$p:lk] = 11247968                            (: 'element' 'treat' '{' :)
     or $state[$p:lk] = 11248019                            (: 'processing-instruction' 'treat' '{' :)
     or $state[$p:lk] = 11248715                            (: 'attribute' 'union' '{' :)
     or $state[$p:lk] = 11248736                            (: 'element' 'union' '{' :)
     or $state[$p:lk] = 11248787                            (: 'processing-instruction' 'union' '{' :)
     or $state[$p:lk] = 11249995                            (: 'attribute' 'where' '{' :)
     or $state[$p:lk] = 11250016                            (: 'element' 'where' '{' :)
     or $state[$p:lk] = 11250067) then                      (: 'processing-instruction' 'where' '{' :)
      let $state := p:parse-FilterExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AxisStep($input, $state)
      return $state
  return p:reduce($state, "StepExpr", $count)
};

(:~
 : Parse the 1st loop of production RelativePathExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RelativePathExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(116, $input, $state)        (: S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                               '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'and' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'ne' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'to' | 'treat' |
                                                               'union' | 'where' | '|' | '}' :)
    return
      if ($state[$p:l1] != 46                               (: '/' :)
      and $state[$p:l1] != 47) then                         (: '//' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 46) then                      (: '/' :)
            let $state := p:shift(46, $input, $state)       (: '/' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(47, $input, $state)       (: '//' :)
            return $state
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-StepExpr($input, $state)
        return p:parse-RelativePathExpr-1($input, $state)
};

(:~
 : Parse RelativePathExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RelativePathExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-StepExpr($input, $state)
  let $state := p:parse-RelativePathExpr-1($input, $state)
  return p:reduce($state, "RelativePathExpr", $count)
};

(:~
 : Parse PathExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PathExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 46) then                            (: '/' :)
      let $state := p:shift(46, $input, $state)             (: '/' :)
      let $state := p:lookahead1W(153, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '!=' | '$' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '.' | '..' | ';' | '<' | '<!--' |
                                                               '<<' | '<=' | '<?' | '=' | '>' | '>=' | '>>' | '@' |
                                                               ']' | '^' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' | '|' | '}' :)
      let $state :=
        if ($state[$p:l1] = 26                              (: '!=' :)
         or $state[$p:l1] = 36                              (: ')' :)
         or $state[$p:l1] = 37                              (: '*' :)
         or $state[$p:l1] = 39                              (: '+' :)
         or $state[$p:l1] = 41                              (: ',' :)
         or $state[$p:l1] = 42                              (: '-' :)
         or $state[$p:l1] = 52                              (: ';' :)
         or $state[$p:l1] = 56                              (: '<<' :)
         or $state[$p:l1] = 57                              (: '<=' :)
         or $state[$p:l1] = 59                              (: '=' :)
         or $state[$p:l1] = 60                              (: '>' :)
         or $state[$p:l1] = 61                              (: '>=' :)
         or $state[$p:l1] = 62                              (: '>>' :)
         or $state[$p:l1] = 67                              (: ']' :)
         or $state[$p:l1] = 173                             (: '|' :)
         or $state[$p:l1] = 174) then                       (: '}' :)
          $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:parse-RelativePathExpr($input, $state)
          return $state
      return $state
    else if ($state[$p:l1] = 47) then                       (: '//' :)
      let $state := p:shift(47, $input, $state)             (: '//' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-RelativePathExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-RelativePathExpr($input, $state)
      return $state
  return p:reduce($state, "PathExpr", $count)
};

(:~
 : Parse ValidationMode.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValidationMode($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 124) then                           (: 'lax' :)
      let $state := p:shift(124, $input, $state)            (: 'lax' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(156, $input, $state)            (: 'strict' :)
      return $state
  return p:reduce($state, "ValidationMode", $count)
};

(:~
 : Parse ValidateExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValidateExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(166, $input, $state)                (: 'validate' :)
  let $state := p:lookahead1W(82, $input, $state)           (: S^WS | ('(' ':') | 'lax' | 'strict' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 171) then                     (: '{' :)
      let $state := p:parse-ValidationMode($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(171, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(174, $input, $state)                (: '}' :)
  return p:reduce($state, "ValidateExpr", $count)
};

(:~
 : Parse ValueExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValueExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 166) then                           (: 'validate' :)
      let $state := p:lookahead2W(127, $input, $state)      (: S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'lax' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'strict' | 'to' | 'treat' | 'union' |
                                                               'where' | '{' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 31910                               (: 'validate' 'lax' :)
     or $state[$p:lk] = 40102                               (: 'validate' 'strict' :)
     or $state[$p:lk] = 43942) then                         (: 'validate' '{' :)
      let $state := p:parse-ValidateExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 34) then                       (: '(#' :)
      let $state := p:parse-ExtensionExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-PathExpr($input, $state)
      return $state
  return p:reduce($state, "ValueExpr", $count)
};

(:~
 : Parse the 1st loop of production UnaryExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnaryExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(146, $input, $state)        (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               '^' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
    return
      if ($state[$p:l1] != 39                               (: '+' :)
      and $state[$p:l1] != 42) then                         (: '-' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 42) then                      (: '-' :)
            let $state := p:shift(42, $input, $state)       (: '-' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(39, $input, $state)       (: '+' :)
            return $state
        return p:parse-UnaryExpr-1($input, $state)
};

(:~
 : Parse UnaryExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-UnaryExpr-1($input, $state)
  let $state := p:parse-ValueExpr($input, $state)
  return p:reduce($state, "UnaryExpr", $count)
};

(:~
 : Parse CastExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CastExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-UnaryExpr($input, $state)
  let $state := p:lookahead1W(115, $input, $state)          (: S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'eq' | 'except' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'to' | 'treat' | 'union' |
                                                               'where' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 80) then                       (: 'cast' :)
      let $state := p:shift(80, $input, $state)             (: 'cast' :)
      let $state := p:lookahead1W(35, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:shift(72, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-SingleType($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "CastExpr", $count)
};

(:~
 : Parse CastableExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CastableExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-CastExpr($input, $state)
  let $state := p:lookahead1W(113, $input, $state)          (: S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'castable' | 'collation' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'eq' | 'except' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 81) then                       (: 'castable' :)
      let $state := p:shift(81, $input, $state)             (: 'castable' :)
      let $state := p:lookahead1W(35, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:shift(72, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-SingleType($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "CastableExpr", $count)
};

(:~
 : Parse TreatExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TreatExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-CastableExpr($input, $state)
  let $state := p:lookahead1W(112, $input, $state)          (: S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 161) then                      (: 'treat' :)
      let $state := p:shift(161, $input, $state)            (: 'treat' :)
      let $state := p:lookahead1W(35, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:shift(72, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "TreatExpr", $count)
};

(:~
 : Parse InstanceofExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InstanceofExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-TreatExpr($input, $state)
  let $state := p:lookahead1W(111, $input, $state)          (: S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'union' | 'where' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 119) then                      (: 'instance' :)
      let $state := p:shift(119, $input, $state)            (: 'instance' :)
      let $state := p:lookahead1W(39, $input, $state)       (: S^WS | ('(' ':') | 'of' :)
      let $state := p:shift(136, $input, $state)            (: 'of' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "InstanceofExpr", $count)
};

(:~
 : Parse the 1st loop of production IntersectExceptExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IntersectExceptExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(110, $input, $state)        (: S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'intersect' |
                                                               'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'to' |
                                                               'union' | 'where' | '|' | '}' :)
    return
      if ($state[$p:l1] != 103                              (: 'except' :)
      and $state[$p:l1] != 120) then                        (: 'intersect' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 120) then                     (: 'intersect' :)
            let $state := p:shift(120, $input, $state)      (: 'intersect' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(103, $input, $state)      (: 'except' :)
            return $state
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-InstanceofExpr($input, $state)
        return p:parse-IntersectExceptExpr-1($input, $state)
};

(:~
 : Parse IntersectExceptExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IntersectExceptExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-InstanceofExpr($input, $state)
  let $state := p:parse-IntersectExceptExpr-1($input, $state)
  return p:reduce($state, "IntersectExceptExpr", $count)
};

(:~
 : Parse the 1st loop of production UnionExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnionExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(109, $input, $state)        (: S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'to' | 'union' | 'where' | '|' | '}' :)
    return
      if ($state[$p:l1] != 164                              (: 'union' :)
      and $state[$p:l1] != 173) then                        (: '|' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 164) then                     (: 'union' :)
            let $state := p:shift(164, $input, $state)      (: 'union' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(173, $input, $state)      (: '|' :)
            return $state
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-IntersectExceptExpr($input, $state)
        return p:parse-UnionExpr-1($input, $state)
};

(:~
 : Parse UnionExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnionExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-IntersectExceptExpr($input, $state)
  let $state := p:parse-UnionExpr-1($input, $state)
  return p:reduce($state, "UnionExpr", $count)
};

(:~
 : Parse the 1st loop of production MultiplicativeExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MultiplicativeExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(108, $input, $state)        (: S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'to' | 'where' | '}' :)
    return
      if ($state[$p:l1] != 37                               (: '*' :)
      and $state[$p:l1] != 93                               (: 'div' :)
      and $state[$p:l1] != 113                              (: 'idiv' :)
      and $state[$p:l1] != 129) then                        (: 'mod' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 37) then                      (: '*' :)
            let $state := p:shift(37, $input, $state)       (: '*' :)
            return $state
          else if ($state[$p:l1] = 93) then                 (: 'div' :)
            let $state := p:shift(93, $input, $state)       (: 'div' :)
            return $state
          else if ($state[$p:l1] = 113) then                (: 'idiv' :)
            let $state := p:shift(113, $input, $state)      (: 'idiv' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(129, $input, $state)      (: 'mod' :)
            return $state
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-UnionExpr($input, $state)
        return p:parse-MultiplicativeExpr-1($input, $state)
};

(:~
 : Parse MultiplicativeExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MultiplicativeExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-UnionExpr($input, $state)
  let $state := p:parse-MultiplicativeExpr-1($input, $state)
  return p:reduce($state, "MultiplicativeExpr", $count)
};

(:~
 : Parse the 1st loop of production AdditiveExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AdditiveExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(107, $input, $state)        (: S^WS | '!=' | ('(' ':') | ')' | '+' | ',' | '-' | ';' |
                                                               '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'else' | 'empty' | 'eq' | 'for' | 'ge' |
                                                               'gt' | 'is' | 'le' | 'let' | 'lt' | 'ne' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'to' |
                                                               'where' | '}' :)
    return
      if ($state[$p:l1] != 39                               (: '+' :)
      and $state[$p:l1] != 42) then                         (: '-' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 39) then                      (: '+' :)
            let $state := p:shift(39, $input, $state)       (: '+' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(42, $input, $state)       (: '-' :)
            return $state
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-MultiplicativeExpr($input, $state)
        return p:parse-AdditiveExpr-1($input, $state)
};

(:~
 : Parse AdditiveExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AdditiveExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-MultiplicativeExpr($input, $state)
  let $state := p:parse-AdditiveExpr-1($input, $state)
  return p:reduce($state, "AdditiveExpr", $count)
};

(:~
 : Parse RangeExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RangeExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-AdditiveExpr($input, $state)
  let $state := p:lookahead1W(106, $input, $state)          (: S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' |
                                                               'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'else' | 'empty' | 'eq' | 'for' | 'ge' |
                                                               'gt' | 'is' | 'le' | 'let' | 'lt' | 'ne' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'to' |
                                                               'where' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 160) then                      (: 'to' :)
      let $state := p:shift(160, $input, $state)            (: 'to' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-AdditiveExpr($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "RangeExpr", $count)
};

(:~
 : Parse ComparisonExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ComparisonExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-RangeExpr($input, $state)
  let $state := p:lookahead1W(104, $input, $state)          (: S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' |
                                                               'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'else' | 'empty' | 'eq' | 'for' | 'ge' |
                                                               'gt' | 'is' | 'le' | 'let' | 'lt' | 'ne' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'where' |
                                                               '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 26                             (: '!=' :)
          or $state[$p:l1] = 53                             (: '<' :)
          or $state[$p:l1] = 56                             (: '<<' :)
          or $state[$p:l1] = 57                             (: '<=' :)
          or $state[$p:l1] = 59                             (: '=' :)
          or $state[$p:l1] = 60                             (: '>' :)
          or $state[$p:l1] = 61                             (: '>=' :)
          or $state[$p:l1] = 62                             (: '>>' :)
          or $state[$p:l1] = 101                            (: 'eq' :)
          or $state[$p:l1] = 109                            (: 'ge' :)
          or $state[$p:l1] = 111                            (: 'gt' :)
          or $state[$p:l1] = 121                            (: 'is' :)
          or $state[$p:l1] = 125                            (: 'le' :)
          or $state[$p:l1] = 128                            (: 'lt' :)
          or $state[$p:l1] = 132) then                      (: 'ne' :)
      let $state :=
        if ($state[$p:l1] = 101                             (: 'eq' :)
         or $state[$p:l1] = 109                             (: 'ge' :)
         or $state[$p:l1] = 111                             (: 'gt' :)
         or $state[$p:l1] = 125                             (: 'le' :)
         or $state[$p:l1] = 128                             (: 'lt' :)
         or $state[$p:l1] = 132) then                       (: 'ne' :)
          let $state := p:parse-ValueComp($input, $state)
          return $state
        else if ($state[$p:l1] = 56                         (: '<<' :)
              or $state[$p:l1] = 62                         (: '>>' :)
              or $state[$p:l1] = 121) then                  (: 'is' :)
          let $state := p:parse-NodeComp($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:parse-GeneralComp($input, $state)
          return $state
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-RangeExpr($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "ComparisonExpr", $count)
};

(:~
 : Parse the 1st loop of production AndExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AndExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(99, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' | ';' | ']' | 'and' |
                                                               'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'else' | 'empty' | 'for' | 'let' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'where' |
                                                               '}' :)
    return
      if ($state[$p:l1] != 71) then                         (: 'and' :)
        $state
      else
        let $state := p:shift(71, $input, $state)           (: 'and' :)
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-ComparisonExpr($input, $state)
        return p:parse-AndExpr-1($input, $state)
};

(:~
 : Parse AndExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AndExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ComparisonExpr($input, $state)
  let $state := p:parse-AndExpr-1($input, $state)
  return p:reduce($state, "AndExpr", $count)
};

(:~
 : Parse the 1st loop of production OrExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(98, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' | ';' | ']' | 'ascending' |
                                                               'case' | 'collation' | 'default' | 'descending' |
                                                               'else' | 'empty' | 'for' | 'let' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'where' | '}' :)
    return
      if ($state[$p:l1] != 138) then                        (: 'or' :)
        $state
      else
        let $state := p:shift(138, $input, $state)          (: 'or' :)
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-AndExpr($input, $state)
        return p:parse-OrExpr-1($input, $state)
};

(:~
 : Parse OrExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-AndExpr($input, $state)
  let $state := p:parse-OrExpr-1($input, $state)
  return p:reduce($state, "OrExpr", $count)
};

(:~
 : Parse IfExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IfExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(114, $input, $state)                (: 'if' :)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(42, $input, $state)           (: S^WS | ('(' ':') | 'then' :)
  let $state := p:shift(159, $input, $state)                (: 'then' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:lookahead1W(37, $input, $state)           (: S^WS | ('(' ':') | 'else' :)
  let $state := p:shift(97, $input, $state)                 (: 'else' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "IfExpr", $count)
};

(:~
 : Parse CaseClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CaseClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(11, $input, $state)            (: 'case' :)
  let $state := p:shift(79, $input, $state)                 (: 'case' :)
  let $state := p:lookahead1W(135, $input, $state)          (: S^WS | QName^Token | '$' | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:shift(31, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(132, $input, $state)      (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
      let $state := p:parse-VarName($input, $state)
      let $state := p:lookahead1W(35, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:shift(72, $input, $state)             (: 'as' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-SequenceType($input, $state)
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:shift(148, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "CaseClause", $count)
};

(:~
 : Parse the 1st loop of production TypeswitchExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeswitchExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(20, $input, $state)         (: EPSILON | S^WS | ('(' ':') :)
    let $state := p:parse-CaseClause($input, $state)
    let $state := p:lookahead1W(69, $input, $state)         (: S^WS | ('(' ':') | 'case' | 'default' :)
    return
      if ($state[$p:l1] != 79) then                         (: 'case' :)
        $state
      else
        p:parse-TypeswitchExpr-1($input, $state)
};

(:~
 : Parse TypeswitchExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeswitchExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(163, $input, $state)                (: 'typeswitch' :)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-TypeswitchExpr-1($input, $state)
  let $state := p:shift(89, $input, $state)                 (: 'default' :)
  let $state := p:lookahead1W(52, $input, $state)           (: S^WS | '$' | ('(' ':') | 'return' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:shift(31, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(132, $input, $state)      (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
      let $state := p:parse-VarName($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:shift(148, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "TypeswitchExpr", $count)
};

(:~
 : Parse QuantifiedBinding.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QuantifiedBinding($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(5, $input, $state)             (: '$' :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(132, $input, $state)          (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(65, $input, $state)           (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 72) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(38, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:shift(116, $input, $state)                (: 'in' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "QuantifiedBinding", $count)
};

(:~
 : Parse the 1st loop of production QuantifiedExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QuantifiedExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(62, $input, $state)         (: S^WS | ('(' ':') | ',' | 'satisfies' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-QuantifiedBinding($input, $state)
        return p:parse-QuantifiedExpr-1($input, $state)
};

(:~
 : Parse QuantifiedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QuantifiedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 154) then                           (: 'some' :)
      let $state := p:shift(154, $input, $state)            (: 'some' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(102, $input, $state)            (: 'every' :)
      return $state
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-QuantifiedBinding($input, $state)
  let $state := p:parse-QuantifiedExpr-1($input, $state)
  let $state := p:shift(149, $input, $state)                (: 'satisfies' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "QuantifiedExpr", $count)
};

(:~
 : Parse OrderModifier.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderModifier($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(92, $input, $state)           (: S^WS | ('(' ':') | ',' | 'ascending' | 'collation' |
                                                               'descending' | 'empty' | 'return' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 73                             (: 'ascending' :)
          or $state[$p:l1] = 92) then                       (: 'descending' :)
      let $state :=
        if ($state[$p:l1] = 73) then                        (: 'ascending' :)
          let $state := p:shift(73, $input, $state)         (: 'ascending' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(92, $input, $state)         (: 'descending' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(85, $input, $state)           (: S^WS | ('(' ':') | ',' | 'collation' | 'empty' | 'return' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 98) then                       (: 'empty' :)
      let $state := p:shift(98, $input, $state)             (: 'empty' :)
      let $state := p:lookahead1W(70, $input, $state)       (: S^WS | ('(' ':') | 'greatest' | 'least' :)
      let $state :=
        if ($state[$p:l1] = 110) then                       (: 'greatest' :)
          let $state := p:shift(110, $input, $state)        (: 'greatest' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(126, $input, $state)        (: 'least' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(79, $input, $state)           (: S^WS | ('(' ':') | ',' | 'collation' | 'return' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 83) then                       (: 'collation' :)
      let $state := p:shift(83, $input, $state)             (: 'collation' :)
      let $state := p:lookahead1W(22, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:parse-URILiteral($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "OrderModifier", $count)
};

(:~
 : Parse OrderSpec.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderSpec($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-OrderModifier($input, $state)
  return p:reduce($state, "OrderSpec", $count)
};

(:~
 : Parse the 1st loop of production OrderSpecList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderSpecList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(61, $input, $state)         (: S^WS | ('(' ':') | ',' | 'return' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-OrderSpec($input, $state)
        return p:parse-OrderSpecList-1($input, $state)
};

(:~
 : Parse OrderSpecList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderSpecList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-OrderSpec($input, $state)
  let $state := p:parse-OrderSpecList-1($input, $state)
  return p:reduce($state, "OrderSpecList", $count)
};

(:~
 : Parse OrderByClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderByClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 139) then                           (: 'order' :)
      let $state := p:shift(139, $input, $state)            (: 'order' :)
      let $state := p:lookahead1W(36, $input, $state)       (: S^WS | ('(' ':') | 'by' :)
      let $state := p:shift(78, $input, $state)             (: 'by' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(155, $input, $state)            (: 'stable' :)
      let $state := p:lookahead1W(40, $input, $state)       (: S^WS | ('(' ':') | 'order' :)
      let $state := p:shift(139, $input, $state)            (: 'order' :)
      let $state := p:lookahead1W(36, $input, $state)       (: S^WS | ('(' ':') | 'by' :)
      let $state := p:shift(78, $input, $state)             (: 'by' :)
      return $state
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-OrderSpecList($input, $state)
  return p:reduce($state, "OrderByClause", $count)
};

(:~
 : Parse WhereClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-WhereClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(169, $input, $state)                (: 'where' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "WhereClause", $count)
};

(:~
 : Parse LetBinding.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LetBinding($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(5, $input, $state)             (: '$' :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(132, $input, $state)          (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(64, $input, $state)           (: S^WS | ('(' ':') | ':=' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 72) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(31, $input, $state)           (: S^WS | ('(' ':') | ':=' :)
  let $state := p:shift(51, $input, $state)                 (: ':=' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "LetBinding", $count)
};

(:~
 : Parse the 1st loop of production LetClause (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LetClause-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(95, $input, $state)         (: S^WS | ('(' ':') | ',' | 'for' | 'let' | 'order' |
                                                               'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-LetBinding($input, $state)
        return p:parse-LetClause-1($input, $state)
};

(:~
 : Parse LetClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LetClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(127, $input, $state)                (: 'let' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-LetBinding($input, $state)
  let $state := p:parse-LetClause-1($input, $state)
  return p:reduce($state, "LetClause", $count)
};

(:~
 : Parse PositionalVar.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PositionalVar($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(74, $input, $state)                 (: 'at' :)
  let $state := p:lookahead1W(26, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(132, $input, $state)          (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  return p:reduce($state, "PositionalVar", $count)
};

(:~
 : Parse VarName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-QName($input, $state)
  return p:reduce($state, "VarName", $count)
};

(:~
 : Parse ForBinding.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForBinding($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(5, $input, $state)             (: '$' :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(132, $input, $state)          (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | 'as' | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 72) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(67, $input, $state)           (: S^WS | ('(' ':') | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 74) then                       (: 'at' :)
      let $state := p:parse-PositionalVar($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(38, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:shift(116, $input, $state)                (: 'in' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "ForBinding", $count)
};

(:~
 : Parse the 1st loop of production ForClause (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForClause-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(95, $input, $state)         (: S^WS | ('(' ':') | ',' | 'for' | 'let' | 'order' |
                                                               'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-ForBinding($input, $state)
        return p:parse-ForClause-1($input, $state)
};

(:~
 : Parse ForClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(107, $input, $state)                (: 'for' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ForBinding($input, $state)
  let $state := p:parse-ForClause-1($input, $state)
  return p:reduce($state, "ForClause", $count)
};

(:~
 : Parse the 1st loop of production FLWORExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FLWORExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:l1] = 107) then                         (: 'for' :)
        let $state := p:parse-ForClause($input, $state)
        return $state
      else if ($state[$p:error]) then
        $state
      else
        let $state := p:parse-LetClause($input, $state)
        return $state
    let $state := p:lookahead1W(93, $input, $state)         (: S^WS | ('(' ':') | 'for' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' :)
    return
      if ($state[$p:l1] != 107                              (: 'for' :)
      and $state[$p:l1] != 127) then                        (: 'let' :)
        $state
      else
        p:parse-FLWORExpr-1($input, $state)
};

(:~
 : Parse FLWORExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FLWORExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-FLWORExpr-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 169) then                      (: 'where' :)
      let $state := p:parse-WhereClause($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(83, $input, $state)           (: S^WS | ('(' ':') | 'order' | 'return' | 'stable' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 148) then                     (: 'return' :)
      let $state := p:parse-OrderByClause($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:shift(148, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "FLWORExpr", $count)
};

(:~
 : Parse ExprSingle.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ExprSingle($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(146, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | ('(' ':') | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               '^' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 114                                 (: 'typeswitch' :)
     or $state[$p:l1] = 163) then                           (: 'typeswitch' :)
      let $state := p:lookahead2W(120, $input, $state)      (: S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 102                            (: 'for' :)
          or $state[$p:l1] = 107                            (: 'let' :)
          or $state[$p:l1] = 127                            (: 'some' :)
          or $state[$p:l1] = 154) then                      (: 'some' :)
      let $state := p:lookahead2W(122, $input, $state)      (: S^WS | '!=' | '$' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 8043                                (: 'for' '$' :)
     or $state[$p:lk] = 8063) then                          (: 'let' '$' :)
      let $state := p:parse-FLWORExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 8038                           (: 'every' '$' :)
          or $state[$p:lk] = 8090) then                     (: 'some' '$' :)
      let $state := p:parse-QuantifiedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 8611) then                     (: 'typeswitch' '(' :)
      let $state := p:parse-TypeswitchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 8562) then                     (: 'if' '(' :)
      let $state := p:parse-IfExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-OrExpr($input, $state)
      return $state
  return p:reduce($state, "ExprSingle", $count)
};

(:~
 : Parse the 1st loop of production Expr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Expr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(87, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' | ';' | ']' | '}' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-ExprSingle($input, $state)
        return p:parse-Expr-1($input, $state)
};

(:~
 : Parse Expr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Expr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:parse-Expr-1($input, $state)
  return p:reduce($state, "Expr", $count)
};

(:~
 : Parse OccurrenceIndicator.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OccurrenceIndicator($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 63) then                            (: '?' :)
      let $state := p:shift(63, $input, $state)             (: '?' :)
      return $state
    else if ($state[$p:l1] = 38) then                       (: '*' :)
      let $state := p:shift(38, $input, $state)             (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(40, $input, $state)             (: '+' :)
      return $state
  return p:reduce($state, "OccurrenceIndicator", $count)
};

(:~
 : Parse AtomicType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AtomicType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-QName($input, $state)
  return p:reduce($state, "AtomicType", $count)
};

(:~
 : Parse AnyKindTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AnyKindTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(135, $input, $state)                (: 'node' :)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "AnyKindTest", $count)
};

(:~
 : Parse TextTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TextTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(158, $input, $state)                (: 'text' :)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "TextTest", $count)
};

(:~
 : Parse CommentTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CommentTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(84, $input, $state)                 (: 'comment' :)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "CommentTest", $count)
};

(:~
 : Parse PITest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PITest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(147, $input, $state)                (: 'processing-instruction' :)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(105, $input, $state)          (: StringLiteral | S^WS | NCName^Token | ('(' ':') | ')' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'eq' | 'except' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'to' | 'treat' | 'union' |
                                                               'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36) then                      (: ')' :)
      let $state :=
        if ($state[$p:l1] = 6) then                         (: StringLiteral :)
          let $state := p:shift(6, $input, $state)          (: StringLiteral :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:parse-NCName($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "PITest", $count)
};

(:~
 : Parse AttributeDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttributeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-AttributeName($input, $state)
  return p:reduce($state, "AttributeDeclaration", $count)
};

(:~
 : Parse SchemaAttributeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaAttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(151, $input, $state)                (: 'schema-attribute' :)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(132, $input, $state)          (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state := p:parse-AttributeDeclaration($input, $state)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "SchemaAttributeTest", $count)
};

(:~
 : Parse AttributeName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttributeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-QName($input, $state)
  return p:reduce($state, "AttributeName", $count)
};

(:~
 : Parse AttribNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttribNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 37) then                            (: '*' :)
      let $state := p:shift(37, $input, $state)             (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AttributeName($input, $state)
      return $state
  return p:reduce($state, "AttribNameOrWildcard", $count)
};

(:~
 : Parse AttributeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(75, $input, $state)                 (: 'attribute' :)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(140, $input, $state)          (: S^WS | QName^Token | ('(' ':') | ')' | '*' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36) then                      (: ')' :)
      let $state := p:parse-AttribNameOrWildcard($input, $state)
      let $state := p:lookahead1W(58, $input, $state)       (: S^WS | ('(' ':') | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 41) then                   (: ',' :)
          let $state := p:shift(41, $input, $state)         (: ',' :)
          let $state := p:lookahead1W(132, $input, $state)  (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
          let $state := p:parse-TypeName($input, $state)
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "AttributeTest", $count)
};

(:~
 : Parse ElementDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ElementName($input, $state)
  return p:reduce($state, "ElementDeclaration", $count)
};

(:~
 : Parse SchemaElementTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaElementTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(152, $input, $state)                (: 'schema-element' :)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(132, $input, $state)          (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state := p:parse-ElementDeclaration($input, $state)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "SchemaElementTest", $count)
};

(:~
 : Parse TypeName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-QName($input, $state)
  return p:reduce($state, "TypeName", $count)
};

(:~
 : Parse ElementName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-QName($input, $state)
  return p:reduce($state, "ElementName", $count)
};

(:~
 : Parse ElementNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 37) then                            (: '*' :)
      let $state := p:shift(37, $input, $state)             (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ElementName($input, $state)
      return $state
  return p:reduce($state, "ElementNameOrWildcard", $count)
};

(:~
 : Parse ElementTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(96, $input, $state)                 (: 'element' :)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(140, $input, $state)          (: S^WS | QName^Token | ('(' ':') | ')' | '*' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36) then                      (: ')' :)
      let $state := p:parse-ElementNameOrWildcard($input, $state)
      let $state := p:lookahead1W(58, $input, $state)       (: S^WS | ('(' ':') | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 41) then                   (: ',' :)
          let $state := p:shift(41, $input, $state)         (: ',' :)
          let $state := p:lookahead1W(132, $input, $state)  (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
          let $state := p:parse-TypeName($input, $state)
          let $state := p:lookahead1W(60, $input, $state)   (: S^WS | ('(' ':') | ')' | '?' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 63) then               (: '?' :)
              let $state := p:shift(63, $input, $state)     (: '?' :)
              return $state
            else
              $state
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "ElementTest", $count)
};

(:~
 : Parse DocumentTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DocumentTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(95, $input, $state)                 (: 'document-node' :)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(78, $input, $state)           (: S^WS | ('(' ':') | ')' | 'element' | 'schema-element' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36) then                      (: ')' :)
      let $state :=
        if ($state[$p:l1] = 96) then                        (: 'element' :)
          let $state := p:parse-ElementTest($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:parse-SchemaElementTest($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "DocumentTest", $count)
};

(:~
 : Parse KindTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-KindTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 95) then                            (: 'document-node' :)
      let $state := p:parse-DocumentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 96) then                       (: 'element' :)
      let $state := p:parse-ElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 75) then                       (: 'attribute' :)
      let $state := p:parse-AttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 152) then                      (: 'schema-element' :)
      let $state := p:parse-SchemaElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 151) then                      (: 'schema-attribute' :)
      let $state := p:parse-SchemaAttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 147) then                      (: 'processing-instruction' :)
      let $state := p:parse-PITest($input, $state)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'comment' :)
      let $state := p:parse-CommentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 158) then                      (: 'text' :)
      let $state := p:parse-TextTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AnyKindTest($input, $state)
      return $state
  return p:reduce($state, "KindTest", $count)
};

(:~
 : Parse ItemType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ItemType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 75                                  (: 'comment' :)
     or $state[$p:l1] = 84                                  (: 'document-node' :)
     or $state[$p:l1] = 95                                  (: 'element' :)
     or $state[$p:l1] = 96                                  (: 'item' :)
     or $state[$p:l1] = 122                                 (: 'node' :)
     or $state[$p:l1] = 135                                 (: 'processing-instruction' :)
     or $state[$p:l1] = 147                                 (: 'schema-attribute' :)
     or $state[$p:l1] = 151                                 (: 'schema-element' :)
     or $state[$p:l1] = 152                                 (: 'text' :)
     or $state[$p:l1] = 158) then                           (: 'text' :)
      let $state := p:lookahead2W(119, $input, $state)      (: S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '*' | '+' |
                                                               '+' | ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '?' | ']' | 'and' | 'ascending' |
                                                               'at' | 'case' | 'collation' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'in' | 'instance' | 'intersect' |
                                                               'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'to' |
                                                               'union' | 'where' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 8523                                (: 'attribute' '(' :)
     or $state[$p:lk] = 8532                                (: 'comment' '(' :)
     or $state[$p:lk] = 8543                                (: 'document-node' '(' :)
     or $state[$p:lk] = 8544                                (: 'element' '(' :)
     or $state[$p:lk] = 8583                                (: 'node' '(' :)
     or $state[$p:lk] = 8595                                (: 'processing-instruction' '(' :)
     or $state[$p:lk] = 8599                                (: 'schema-attribute' '(' :)
     or $state[$p:lk] = 8600                                (: 'schema-element' '(' :)
     or $state[$p:lk] = 8606) then                          (: 'text' '(' :)
      let $state := p:parse-KindTest($input, $state)
      return $state
    else if ($state[$p:lk] = 8570) then                     (: 'item' '(' :)
      let $state := p:shift(122, $input, $state)            (: 'item' :)
      let $state := p:lookahead1W(27, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:shift(33, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:shift(36, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AtomicType($input, $state)
      return $state
  return p:reduce($state, "ItemType", $count)
};

(:~
 : Parse SequenceType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SequenceType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(129, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 99) then                            (: 'empty-sequence' :)
      let $state := p:lookahead2W(119, $input, $state)      (: S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '*' | '+' |
                                                               '+' | ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '?' | ']' | 'and' | 'ascending' |
                                                               'at' | 'case' | 'collation' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'in' | 'instance' | 'intersect' |
                                                               'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'to' |
                                                               'union' | 'where' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 8547) then                          (: 'empty-sequence' '(' :)
      let $state := p:shift(99, $input, $state)             (: 'empty-sequence' :)
      let $state := p:lookahead1W(27, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:shift(33, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:shift(36, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ItemType($input, $state)
      let $state := p:lookahead1W(117, $input, $state)      (: S^WS | '!=' | ('(' ':') | ')' | '*' | '*' | '+' | '+' |
                                                               ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '?' | ']' | 'and' | 'ascending' | 'at' |
                                                               'case' | 'collation' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'gt' | 'idiv' | 'in' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'ne' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'to' | 'union' |
                                                               'where' | '|' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 38                         (: '*' :)
              or $state[$p:l1] = 40                         (: '+' :)
              or $state[$p:l1] = 63) then                   (: '?' :)
          let $state := p:parse-OccurrenceIndicator($input, $state)
          return $state
        else
          $state
      return $state
  return p:reduce($state, "SequenceType", $count)
};

(:~
 : Parse TypeDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(72, $input, $state)                 (: 'as' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-SequenceType($input, $state)
  return p:reduce($state, "TypeDeclaration", $count)
};

(:~
 : Parse FunctionName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(126, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'else' | 'empty' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'import' | 'include' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'or' | 'order' |
                                                               'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'return' | 'satisfies' | 'self' |
                                                               'some' | 'stable' | 'to' | 'treat' | 'union' |
                                                               'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 69) then                            (: 'ancestor' :)
      let $state := p:shift(69, $input, $state)             (: 'ancestor' :)
      return $state
    else if ($state[$p:l1] = 70) then                       (: 'ancestor-or-self' :)
      let $state := p:shift(70, $input, $state)             (: 'ancestor-or-self' :)
      return $state
    else if ($state[$p:l1] = 71) then                       (: 'and' :)
      let $state := p:shift(71, $input, $state)             (: 'and' :)
      return $state
    else if ($state[$p:l1] = 73) then                       (: 'ascending' :)
      let $state := p:shift(73, $input, $state)             (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 79) then                       (: 'case' :)
      let $state := p:shift(79, $input, $state)             (: 'case' :)
      return $state
    else if ($state[$p:l1] = 80) then                       (: 'cast' :)
      let $state := p:shift(80, $input, $state)             (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 81) then                       (: 'castable' :)
      let $state := p:shift(81, $input, $state)             (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 82) then                       (: 'child' :)
      let $state := p:shift(82, $input, $state)             (: 'child' :)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'collation' :)
      let $state := p:shift(83, $input, $state)             (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 88) then                       (: 'declare' :)
      let $state := p:shift(88, $input, $state)             (: 'declare' :)
      return $state
    else if ($state[$p:l1] = 89) then                       (: 'default' :)
      let $state := p:shift(89, $input, $state)             (: 'default' :)
      return $state
    else if ($state[$p:l1] = 90) then                       (: 'descendant' :)
      let $state := p:shift(90, $input, $state)             (: 'descendant' :)
      return $state
    else if ($state[$p:l1] = 91) then                       (: 'descendant-or-self' :)
      let $state := p:shift(91, $input, $state)             (: 'descendant-or-self' :)
      return $state
    else if ($state[$p:l1] = 92) then                       (: 'descending' :)
      let $state := p:shift(92, $input, $state)             (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'div' :)
      let $state := p:shift(93, $input, $state)             (: 'div' :)
      return $state
    else if ($state[$p:l1] = 94) then                       (: 'document' :)
      let $state := p:shift(94, $input, $state)             (: 'document' :)
      return $state
    else if ($state[$p:l1] = 97) then                       (: 'else' :)
      let $state := p:shift(97, $input, $state)             (: 'else' :)
      return $state
    else if ($state[$p:l1] = 98) then                       (: 'empty' :)
      let $state := p:shift(98, $input, $state)             (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 101) then                      (: 'eq' :)
      let $state := p:shift(101, $input, $state)            (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 102) then                      (: 'every' :)
      let $state := p:shift(102, $input, $state)            (: 'every' :)
      return $state
    else if ($state[$p:l1] = 103) then                      (: 'except' :)
      let $state := p:shift(103, $input, $state)            (: 'except' :)
      return $state
    else if ($state[$p:l1] = 105) then                      (: 'following' :)
      let $state := p:shift(105, $input, $state)            (: 'following' :)
      return $state
    else if ($state[$p:l1] = 106) then                      (: 'following-sibling' :)
      let $state := p:shift(106, $input, $state)            (: 'following-sibling' :)
      return $state
    else if ($state[$p:l1] = 107) then                      (: 'for' :)
      let $state := p:shift(107, $input, $state)            (: 'for' :)
      return $state
    else if ($state[$p:l1] = 109) then                      (: 'ge' :)
      let $state := p:shift(109, $input, $state)            (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 111) then                      (: 'gt' :)
      let $state := p:shift(111, $input, $state)            (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 113) then                      (: 'idiv' :)
      let $state := p:shift(113, $input, $state)            (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 115) then                      (: 'import' :)
      let $state := p:shift(115, $input, $state)            (: 'import' :)
      return $state
    else if ($state[$p:l1] = 117) then                      (: 'include' :)
      let $state := p:shift(117, $input, $state)            (: 'include' :)
      return $state
    else if ($state[$p:l1] = 119) then                      (: 'instance' :)
      let $state := p:shift(119, $input, $state)            (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 120) then                      (: 'intersect' :)
      let $state := p:shift(120, $input, $state)            (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 121) then                      (: 'is' :)
      let $state := p:shift(121, $input, $state)            (: 'is' :)
      return $state
    else if ($state[$p:l1] = 125) then                      (: 'le' :)
      let $state := p:shift(125, $input, $state)            (: 'le' :)
      return $state
    else if ($state[$p:l1] = 127) then                      (: 'let' :)
      let $state := p:shift(127, $input, $state)            (: 'let' :)
      return $state
    else if ($state[$p:l1] = 128) then                      (: 'lt' :)
      let $state := p:shift(128, $input, $state)            (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 129) then                      (: 'mod' :)
      let $state := p:shift(129, $input, $state)            (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 130) then                      (: 'module' :)
      let $state := p:shift(130, $input, $state)            (: 'module' :)
      return $state
    else if ($state[$p:l1] = 131) then                      (: 'namespace' :)
      let $state := p:shift(131, $input, $state)            (: 'namespace' :)
      return $state
    else if ($state[$p:l1] = 132) then                      (: 'ne' :)
      let $state := p:shift(132, $input, $state)            (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 138) then                      (: 'or' :)
      let $state := p:shift(138, $input, $state)            (: 'or' :)
      return $state
    else if ($state[$p:l1] = 139) then                      (: 'order' :)
      let $state := p:shift(139, $input, $state)            (: 'order' :)
      return $state
    else if ($state[$p:l1] = 140) then                      (: 'ordered' :)
      let $state := p:shift(140, $input, $state)            (: 'ordered' :)
      return $state
    else if ($state[$p:l1] = 142) then                      (: 'param' :)
      let $state := p:shift(142, $input, $state)            (: 'param' :)
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'parent' :)
      let $state := p:shift(143, $input, $state)            (: 'parent' :)
      return $state
    else if ($state[$p:l1] = 144) then                      (: 'preceding' :)
      let $state := p:shift(144, $input, $state)            (: 'preceding' :)
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'preceding-sibling' :)
      let $state := p:shift(145, $input, $state)            (: 'preceding-sibling' :)
      return $state
    else if ($state[$p:l1] = 148) then                      (: 'return' :)
      let $state := p:shift(148, $input, $state)            (: 'return' :)
      return $state
    else if ($state[$p:l1] = 149) then                      (: 'satisfies' :)
      let $state := p:shift(149, $input, $state)            (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 153) then                      (: 'self' :)
      let $state := p:shift(153, $input, $state)            (: 'self' :)
      return $state
    else if ($state[$p:l1] = 154) then                      (: 'some' :)
      let $state := p:shift(154, $input, $state)            (: 'some' :)
      return $state
    else if ($state[$p:l1] = 155) then                      (: 'stable' :)
      let $state := p:shift(155, $input, $state)            (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 160) then                      (: 'to' :)
      let $state := p:shift(160, $input, $state)            (: 'to' :)
      return $state
    else if ($state[$p:l1] = 161) then                      (: 'treat' :)
      let $state := p:shift(161, $input, $state)            (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 164) then                      (: 'union' :)
      let $state := p:shift(164, $input, $state)            (: 'union' :)
      return $state
    else if ($state[$p:l1] = 165) then                      (: 'unordered' :)
      let $state := p:shift(165, $input, $state)            (: 'unordered' :)
      return $state
    else if ($state[$p:l1] = 166) then                      (: 'validate' :)
      let $state := p:shift(166, $input, $state)            (: 'validate' :)
      return $state
    else if ($state[$p:l1] = 169) then                      (: 'where' :)
      let $state := p:shift(169, $input, $state)            (: 'where' :)
      return $state
    else if ($state[$p:l1] = 170) then                      (: 'xquery' :)
      let $state := p:shift(170, $input, $state)            (: 'xquery' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(18, $input, $state)             (: QName^Token :)
      return $state
  return p:reduce($state, "FunctionName", $count)
};

(:~
 : Parse QName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(129, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 75) then                            (: 'attribute' :)
      let $state := p:shift(75, $input, $state)             (: 'attribute' :)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'comment' :)
      let $state := p:shift(84, $input, $state)             (: 'comment' :)
      return $state
    else if ($state[$p:l1] = 95) then                       (: 'document-node' :)
      let $state := p:shift(95, $input, $state)             (: 'document-node' :)
      return $state
    else if ($state[$p:l1] = 96) then                       (: 'element' :)
      let $state := p:shift(96, $input, $state)             (: 'element' :)
      return $state
    else if ($state[$p:l1] = 99) then                       (: 'empty-sequence' :)
      let $state := p:shift(99, $input, $state)             (: 'empty-sequence' :)
      return $state
    else if ($state[$p:l1] = 114) then                      (: 'if' :)
      let $state := p:shift(114, $input, $state)            (: 'if' :)
      return $state
    else if ($state[$p:l1] = 122) then                      (: 'item' :)
      let $state := p:shift(122, $input, $state)            (: 'item' :)
      return $state
    else if ($state[$p:l1] = 135) then                      (: 'node' :)
      let $state := p:shift(135, $input, $state)            (: 'node' :)
      return $state
    else if ($state[$p:l1] = 147) then                      (: 'processing-instruction' :)
      let $state := p:shift(147, $input, $state)            (: 'processing-instruction' :)
      return $state
    else if ($state[$p:l1] = 151) then                      (: 'schema-attribute' :)
      let $state := p:shift(151, $input, $state)            (: 'schema-attribute' :)
      return $state
    else if ($state[$p:l1] = 152) then                      (: 'schema-element' :)
      let $state := p:shift(152, $input, $state)            (: 'schema-element' :)
      return $state
    else if ($state[$p:l1] = 158) then                      (: 'text' :)
      let $state := p:shift(158, $input, $state)            (: 'text' :)
      return $state
    else if ($state[$p:l1] = 163) then                      (: 'typeswitch' :)
      let $state := p:shift(163, $input, $state)            (: 'typeswitch' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-FunctionName($input, $state)
      return $state
  return p:reduce($state, "QName", $count)
};

(:~
 : Parse Param.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Param($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(5, $input, $state)             (: '$' :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(132, $input, $state)          (: S^WS | QName^Token | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'include' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state := p:parse-QName($input, $state)
  let $state := p:lookahead1W(86, $input, $state)           (: S^WS | ('(' ':') | ')' | ',' | ':=' | ';' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 72) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "Param", $count)
};

(:~
 : Parse ParamDef.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParamDef($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(142, $input, $state)                (: 'param' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Param($input, $state)
  let $state := p:lookahead1W(63, $input, $state)           (: S^WS | ('(' ':') | ':=' | ';' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 51) then                       (: ':=' :)
      let $state := p:shift(51, $input, $state)             (: ':=' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "ParamDef", $count)
};

(:~
 : Parse ImportDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ImportDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(115, $input, $state)                (: 'import' :)
  let $state := p:lookahead1W(22, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:parse-URILiteral($input, $state)
  return p:reduce($state, "ImportDecl", $count)
};

(:~
 : Parse IncludeDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IncludeDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(117, $input, $state)                (: 'include' :)
  let $state := p:lookahead1W(22, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:parse-URILiteral($input, $state)
  return p:reduce($state, "IncludeDecl", $count)
};

(:~
 : Parse URILiteral.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-URILiteral($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(6, $input, $state)                  (: StringLiteral :)
  return p:reduce($state, "URILiteral", $count)
};

(:~
 : Parse NCName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NCName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(100, $input, $state)           (: NCName^Token | 'and' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'ne' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'to' | 'treat' |
                                                               'union' | 'where' :)
  let $state :=
    if ($state[$p:l1] = 71) then                            (: 'and' :)
      let $state := p:shift(71, $input, $state)             (: 'and' :)
      return $state
    else if ($state[$p:l1] = 73) then                       (: 'ascending' :)
      let $state := p:shift(73, $input, $state)             (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 79) then                       (: 'case' :)
      let $state := p:shift(79, $input, $state)             (: 'case' :)
      return $state
    else if ($state[$p:l1] = 80) then                       (: 'cast' :)
      let $state := p:shift(80, $input, $state)             (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 81) then                       (: 'castable' :)
      let $state := p:shift(81, $input, $state)             (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'collation' :)
      let $state := p:shift(83, $input, $state)             (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 89) then                       (: 'default' :)
      let $state := p:shift(89, $input, $state)             (: 'default' :)
      return $state
    else if ($state[$p:l1] = 92) then                       (: 'descending' :)
      let $state := p:shift(92, $input, $state)             (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'div' :)
      let $state := p:shift(93, $input, $state)             (: 'div' :)
      return $state
    else if ($state[$p:l1] = 97) then                       (: 'else' :)
      let $state := p:shift(97, $input, $state)             (: 'else' :)
      return $state
    else if ($state[$p:l1] = 98) then                       (: 'empty' :)
      let $state := p:shift(98, $input, $state)             (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 101) then                      (: 'eq' :)
      let $state := p:shift(101, $input, $state)            (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 103) then                      (: 'except' :)
      let $state := p:shift(103, $input, $state)            (: 'except' :)
      return $state
    else if ($state[$p:l1] = 107) then                      (: 'for' :)
      let $state := p:shift(107, $input, $state)            (: 'for' :)
      return $state
    else if ($state[$p:l1] = 109) then                      (: 'ge' :)
      let $state := p:shift(109, $input, $state)            (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 111) then                      (: 'gt' :)
      let $state := p:shift(111, $input, $state)            (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 113) then                      (: 'idiv' :)
      let $state := p:shift(113, $input, $state)            (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 119) then                      (: 'instance' :)
      let $state := p:shift(119, $input, $state)            (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 120) then                      (: 'intersect' :)
      let $state := p:shift(120, $input, $state)            (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 121) then                      (: 'is' :)
      let $state := p:shift(121, $input, $state)            (: 'is' :)
      return $state
    else if ($state[$p:l1] = 125) then                      (: 'le' :)
      let $state := p:shift(125, $input, $state)            (: 'le' :)
      return $state
    else if ($state[$p:l1] = 127) then                      (: 'let' :)
      let $state := p:shift(127, $input, $state)            (: 'let' :)
      return $state
    else if ($state[$p:l1] = 128) then                      (: 'lt' :)
      let $state := p:shift(128, $input, $state)            (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 129) then                      (: 'mod' :)
      let $state := p:shift(129, $input, $state)            (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 132) then                      (: 'ne' :)
      let $state := p:shift(132, $input, $state)            (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 138) then                      (: 'or' :)
      let $state := p:shift(138, $input, $state)            (: 'or' :)
      return $state
    else if ($state[$p:l1] = 139) then                      (: 'order' :)
      let $state := p:shift(139, $input, $state)            (: 'order' :)
      return $state
    else if ($state[$p:l1] = 148) then                      (: 'return' :)
      let $state := p:shift(148, $input, $state)            (: 'return' :)
      return $state
    else if ($state[$p:l1] = 149) then                      (: 'satisfies' :)
      let $state := p:shift(149, $input, $state)            (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 155) then                      (: 'stable' :)
      let $state := p:shift(155, $input, $state)            (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 160) then                      (: 'to' :)
      let $state := p:shift(160, $input, $state)            (: 'to' :)
      return $state
    else if ($state[$p:l1] = 161) then                      (: 'treat' :)
      let $state := p:shift(161, $input, $state)            (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 164) then                      (: 'union' :)
      let $state := p:shift(164, $input, $state)            (: 'union' :)
      return $state
    else if ($state[$p:l1] = 169) then                      (: 'where' :)
      let $state := p:shift(169, $input, $state)            (: 'where' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(17, $input, $state)             (: NCName^Token :)
      return $state
  return p:reduce($state, "NCName", $count)
};

(:~
 : Parse NamespaceDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NamespaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(131, $input, $state)                (: 'namespace' :)
  let $state := p:lookahead1W(101, $input, $state)          (: S^WS | NCName^Token | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' :)
  let $state := p:parse-NCName($input, $state)
  let $state := p:lookahead1W(33, $input, $state)           (: S^WS | ('(' ':') | '=' :)
  let $state := p:shift(59, $input, $state)                 (: '=' :)
  let $state := p:lookahead1W(22, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:parse-URILiteral($input, $state)
  return p:reduce($state, "NamespaceDecl", $count)
};

(:~
 : Parse the 1st loop of production CarrotModule (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CarrotModule-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(128, $input, $state)        (: S^WS | QName^Token | EOF | '$' | ('(' ':') | '^' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'else' | 'empty' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'import' | 'include' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'or' | 'order' |
                                                               'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'return' | 'satisfies' | 'self' |
                                                               'some' | 'stable' | 'to' | 'treat' | 'union' |
                                                               'unordered' | 'validate' | 'where' | 'xquery' :)
    let $state :=
      if ($state[$p:l1] = 131) then                         (: 'namespace' :)
        let $state := p:lookahead2W(102, $input, $state)    (: S^WS | NCName^Token | '(' | ('(' ':') | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'eq' | 'except' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'to' | 'treat' | 'union' |
                                                               'where' :)
        return $state
      else if ($state[$p:l1] = 142) then                    (: 'param' :)
        let $state := p:lookahead2W(50, $input, $state)     (: S^WS | '$' | '(' | ('(' ':') :)
        return $state
      else if ($state[$p:l1] = 115                          (: 'include' :)
            or $state[$p:l1] = 117) then                    (: 'include' :)
        let $state := p:lookahead2W(47, $input, $state)     (: StringLiteral | S^WS | '(' | ('(' ':') :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 1651                             (: 'import' StringLiteral :)
      and $state[$p:lk] != 1653                             (: 'include' StringLiteral :)
      and $state[$p:lk] != 4483                             (: 'namespace' NCName^Token :)
      and $state[$p:lk] != 8078                             (: 'param' '$' :)
      and $state[$p:lk] != 18307                            (: 'namespace' 'and' :)
      and $state[$p:lk] != 18819                            (: 'namespace' 'ascending' :)
      and $state[$p:lk] != 20355                            (: 'namespace' 'case' :)
      and $state[$p:lk] != 20611                            (: 'namespace' 'cast' :)
      and $state[$p:lk] != 20867                            (: 'namespace' 'castable' :)
      and $state[$p:lk] != 21379                            (: 'namespace' 'collation' :)
      and $state[$p:lk] != 22915                            (: 'namespace' 'default' :)
      and $state[$p:lk] != 23683                            (: 'namespace' 'descending' :)
      and $state[$p:lk] != 23939                            (: 'namespace' 'div' :)
      and $state[$p:lk] != 24963                            (: 'namespace' 'else' :)
      and $state[$p:lk] != 25219                            (: 'namespace' 'empty' :)
      and $state[$p:lk] != 25987                            (: 'namespace' 'eq' :)
      and $state[$p:lk] != 26499                            (: 'namespace' 'except' :)
      and $state[$p:lk] != 27523                            (: 'namespace' 'for' :)
      and $state[$p:lk] != 28035                            (: 'namespace' 'ge' :)
      and $state[$p:lk] != 28547                            (: 'namespace' 'gt' :)
      and $state[$p:lk] != 29059                            (: 'namespace' 'idiv' :)
      and $state[$p:lk] != 30595                            (: 'namespace' 'instance' :)
      and $state[$p:lk] != 30851                            (: 'namespace' 'intersect' :)
      and $state[$p:lk] != 31107                            (: 'namespace' 'is' :)
      and $state[$p:lk] != 32131                            (: 'namespace' 'le' :)
      and $state[$p:lk] != 32643                            (: 'namespace' 'let' :)
      and $state[$p:lk] != 32899                            (: 'namespace' 'lt' :)
      and $state[$p:lk] != 33155                            (: 'namespace' 'mod' :)
      and $state[$p:lk] != 33923                            (: 'namespace' 'ne' :)
      and $state[$p:lk] != 35459                            (: 'namespace' 'or' :)
      and $state[$p:lk] != 35715                            (: 'namespace' 'order' :)
      and $state[$p:lk] != 38019                            (: 'namespace' 'return' :)
      and $state[$p:lk] != 38275                            (: 'namespace' 'satisfies' :)
      and $state[$p:lk] != 39811                            (: 'namespace' 'stable' :)
      and $state[$p:lk] != 41091                            (: 'namespace' 'to' :)
      and $state[$p:lk] != 41347                            (: 'namespace' 'treat' :)
      and $state[$p:lk] != 42115                            (: 'namespace' 'union' :)
      and $state[$p:lk] != 43395) then                      (: 'namespace' 'where' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 131) then                     (: 'namespace' :)
            let $state := p:parse-NamespaceDecl($input, $state)
            return $state
          else if ($state[$p:l1] = 117) then                (: 'include' :)
            let $state := p:parse-IncludeDecl($input, $state)
            return $state
          else if ($state[$p:l1] = 115) then                (: 'import' :)
            let $state := p:parse-ImportDecl($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-ParamDef($input, $state)
            return $state
        let $state := p:lookahead1W(32, $input, $state)     (: S^WS | ('(' ':') | ';' :)
        let $state := p:parse-Separator($input, $state)
        return p:parse-CarrotModule-1($input, $state)
};

(:~
 : Parse the 2nd loop of production CarrotModule (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CarrotModule-2($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(128, $input, $state)        (: S^WS | QName^Token | EOF | '$' | ('(' ':') | '^' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'else' | 'empty' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'import' | 'include' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'or' | 'order' |
                                                               'ordered' | 'param' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'return' | 'satisfies' | 'self' |
                                                               'some' | 'stable' | 'to' | 'treat' | 'union' |
                                                               'unordered' | 'validate' | 'where' | 'xquery' :)
    return
      if ($state[$p:l1] = 25) then                          (: EOF :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 31) then                      (: '$' :)
            let $state := p:parse-VarDecl($input, $state)
            return $state
          else if ($state[$p:l1] = 68) then                 (: '^' :)
            let $state := p:parse-RuleDecl($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-FunctionDecl($input, $state)
            return $state
        let $state := p:lookahead1W(32, $input, $state)     (: S^WS | ('(' ':') | ';' :)
        let $state := p:parse-Separator($input, $state)
        return p:parse-CarrotModule-2($input, $state)
};

(:~
 : Parse CarrotModule.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CarrotModule($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-CarrotModule-1($input, $state)
  let $state := p:parse-CarrotModule-2($input, $state)
  return p:reduce($state, "CarrotModule", $count)
};

(:~
 : Parse Carrot.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Carrot($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-CarrotModule($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | EOF | ('(' ':') :)
  let $state := p:shift(25, $input, $state)                 (: EOF :)
  return p:reduce($state, "Carrot", $count)
};

(:~
 : Parse start symbol Carrot from given string.
 :
 : @param $s the string to be parsed.
 : @return the result as generated by parser actions.
 :)
declare function p:parse-Carrot($s as xs:string) as item()*
{
  let $state := p:parse-Carrot($s, (0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, false()))
  let $error := $state[$p:error]
  return
    if ($error) then
      element ERROR {$error/@*, p:error-message($s, $error)}
    else
      subsequence($state, $p:result)
};

(:~
 : Parse start symbol KeyValuePairs from given string.
 :
 : @param $s the string to be parsed.
 : @return the result as generated by parser actions.
 :)
declare function p:parse-KeyValuePairs($s as xs:string) as item()*
{
  let $state := p:parse-KeyValuePairs($s, (0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, false()))
  let $error := $state[$p:error]
  return
    if ($error) then
      element ERROR {$error/@*, p:error-message($s, $error)}
    else
      subsequence($state, $p:result)
};

(: End :)
