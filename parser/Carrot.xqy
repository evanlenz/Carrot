xquery version "1.0" encoding "UTF-8";

(: This file was generated on Thu Sep 22, 2011 21:36 by REx v5.9 which is Copyright (c) 1979-2011 by Gunther Rademacher <grd@gmx.net> :)
(: REx command line: Carrot.ebnf -main -tree -xquery :)

declare namespace p="Carrot";

(:~
 : The codepoint to charclass mapping for 7 bit codepoints.
 :)
declare variable $p:MAP0 as xs:integer+ :=
(
  64, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7,
  8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,
  29, 26, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 31, 30, 30, 30, 30, 30, 30, 32, 6, 33, 34, 30, 35, 36, 37,
  38, 39, 40, 41, 42, 43, 44, 30, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 30, 60, 61, 62, 6, 6
);

(:~
 : The codepoint to charclass mapping for codepoints below the surrogate block.
 :)
declare variable $p:MAP1 as xs:integer+ :=
(
  216, 291, 323, 383, 415, 908, 351, 815, 815, 447, 479, 511, 543, 575, 621, 882, 589, 681, 815, 815, 815, 815, 815,
  815, 815, 815, 815, 815, 815, 815, 713, 745, 821, 649, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815,
  815, 815, 777, 809, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815,
  815, 815, 815, 815, 815, 815, 815, 815, 815, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 259, 815,
  815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 853, 940, 949, 941, 941, 957, 965, 973, 979, 987, 1259, 1010, 1027, 1045,
  1053, 1061, 1069, 1267, 1267, 1267, 1267, 1267, 1267, 1425, 1267, 1259, 1259, 1260, 1259, 1259, 1259, 1260, 1259,
  1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259,
  1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1261, 1267, 1267, 1267, 1267, 1267, 1267,
  1267, 1267, 1267, 1267, 1267, 1259, 1259, 1259, 1259, 1259, 1259, 1347, 1260, 1258, 1257, 1259, 1259, 1259, 1259,
  1259, 1260, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1263, 1083, 1259, 1259, 1259, 1259, 1188, 1086, 1259,
  1259, 1259, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259,
  1259, 1266, 1267, 1085, 1265, 1267, 1393, 1267, 1267, 1267, 1267, 1267, 1258, 1259, 1259, 1264, 1125, 1313, 1392,
  1267, 1387, 1393, 1125, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1349, 1259, 1260, 1136, 1387, 1302, 1201,
  1387, 1393, 1387, 1387, 1387, 1387, 1387, 1387, 1387, 1387, 1389, 1267, 1267, 1267, 1393, 1267, 1267, 1267, 1372,
  1236, 1259, 1259, 1256, 1259, 1259, 1259, 1259, 1260, 1260, 1412, 1257, 1259, 1263, 1267, 1258, 1094, 1259, 1259,
  1259, 1259, 1259, 1259, 1259, 1259, 1258, 1094, 1259, 1259, 1259, 1259, 1103, 1267, 1259, 1259, 1259, 1259, 1259,
  1259, 1116, 1034, 1259, 1259, 1259, 1117, 1261, 1265, 1438, 1259, 1259, 1259, 1259, 1259, 1259, 1154, 1387, 1389,
  1202, 1259, 1172, 1387, 1267, 1267, 1438, 1116, 1348, 1259, 1259, 1257, 1186, 1197, 1163, 1175, 1425, 1212, 1172,
  1387, 1265, 1267, 1223, 1246, 1348, 1259, 1259, 1257, 1402, 1197, 1178, 1175, 1267, 1234, 1426, 1387, 1244, 1267,
  1438, 1235, 1256, 1259, 1259, 1257, 1254, 1154, 1277, 1108, 1267, 1267, 994, 1387, 1267, 1267, 1438, 1116, 1348, 1259,
  1259, 1257, 1345, 1154, 1203, 1175, 1426, 1212, 1037, 1387, 1267, 1267, 1002, 1015, 1290, 1286, 1189, 1015, 1127,
  1037, 1204, 1201, 1425, 1267, 1425, 1387, 1267, 1267, 1438, 1094, 1257, 1259, 1259, 1257, 1095, 1037, 1278, 1201,
  1427, 1267, 1037, 1387, 1267, 1267, 1002, 1094, 1257, 1259, 1259, 1257, 1095, 1037, 1278, 1201, 1427, 1269, 1037,
  1387, 1267, 1267, 1002, 1094, 1257, 1259, 1259, 1257, 1259, 1037, 1164, 1201, 1425, 1267, 1037, 1387, 1267, 1267,
  1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1259,
  1259, 1259, 1259, 1261, 1267, 1259, 1259, 1259, 1259, 1260, 1267, 1258, 1259, 1259, 1259, 1259, 1260, 1298, 1392,
  1310, 1388, 1387, 1393, 1267, 1267, 1267, 1267, 1215, 1322, 1084, 1258, 1332, 1342, 1298, 1146, 1357, 1389, 1387,
  1393, 1267, 1267, 1267, 1267, 1269, 1019, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1264, 1267,
  1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1254, 1401, 1264, 1267, 1267,
  1267, 1267, 1410, 1266, 1410, 1188, 1081, 1334, 1187, 1214, 1267, 1267, 1267, 1267, 1269, 1267, 1324, 1268, 1288,
  1264, 1267, 1267, 1267, 1267, 1421, 1266, 1423, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259,
  1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1263, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259,
  1259, 1265, 1259, 1259, 1261, 1261, 1259, 1259, 1259, 1259, 1261, 1261, 1259, 1413, 1259, 1259, 1259, 1261, 1259,
  1259, 1259, 1259, 1259, 1259, 1094, 1128, 1226, 1262, 1117, 1263, 1259, 1262, 1226, 1262, 1075, 1267, 1267, 1267,
  1258, 1314, 1162, 1267, 1258, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1262, 999, 1258, 1259, 1259, 1259,
  1259, 1259, 1259, 1259, 1259, 1259, 1259, 1435, 1083, 1259, 1259, 1259, 1259, 1262, 1267, 1267, 1267, 1267, 1267,
  1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267,
  1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1387, 1390, 1370, 1267, 1267, 1267, 1259, 1259, 1259, 1259, 1259,
  1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1263, 1267, 1267, 1267,
  1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1393, 1387, 1393, 1380, 1362, 1259, 1258, 1259, 1259, 1259, 1265,
  1386, 1387, 1278, 1391, 1277, 1386, 1387, 1389, 1386, 1370, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1258,
  1259, 1259, 1259, 1260, 1423, 1258, 1259, 1259, 1259, 1260, 1267, 1386, 1387, 1160, 1387, 1387, 1142, 1367, 1267,
  1259, 1259, 1259, 1264, 1264, 1267, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
  11, 12, 13, 14, 15, 16, 17, 17, 17, 17, 17, 17, 17, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 26, 30, 6, 6,
  6, 6, 6, 63, 63, 6, 6, 63, 63, 6, 30, 30, 30, 30, 30, 30, 30, 31, 30, 30, 30, 6, 6, 6, 30, 30, 6, 6, 30, 6, 30, 30,
  30, 32, 6, 33, 34, 30, 6, 6, 30, 30, 6, 6, 6, 6, 63, 63, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 30, 45, 46, 47, 48,
  49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 30, 60, 61, 62, 6, 6, 6, 6, 6, 63, 6, 30, 6, 6, 6, 6, 6, 30, 30, 30, 30,
  30, 30, 30, 30, 30, 30, 30, 6, 30, 30, 30, 30, 30, 6, 63, 63, 63, 63, 6, 63, 63, 63, 6, 6, 30, 30, 30, 30, 30, 6, 6,
  30, 30, 63, 30, 30, 30, 30, 30, 30, 30, 6, 30, 6, 30, 30, 30, 30, 6, 30, 63, 63, 6, 63, 63, 63, 6, 63, 63, 30, 6, 6,
  30, 30, 6, 6, 63, 30, 63, 63, 6, 63, 63, 63, 63, 63, 6, 6, 63, 63, 30, 30, 63, 63, 6, 6, 63, 63, 63, 6, 6, 6, 6, 63,
  30, 6, 30, 6, 6, 6, 30, 30, 6, 6, 6, 30, 30, 6, 6, 63, 6, 63, 63, 63, 63, 6, 6, 6, 63, 63, 6, 6, 6, 6, 30, 30, 6, 30,
  6, 6, 30, 6, 6, 63, 6, 6, 30, 30, 30, 6, 30, 30, 6, 30, 30, 30, 30, 6, 30, 6, 30, 30, 63, 63, 30, 30, 30, 6, 6, 6, 6,
  30, 30, 6, 30, 30, 6, 30, 30, 30, 30, 30, 30, 30, 30, 6, 6, 6, 6, 6, 6, 6, 6, 30, 6, 63, 63, 63, 63, 63, 63, 6, 63,
  63, 6, 30, 30, 6, 30, 6, 30, 30, 30, 30, 6, 6, 30, 63, 30, 30, 63, 63, 63, 63, 63, 30, 30, 63, 30, 30, 30, 30, 30, 30,
  63, 63, 63, 63, 63, 63, 30, 6, 30, 6, 6, 30, 6, 6, 30, 30, 6, 30, 30, 30, 6, 30, 6, 30, 6, 30, 6, 6, 30, 30, 6, 30,
  30, 6, 6, 30, 30, 30, 30, 30, 6, 30, 30, 30, 30, 30, 6, 63, 6, 6, 6, 6, 63, 63, 6, 63, 6, 6, 6, 6, 6, 6, 30, 63, 6, 6,
  6, 6, 6, 63, 6, 63, 63, 63, 63, 63, 63, 63, 63, 6, 6, 6, 6, 6, 6, 6, 30, 6, 30, 30, 6, 30, 30, 6, 6, 6, 6, 6, 30, 6,
  30, 6, 30, 6, 30, 6, 6, 6, 30, 6, 6, 6, 6, 6, 6, 6, 63, 63, 6, 30, 30, 30, 6, 63, 63, 63, 6, 30, 30, 30
);

(:~
 : The codepoint to charclass mapping for codepoints above the surrogate block.
 :)
declare variable $p:MAP2 as xs:integer+ :=
(
  57344, 65536, 65533, 1114111, 6, 6
);

(:~
 : The token-set-id to DFA-initial-state mapping.
 :)
declare variable $p:INITIAL as xs:integer+ :=
(
  6145, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 2069, 4117, 22, 23, 24, 25, 26, 27, 28, 29,
  30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58,
  59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87,
  88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113,
  114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136,
  137, 138, 139, 140, 141, 142, 143, 144, 145, 146
);

(:~
 : The DFA transition table.
 :)
declare variable $p:TRANSITION as xs:integer+ :=
(
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 8320, 8334, 8394, 8358, 8359, 8375, 8359, 8342, 8388,
  8410, 8447, 8572, 8497, 14581, 14591, 10925, 8752, 11416, 8752, 8925, 8515, 13214, 12107, 8531, 8560, 11408, 8596,
  9615, 8612, 8649, 8640, 8665, 19731, 14991, 8898, 8694, 8544, 8726, 8747, 16973, 8723, 8742, 8753, 8769, 8811, 13171,
  8829, 16950, 8874, 16471, 16448, 8914, 8886, 8941, 8984, 9043, 9467, 9085, 9459, 9475, 9114, 9166, 9069, 9195, 9066,
  9218, 9254, 16433, 9298, 9321, 8678, 15134, 9348, 9378, 9428, 9444, 9491, 9507, 16965, 11415, 16974, 9537, 9564, 9592,
  9631, 9647, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 9689, 18041, 19078, 18041, 18041, 21279, 9709,
  9716, 8813, 9732, 15961, 8572, 9762, 14581, 14591, 10925, 8752, 11416, 9202, 10713, 8515, 13214, 12107, 8531, 8560,
  11408, 8596, 9615, 8612, 8649, 8640, 8665, 19731, 14991, 8898, 8694, 8544, 8726, 8747, 16973, 8723, 8742, 8753, 8769,
  8811, 13171, 8829, 16950, 8874, 16471, 16448, 8914, 8886, 8941, 8984, 9043, 9467, 9085, 9459, 9475, 9114, 9166, 9069,
  9195, 9066, 9218, 9254, 16433, 9298, 9321, 8678, 15134, 9348, 9378, 9428, 9444, 9491, 9507, 16965, 11415, 16974, 9537,
  9564, 9592, 9631, 9647, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 9809, 9851, 16674, 18041, 18042,
  13201, 12509, 18041, 11480, 9874, 15961, 8572, 9911, 14581, 14591, 10925, 8752, 11416, 8752, 8624, 8515, 13214, 12107,
  8531, 8560, 11408, 8596, 9615, 8612, 8649, 8640, 8665, 19731, 14991, 8898, 8694, 8544, 8726, 8747, 16973, 8723, 8742,
  8753, 8769, 8811, 13171, 8829, 16950, 8874, 16471, 16448, 8914, 8886, 8941, 8984, 9043, 9467, 9085, 9459, 9475, 9114,
  9166, 9069, 9195, 9066, 9218, 9254, 16433, 9298, 9321, 8678, 15134, 9348, 9378, 9428, 9444, 9491, 9507, 16965, 11415,
  16974, 9537, 9564, 9592, 9631, 9647, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 9932, 18041, 19078,
  18041, 18041, 21279, 18041, 20941, 18905, 9970, 15961, 10000, 10038, 14581, 14591, 10925, 8752, 11416, 8752, 9548,
  8515, 13031, 12107, 8531, 8560, 11408, 8596, 9615, 8612, 8649, 8640, 8665, 19731, 14991, 8898, 8694, 8544, 8726, 8747,
  16973, 8723, 8742, 8753, 8769, 8811, 13171, 8829, 16950, 8874, 16471, 16448, 8914, 8886, 8941, 8984, 9043, 9467, 9085,
  9459, 9475, 9114, 9166, 9069, 9195, 9066, 9218, 9254, 16433, 9298, 9321, 8678, 15134, 9348, 9378, 9428, 9444, 9491,
  9507, 16965, 11415, 16974, 9537, 9564, 9592, 9631, 9647, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  10060, 19301, 14522, 10086, 19304, 21279, 18041, 10070, 15245, 15259, 15961, 8572, 8497, 14581, 14591, 10925, 8752,
  11416, 8752, 8925, 8515, 13214, 12107, 8531, 8560, 11408, 8596, 9615, 8612, 8649, 8640, 8665, 19731, 14991, 8898,
  8694, 8544, 8726, 8747, 16973, 8723, 8742, 8753, 8769, 8811, 13171, 8829, 16950, 8874, 16471, 16448, 8914, 8886, 8941,
  8984, 9043, 9467, 9085, 9459, 9475, 9114, 9166, 9069, 9195, 9066, 9218, 9254, 16433, 9298, 9321, 8678, 15134, 9348,
  9378, 9428, 9444, 9491, 9507, 16965, 11415, 16974, 9537, 9564, 9592, 9631, 9647, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 9689, 18041, 19078, 18041, 18041, 21279, 18041, 18041, 18041, 10105, 15961, 8572, 8497, 14581,
  14591, 10925, 8752, 11416, 8752, 8925, 8515, 13214, 12107, 8531, 8560, 11408, 8596, 9615, 8612, 8649, 8640, 8665,
  19731, 14991, 8898, 8694, 8544, 8726, 8747, 16973, 8723, 8742, 8753, 8769, 8811, 13171, 8829, 16950, 8874, 16471,
  16448, 8914, 8886, 8941, 8984, 9043, 9467, 9085, 9459, 9475, 9114, 9166, 9069, 9195, 9066, 9218, 9254, 16433, 9298,
  9321, 8678, 15134, 9348, 9378, 9428, 9444, 9491, 9507, 16965, 11415, 16974, 9537, 9564, 9592, 9631, 9647, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 9689, 18041, 19078, 18041, 18041, 17371, 18041, 18041, 18041, 10148,
  15961, 8572, 10188, 14581, 14591, 10925, 8752, 11416, 8752, 8925, 8515, 13214, 12107, 8531, 8560, 11408, 8596, 9615,
  8612, 8649, 8640, 8665, 19731, 14991, 8898, 8694, 8544, 8726, 8747, 16973, 8723, 8742, 8753, 8769, 8811, 13171, 8829,
  16950, 8874, 16471, 16448, 8914, 8886, 8941, 8984, 9043, 9467, 9085, 9459, 9475, 9114, 9166, 9069, 9195, 9066, 9218,
  9254, 16433, 9298, 9321, 8678, 15134, 9348, 9378, 9428, 9444, 9491, 9507, 16965, 11415, 16974, 9537, 9564, 9592, 9631,
  9647, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 10208, 10245, 10472, 18041, 18782, 13018, 10268, 18041,
  13592, 10286, 15961, 8572, 10327, 14581, 14591, 10925, 8752, 11416, 8752, 9332, 8515, 13214, 12107, 8531, 8560, 11408,
  8596, 9615, 8612, 8649, 8640, 8665, 19731, 14991, 8898, 8694, 8544, 8726, 8747, 16973, 8723, 8742, 8753, 8769, 8811,
  13171, 8829, 16950, 8874, 16471, 16448, 8914, 8886, 8941, 8984, 9043, 9467, 9085, 9459, 9475, 9114, 9166, 9069, 9195,
  9066, 9218, 9254, 16433, 9298, 9321, 8678, 15134, 9348, 9378, 9428, 9444, 9491, 9507, 16965, 11415, 16974, 9537, 9564,
  9592, 9631, 9647, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 10352, 16221, 16232, 10375, 10381, 10412,
  10381, 10397, 10425, 10441, 19645, 8572, 8497, 14581, 14591, 10925, 8752, 11416, 8752, 8925, 10488, 13214, 12107,
  8531, 8560, 11408, 8596, 9615, 8612, 8649, 8640, 8665, 19731, 14991, 8898, 8694, 8544, 8726, 8747, 16973, 8723, 8742,
  8753, 8769, 8811, 13171, 8829, 16950, 8874, 16471, 16448, 8914, 8886, 8941, 8984, 9043, 9467, 9085, 9459, 9475, 9114,
  9166, 9069, 9195, 9066, 9218, 9254, 16433, 9298, 9321, 8678, 15134, 9348, 9378, 9428, 9444, 9491, 9507, 16965, 11415,
  16974, 9537, 9564, 9592, 9631, 9647, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 9689, 10359, 8431,
  21304, 21303, 10504, 10554, 10561, 21251, 21265, 9916, 8572, 8497, 14581, 14591, 10925, 8752, 11416, 8752, 8925,
  10577, 13214, 12107, 8531, 8560, 11408, 8596, 9615, 8612, 8649, 8640, 8665, 19731, 14991, 8898, 8694, 8544, 8726,
  8747, 16973, 8723, 8742, 8753, 8769, 8811, 13171, 8829, 16950, 8874, 16471, 16448, 8914, 8886, 8941, 8984, 9043, 9467,
  9085, 9459, 9475, 9114, 9166, 9069, 9195, 9066, 9218, 9254, 16433, 9298, 9321, 8678, 15134, 9348, 9378, 9428, 9444,
  9491, 9507, 16965, 11415, 16974, 9537, 9564, 9592, 9631, 9647, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  9689, 18041, 19078, 18041, 18041, 21279, 21386, 10593, 10631, 10645, 15961, 8572, 8497, 14581, 14591, 10925, 8752,
  11416, 8752, 8925, 8515, 13214, 12107, 8531, 8560, 11408, 8596, 9615, 10701, 8649, 8640, 8665, 19731, 14991, 8898,
  8694, 8544, 8726, 8747, 16973, 8723, 8742, 8753, 8769, 8811, 13171, 8829, 16950, 8874, 16471, 16448, 8914, 8886, 8941,
  8984, 9043, 9467, 9085, 9459, 9475, 9114, 9166, 9069, 9195, 9066, 9218, 9254, 16433, 9298, 9321, 8678, 15134, 9348,
  9378, 9428, 9444, 9491, 9507, 16965, 11415, 16974, 9537, 9564, 9592, 9631, 9647, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 9689, 18041, 19078, 18041, 18041, 21279, 22861, 10729, 22854, 10753, 15961, 8572, 8497, 14581,
  14591, 10925, 8752, 11416, 8752, 8925, 8515, 15808, 12107, 8531, 8560, 11408, 8596, 9615, 8612, 8649, 8640, 8665,
  19731, 14991, 8898, 8694, 8544, 8726, 8747, 16973, 8723, 8742, 8753, 8769, 8811, 13171, 8829, 16950, 8874, 16471,
  16448, 8914, 8886, 8941, 8984, 9043, 9467, 9085, 9459, 9475, 9114, 9166, 9069, 9195, 9066, 9218, 9254, 16433, 9298,
  9321, 8678, 15134, 9348, 9378, 9428, 9444, 9491, 9507, 16965, 11415, 16974, 9537, 9564, 9592, 9631, 9647, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 9689, 17396, 19078, 21292, 14093, 10783, 10797, 10804, 17394, 10820,
  15961, 8572, 8497, 14581, 14591, 10925, 8752, 11416, 8752, 8925, 8515, 13214, 12107, 8531, 8560, 11408, 8596, 9615,
  8612, 8649, 8640, 8665, 19731, 14991, 8898, 8694, 8544, 8726, 8747, 16973, 8723, 8742, 8753, 8769, 8811, 13171, 8829,
  16950, 8874, 16471, 16448, 8914, 8886, 8941, 8984, 9043, 9467, 9085, 9459, 9475, 9114, 9166, 9069, 9195, 9066, 9218,
  9254, 16433, 9298, 9321, 8678, 15134, 9348, 9378, 9428, 9444, 9491, 9507, 16965, 11415, 16974, 9537, 9564, 9592, 9631,
  9647, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 10850, 18041, 19078, 18041, 18041, 21279, 10015, 10022,
  10008, 10874, 15961, 18041, 17392, 20166, 13145, 10677, 18060, 18590, 14826, 10918, 21516, 15050, 19213, 17940, 13147,
  10681, 16511, 15357, 14653, 19482, 19482, 20755, 8959, 18041, 10737, 17940, 12040, 16511, 16511, 19837, 19482, 19482,
  16365, 18040, 18041, 21013, 14375, 10684, 16511, 16511, 19481, 19482, 14828, 18041, 20166, 21780, 16511, 20187, 20905,
  19482, 20493, 19405, 16511, 14786, 19482, 13637, 21014, 10685, 20053, 19482, 21011, 16836, 10941, 10968, 18492, 10986,
  11010, 11060, 11094, 11119, 17243, 22365, 13705, 16540, 16544, 16062, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 9689, 18041, 19078, 18041, 17068, 21279, 18041, 18041, 13295, 13309, 15961, 13657, 11145, 20166, 13145, 10677,
  18060, 18590, 14826, 11163, 21516, 18041, 21014, 17940, 13147, 10681, 16511, 15357, 14653, 19482, 19482, 14848, 8959,
  18041, 16993, 17940, 12040, 16511, 16511, 19837, 19482, 19482, 16365, 18040, 18041, 21013, 14375, 10684, 16511, 16511,
  19481, 19482, 14828, 18041, 20166, 21780, 16511, 16511, 19482, 19482, 18038, 19405, 16511, 16512, 19482, 14827, 21014,
  10685, 20053, 19482, 21011, 8476, 20054, 14826, 13696, 20053, 16296, 20053, 17588, 14873, 14870, 13707, 13705, 16540,
  16544, 16062, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 9689, 22891, 19078, 18041, 18041, 15795, 18279,
  19819, 19810, 11186, 15961, 8572, 11230, 14581, 14591, 10925, 8752, 11416, 8752, 8925, 8515, 13214, 12107, 8531, 8560,
  11408, 8596, 9615, 8612, 8649, 8640, 8665, 19731, 14991, 8898, 8694, 8544, 8726, 8747, 16973, 8723, 8742, 8753, 8769,
  8811, 13171, 8829, 16950, 8874, 16471, 16448, 8914, 8886, 8941, 8984, 9043, 9467, 9085, 9459, 9475, 9114, 9166, 9069,
  9195, 9066, 9218, 9254, 16433, 9298, 9321, 8678, 15134, 9348, 9378, 9428, 9444, 9491, 9507, 16965, 11415, 16974, 9537,
  9564, 9592, 9631, 9647, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 9689, 18041, 19078, 18041, 17626,
  21279, 18041, 18041, 17636, 11265, 15961, 21888, 11309, 20166, 13145, 10677, 18060, 18590, 14826, 11327, 21879, 21897,
  21014, 17940, 13147, 10681, 16511, 15357, 14653, 19482, 19482, 14848, 11350, 11359, 11375, 17940, 12040, 16511, 16511,
  19837, 19482, 19482, 16365, 13737, 19355, 11511, 14375, 10684, 16511, 16511, 19481, 19482, 10970, 13746, 20166, 21780,
  16511, 16511, 19482, 19482, 18038, 19405, 16511, 16512, 19482, 14827, 21014, 10685, 20053, 19482, 21011, 8476, 20054,
  14826, 13696, 20053, 16296, 20053, 17588, 14873, 14870, 13707, 13705, 16540, 16544, 16062, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 9689, 10089, 19877, 13434, 16618, 11395, 13432, 11432, 18041, 11453, 11496, 11531, 8497,
  14581, 14591, 11170, 16725, 11924, 11596, 11888, 11555, 13214, 12107, 8531, 8560, 11917, 11571, 9013, 11775, 12258,
  11587, 12177, 19731, 14991, 8898, 8694, 8707, 9027, 16720, 11632, 11613, 11982, 11597, 11663, 8811, 13171, 8829,
  17822, 11760, 17850, 11648, 12248, 11707, 8941, 8984, 11745, 17837, 11803, 11787, 11952, 11832, 9166, 11816, 11876,
  11992, 11904, 9254, 16705, 12288, 11940, 12190, 8999, 11968, 12008, 12063, 12079, 12219, 12163, 11624, 12298, 12295,
  12206, 12235, 12274, 12314, 12094, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 9689, 8499, 19078, 10172,
  10171, 12330, 12344, 12351, 14104, 12367, 15961, 8572, 8497, 14581, 14591, 10925, 8752, 11416, 8752, 8925, 8515,
  13214, 12107, 8531, 8560, 11408, 8596, 9615, 8612, 8649, 8640, 8665, 19731, 15629, 15120, 8694, 8544, 8726, 8747,
  16973, 8723, 8742, 8753, 12411, 12457, 12480, 8829, 16950, 8874, 16471, 16448, 8914, 12496, 12527, 8984, 9043, 9467,
  9085, 9459, 9475, 9114, 9166, 9069, 9195, 9066, 9218, 9254, 16433, 9298, 9321, 8678, 15134, 9348, 9378, 9428, 9444,
  9491, 9507, 16965, 11415, 16974, 9537, 9564, 9592, 9631, 9647, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  9689, 18041, 19078, 18041, 18041, 19041, 12556, 12563, 13413, 12579, 15961, 8572, 8497, 14581, 19293, 10925, 8752,
  11416, 8752, 9098, 8515, 13214, 12107, 8531, 8560, 11408, 8596, 9615, 8612, 8649, 8640, 8665, 19731, 14991, 8898,
  8694, 8544, 8726, 8747, 16973, 8723, 8742, 8753, 8769, 8811, 13171, 8829, 16950, 8874, 16471, 16448, 8914, 8886, 8941,
  8984, 9043, 9467, 9085, 9459, 9475, 9114, 9166, 9069, 9195, 9066, 9218, 9254, 16433, 9298, 9321, 8678, 15134, 9348,
  9378, 9428, 9444, 9491, 9507, 16965, 11415, 16974, 9537, 9564, 9592, 9631, 9647, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 12623, 18041, 19078, 18041, 12633, 21279, 12655, 12662, 11147, 12678, 16327, 8572, 8497, 14581,
  9266, 10925, 8752, 11416, 8752, 9362, 8515, 13214, 12107, 8531, 8560, 11408, 8596, 9615, 8612, 8649, 8640, 8665,
  19731, 14991, 8898, 8694, 8544, 8726, 8747, 16973, 8723, 8742, 8753, 8769, 8811, 13171, 8829, 16950, 8874, 16471,
  16448, 8914, 8886, 8941, 8984, 9043, 9467, 9085, 9459, 9475, 9114, 9166, 9069, 9195, 9066, 9218, 9254, 16433, 9298,
  9321, 8678, 15134, 9348, 9378, 9428, 9444, 9491, 9507, 16965, 11415, 16974, 9537, 9564, 9592, 9631, 9647, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 12708, 12734, 19078, 18041, 18041, 21279, 12758, 12765, 11311, 12781,
  15961, 8572, 8497, 14581, 12117, 10925, 8752, 11416, 8752, 9576, 8515, 13214, 12107, 8531, 8560, 11408, 8596, 9615,
  8612, 8649, 8640, 8665, 19731, 14991, 8898, 8694, 8544, 8726, 8747, 16973, 8723, 8742, 8753, 8769, 8811, 13171, 8829,
  16950, 8874, 16471, 16448, 8914, 8886, 8941, 8984, 9043, 9467, 9085, 9459, 9475, 9114, 9166, 9069, 9195, 9066, 9218,
  9254, 16433, 9298, 9321, 8678, 15134, 9348, 9378, 9428, 9444, 9491, 9507, 9058, 11415, 16974, 9537, 9564, 9592, 9631,
  9647, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 12797, 12806, 19078, 18773, 18041, 21279, 15816, 18781,
  18041, 12824, 15961, 8572, 12868, 14581, 14591, 10925, 8752, 11416, 9305, 9521, 8515, 13214, 12107, 8531, 8560, 11408,
  8596, 9615, 8612, 8649, 8640, 8665, 19731, 14991, 8898, 8694, 8544, 8726, 8747, 16973, 8723, 8742, 8753, 8769, 8811,
  13171, 8829, 16950, 8874, 16471, 16448, 8914, 8886, 8941, 8984, 9043, 9467, 9085, 9459, 9475, 9114, 9166, 9069, 9195,
  9066, 9218, 9254, 16433, 9298, 9321, 8678, 15134, 9348, 9378, 9428, 9444, 9491, 9507, 16965, 11415, 16974, 9537, 9564,
  9592, 9631, 9647, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 9689, 18041, 19078, 18041, 18041, 21279,
  18041, 18041, 12917, 12931, 15961, 8572, 8497, 14581, 14591, 10925, 8752, 11416, 8752, 8925, 8515, 13214, 12107, 8531,
  8560, 11408, 8596, 9615, 8612, 8649, 8640, 8665, 19731, 14991, 8898, 8694, 8544, 8726, 8747, 16973, 8723, 8742, 8753,
  8769, 8811, 13171, 8829, 16950, 8874, 16471, 16448, 8914, 8886, 8941, 8984, 9043, 9467, 9085, 9459, 9475, 9114, 9166,
  9069, 9195, 9066, 9218, 9254, 16433, 9298, 9321, 8678, 15134, 9348, 9378, 9428, 9444, 9491, 9507, 16965, 11415, 16974,
  9537, 9564, 9592, 9631, 9647, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 12975, 18041, 22668, 18041,
  12982, 10659, 10673, 10605, 10615, 13004, 15961, 18041, 17392, 20166, 13145, 10677, 18060, 18590, 14826, 13056, 21516,
  18041, 21014, 17940, 13147, 10681, 16511, 15357, 12901, 19482, 19482, 14848, 8959, 18041, 11375, 17940, 12040, 16511,
  16511, 19837, 19482, 19482, 16365, 15436, 13747, 11511, 14375, 10684, 16511, 16511, 19481, 19482, 10970, 13746, 20576,
  21780, 16511, 16511, 19482, 19482, 18038, 19405, 16511, 16512, 19482, 14827, 20607, 10685, 20053, 19482, 21011, 8476,
  20054, 14826, 13696, 20053, 16296, 20053, 17588, 14873, 14870, 13707, 13705, 16540, 16544, 16062, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 12975, 18041, 22668, 18041, 12982, 10659, 10673, 10605, 10615, 13004, 15961, 18041,
  17392, 20166, 13145, 10677, 18060, 18590, 14826, 13056, 21516, 18041, 21014, 17940, 13147, 10681, 16511, 15357, 12901,
  19482, 19482, 14848, 8959, 18041, 11375, 17940, 12040, 16511, 16511, 19837, 19482, 19482, 16365, 15436, 13747, 11511,
  14375, 10684, 16511, 16511, 19481, 19482, 10970, 13746, 20166, 21780, 16511, 16511, 19482, 19482, 18038, 19405, 16511,
  16512, 19482, 14827, 21014, 10685, 20053, 19482, 21011, 8476, 20054, 14826, 13696, 20053, 16296, 20053, 17588, 14873,
  14870, 13707, 13705, 16540, 16544, 16062, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 12975, 18041, 22668,
  18041, 12982, 10659, 10673, 10605, 10615, 13004, 15961, 18041, 17392, 20166, 13145, 10677, 18060, 18590, 14826, 13056,
  21516, 18041, 21014, 17940, 13147, 10681, 16511, 15357, 12901, 19482, 19482, 14848, 8959, 18041, 13087, 17940, 12040,
  16511, 16511, 19837, 19482, 19482, 16365, 15436, 13747, 11511, 14375, 10684, 16511, 16511, 19481, 19482, 10970, 13746,
  20166, 21780, 16511, 16511, 19482, 19482, 18038, 19405, 16511, 16512, 19482, 14827, 21014, 10685, 20053, 19482, 21011,
  8476, 20054, 14826, 13696, 20053, 16296, 20053, 17588, 14873, 14870, 13707, 13705, 16540, 16544, 16062, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 12975, 18041, 22668, 18041, 12982, 10659, 10673, 10605, 10615, 13004, 15961,
  18041, 17392, 20166, 13145, 10677, 18060, 18590, 14826, 13056, 21516, 18041, 21014, 17940, 13147, 10681, 16511, 15357,
  12901, 19482, 19482, 14848, 8959, 18041, 11375, 17940, 12040, 16511, 16511, 19837, 19482, 19482, 16365, 15436, 13747,
  12023, 14375, 10684, 16511, 16511, 19481, 19482, 10970, 13746, 20166, 21780, 16511, 16511, 19482, 19482, 18038, 19405,
  16511, 16512, 19482, 14827, 21014, 10685, 20053, 19482, 21011, 8476, 20054, 14826, 13696, 20053, 16296, 20053, 17588,
  14873, 14870, 13707, 13705, 16540, 16544, 16062, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 12975, 18041,
  22668, 18041, 12982, 10659, 10673, 10605, 10615, 13004, 15961, 18041, 13121, 20166, 13145, 10677, 18060, 18590, 14826,
  13056, 21516, 10531, 21014, 17940, 13147, 10681, 16511, 15357, 12901, 19482, 19482, 14848, 8959, 18041, 11375, 17940,
  12040, 16511, 16511, 19837, 19482, 19482, 16365, 15436, 13747, 11511, 14375, 10684, 16511, 16511, 19481, 19482, 10970,
  13746, 20166, 21780, 16511, 16511, 19482, 19482, 18038, 19405, 16511, 16512, 19482, 14827, 21014, 10685, 20053, 19482,
  21011, 8476, 20054, 14826, 13696, 20053, 16296, 20053, 17588, 14873, 14870, 13707, 13705, 16540, 16544, 16062, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 12975, 18041, 22668, 18041, 12982, 10659, 10673, 10605, 10615, 13004,
  15961, 18041, 17392, 20166, 13145, 10677, 18060, 18590, 14826, 13056, 21516, 18041, 21014, 17940, 13147, 10681, 16511,
  15357, 12901, 19482, 19482, 14848, 8959, 18041, 16993, 17940, 12040, 16511, 16511, 19837, 19482, 19482, 16365, 18040,
  18041, 21013, 14375, 10684, 16511, 16511, 19481, 19482, 14828, 18041, 20166, 21780, 16511, 16511, 19482, 19482, 18038,
  19405, 16511, 16512, 19482, 14827, 21014, 10685, 20053, 19482, 21011, 8476, 20054, 14826, 13696, 20053, 16296, 20053,
  17588, 14873, 14870, 13707, 13705, 16540, 16544, 16062, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 12975,
  18041, 22668, 18041, 12982, 10659, 10673, 10605, 10615, 13004, 15961, 18041, 17392, 20166, 13145, 10677, 18060, 18590,
  14826, 13056, 21516, 18041, 21014, 17940, 13147, 10681, 16511, 15357, 12901, 19482, 19482, 14848, 8959, 18041, 16993,
  17940, 12040, 16511, 16511, 19837, 19482, 19482, 16365, 18040, 18041, 21013, 14375, 10684, 16511, 16511, 19481, 19482,
  14828, 18041, 20166, 21780, 16511, 16511, 19482, 19482, 18038, 13139, 16511, 16512, 19482, 14827, 21014, 10685, 20053,
  19482, 21011, 8476, 20054, 14826, 13696, 20053, 16296, 20053, 17588, 14873, 14870, 13707, 13705, 16540, 16544, 16062,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 9689, 18041, 19078, 18041, 18041, 11467, 12808, 13163, 12808,
  13187, 15961, 8572, 8497, 14581, 14591, 10925, 8752, 11416, 8752, 8925, 8515, 13214, 19283, 8531, 8560, 11408, 8596,
  9615, 8612, 8649, 8640, 8665, 19731, 14991, 8898, 8694, 8544, 8726, 8747, 16973, 8723, 8742, 8753, 8769, 8811, 13171,
  8829, 16950, 8874, 16471, 16448, 8914, 8886, 8941, 8984, 9043, 9467, 9085, 9459, 9475, 9114, 9166, 9069, 9195, 9066,
  9218, 9254, 16433, 9298, 9321, 15148, 15134, 9348, 9378, 9428, 9444, 9491, 9507, 16965, 11415, 16974, 9537, 9564,
  9592, 9631, 9647, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 9689, 18041, 13265, 18041, 18041, 13237,
  13251, 13258, 13123, 13281, 15961, 8572, 8497, 14581, 14591, 10925, 8752, 11416, 8752, 8925, 8515, 13214, 12107, 8531,
  8560, 11408, 8596, 9615, 8612, 8649, 8640, 8665, 19731, 14991, 8898, 8694, 8544, 8726, 8747, 16973, 8723, 8742, 8753,
  8769, 8811, 13171, 8829, 16950, 8874, 16471, 16448, 8914, 8886, 8941, 8984, 9043, 9467, 9085, 9459, 9475, 9114, 9166,
  9069, 9195, 9066, 9218, 9254, 16433, 9298, 9321, 8678, 15134, 9348, 9378, 13339, 9444, 13355, 9507, 16463, 11415,
  16974, 9537, 9564, 9592, 9631, 9647, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 9689, 18041, 19078,
  18041, 18041, 21279, 18041, 19801, 13385, 13399, 15961, 8572, 8497, 14581, 14591, 10925, 8752, 11416, 8752, 8925,
  8515, 13214, 12107, 8531, 8560, 11408, 8596, 9615, 8612, 8649, 8640, 8665, 19731, 14991, 8898, 8694, 8544, 8726, 8747,
  16973, 8723, 8742, 8753, 8769, 8811, 13171, 8829, 16950, 8874, 16471, 16448, 8914, 8886, 8941, 8984, 9043, 9467, 9085,
  9459, 9475, 9114, 9166, 9069, 9195, 9066, 9218, 9254, 16433, 9298, 9321, 8678, 15134, 9348, 9378, 9428, 9444, 9491,
  9507, 16965, 11415, 16974, 9537, 9564, 9592, 9631, 9647, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  9689, 18041, 19078, 18041, 20344, 21279, 18041, 18041, 12464, 13371, 15961, 8572, 13429, 14581, 14591, 10925, 8752,
  11416, 8752, 8925, 8515, 17384, 12107, 8531, 8560, 11408, 8596, 9615, 8612, 8649, 8640, 8665, 19731, 14991, 8898,
  8694, 8544, 8726, 8747, 16973, 8723, 8742, 8753, 8769, 8811, 13171, 8829, 16950, 8874, 16471, 16448, 8914, 8886, 8941,
  8984, 9043, 9467, 9085, 9459, 9475, 9114, 9166, 9069, 9195, 9066, 9218, 9254, 16433, 9298, 9321, 8678, 15134, 9348,
  9378, 9428, 9444, 9491, 9507, 16965, 11415, 16974, 9537, 9564, 9592, 9631, 9647, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 12975, 18041, 13450, 12988, 14478, 13485, 13499, 13515, 13525, 13541, 15961, 13579, 13608, 23020,
  19072, 12718, 15533, 13624, 15658, 13681, 20795, 10162, 21014, 17941, 13147, 10681, 16511, 15990, 12901, 19482, 19482,
  13723, 8968, 13763, 11375, 13780, 13798, 21137, 21615, 19837, 17914, 19482, 17438, 15436, 11539, 11678, 18376, 13827,
  15728, 16511, 17578, 20412, 13993, 15445, 20166, 21780, 16511, 15713, 19482, 17107, 13864, 19405, 16511, 16512, 19482,
  14827, 21014, 22289, 22516, 13882, 21011, 8476, 20054, 14826, 13696, 20053, 16296, 20053, 17588, 14873, 14870, 13707,
  13705, 16540, 16544, 16062, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 12975, 18041, 18477, 13764, 12982,
  10659, 10673, 10605, 10615, 13004, 15961, 18041, 17392, 20166, 13145, 10677, 18060, 18590, 14826, 13056, 21516, 18041,
  21014, 17940, 13147, 10681, 16511, 15357, 12901, 19482, 19482, 14848, 8959, 19995, 11375, 17940, 13925, 16511, 8481,
  19837, 19482, 19482, 13948, 15436, 13747, 11511, 14375, 10684, 16511, 16511, 19481, 19482, 10970, 13746, 9888, 17734,
  16511, 22507, 13989, 19482, 18038, 19405, 16511, 16512, 19482, 14827, 21014, 10685, 20053, 19482, 21011, 8476, 20054,
  14826, 13696, 20053, 16296, 20053, 17588, 14633, 14009, 13707, 13705, 16540, 16544, 16062, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 14046, 18041, 22668, 18041, 14082, 14120, 14134, 14150, 14165, 14179, 15961, 22899, 17392,
  20166, 13145, 10677, 18060, 15915, 15472, 13056, 21516, 22710, 22990, 14216, 13147, 14234, 14271, 15357, 14291, 14321,
  19482, 14848, 8959, 18041, 14347, 14371, 12040, 18583, 11036, 14030, 16268, 17263, 16365, 15436, 10229, 11511, 14375,
  10684, 16511, 16511, 19481, 19482, 10970, 13746, 20166, 21780, 16511, 16511, 19482, 19482, 18038, 16763, 15734, 16512,
  19855, 14827, 22401, 14391, 20053, 21813, 21011, 8476, 19440, 19706, 13696, 20053, 16296, 20053, 17588, 14873, 14435,
  13707, 13705, 16540, 10994, 14465, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 12975, 18041, 22668, 18041,
  14516, 12945, 12959, 14538, 14553, 14567, 15961, 18041, 17392, 11515, 13145, 14613, 14649, 14669, 14695, 14740, 18764,
  18041, 8842, 14808, 15682, 12893, 19523, 15357, 22016, 19482, 17153, 14848, 8959, 18041, 11375, 17940, 12040, 16511,
  16511, 19837, 19482, 19482, 16365, 15436, 13747, 11511, 14375, 19431, 16511, 14782, 22237, 19482, 15425, 13746, 14802,
  22733, 18930, 16511, 14824, 21554, 18615, 13099, 14419, 16512, 21348, 14844, 21014, 10685, 20053, 19482, 21011, 8476,
  14864, 19914, 13696, 20053, 16296, 20053, 14331, 14889, 14870, 13707, 13705, 16540, 16544, 16062, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 12975, 18041, 22966, 18041, 15040, 14916, 14932, 14948, 14963, 14977, 10538, 8425,
  15027, 15089, 15074, 14597, 15105, 15164, 15202, 15230, 9179, 15311, 9777, 17940, 15334, 9947, 15354, 15373, 15413,
  17098, 15461, 15488, 21525, 11245, 15504, 9673, 21971, 15520, 15549, 15585, 15601, 15645, 15698, 15436, 22599, 12426,
  20581, 16494, 22568, 15750, 18218, 20418, 17923, 15780, 20166, 15832, 15855, 15904, 17162, 15941, 15957, 19157, 15977,
  16512, 21646, 18114, 13071, 16006, 16047, 14305, 16090, 8476, 16109, 18013, 13696, 19670, 10952, 15764, 15178, 16138,
  16805, 16154, 13705, 18570, 16544, 16062, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 12975, 18041, 22668,
  18041, 12982, 12593, 12607, 16181, 16191, 16207, 19740, 18041, 17392, 20166, 13145, 10677, 18060, 16248, 16294, 16312,
  22693, 18041, 10119, 17940, 13147, 13932, 16511, 15357, 12901, 16362, 19482, 14848, 8959, 18041, 11375, 17940, 12040,
  16511, 9954, 19837, 19482, 19482, 16381, 15436, 13747, 11511, 14375, 10684, 16511, 16511, 19481, 19482, 10970, 16418,
  20166, 16487, 16511, 16510, 19482, 15878, 18038, 19405, 16511, 16512, 19482, 14827, 21014, 10685, 20053, 19482, 21011,
  8476, 20054, 14826, 13696, 20053, 16296, 20053, 17588, 14873, 14870, 13707, 13705, 16528, 20651, 16062, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 12975, 18041, 22668, 18041, 16560, 10767, 16589, 16642, 16652, 16604, 15961,
  18041, 16668, 20166, 13145, 10677, 18060, 18590, 14826, 16690, 21516, 9275, 21014, 17940, 13147, 10681, 16511, 15357,
  12901, 19482, 19482, 14848, 8959, 18041, 16993, 17940, 12040, 16511, 16511, 19837, 19482, 19482, 16365, 18040, 18041,
  21013, 14375, 10684, 16511, 16511, 19481, 19482, 14828, 18041, 20166, 21780, 16511, 16511, 19482, 19482, 18038, 19405,
  16511, 16512, 19482, 14827, 21014, 10685, 20053, 19482, 15670, 12441, 20456, 16741, 16779, 20643, 16821, 20053, 17588,
  14873, 14870, 13707, 13705, 18425, 16858, 16062, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 12975, 18041,
  22668, 18041, 12982, 10659, 10673, 10605, 10615, 13004, 13221, 18041, 12540, 20166, 10466, 12639, 13469, 16906, 19504,
  16935, 21516, 16990, 21014, 17940, 13147, 10681, 16511, 15357, 9150, 19482, 22167, 14848, 8959, 18041, 16993, 17940,
  12040, 16511, 16511, 19837, 19482, 19482, 16365, 18040, 18041, 21013, 14375, 10684, 16511, 16511, 19481, 19482, 14828,
  18041, 20166, 21780, 16511, 16511, 19482, 19482, 18038, 19405, 16511, 16512, 19482, 14827, 21014, 10685, 20053, 19482,
  21011, 8476, 20054, 14826, 13696, 11044, 18164, 20053, 17588, 14873, 14870, 13707, 13705, 16540, 16544, 16062, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 12975, 18041, 14066, 11249, 14059, 10834, 17009, 17025, 17040, 17054,
  15961, 18041, 17392, 20291, 18382, 10044, 18060, 17084, 14826, 13056, 21516, 18041, 21014, 20692, 17123, 20883, 17540,
  15569, 12901, 17139, 19482, 21173, 13040, 9231, 16993, 13782, 12040, 16511, 21107, 17178, 19482, 19482, 17222, 18040,
  18041, 21013, 14375, 10684, 16511, 14023, 17259, 19482, 14828, 18041, 20166, 21780, 16511, 16511, 19482, 19482, 17464,
  17279, 17317, 17343, 17412, 17454, 9660, 22497, 13838, 17480, 21011, 8476, 20054, 14826, 13696, 20053, 16296, 20053,
  16278, 17529, 14870, 13707, 13811, 16540, 16544, 17765, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 12975,
  18041, 22668, 18041, 12982, 10659, 10673, 10605, 17564, 13004, 15961, 18041, 17392, 20166, 13145, 10677, 18060, 18590,
  14826, 13056, 21516, 18041, 21014, 17940, 13147, 10681, 16511, 15357, 12901, 19482, 19482, 14848, 8959, 18041, 16993,
  17940, 12040, 16511, 16511, 19837, 19482, 19482, 16365, 18040, 18041, 21013, 14375, 10684, 16511, 16511, 19481, 19482,
  14828, 18041, 20166, 21780, 16511, 16511, 19482, 19482, 18038, 19405, 16511, 16512, 19482, 14827, 21014, 10685, 20053,
  19482, 21011, 8476, 20054, 14826, 13696, 20053, 16296, 20053, 17588, 14873, 14870, 13707, 13705, 16540, 16544, 16062,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 12975, 18041, 22668, 18041, 17612, 12692, 17652, 17697, 17707,
  17667, 21429, 8950, 16668, 17723, 23030, 23036, 18060, 17750, 14826, 17807, 21516, 19792, 13563, 17940, 13147, 18734,
  17866, 17887, 12901, 17903, 18510, 16919, 8959, 19350, 16993, 17939, 12040, 17957, 16511, 19837, 17987, 18011, 16365,
  18040, 18912, 21013, 20615, 10684, 14766, 16511, 19481, 16881, 18029, 21728, 9128, 21780, 18058, 16511, 18810, 19482,
  18038, 18076, 18092, 16512, 18111, 19542, 21014, 10685, 20053, 19482, 16753, 8476, 14624, 19006, 13696, 20053, 16296,
  20053, 17588, 14873, 14870, 18130, 18180, 13909, 18206, 16062, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  12975, 18041, 22668, 18041, 12982, 10888, 10902, 18234, 18244, 18260, 15961, 18041, 18295, 18314, 8852, 8858, 18349,
  18398, 18441, 18462, 21516, 11437, 21014, 17940, 13147, 10681, 16511, 20217, 12901, 18508, 19483, 19969, 18526, 21417,
  16993, 17940, 12040, 16511, 16511, 18555, 17425, 19698, 16365, 18040, 12135, 21013, 14375, 15839, 16511, 17327, 15397,
  19482, 18606, 18041, 20166, 21780, 16511, 16511, 19482, 19482, 18038, 19405, 16511, 16512, 19482, 14827, 21014, 10685,
  20053, 19482, 21011, 8476, 20054, 14826, 13696, 20053, 21757, 21842, 18631, 14873, 14870, 13707, 13705, 16540, 16544,
  16062, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 12975, 18041, 22668, 18041, 12982, 13323, 18655, 18671,
  18686, 18700, 15011, 18041, 17392, 18714, 22662, 22345, 18750, 18798, 18835, 18875, 15001, 18041, 21014, 17940, 13147,
  10681, 16511, 15357, 12901, 19482, 19482, 14848, 10336, 18041, 16993, 17940, 12040, 16511, 16511, 19837, 19482, 19482,
  16365, 18040, 18041, 10300, 20698, 22613, 19594, 18928, 18946, 21561, 20484, 12883, 18965, 9139, 18981, 21596, 18143,
  18997, 18038, 19405, 15561, 11103, 18155, 22441, 10455, 22831, 16842, 22029, 15214, 11025, 14449, 19022, 13696, 19471,
  19057, 20053, 15925, 19094, 19121, 13707, 13705, 18413, 16544, 17193, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 12975, 18041, 17206, 18041, 18890, 11846, 11860, 19173, 19183, 19199, 15961, 15318, 19237, 9746, 10132, 19253,
  19269, 19320, 19336, 19371, 21516, 18041, 21014, 17940, 13147, 10681, 16511, 20517, 16019, 19482, 20984, 21927, 8959,
  18041, 22396, 17940, 19421, 16511, 19456, 19837, 19482, 19499, 13973, 16074, 8580, 9282, 14375, 10684, 19520, 16511,
  19481, 19539, 14828, 18041, 20166, 21780, 16511, 16511, 19482, 19482, 18038, 19405, 19558, 22750, 19482, 14827, 20681,
  22561, 21035, 19482, 21011, 8476, 20054, 14826, 14755, 16402, 16296, 20263, 21823, 19575, 14870, 13707, 13705, 16540,
  16544, 17358, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 12975, 18041, 22668, 18041, 12982, 10659, 19610,
  11719, 11729, 19626, 15961, 18041, 17392, 20166, 13145, 10677, 18060, 18590, 14826, 13056, 21516, 9238, 16093, 17940,
  13147, 10681, 19661, 15357, 19686, 16122, 19482, 22330, 19722, 9858, 19756, 17940, 12040, 16511, 16511, 19837, 19482,
  19482, 16365, 17504, 10190, 21013, 19777, 10684, 19835, 16511, 19481, 19853, 14828, 18041, 20166, 21780, 16511, 16511,
  19482, 19482, 18038, 19405, 16511, 16512, 19482, 14827, 21014, 10685, 20053, 19482, 21011, 8476, 20054, 14826, 13696,
  20053, 16296, 20053, 17588, 14873, 14870, 13707, 13705, 16540, 16544, 16062, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 12975, 18041, 22668, 18041, 12982, 10659, 10673, 10605, 10615, 13004, 15961, 18041, 19871, 14355, 9787,
  9793, 18095, 19893, 20960, 19930, 21516, 12126, 21014, 17940, 13147, 10681, 16511, 15357, 12901, 19482, 19482, 14848,
  8959, 18041, 16993, 17940, 12040, 16511, 16511, 19837, 19482, 19482, 16365, 18040, 18041, 21013, 14375, 10684, 16511,
  16511, 19481, 19482, 14828, 18041, 20166, 21780, 16511, 16511, 19482, 19482, 18038, 19405, 16511, 16512, 19482, 14827,
  21014, 10685, 20053, 19482, 21011, 8476, 17237, 19964, 13696, 20053, 16296, 20053, 17588, 14873, 14870, 13707, 13705,
  16540, 16544, 16062, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 12975, 18041, 20820, 19985, 17778, 17791,
  20019, 20070, 20080, 20034, 15058, 18274, 17392, 19401, 20096, 9405, 19135, 15868, 15615, 20118, 21516, 19036, 20163,
  22198, 13147, 10681, 20182, 20203, 12901, 20734, 16258, 14848, 8959, 18041, 16626, 17940, 18727, 21143, 20435, 20233,
  20327, 19482, 18190, 13866, 20343, 21013, 11691, 10684, 20360, 14249, 19481, 20397, 21356, 18041, 20166, 21780, 20434,
  16511, 20726, 19482, 18038, 19405, 16511, 20451, 19482, 18819, 21014, 13465, 14255, 19482, 21011, 8476, 20054, 14826,
  13696, 20053, 16296, 20472, 20509, 20381, 22002, 13707, 13705, 13897, 16544, 16062, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 12975, 18041, 22668, 11334, 16573, 12381, 12395, 20533, 20548, 20562, 17681, 20102, 20597, 18363,
  13105, 20631, 20667, 20714, 20750, 20771, 20811, 18041, 20836, 20301, 13147, 20133, 17548, 15357, 20147, 20899, 20921,
  14848, 8959, 20938, 16993, 17940, 12040, 16511, 16511, 19837, 19482, 19482, 16365, 18040, 16342, 19149, 12032, 20048,
  17871, 16511, 20957, 20922, 17493, 17513, 19948, 18325, 17596, 14275, 19482, 20976, 21507, 19405, 16511, 22619, 16890,
  21000, 21014, 10685, 20053, 19482, 18847, 21030, 21051, 22041, 13696, 20053, 16296, 21073, 21099, 13848, 21123, 21159,
  13962, 16540, 16544, 16062, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 12975, 18041, 20003, 21189, 12982,
  11200, 11214, 21208, 21223, 21237, 15961, 19386, 17392, 8462, 20851, 13665, 21320, 21336, 21372, 21402, 15273, 21192,
  19945, 20311, 21870, 21445, 18639, 21468, 15186, 19482, 21541, 14848, 20786, 10192, 18298, 22209, 9835, 21577, 21612,
  19105, 21631, 19908, 20248, 18040, 10222, 21013, 9895, 21662, 16511, 21682, 19481, 19482, 21498, 10252, 9823, 10311,
  14405, 16511, 21699, 21751, 13647, 21773, 16396, 16794, 21803, 17995, 21858, 18333, 21913, 21943, 21959, 21987, 20372,
  21714, 14710, 14900, 16031, 20053, 17588, 14873, 21057, 17971, 11129, 16540, 16544, 20278, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 12975, 18041, 22668, 18041, 12982, 11279, 11293, 22057, 22067, 22083, 16346, 18041, 17392,
  20166, 13145, 10677, 18060, 18590, 14826, 13056, 21516, 12511, 21014, 17940, 13147, 10681, 16511, 21666, 12901, 19482,
  19482, 16165, 10519, 22786, 16993, 14218, 12040, 21833, 22139, 14724, 22244, 15888, 16365, 18040, 19640, 11379, 14375,
  9412, 16511, 16511, 16870, 19482, 14828, 18041, 20166, 21780, 16511, 16511, 19482, 19482, 11073, 19405, 16511, 22357,
  22164, 14827, 21014, 10685, 20053, 19482, 21011, 8476, 20054, 14826, 13696, 15387, 22183, 20053, 17588, 14873, 14870,
  21483, 13705, 16540, 22225, 16062, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 12975, 18041, 22668, 18041,
  12982, 10659, 22260, 14490, 14500, 22275, 15961, 18041, 17392, 20166, 13145, 11078, 18060, 22315, 14826, 22381, 21516,
  18041, 19761, 17940, 18859, 12047, 16511, 15357, 12901, 22417, 19482, 14848, 8959, 18041, 16993, 19221, 20876, 19559,
  16511, 19837, 19482, 22437, 16365, 18040, 18041, 21013, 14375, 10684, 16511, 16511, 19481, 19482, 14828, 18041, 20166,
  21780, 16511, 16511, 19482, 19482, 18038, 19405, 16511, 16512, 19482, 14827, 21014, 10685, 20053, 19482, 21011, 8476,
  20054, 14826, 13696, 20053, 16296, 20053, 17588, 14873, 14870, 13707, 13705, 16540, 16544, 16062, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 12975, 18041, 22668, 18041, 12982, 12838, 12852, 22457, 22467, 22483, 15961, 18041,
  17392, 20166, 13145, 10677, 18060, 18590, 14826, 13056, 21516, 18041, 21014, 17940, 13147, 10681, 16511, 15357, 12901,
  19482, 19482, 14848, 8959, 18041, 16993, 17940, 12040, 16511, 16511, 19837, 19482, 19482, 16365, 18040, 18041, 21013,
  14375, 10684, 16511, 16511, 19481, 19482, 14828, 18041, 20166, 21780, 19586, 21683, 22767, 22421, 18038, 19405, 16511,
  16512, 19482, 14827, 21014, 10685, 20053, 19482, 21011, 8476, 20054, 14826, 13696, 20053, 16296, 20053, 17588, 14873,
  14870, 13707, 13705, 16540, 16544, 16062, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 12975, 18041, 22668,
  18041, 12982, 10659, 22532, 17291, 17301, 22547, 15961, 18041, 17392, 20864, 13145, 8784, 18060, 8795, 14826, 22584,
  21516, 9393, 21014, 17940, 13147, 10681, 16511, 15357, 22299, 19482, 19482, 22635, 22684, 21735, 16993, 17940, 12040,
  16511, 16511, 19837, 19482, 19482, 16365, 18040, 18041, 21013, 14375, 10684, 16511, 16511, 19481, 19482, 14828, 18041,
  20166, 21780, 16511, 16511, 19482, 19482, 18038, 19405, 16511, 16512, 19482, 14827, 21014, 10685, 20053, 19482, 21011,
  8476, 20054, 14826, 13696, 20053, 16296, 20053, 17588, 14873, 14870, 13707, 13705, 16540, 16544, 16062, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 12975, 18041, 22668, 18041, 12982, 10659, 10673, 10605, 10615, 13004, 9984,
  18041, 17392, 20166, 13145, 10677, 18060, 22148, 14679, 13056, 21516, 18041, 21014, 17940, 13147, 10681, 16511, 15357,
  12901, 19482, 19482, 18446, 8959, 18041, 16993, 17940, 12040, 16511, 16511, 19837, 19482, 19482, 18949, 22709, 18041,
  22650, 22726, 21787, 22749, 21452, 21083, 22766, 14828, 18041, 20166, 21780, 16511, 21588, 19482, 19482, 22783, 19405,
  16511, 16512, 19482, 14827, 21014, 10685, 20053, 19482, 21011, 8476, 20054, 14826, 13696, 20053, 16296, 20053, 17588,
  14873, 14870, 13707, 13705, 16540, 16544, 16062, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 9689, 18041,
  12742, 22802, 22110, 22097, 18041, 13555, 22123, 22817, 15961, 8572, 22847, 14581, 14591, 10925, 8752, 11416, 8752,
  8925, 8515, 13214, 12107, 8531, 8560, 11408, 8596, 9615, 8612, 8649, 8640, 8665, 19731, 14991, 8898, 8694, 8544, 8726,
  8747, 16973, 8723, 8742, 8753, 8769, 8811, 13171, 8829, 16950, 8874, 16471, 16448, 8914, 8886, 8941, 8984, 9043, 9467,
  9085, 9459, 9475, 9114, 9166, 9069, 9195, 9066, 9218, 9254, 16433, 9298, 9321, 8678, 15134, 9348, 9378, 9428, 9444,
  9491, 9507, 16965, 11415, 16974, 9537, 9564, 9592, 9631, 9647, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  9689, 18041, 19078, 18539, 18535, 15295, 14193, 14200, 15284, 22877, 15961, 8572, 8497, 14581, 14591, 10925, 8752,
  11416, 8752, 8925, 8515, 13214, 12107, 8531, 8560, 11408, 8596, 9615, 8612, 8649, 8640, 8665, 19731, 14991, 8898,
  8694, 8544, 8726, 8747, 16973, 8723, 8742, 8753, 8769, 8811, 13171, 8829, 16950, 8874, 16471, 16448, 8914, 8886, 8941,
  8984, 9043, 9467, 9085, 9459, 9475, 9114, 9166, 9069, 9195, 9066, 9218, 9254, 16433, 9298, 9321, 8678, 15134, 9348,
  9378, 9428, 9444, 9491, 9507, 16965, 11415, 16974, 9537, 9564, 9592, 9631, 9647, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 9689, 18041, 10858, 18041, 18041, 22915, 22929, 22936, 9693, 22952, 15961, 8572, 22982, 14581,
  14591, 10925, 8752, 11416, 8752, 8925, 8515, 13214, 12107, 8531, 8560, 11408, 8596, 9615, 8612, 8649, 8640, 8665,
  19731, 14991, 8898, 8694, 8544, 8726, 8747, 16973, 8723, 8742, 8753, 8769, 8811, 13171, 8829, 16950, 8874, 16471,
  16448, 8914, 8886, 8941, 8984, 9043, 9467, 9085, 9459, 9475, 9114, 9166, 9069, 9195, 9066, 9218, 9254, 16433, 9298,
  9321, 8678, 15134, 9348, 9378, 9428, 9444, 9491, 9507, 16965, 11415, 16974, 9537, 9564, 9592, 9631, 9647, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 9689, 18041, 19078, 18041, 18041, 21279, 18041, 18041, 18041, 23006,
  15961, 18041, 17392, 20166, 13145, 10677, 18060, 18590, 14826, 10918, 21516, 18041, 21014, 17940, 13147, 10681, 16511,
  15357, 14653, 19482, 19482, 14848, 8959, 18041, 16993, 17940, 12040, 16511, 16511, 19837, 19482, 19482, 16365, 18040,
  18041, 21013, 14375, 10684, 16511, 16511, 19481, 19482, 14828, 18041, 20166, 21780, 16511, 16511, 19482, 19482, 18038,
  19405, 16511, 16512, 19482, 14827, 21014, 10685, 20053, 19482, 21011, 8476, 20054, 14826, 13696, 20053, 16296, 20053,
  17588, 14873, 14870, 13707, 13705, 16540, 16544, 16062, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  12144, 10270, 18041, 12147, 18041, 18041, 12144, 18041, 15338, 18041, 8572, 8579, 14581, 14591, 10925, 8752, 11416,
  8752, 8925, 23052, 13214, 12107, 8531, 8560, 11408, 8596, 9615, 8612, 8649, 8640, 8665, 19731, 14991, 8898, 8694,
  8544, 8726, 8747, 16973, 8723, 8742, 8753, 8769, 8811, 13171, 8829, 16950, 8874, 16471, 16448, 8914, 8886, 8941, 8984,
  9043, 9467, 9085, 9459, 9475, 9114, 9166, 9069, 9195, 9066, 9218, 9254, 16433, 9298, 9321, 8678, 15134, 9348, 9378,
  23068, 9444, 23084, 9507, 9606, 11415, 16974, 9537, 9564, 9592, 9631, 9647, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041, 18041,
  18041, 18041, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 30879, 30879, 0, 0, 32929, 32929, 30879, 30879, 32929,
  32929, 32929, 32929, 32929, 32929, 32929, 32929, 32929, 0, 30879, 0, 32929, 0, 30879, 32929, 32929, 32929, 32929,
  32929, 32929, 32929, 32929, 32929, 32929, 32929, 32929, 32929, 32929, 32929, 32929, 32929, 0, 32929, 32929, 32929,
  32929, 32929, 26624, 28672, 32929, 32929, 32929, 32929, 32929, 24576, 32929, 32929, 32929, 32929, 32929, 0, 32929,
  32929, 32929, 32929, 32929, 32929, 32929, 32929, 32929, 32929, 32929, 173, 32929, 32929, 32929, 32929, 32929, 32929,
  6145, 0, 3, 4, 0, 0, 0, 0, 0, 156, 157, 563200, 30879, 0, 0, 0, 333, 0, 335, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 173, 0,
  0, 0, 75776, 32929, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 173, 173, 173, 0, 0, 0, 342, 0, 214, 214, 214, 214, 214, 214,
  373, 214, 378, 214, 214, 0, 0, 0, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 784, 158, 158, 158,
  532480, 194, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 108544, 686080, 0, 763904, 802816, 0, 0, 0, 173, 173, 0, 0,
  677888, 0, 0, 0, 534528, 733184, 561152, 561152, 749568, 753664, 561152, 561152, 772096, 780288, 786432, 561152,
  794624, 806912, 561152, 561152, 561152, 561152, 716800, 0, 788480, 0, 0, 0, 0, 0, 0, 0, 563200, 671744, 849920,
  561152, 561152, 561152, 733184, 749568, 753664, 772096, 780288, 786432, 794624, 849920, 0, 0, 0, 0, 0, 0, 0, 532480,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 864, 563200, 733184, 563200, 563200, 563200, 749568, 753664, 563200,
  563200, 563200, 772096, 780288, 786432, 563200, 794624, 806912, 563200, 563200, 563200, 759808, 563200, 563200,
  563200, 563200, 563200, 563200, 0, 0, 563200, 563200, 563200, 563200, 563200, 0, 563200, 0, 0, 0, 156, 0, 0, 0, 0,
  673792, 563200, 772096, 563200, 780288, 786432, 563200, 794624, 563200, 806912, 563200, 563200, 563200, 563200,
  563200, 563200, 563200, 733184, 563200, 563200, 563200, 749568, 753664, 563200, 759808, 563200, 563200, 563200,
  849920, 563200, 563200, 563200, 563200, 563200, 563200, 0, 0, 0, 563200, 563200, 563200, 0, 0, 0, 751616, 0, 0, 0, 0,
  0, 561152, 692224, 561152, 561152, 768000, 561152, 561152, 561152, 716800, 561152, 561152, 561152, 745472, 561152,
  561152, 561152, 784384, 788480, 561152, 561152, 561152, 561152, 716800, 0, 788480, 0, 0, 0, 0, 0, 0, 0, 563519,
  672063, 671744, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 716800, 563200, 563200,
  563200, 563200, 563200, 563200, 745472, 563200, 563200, 563200, 745472, 563200, 563200, 563200, 563200, 563200,
  784384, 788480, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200,
  563200, 563200, 0, 0, 563200, 563200, 688128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 724992, 0, 0, 0, 401, 0, 0, 0, 0, 0,
  0, 0, 158, 158, 158, 420, 158, 158, 158, 158, 158, 0, 283, 283, 283, 283, 474, 283, 0, 847872, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 231, 0, 561152, 561152, 757760, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152,
  561152, 757760, 0, 0, 0, 0, 0, 0, 523, 557, 558, 214, 214, 214, 214, 214, 214, 214, 0, 0, 0, 347, 0, 0, 0, 0, 0, 0, 0,
  158, 158, 158, 417, 158, 563200, 563200, 563200, 757760, 563200, 563200, 563200, 563200, 563200, 563200, 563200,
  563200, 563200, 835584, 837632, 563200, 845824, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 0, 0, 0, 0, 0,
  0, 0, 745472, 784384, 0, 0, 0, 671744, 671744, 561152, 561152, 563200, 563200, 563200, 757760, 563200, 563200, 563200,
  774144, 563200, 800768, 563200, 563200, 563200, 563200, 563200, 563200, 0, 563200, 0, 0, 0, 0, 0, 0, 0, 0, 673792, 0,
  0, 808960, 0, 0, 0, 0, 0, 782336, 0, 0, 0, 0, 0, 0, 0, 0, 337, 0, 0, 0, 0, 0, 0, 0, 0, 521, 0, 0, 0, 0, 0, 0, 0, 0,
  521, 0, 0, 0, 0, 0, 0, 709, 727040, 0, 0, 868352, 0, 561152, 561152, 561152, 561152, 561152, 727040, 561152, 561152,
  561152, 808960, 561152, 561152, 0, 768000, 692224, 667967, 563519, 692543, 563519, 563519, 563519, 719167, 563519,
  768319, 563519, 563519, 563519, 563519, 563519, 563519, 563519, 850239, 563519, 563519, 563519, 563519, 563519, 0,
  563519, 563519, 563519, 563519, 563519, 563519, 563519, 717119, 563519, 563519, 563519, 563519, 563519, 563519,
  745791, 563519, 561152, 561152, 851968, 858112, 868352, 858112, 0, 0, 0, 851968, 0, 563200, 563200, 563200, 694272,
  563200, 563200, 563200, 563200, 563200, 856064, 0, 49152, 563200, 563200, 563200, 563200, 563200, 563200, 563200,
  563200, 563200, 563200, 563200, 737280, 563200, 761856, 563200, 563200, 790528, 563200, 815104, 563200, 563200,
  851968, 858112, 563200, 563200, 868352, 563200, 563200, 563200, 563200, 563200, 727040, 563200, 563200, 563200,
  563200, 563200, 0, 563200, 116736, 0, 0, 0, 0, 0, 0, 0, 673792, 563200, 868352, 563200, 0, 0, 825344, 0, 0, 0, 0, 0,
  0, 841728, 839680, 0, 0, 0, 0, 0, 214, 214, 214, 981, 214, 214, 214, 214, 214, 214, 214, 0, 0, 0, 991, 0, 0, 158, 158,
  158, 158, 158, 158, 158, 636, 158, 158, 51839, 521, 283, 283, 283, 283, 0, 561152, 561152, 561152, 561152, 561152,
  737280, 561152, 561152, 825344, 561152, 839680, 737280, 0, 0, 0, 0, 0, 0, 525, 173, 173, 0, 0, 0, 0, 529, 0, 0,
  563200, 825344, 563200, 839680, 563200, 563200, 870400, 563200, 563200, 563200, 563200, 563200, 563200, 563200,
  563200, 563200, 563200, 563200, 563200, 563200, 563200, 0, 508, 790528, 563200, 815104, 563200, 563200, 825344,
  563200, 563200, 839680, 563200, 563200, 563200, 870400, 0, 0, 0, 0, 0, 0, 715, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 543, 0,
  547, 0, 0, 0, 708608, 0, 722944, 0, 0, 0, 0, 0, 561152, 561152, 561152, 708608, 561152, 561152, 561152, 561152,
  561152, 561152, 55296, 118784, 126976, 0, 0, 0, 0, 0, 0, 0, 0, 541, 0, 0, 0, 0, 0, 0, 0, 214, 214, 214, 214, 214, 214,
  214, 563200, 563200, 563200, 563200, 698368, 563200, 722944, 563200, 563200, 563200, 563200, 563200, 563200, 563200,
  563200, 563200, 563200, 563200, 563200, 563200, 563200, 0, 120832, 698368, 706560, 708608, 563200, 563200, 722944,
  563200, 563200, 563200, 563200, 811008, 563200, 563200, 563200, 563200, 563200, 0, 563200, 0, 0, 0, 0, 0, 0, 157, 0,
  673792, 563200, 563200, 862208, 563200, 718848, 563200, 563200, 563200, 563200, 563200, 667648, 563200, 563200,
  692224, 563200, 563200, 563200, 563200, 563200, 0, 563200, 118784, 0, 0, 0, 0, 0, 0, 0, 673792, 563200, 718848,
  563200, 563200, 768000, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 862208, 827392, 0, 0, 0, 534,
  0, 0, 0, 0, 0, 0, 0, 545, 0, 0, 0, 0, 0, 0, 404, 0, 0, 0, 0, 158, 158, 158, 158, 158, 158, 158, 898, 158, 158, 158,
  158, 696320, 675840, 0, 1188, 675840, 696320, 561152, 770048, 827392, 770048, 563200, 675840, 696320, 563200, 563200,
  741376, 770048, 817152, 827392, 860160, 679936, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 675840,
  679936, 696320, 563200, 563200, 563200, 563200, 694272, 563200, 563200, 563200, 563200, 563200, 563200, 563200,
  727040, 735232, 563200, 563200, 563200, 563200, 563200, 563200, 808960, 563200, 563200, 563200, 563200, 563200,
  563200, 563200, 851968, 563200, 858112, 563200, 563200, 563200, 563200, 741376, 770048, 817152, 563200, 827392,
  563200, 563200, 563200, 860160, 0, 714752, 1188, 714752, 563200, 710656, 714752, 563200, 563200, 563200, 563200,
  563200, 563200, 563200, 856064, 563200, 710656, 714752, 563200, 563200, 563200, 563200, 563200, 0, 563200, 120832, 0,
  0, 0, 0, 0, 0, 0, 673792, 563200, 563200, 720896, 563200, 563200, 563200, 563200, 563200, 563200, 720896, 563200,
  563200, 563200, 563200, 563200, 563200, 0, 563200, 0, 0, 0, 0, 513, 517, 0, 0, 673792, 833536, 563200, 563200, 563200,
  563200, 729088, 563200, 563200, 833536, 563200, 563200, 729088, 563200, 563200, 563200, 563200, 563200, 0, 563200, 0,
  90112, 0, 0, 0, 0, 0, 0, 673792, 833536, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200,
  563200, 563200, 563200, 669696, 563200, 563200, 563200, 563200, 563200, 856064, 0, 0, 563200, 563200, 563200, 563200,
  563200, 563200, 563200, 563200, 849920, 563200, 563200, 563200, 563200, 563200, 0, 563200, 563200, 563200, 563200,
  831488, 669696, 563200, 563200, 563200, 563200, 831488, 563200, 743424, 819200, 563200, 563200, 743424, 819200,
  563200, 712704, 563200, 712704, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 823296, 823296, 0, 0, 0, 0, 0,
  0, 1130, 0, 214, 214, 214, 214, 1135, 214, 214, 214, 214, 736, 214, 738, 214, 214, 214, 741, 214, 214, 742, 214, 214,
  6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 354304, 354304, 0, 231, 0, 231, 231, 231, 231, 231, 231, 231,
  231, 231, 231, 231, 231, 231, 0, 0, 0, 0, 0, 0, 0, 0, 231, 231, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 156, 157, 563200, 0, 0,
  0, 0, 0, 214, 214, 364, 214, 214, 371, 214, 214, 214, 379, 214, 532480, 194, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 357,
  0, 0, 0, 554, 0, 0, 0, 0, 214, 214, 214, 214, 214, 214, 214, 214, 0, 0, 0, 389, 0, 0, 0, 0, 0, 0, 0, 158, 158, 158,
  418, 158, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 156, 156, 0, 0, 0, 0, 0, 214, 214, 980, 214, 214, 214, 983, 214, 214,
  214, 214, 0, 0, 0, 0, 0, 0, 753, 0, 755, 756, 158, 158, 0, 0, 57344, 0, 0, 156, 57344, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 720, 0, 0, 0, 0, 0, 156, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 14651, 157, 563200, 0, 0, 0, 0, 0, 214, 979, 214, 214, 214,
  214, 214, 214, 214, 214, 214, 883, 214, 214, 0, 0, 0, 0, 532480, 194, 0, 0, 20480, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  173, 173, 102400, 0, 6145, 0, 569493, 4, 151, 0, 0, 0, 0, 0, 0, 0, 0, 0, 151, 0, 0, 0, 588, 0, 0, 0, 158, 158, 158,
  158, 158, 158, 158, 158, 158, 158, 782, 158, 158, 158, 158, 158, 0, 0, 6145, 0, 569493, 4, 0, 71680, 0, 0, 0, 156,
  157, 563200, 0, 0, 0, 0, 0, 321, 0, 0, 0, 0, 0, 0, 173, 173, 173, 0, 71680, 0, 0, 0, 0, 0, 0, 532480, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 88064, 88064, 88064, 88064, 88064, 88064, 88064, 88064, 88064, 88064, 88064, 88064, 0, 0, 0, 0, 0, 0,
  0, 0, 532480, 194, 0, 0, 0, 348, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 158, 158, 414, 158, 158, 6145, 0, 3, 4, 0, 65536, 0,
  0, 0, 0, 0, 0, 0, 65536, 0, 0, 0, 0, 65536, 0, 0, 0, 0, 0, 0, 65536, 65536, 65536, 65536, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 163, 164, 0, 0, 0, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 156, 157, 563200, 0, 0, 0, 0, 0, 528, 0, 0, 214, 214,
  214, 214, 562, 214, 214, 214, 385, 214, 214, 0, 0, 0, 0, 0, 0, 0, 0, 396, 0, 0, 0, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 316,
  317, 563200, 0, 0, 0, 0, 0, 536, 0, 0, 540, 0, 0, 0, 0, 0, 0, 0, 0, 108544, 0, 0, 0, 0, 0, 0, 0, 0, 532480, 345, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 721, 0, 723, 0, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 157, 157, 0, 0, 0, 0, 0,
  856, 857, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 861, 0, 0, 863, 0, 0, 0, 0, 67584, 0, 0, 157, 67584, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 972, 973, 0, 0, 0, 0, 157, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53248, 0, 0, 157, 6145, 0, 3, 4, 0, 0,
  0, 0, 0, 156, 14654, 563200, 0, 0, 0, 0, 0, 866, 0, 0, 0, 870, 214, 214, 214, 214, 214, 214, 0, 989, 0, 0, 0, 0, 993,
  158, 158, 158, 996, 532480, 194, 0, 0, 0, 0, 0, 0, 22528, 0, 0, 0, 0, 0, 0, 0, 0, 521, 0, 0, 0, 706, 707, 0, 0, 6145,
  0, 3, 4, 0, 0, 152, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 75776, 0, 0, 0, 0, 162, 162, 162, 69794, 69794, 177, 162, 162,
  162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 0, 69794, 69794, 162, 69794, 69794, 69794, 69794,
  69794, 162, 0, 0, 0, 162, 0, 0, 162, 162, 162, 162, 162, 26624, 28672, 162, 162, 162, 162, 69794, 24576, 162, 162,
  162, 162, 162, 69632, 69794, 162, 162, 69794, 69809, 69809, 69809, 69809, 69794, 69809, 69794, 69794, 6145, 0, 3, 4,
  0, 0, 0, 0, 0, 156, 157, 563200, 0, 0, 0, 0, 0, 1129, 0, 0, 1132, 214, 214, 214, 214, 214, 214, 214, 388, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 173, 157, 157, 0, 0, 686080, 0, 763904, 802816, 0, 0, 0, 567624, 173, 0, 0, 677888, 0, 0, 0,
  534528, 75776, 0, 75776, 75776, 0, 26624, 28672, 0, 0, 75776, 0, 75776, 24576, 75776, 75776, 0, 0, 0, 696, 0, 0, 0,
  702, 521, 0, 0, 705, 0, 0, 0, 0, 0, 0, 344, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 326, 0, 173, 173, 173, 0, 75776, 75776,
  75776, 75776, 75776, 75776, 75776, 75776, 75776, 75776, 75776, 75776, 75776, 75776, 75776, 0, 0, 0, 0, 0, 0, 0, 0,
  686080, 0, 763904, 802816, 0, 0, 0, 173, 0, 0, 0, 677888, 0, 0, 0, 534528, 79872, 77824, 77824, 77824, 77824, 77824,
  77824, 77824, 0, 0, 0, 51482, 0, 0, 0, 0, 0, 0, 214, 0, 158, 158, 158, 283, 158, 158, 158, 158, 158, 283, 283, 283,
  283, 283, 283, 283, 158, 283, 0, 51482, 0, 0, 77824, 0, 0, 51482, 51482, 51482, 51482, 51482, 51482, 51482, 77824,
  51482, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 156, 157, 563200, 0, 0, 0, 0, 0, 26624, 28672, 0, 0, 0, 0, 0, 24576, 0, 0, 214,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 563200,
  563200, 563200, 759808, 563200, 563200, 563200, 563200, 563200, 563200, 0, 51200, 563200, 563200, 563200, 563200,
  563200, 0, 563200, 508, 0, 0, 0, 0, 0, 0, 0, 673792, 83968, 81920, 81920, 81920, 81920, 81920, 81920, 81920, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 112640, 0, 0, 214, 214, 214, 81920, 81920, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 156, 157, 563200, 0, 0,
  0, 0, 0, 26624, 28672, 0, 0, 0, 0, 0, 24576, 0, 0, 220, 86016, 86016, 86016, 0, 86016, 26624, 28672, 86016, 0, 0,
  86016, 0, 24576, 86016, 86016, 0, 86016, 86016, 86016, 86016, 86016, 86016, 86016, 86016, 86016, 86016, 86016, 86016,
  86016, 0, 0, 0, 0, 0, 0, 0, 0, 86016, 86016, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 156, 157, 563200, 0, 0, 0, 0, 0, 26624,
  28672, 0, 0, 0, 0, 0, 24576, 0, 0, 221, 147, 0, 3, 4, 0, 0, 0, 153, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 354304, 173, 0, 0,
  0, 0, 88064, 88064, 0, 41108, 3, 4, 0, 0, 313, 0, 0, 156, 157, 158, 0, 0, 0, 0, 0, 26624, 28672, 0, 0, 0, 0, 0, 24576,
  0, 0, 223, 0, 0, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 260, 158, 158, 158, 283, 283, 0, 283, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 563200, 563200, 563200, 563200, 563200, 158, 158, 158, 158, 1206, 158, 158, 158, 158, 158,
  1212, 283, 283, 283, 283, 283, 283, 283, 283, 283, 1253, 283, 283, 0, 0, 1188, 214, 283, 1218, 283, 283, 283, 283,
  283, 283, 283, 283, 283, 283, 283, 283, 0, 0, 847, 0, 158, 1237, 158, 158, 158, 158, 158, 158, 158, 158, 158, 283,
  283, 283, 283, 283, 283, 158, 158, 158, 1363, 283, 283, 283, 283, 283, 283, 1249, 283, 1250, 283, 283, 283, 283, 283,
  283, 0, 0, 1188, 214, 214, 0, 0, 0, 158, 158, 158, 1197, 1198, 1199, 158, 158, 158, 158, 158, 158, 158, 779, 158, 158,
  158, 158, 158, 158, 158, 158, 158, 158, 1243, 283, 283, 283, 283, 283, 158, 1258, 158, 158, 158, 158, 158, 1263, 158,
  158, 158, 283, 1267, 283, 283, 283, 0, 1055, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 158, 158, 158, 419, 158, 283, 283, 1272,
  283, 283, 283, 0, 1188, 1276, 158, 158, 158, 158, 158, 158, 158, 158, 158, 1094, 158, 158, 158, 158, 158, 283, 158,
  1285, 283, 283, 283, 283, 283, 283, 283, 283, 0, 158, 158, 158, 158, 158, 1334, 1335, 158, 283, 283, 283, 283, 283,
  1340, 1341, 343, 194, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 122880, 0, 158, 158, 158, 283, 283, 94208, 283, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 563519, 563519, 563519, 563519, 563519, 96452, 0, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 156, 157,
  563200, 0, 0, 0, 0, 0, 26624, 28672, 0, 0, 0, 0, 0, 24576, 0, 0, 228, 239, 239, 239, 239, 239, 239, 247, 247, 247,
  247, 247, 239, 247, 266, 532480, 194, 0, 98304, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 114688, 0, 0, 0, 713, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 168, 0, 168, 0, 0, 193, 6145, 41108, 3, 4, 0, 0, 0, 0, 0, 156, 157, 158, 0, 0, 0, 0, 0, 26624,
  28672, 0, 0, 0, 0, 0, 24576, 0, 0, 229, 0, 0, 0, 243, 243, 243, 243, 243, 243, 243, 243, 243, 243, 267, 193, 194, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 125161, 0, 158, 158, 158, 283, 283, 343, 283, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  178, 0, 0, 0, 0, 0, 691, 0, 0, 0, 697, 0, 0, 0, 521, 0, 0, 0, 0, 0, 0, 0, 0, 538, 538, 717, 0, 0, 0, 0, 544, 724, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 214, 214, 214, 214, 873, 214, 214, 164, 0, 0, 0, 0, 26624, 28672, 0, 0, 163, 0, 163,
  24576, 0, 0, 0, 0, 0, 0, 763904, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 0,
  563200, 563200, 563200, 563200, 563200, 563200, 164, 0, 163, 0, 163, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 546, 0, 0, 0,
  163, 0, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 156, 157, 563519, 0, 0, 0, 0, 0, 26624, 28672, 0, 0, 137216, 0, 137216, 24576,
  0, 0, 0, 0, 0, 156, 0, 0, 0, 156, 156, 156, 156, 156, 0, 156, 0, 73728, 104448, 0, 0, 0, 0, 0, 0, 0, 0, 0, 567625,
  73728, 567625, 0, 0, 0, 724, 0, 0, 0, 0, 0, 214, 214, 214, 214, 214, 214, 214, 374, 214, 214, 214, 73728, 0, 0, 0, 0,
  0, 0, 532480, 0, 0, 0, 0, 0, 0, 0, 0, 0, 860, 0, 0, 0, 863, 0, 0, 686080, 0, 763904, 802816, 0, 0, 0, 0, 567625, 0, 0,
  677888, 0, 0, 0, 534528, 563519, 733503, 563519, 563519, 563519, 749887, 753983, 563519, 563519, 563519, 772415,
  780607, 786751, 563519, 794943, 807231, 563660, 772556, 563660, 780748, 786892, 563660, 795084, 563660, 807372,
  563660, 563660, 563660, 563660, 563660, 563660, 563660, 563660, 563660, 563660, 563660, 563660, 563660, 563660, 0, 0,
  563519, 672204, 563660, 563660, 563660, 563660, 563660, 563660, 563660, 563660, 563660, 717260, 563660, 563660,
  563660, 563660, 563660, 856524, 0, 1188, 563519, 563519, 563519, 563519, 563519, 563519, 563519, 563519, 563519,
  563519, 563519, 563519, 563519, 563519, 0, 563660, 563519, 563660, 563660, 563660, 688588, 690636, 563660, 563660,
  563660, 563660, 563660, 563660, 563660, 563660, 725452, 563660, 688128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 724992, 0,
  0, 0, 724, 0, 0, 0, 0, 0, 214, 214, 871, 872, 214, 214, 214, 214, 878, 879, 880, 214, 214, 214, 214, 214, 0, 0, 0,
  888, 563660, 836044, 838092, 563660, 846284, 563660, 563660, 563660, 563660, 563660, 563660, 563660, 0, 0, 0, 0, 0, 0,
  214, 0, 263, 279, 279, 295, 279, 279, 279, 279, 279, 295, 295, 295, 295, 295, 295, 295, 279, 295, 561152, 561152,
  851968, 858112, 868352, 858112, 0, 0, 0, 851968, 0, 563519, 563519, 563519, 694591, 563519, 563519, 563519, 758079,
  563519, 563519, 563519, 563519, 563519, 563519, 563519, 563519, 563519, 835903, 837951, 563519, 563519, 563519,
  760127, 563519, 563519, 563519, 563519, 563519, 563519, 0, 0, 563660, 563660, 563660, 563660, 694732, 563660, 563660,
  563660, 563660, 563660, 563660, 563660, 727500, 735692, 563660, 563660, 563519, 563519, 852287, 858431, 563519,
  563519, 868671, 563519, 563519, 563519, 563519, 563519, 727359, 563519, 563519, 563519, 563519, 563519, 563519,
  563519, 563519, 737599, 563519, 762175, 563519, 563519, 790847, 563519, 815423, 563660, 868812, 563660, 0, 0, 825344,
  0, 0, 0, 0, 0, 0, 841728, 839680, 0, 0, 0, 0, 0, 26624, 28672, 0, 170, 0, 170, 0, 24576, 211, 211, 225, 211, 211, 211,
  211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 262, 563519, 825663, 563519, 839999, 563519, 563519, 870719, 563519,
  563519, 563519, 563519, 563519, 563519, 563519, 563519, 563660, 563660, 0, 563660, 0, 0, 0, 0, 0, 0, 0, 0, 673792,
  790988, 563660, 815564, 563660, 563660, 825804, 563660, 563660, 840140, 563660, 563660, 563660, 870860, 0, 0, 0, 0, 0,
  0, 763904, 563519, 563519, 563519, 563519, 563519, 563519, 563519, 563519, 563519, 459, 563660, 563660, 563660,
  563660, 563660, 563660, 698828, 707020, 709068, 563660, 563660, 723404, 563660, 563660, 563660, 563660, 811468,
  563660, 563660, 563660, 563660, 563660, 809420, 563660, 563660, 563660, 563660, 563660, 563660, 563660, 852428,
  563660, 858572, 563660, 563519, 563519, 862527, 563519, 719167, 563519, 563519, 563519, 563519, 563519, 668108,
  563660, 563660, 692684, 563660, 563660, 745932, 563660, 563660, 563660, 563660, 563660, 784844, 788940, 563660,
  563660, 563660, 563660, 563660, 563660, 563660, 563660, 563660, 563660, 563660, 737740, 563660, 762316, 563660,
  563660, 563660, 719308, 563660, 563660, 768460, 563660, 563660, 563660, 563660, 563660, 563660, 563660, 563660,
  862668, 827392, 0, 0, 0, 724, 0, 0, 0, 0, 869, 214, 214, 214, 214, 214, 214, 214, 881, 214, 214, 214, 214, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 158, 158, 158, 158, 158, 158, 600, 158, 158, 696320, 675840, 0, 1188, 675840, 696320, 561152,
  770048, 827392, 770048, 563519, 676159, 696639, 563519, 563519, 741695, 770367, 817471, 827711, 860479, 680255,
  563519, 563519, 563519, 563519, 563519, 563519, 563660, 676300, 680396, 696780, 563660, 713023, 563519, 713164,
  563660, 563519, 563660, 563519, 563660, 563519, 563660, 823615, 823756, 0, 0, 0, 0, 0, 0, 806912, 0, 561152, 561152,
  561152, 561152, 561152, 561152, 561152, 561152, 0, 0, 129024, 0, 0, 0, 0, 0, 0, 0, 0, 542, 0, 0, 0, 0, 0, 0, 0, 0,
  859, 0, 0, 0, 0, 0, 0, 0, 0, 53248, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 563519, 710975, 715071, 563519, 563519, 563519,
  563519, 563519, 563519, 563519, 856383, 563660, 711116, 715212, 563660, 563660, 850380, 563660, 563660, 563660,
  563660, 563660, 563660, 0, 0, 0, 563519, 563660, 563660, 0, 0, 0, 751616, 0, 0, 0, 0, 0, 561152, 692224, 561152,
  561152, 768000, 563519, 563519, 721215, 563519, 563519, 563519, 563519, 563660, 563660, 721356, 563660, 563660,
  563660, 563660, 563660, 563660, 741836, 770508, 817612, 563660, 827852, 563660, 563660, 563660, 860620, 0, 714752,
  1188, 714752, 833536, 563519, 563519, 563519, 563519, 729407, 563519, 563519, 833855, 563660, 563660, 729548, 563660,
  563660, 563660, 563660, 758220, 563660, 563660, 563660, 774604, 563660, 801228, 563660, 563660, 563660, 563660,
  563660, 563660, 563660, 733644, 563660, 563660, 563660, 750028, 754124, 563660, 760268, 563660, 833996, 563519,
  563519, 563519, 563519, 563519, 563519, 563660, 563660, 563660, 563660, 563660, 563660, 670015, 563519, 563519,
  563519, 563519, 698687, 563519, 723263, 563519, 563519, 563519, 563519, 563660, 563660, 563660, 563660, 563660,
  563660, 563660, 563660, 563660, 0, 563519, 563519, 563519, 563519, 563519, 563519, 563519, 831807, 670156, 563660,
  563660, 563660, 563660, 831948, 563519, 743743, 819519, 563519, 563660, 743884, 819660, 0, 0, 108544, 108544, 0,
  26624, 28672, 0, 0, 108544, 0, 108544, 24576, 108544, 108544, 0, 108544, 108544, 108544, 108544, 108544, 108544,
  108544, 108544, 108544, 108544, 108544, 108544, 108544, 0, 0, 0, 0, 0, 0, 0, 0, 108544, 108544, 6145, 0, 3, 4, 0, 0,
  0, 0, 0, 156, 157, 563200, 0, 0, 0, 0, 0, 26624, 28672, 0, 191, 0, 191, 0, 24576, 212, 212, 227, 212, 212, 212, 212,
  212, 212, 212, 212, 212, 212, 212, 212, 212, 265, 563200, 688128, 156, 0, 0, 0, 156, 0, 157, 0, 0, 0, 157, 0, 724992,
  0, 0, 0, 724, 0, 0, 867, 868, 0, 214, 214, 214, 214, 214, 874, 214, 214, 0, 0, 0, 158, 1196, 158, 158, 158, 158, 158,
  1200, 158, 158, 1202, 0, 847872, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 194, 0, 0, 0, 194, 194, 194, 194, 194, 0, 194, 194, 0,
  0, 34816, 0, 0, 0, 0, 0, 561152, 688128, 690176, 561152, 561152, 561152, 724992, 563200, 835584, 837632, 563200,
  845824, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 0, 0, 156, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  549, 0, 157, 0, 808960, 0, 0, 0, 0, 0, 782336, 0, 0, 0, 0, 0, 194, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 356, 0, 0, 110824,
  0, 110824, 110824, 110824, 110824, 110824, 110824, 110824, 110824, 110824, 110824, 110824, 110824, 110824, 0, 0, 0, 0,
  0, 0, 0, 0, 110824, 110904, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 156, 157, 563200, 0, 0, 0, 0, 0, 26624, 28672, 0, 204, 0,
  204, 0, 24576, 204, 204, 219, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 256, 6145, 0, 3, 4, 0,
  0, 0, 0, 122880, 0, 0, 0, 0, 0, 0, 122880, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 158, 411, 158, 158, 158, 122880, 0,
  122880, 122880, 122880, 122880, 122880, 122880, 122880, 122880, 122880, 122880, 122880, 122880, 122880, 0, 0, 0, 0, 0,
  0, 0, 0, 122880, 122880, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 156, 157, 563200, 0, 0, 0, 0, 0, 26624, 28672, 0, 205, 0, 205,
  0, 24576, 205, 205, 222, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 124928, 0, 0, 0, 0, 0, 0, 0, 405, 406, 0, 0, 158, 410, 158,
  158, 158, 124928, 0, 0, 124928, 0, 0, 0, 124928, 0, 0, 0, 0, 0, 0, 0, 0, 0, 348160, 0, 173, 0, 348160, 0, 0, 125161,
  0, 125161, 125161, 125161, 125161, 125161, 125161, 125161, 125161, 125161, 125161, 125161, 125161, 125161, 0, 0, 0, 0,
  0, 0, 124928, 0, 125161, 125161, 6145, 0, 3, 0, 0, 0, 0, 133120, 0, 156, 157, 563200, 0, 100352, 6145, 0, 3, 571542,
  0, 0, 0, 0, 0, 0, 154, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 137216, 0, 0, 0, 6145, 0, 3, 571542, 0, 0, 0, 0, 0,
  156, 157, 563200, 0, 0, 0, 0, 0, 26624, 28672, 0, 206, 0, 206, 0, 24576, 206, 206, 230, 206, 206, 206, 206, 206, 206,
  206, 206, 206, 206, 206, 206, 206, 269, 532480, 194, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 120832, 0, 0, 0, 966, 0, 0,
  0, 0, 0, 970, 0, 0, 0, 0, 0, 0, 0, 592, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 51839, 521, 283, 283, 283,
  283, 0, 135168, 0, 0, 0, 0, 0, 135168, 135168, 135168, 135168, 135168, 135168, 135168, 0, 135168, 6145, 0, 3, 4, 0, 0,
  0, 0, 0, 156, 157, 563200, 0, 0, 0, 0, 0, 26624, 28672, 203, 0, 0, 0, 0, 24576, 209, 209, 217, 209, 209, 240, 240,
  240, 240, 240, 240, 240, 240, 240, 240, 240, 254, 6145, 41108, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 158, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 165, 165, 165, 179, 0, 158, 283, 6145, 41108, 3, 4, 0, 0, 0, 0, 0, 156, 157, 158, 0, 0, 0, 0, 0, 26624,
  67785, 0, 0, 0, 0, 0, 24576, 0, 0, 0, 0, 0, 0, 534528, 0, 539, 0, 0, 0, 0, 0, 0, 0, 0, 521, 0, 0, 0, 0, 0, 708, 0,
  158, 158, 158, 283, 283, 0, 283, 0, 0, 0, 0, 0, 0, 0, 521, 0, 0, 0, 1127, 0, 0, 0, 0, 214, 1133, 214, 214, 214, 1136,
  214, 1138, 724, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 729, 0, 214, 214, 214, 214, 1069, 214, 214, 214, 214, 214, 214, 0, 0, 0,
  0, 0, 392, 0, 0, 0, 0, 344, 194, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 139264, 0, 1064, 214, 214, 214, 214, 214,
  214, 214, 214, 214, 214, 214, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 137216, 137216, 137216, 137216, 137216, 137216,
  137216, 0, 0, 0, 0, 0, 0, 0, 0, 0, 561152, 688128, 690176, 561152, 561152, 561152, 724992, 137216, 0, 6145, 0, 3, 4,
  0, 0, 0, 0, 0, 156, 157, 563200, 0, 0, 0, 0, 0, 57541, 28672, 0, 0, 0, 0, 0, 24576, 0, 0, 0, 0, 0, 0, 534528, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 327, 173, 173, 173, 0, 0, 0, 139264, 0, 0, 26624, 28672, 0, 0, 0, 0, 0, 24576, 139264, 139264,
  0, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 139264, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 173, 0, 0, 0, 0, 139264, 139264, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 156, 157, 563200, 0, 0, 0, 0, 0,
  92352, 0, 0, 0, 92470, 92470, 92470, 92470, 92470, 0, 92470, 6145, 41108, 3, 4, 0, 0, 0, 0, 0, 156, 157, 158, 0, 0, 0,
  0, 0, 26624, 28672, 0, 0, 0, 0, 0, 24576, 0, 0, 224, 696320, 675840, 0, 1231, 675840, 696320, 561152, 770048, 827392,
  770048, 563200, 675840, 696320, 563200, 563200, 741376, 563200, 563200, 563200, 741376, 770048, 817152, 563200,
  827392, 563200, 563200, 563200, 860160, 0, 714752, 1256, 714752, 0, 194, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 156, 157,
  563200, 0, 0, 0, 0, 0, 141312, 0, 0, 0, 141312, 141312, 141312, 141312, 141312, 0, 141312, 6145, 0, 3, 4, 0, 0, 0, 0,
  0, 156, 157, 563200, 0, 0, 0, 0, 0, 110896, 0, 0, 0, 110896, 110896, 110896, 110896, 110896, 110824, 110896, 532480,
  16730, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 164, 0, 0, 0, 0, 0, 165, 0, 0, 0, 0, 0, 0, 0, 0, 0, 173, 158, 0, 158,
  0, 0, 0, 1142, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 444, 158, 0, 0, 165, 0, 0, 0, 0, 26624,
  28672, 202, 0, 0, 0, 0, 24576, 202, 213, 215, 213, 213, 213, 213, 213, 213, 213, 213, 213, 213, 213, 250, 213, 252,
  250, 213, 213, 213, 213, 213, 215, 213, 252, 273, 273, 284, 273, 273, 273, 273, 273, 284, 284, 284, 284, 284, 284,
  284, 273, 284, 273, 284, 6145, 41108, 3, 4, 0, 0, 0, 0, 314, 156, 157, 158, 0, 0, 0, 0, 0, 348160, 348160, 348160, 0,
  0, 0, 0, 0, 0, 0, 0, 214, 214, 214, 561, 214, 214, 214, 214, 0, 331, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 340, 0, 0, 0, 0, 0,
  157, 0, 0, 0, 157, 157, 157, 157, 157, 0, 157, 0, 194, 0, 0, 0, 349, 0, 0, 0, 0, 0, 0, 0, 0, 0, 314, 158, 410, 158,
  158, 158, 158, 433, 436, 158, 0, 283, 283, 464, 283, 283, 283, 283, 283, 283, 283, 1119, 283, 283, 283, 283, 283, 0,
  0, 0, 0, 1057, 0, 1059, 0, 0, 0, 0, 0, 0, 0, 336, 0, 0, 0, 0, 0, 0, 0, 0, 0, 332, 0, 158, 158, 158, 158, 158, 410,
  158, 158, 283, 283, 0, 464, 0, 0, 0, 0, 514, 518, 0, 521, 0, 0, 0, 1188, 214, 214, 214, 214, 214, 0, 158, 158, 158,
  158, 158, 158, 158, 158, 283, 283, 283, 283, 283, 283, 283, 283, 283, 677, 283, 283, 283, 283, 283, 283, 283, 283, 0,
  0, 0, 158, 283, 283, 0, 691, 847, 0, 0, 0, 0, 697, 849, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 863, 0, 0, 710, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 166, 214, 734, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
  214, 214, 744, 214, 746, 214, 214, 0, 0, 0, 0, 0, 0, 0, 754, 0, 0, 158, 158, 1332, 1333, 158, 158, 158, 158, 283, 283,
  283, 1338, 1339, 283, 283, 889, 0, 891, 891, 158, 158, 158, 894, 158, 896, 897, 158, 158, 158, 158, 158, 158, 158,
  158, 1159, 158, 158, 283, 283, 283, 283, 283, 283, 283, 283, 283, 0, 1295, 158, 158, 158, 158, 1052, 283, 283, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 851, 283, 283, 283, 1168, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 1178,
  283, 158, 158, 158, 158, 1346, 158, 283, 283, 283, 283, 1352, 283, 158, 158, 158, 158, 158, 158, 283, 283, 283, 283,
  283, 283, 158, 1354, 158, 745, 214, 214, 214, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 158, 158, 158, 158, 158, 598, 158, 158,
  158, 283, 283, 283, 283, 836, 283, 283, 283, 283, 283, 283, 283, 283, 0, 0, 158, 1331, 158, 158, 158, 158, 158, 158,
  283, 1337, 283, 283, 283, 283, 283, 283, 283, 283, 840, 283, 283, 283, 283, 0, 0, 158, 283, 283, 1026, 1027, 283, 283,
  283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 0, 965, 847, 0, 158, 158, 1302, 158, 283, 283, 283, 283, 1308, 1309,
  283, 1311, 283, 0, 158, 158, 158, 158, 158, 158, 921, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 798, 158, 158,
  158, 51839, 283, 6145, 41108, 3, 4, 0, 0, 0, 0, 0, 0, 0, 155, 158, 0, 0, 0, 0, 0, 158, 0, 0, 0, 0, 0, 168, 0, 0, 0, 0,
  0, 0, 173, 158, 0, 158, 0, 155, 0, 0, 0, 0, 158, 0, 0, 0, 0, 187, 0, 0, 0, 0, 0, 0, 0, 86016, 0, 0, 86016, 0, 0, 0, 0,
  0, 0, 0, 108544, 0, 0, 0, 0, 0, 0, 108544, 108544, 0, 187, 0, 0, 187, 26624, 28672, 187, 0, 0, 0, 0, 24576, 208, 208,
  216, 208, 208, 208, 208, 208, 208, 208, 248, 248, 249, 249, 208, 249, 253, 208, 249, 249, 249, 249, 249, 216, 249,
  253, 274, 274, 285, 274, 274, 274, 274, 285, 274, 274, 274, 305, 274, 285, 285, 311, 311, 311, 311, 311, 274, 311,
  6145, 41108, 3, 4, 0, 0, 0, 0, 0, 156, 157, 158, 0, 0, 0, 0, 0, 352256, 352256, 352256, 352256, 352256, 352256,
  352256, 352256, 352256, 352256, 0, 0, 0, 0, 0, 0, 0, 0, 214, 567, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
  214, 214, 214, 214, 743, 214, 585, 0, 0, 0, 0, 0, 0, 591, 593, 158, 158, 158, 597, 158, 601, 158, 158, 158, 158, 158,
  920, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 1163, 283, 283, 283, 283, 158, 158, 158, 605, 158, 158,
  158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 1021, 158, 158, 630, 158, 158, 158, 158, 158, 158, 158, 158,
  158, 51839, 521, 640, 642, 283, 283, 283, 283, 283, 283, 1171, 283, 1173, 283, 283, 283, 283, 1177, 1179, 283, 283,
  283, 648, 283, 652, 283, 283, 283, 283, 657, 283, 283, 283, 283, 283, 283, 0, 1188, 158, 158, 158, 158, 1280, 158,
  158, 158, 724, 0, 0, 0, 0, 0, 727, 0, 0, 0, 0, 0, 0, 214, 214, 214, 214, 369, 214, 214, 214, 214, 214, 214, 214, 214,
  735, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 0, 0, 0, 0, 1139, 0, 0, 158, 158, 158, 158, 158,
  158, 158, 158, 158, 158, 1151, 158, 158, 158, 158, 158, 158, 1001, 158, 1003, 158, 158, 158, 158, 1008, 158, 158, 158,
  158, 158, 158, 1082, 158, 158, 158, 158, 158, 158, 158, 1087, 158, 1300, 158, 158, 158, 283, 283, 283, 1307, 283, 283,
  283, 283, 283, 0, 158, 158, 158, 158, 158, 158, 1208, 158, 158, 158, 283, 283, 283, 283, 1215, 1216, 1365, 158, 158,
  283, 283, 158, 283, 158, 283, 158, 283, 158, 283, 0, 0, 0, 0, 0, 158, 0, 0, 0, 0, 0, 188, 0, 0, 0, 0, 0, 0, 214, 0,
  268, 268, 268, 300, 268, 268, 268, 268, 268, 300, 300, 300, 300, 300, 300, 300, 268, 300, 180, 0, 0, 0, 0, 158, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 173, 0, 0, 0, 65536, 240, 240, 240, 240, 240, 240, 217, 240, 254, 275, 275, 286, 275, 275,
  275, 275, 286, 275, 275, 275, 254, 275, 286, 286, 286, 286, 286, 286, 286, 275, 286, 6145, 41108, 3, 4, 0, 0, 0, 0, 0,
  156, 157, 158, 0, 0, 0, 0, 0, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 158, 158, 413, 158, 158, 398, 0, 0, 0, 398, 398, 0, 0, 0, 0, 398, 158, 158, 158, 158,
  158, 158, 158, 158, 1210, 158, 283, 283, 283, 283, 283, 283, 283, 283, 283, 0, 158, 158, 1297, 1298, 158, 158, 424,
  158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 0, 0, 283, 283, 283, 283, 158, 158, 158, 158, 424, 158,
  158, 158, 158, 0, 283, 283, 283, 283, 283, 283, 283, 283, 283, 501, 283, 283, 283, 283, 0, 0, 283, 478, 283, 283, 283,
  283, 283, 283, 283, 283, 283, 283, 283, 283, 507, 0, 0, 0, 1188, 214, 214, 214, 214, 214, 0, 158, 158, 158, 1234, 158,
  158, 158, 158, 158, 793, 158, 158, 158, 158, 158, 158, 158, 158, 51839, 283, 158, 158, 158, 231902, 283, 0, 283, 0, 0,
  0, 0, 0, 0, 0, 521, 0, 0, 0, 1188, 214, 214, 214, 214, 214, 0, 1233, 158, 158, 158, 158, 158, 158, 158, 908, 158, 158,
  158, 158, 158, 158, 158, 914, 158, 158, 917, 918, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158,
  1098, 158, 283, 0, 975, 0, 0, 0, 978, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 573, 214, 574, 214, 214, 214,
  283, 1025, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 0, 0, 0, 0, 283, 1115, 283, 283, 283,
  283, 283, 283, 283, 283, 283, 283, 283, 0, 0, 0, 158, 283, 283, 0, 158, 1204, 158, 158, 158, 158, 158, 158, 158, 158,
  283, 283, 283, 283, 283, 283, 283, 283, 283, 0, 158, 158, 158, 158, 158, 158, 283, 283, 1287, 283, 283, 283, 283, 283,
  283, 0, 158, 158, 158, 158, 158, 158, 158, 158, 1241, 158, 158, 283, 283, 283, 283, 1245, 0, 195, 0, 0, 195, 26624,
  28672, 195, 0, 0, 0, 0, 24576, 210, 210, 218, 234, 218, 234, 234, 234, 234, 244, 244, 244, 244, 244, 244, 244, 244,
  244, 255, 244, 244, 244, 244, 244, 244, 218, 244, 255, 276, 276, 287, 276, 276, 276, 276, 287, 276, 276, 276, 306,
  276, 287, 287, 287, 287, 287, 287, 287, 276, 287, 6145, 41108, 3, 4, 0, 0, 0, 0, 0, 156, 157, 158, 0, 0, 0, 0, 0,
  778240, 0, 0, 0, 536576, 0, 0, 0, 0, 0, 0, 0, 173, 173, 526, 0, 0, 0, 0, 0, 0, 0, 323, 0, 0, 0, 0, 173, 173, 173, 0,
  344, 194, 0, 0, 0, 0, 0, 0, 0, 0, 353, 0, 355, 0, 0, 0, 0, 0, 158, 0, 0, 0, 185, 0, 0, 0, 0, 0, 0, 0, 537, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 325, 0, 0, 173, 173, 173, 0, 214, 382, 214, 214, 214, 214, 0, 0, 0, 0, 390, 0, 393, 395, 0, 358, 0, 0,
  0, 0, 214, 214, 214, 365, 214, 214, 372, 214, 377, 214, 380, 422, 158, 428, 158, 431, 158, 158, 435, 437, 158, 158,
  158, 158, 158, 393, 0, 0, 0, 18432, 0, 0, 0, 745472, 784384, 0, 0, 0, 671744, 671744, 561152, 561152, 0, 768000,
  692224, 667648, 563200, 692224, 563200, 563200, 563200, 718848, 563200, 768000, 563200, 563200, 0, 0, 0, 751616, 0, 0,
  0, 0, 1188, 561152, 692224, 561152, 561152, 768000, 158, 158, 413, 158, 158, 431, 158, 437, 457, 0, 283, 283, 283,
  467, 283, 283, 283, 283, 283, 283, 1275, 1188, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 51839, 521, 283, 283,
  643, 283, 476, 283, 484, 283, 487, 283, 283, 492, 495, 498, 283, 283, 283, 283, 0, 0, 0, 0, 0, 1185, 0, 1187, 0, 214,
  214, 1190, 1191, 214, 158, 158, 457, 283, 510, 0, 283, 0, 0, 0, 0, 0, 0, 0, 521, 0, 0, 0, 65536, 0, 65536, 0, 0, 0,
  65536, 65536, 65536, 65536, 65536, 0, 65536, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 156, 157, 563200, 0, 0, 0, 0, 0, 524, 0,
  173, 173, 0, 527, 0, 0, 0, 0, 0, 0, 0, 352256, 0, 0, 0, 0, 0, 0, 352256, 0, 26624, 28672, 0, 0, 352256, 0, 352256,
  24576, 0, 0, 0, 531, 0, 0, 0, 0, 0, 344, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 339, 0, 0, 0, 0, 0, 214, 578, 214, 580, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 563200, 0, 0, 158, 158, 604, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158,
  158, 158, 0, 158, 158, 158, 616, 158, 158, 158, 158, 158, 158, 622, 158, 158, 626, 158, 0, 158, 158, 158, 158, 158,
  158, 1239, 158, 158, 158, 158, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 939, 283, 283, 283, 158, 631,
  158, 158, 633, 158, 616, 158, 158, 158, 51839, 521, 283, 283, 283, 283, 283, 283, 283, 283, 960, 961, 283, 283, 0, 0,
  847, 0, 0, 0, 0, 0, 849, 0, 0, 0, 0, 0, 0, 0, 0, 0, 971, 0, 0, 0, 863, 0, 283, 283, 664, 283, 283, 283, 283, 283, 283,
  283, 670, 283, 283, 283, 283, 283, 283, 283, 283, 494, 283, 283, 283, 283, 283, 506, 0, 283, 283, 283, 679, 283, 283,
  283, 684, 283, 0, 687, 0, 158, 283, 283, 690, 724, 0, 0, 0, 0, 726, 0, 0, 0, 0, 0, 0, 0, 214, 730, 731, 758, 759, 158,
  158, 158, 158, 158, 158, 158, 767, 158, 158, 770, 158, 158, 158, 158, 158, 158, 433, 158, 436, 158, 158, 443, 158,
  158, 340, 331, 158, 158, 775, 158, 158, 777, 778, 158, 158, 158, 158, 783, 158, 158, 158, 158, 158, 158, 158, 1083,
  158, 158, 158, 158, 158, 158, 158, 158, 158, 623, 158, 158, 158, 0, 158, 158, 158, 158, 790, 158, 158, 158, 158, 158,
  158, 797, 158, 799, 158, 801, 51839, 802, 283, 803, 283, 805, 283, 283, 283, 283, 283, 283, 283, 283, 283, 815, 283,
  283, 283, 283, 283, 489, 491, 283, 283, 500, 283, 283, 283, 283, 0, 0, 0, 0, 0, 778240, 0, 0, 0, 536576, 0, 0, 0, 0,
  0, 34816, 818, 283, 283, 283, 283, 283, 823, 283, 283, 283, 826, 827, 828, 283, 283, 283, 283, 283, 283, 490, 283,
  493, 283, 283, 503, 283, 283, 0, 0, 0, 0, 0, 0, 1186, 0, 0, 1189, 214, 214, 214, 214, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  583, 0, 283, 833, 283, 835, 283, 283, 283, 839, 283, 283, 283, 283, 844, 0, 0, 158, 158, 158, 158, 158, 1014, 158,
  158, 158, 158, 158, 158, 158, 158, 1022, 158, 158, 158, 158, 158, 906, 158, 158, 158, 158, 158, 158, 158, 158, 158,
  158, 158, 1085, 158, 158, 158, 158, 158, 158, 158, 158, 919, 158, 158, 922, 158, 924, 158, 158, 158, 926, 158, 158,
  158, 158, 158, 158, 1262, 158, 158, 158, 158, 283, 283, 283, 283, 1269, 849, 0, 0, 0, 0, 0, 0, 969, 0, 0, 0, 0, 0,
  974, 863, 0, 0, 0, 96452, 0, 26624, 28672, 0, 0, 96452, 0, 96452, 24576, 0, 0, 0, 0, 0, 0, 534528, 537, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 131072, 0, 0, 131072, 0, 0, 214, 988, 214, 214, 214, 0, 0, 0, 0, 0, 0, 158, 158, 158, 158, 158, 158,
  158, 158, 158, 900, 158, 158, 158, 158, 158, 1000, 158, 158, 158, 158, 158, 158, 158, 1006, 1007, 158, 158, 158, 158,
  158, 158, 455, 158, 441, 0, 283, 283, 283, 283, 283, 283, 283, 283, 283, 1047, 283, 283, 283, 283, 283, 283, 283, 283,
  283, 825, 283, 283, 283, 283, 283, 831, 158, 1012, 158, 158, 1013, 158, 158, 158, 158, 158, 1018, 158, 158, 158, 158,
  158, 158, 158, 456, 158, 0, 283, 283, 283, 283, 283, 283, 0, 1188, 158, 158, 158, 158, 158, 1281, 158, 158, 283, 283,
  283, 1041, 1042, 283, 283, 283, 283, 283, 283, 1049, 283, 283, 283, 1051, 283, 283, 283, 1054, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 173, 173, 173, 0, 158, 158, 158, 158, 1080, 158, 158, 158, 158, 158, 158, 158, 1086, 158, 158, 158, 158,
  158, 158, 621, 158, 158, 158, 158, 158, 158, 536, 158, 158, 0, 1140, 1141, 158, 158, 1144, 158, 158, 158, 158, 158,
  158, 1150, 158, 158, 158, 158, 158, 158, 635, 158, 158, 158, 51839, 521, 283, 283, 283, 283, 283, 283, 283, 283, 1252,
  283, 283, 283, 0, 0, 1188, 214, 1153, 1154, 1155, 158, 158, 158, 158, 1158, 158, 1161, 158, 283, 283, 283, 1166, 283,
  158, 158, 283, 283, 158, 283, 158, 283, 158, 283, 158, 283, 0, 0, 0, 0, 848, 0, 515, 0, 0, 0, 850, 0, 519, 0, 0, 1181,
  1182, 0, 0, 0, 0, 0, 0, 0, 0, 0, 214, 214, 214, 214, 214, 214, 214, 566, 158, 158, 158, 1205, 158, 158, 158, 158, 158,
  158, 283, 283, 1214, 283, 283, 283, 283, 283, 283, 655, 283, 283, 283, 283, 283, 283, 283, 283, 661, 1284, 283, 283,
  283, 283, 283, 283, 283, 283, 1293, 0, 158, 158, 158, 158, 1299, 158, 158, 158, 1318, 158, 158, 158, 1322, 283, 283,
  1324, 283, 283, 283, 283, 283, 283, 283, 283, 685, 686, 0, 0, 158, 283, 283, 0, 204, 204, 204, 204, 204, 204, 219,
  204, 256, 256, 256, 288, 256, 256, 256, 256, 256, 288, 288, 288, 288, 288, 288, 288, 256, 288, 256, 288, 6145, 41108,
  3, 4, 0, 0, 0, 0, 0, 156, 157, 158, 0, 0, 0, 0, 162, 162, 0, 0, 162, 162, 69794, 162, 162, 162, 162, 162, 162, 162,
  162, 162, 162, 162, 174, 162, 162, 162, 162, 158, 158, 158, 158, 452, 158, 158, 158, 158, 0, 283, 283, 283, 283, 283,
  283, 283, 283, 283, 669, 283, 283, 283, 283, 283, 283, 283, 283, 283, 812, 283, 283, 283, 283, 283, 283, 0, 1188, 158,
  158, 1278, 1279, 158, 158, 1282, 1283, 283, 479, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 0, 0,
  1188, 214, 158, 158, 158, 479, 283, 0, 283, 0, 0, 0, 0, 0, 0, 0, 521, 0, 0, 0, 106496, 0, 0, 0, 0, 0, 0, 0, 0, 173,
  173, 173, 0, 0, 0, 854, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 173, 173, 173, 330, 283, 283, 649, 283, 283, 283, 283,
  283, 283, 283, 283, 283, 283, 283, 283, 283, 0, 0, 158, 283, 283, 834, 283, 283, 283, 283, 283, 283, 283, 283, 283,
  283, 0, 846, 158, 158, 158, 158, 158, 1081, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 1244, 283, 283,
  283, 283, 849, 0, 0, 0, 0, 967, 0, 0, 0, 0, 0, 0, 0, 0, 863, 0, 0, 0, 563200, 563200, 563200, 563200, 706560, 708608,
  563200, 563200, 563200, 563200, 563200, 811008, 563200, 563200, 563200, 563200, 688128, 690176, 563200, 563200,
  563200, 563200, 563200, 563200, 563200, 563200, 724992, 563200, 563200, 563200, 563200, 563200, 856064, 0, 1256,
  563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 774144, 800768, 563200,
  563200, 845824, 987, 214, 214, 214, 214, 0, 0, 0, 0, 0, 0, 158, 158, 158, 158, 158, 158, 158, 158, 899, 158, 158, 158,
  1011, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 283, 283, 1342, 158, 158, 158,
  158, 158, 1348, 283, 283, 283, 283, 283, 158, 158, 158, 158, 158, 158, 283, 283, 283, 283, 283, 283, 158, 158, 158,
  158, 283, 283, 283, 0, 181, 0, 0, 0, 158, 0, 0, 0, 0, 0, 0, 181, 0, 0, 0, 0, 0, 158, 0, 0, 0, 186, 0, 0, 0, 190, 191,
  0, 235, 220, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 257, 289, 6145, 41108, 3, 4, 0, 0, 0, 0,
  0, 156, 157, 158, 0, 0, 0, 0, 164, 0, 0, 164, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 0, 0, 0, 214, 214, 214, 235, 235, 235,
  235, 235, 235, 220, 235, 257, 257, 257, 289, 257, 257, 257, 257, 257, 289, 289, 289, 289, 289, 289, 289, 257, 289, 0,
  194, 0, 0, 0, 350, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 173, 156, 156, 0, 0, 158, 158, 158, 283, 283, 0, 283, 0, 0, 0, 0,
  515, 519, 0, 521, 0, 0, 0, 563519, 563519, 563519, 563519, 706879, 708927, 563519, 563519, 563519, 563519, 563519,
  811327, 563519, 563519, 563519, 784703, 788799, 563519, 563519, 563519, 563519, 563519, 563519, 563519, 563519,
  563519, 563519, 563519, 563519, 563519, 563519, 0, 0, 283, 283, 283, 1220, 283, 283, 1222, 283, 283, 283, 283, 283,
  283, 283, 0, 0, 0, 0, 1184, 0, 0, 0, 0, 214, 214, 214, 214, 214, 214, 1070, 214, 214, 214, 214, 0, 0, 1074, 0, 0, 0,
  1230, 1188, 214, 214, 1232, 214, 214, 0, 158, 158, 158, 158, 1235, 158, 158, 158, 158, 158, 1091, 158, 158, 1093, 158,
  1095, 158, 158, 158, 158, 283, 283, 1306, 283, 283, 283, 283, 283, 283, 0, 1314, 158, 1246, 283, 283, 283, 283, 283,
  1251, 283, 283, 283, 283, 283, 0, 0, 1188, 214, 214, 0, 0, 0, 1195, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158,
  158, 283, 1164, 283, 283, 283, 1356, 158, 158, 283, 283, 1359, 1360, 283, 283, 158, 158, 158, 158, 283, 283, 283, 283,
  283, 283, 283, 283, 283, 937, 283, 283, 283, 283, 283, 283, 283, 283, 948, 283, 283, 283, 283, 283, 283, 283, 283,
  283, 283, 1111, 283, 283, 283, 283, 283, 158, 411, 158, 158, 158, 158, 158, 158, 158, 0, 283, 283, 465, 283, 283, 283,
  283, 283, 283, 683, 283, 283, 0, 0, 0, 596, 283, 646, 0, 411, 158, 158, 283, 283, 0, 465, 0, 0, 0, 0, 0, 0, 0, 521, 0,
  0, 0, 690176, 563200, 563200, 688128, 690176, 563200, 563200, 563200, 563200, 563200, 563200, 724992, 563200, 563200,
  563200, 563200, 563200, 856064, 0, 1188, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200, 563200,
  563200, 563200, 563200, 563200, 563200, 0, 563200, 563200, 0, 532, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 214, 214,
  214, 236, 221, 236, 236, 241, 241, 245, 246, 246, 246, 246, 246, 246, 251, 246, 258, 251, 246, 246, 246, 246, 246,
  221, 246, 258, 277, 277, 290, 277, 277, 277, 277, 290, 277, 277, 277, 258, 277, 290, 308, 290, 290, 290, 290, 290,
  277, 290, 6145, 41108, 3, 4, 0, 0, 0, 0, 0, 156, 157, 158, 0, 0, 0, 0, 183, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 192, 158,
  158, 414, 158, 158, 158, 158, 158, 158, 0, 283, 283, 283, 468, 283, 283, 283, 283, 283, 653, 283, 283, 656, 283, 283,
  283, 283, 283, 283, 283, 283, 283, 283, 1048, 283, 283, 283, 283, 283, 214, 214, 579, 214, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  582, 0, 584, 645, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 660, 283, 283, 283, 283, 283, 666, 283,
  667, 668, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 1033, 283, 283, 283, 283, 283, 788, 158, 158, 158, 158,
  158, 158, 158, 158, 158, 158, 158, 158, 158, 51839, 283, 158, 158, 283, 283, 158, 283, 158, 283, 1372, 1373, 158, 283,
  0, 0, 0, 0, 0, 169, 170, 0, 0, 0, 0, 173, 158, 0, 158, 0, 832, 283, 283, 283, 283, 283, 283, 283, 283, 283, 842, 283,
  283, 0, 0, 158, 158, 158, 158, 158, 1207, 158, 158, 158, 158, 283, 283, 283, 283, 283, 283, 283, 283, 283, 0, 158,
  1315, 158, 283, 283, 931, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 829, 830, 283, 0, 1065,
  214, 1067, 214, 214, 214, 214, 214, 214, 1072, 214, 0, 0, 0, 0, 0, 0, 214, 0, 270, 270, 270, 302, 270, 270, 270, 270,
  270, 302, 302, 302, 302, 302, 302, 302, 270, 302, 158, 1077, 158, 1079, 158, 158, 158, 158, 158, 1084, 158, 158, 158,
  158, 158, 158, 158, 158, 923, 158, 158, 158, 158, 158, 927, 158, 1088, 158, 1089, 158, 158, 158, 158, 158, 158, 158,
  158, 158, 158, 158, 1099, 283, 158, 158, 283, 283, 158, 283, 1370, 1371, 158, 283, 158, 283, 0, 0, 0, 0, 0, 198, 198,
  0, 0, 0, 0, 0, 198, 0, 0, 0, 0, 0, 0, 534528, 0, 0, 194, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86016, 0, 0, 0,
  1101, 283, 283, 1104, 283, 283, 283, 283, 283, 283, 283, 283, 1112, 283, 283, 283, 283, 283, 283, 809, 283, 283, 283,
  283, 283, 814, 283, 283, 283, 283, 283, 283, 838, 283, 283, 283, 283, 283, 283, 0, 0, 158, 283, 283, 283, 1116, 283,
  283, 1118, 283, 283, 1120, 283, 283, 283, 0, 0, 0, 1056, 0, 0, 0, 0, 1061, 0, 0, 1062, 0, 283, 283, 283, 1169, 283,
  283, 283, 283, 283, 283, 283, 283, 1176, 283, 283, 283, 283, 283, 283, 958, 283, 283, 283, 283, 283, 0, 0, 0, 695, 0,
  0, 0, 0, 0, 701, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 721, 158, 283, 283, 283, 283, 1289, 1290, 1291, 1292, 283, 0,
  158, 158, 158, 158, 158, 158, 158, 608, 158, 158, 158, 158, 158, 158, 158, 158, 158, 610, 158, 158, 158, 158, 158,
  158, 158, 283, 158, 158, 158, 158, 158, 283, 309, 283, 283, 283, 283, 283, 158, 283, 283, 283, 283, 932, 283, 934,
  283, 936, 283, 283, 283, 283, 283, 283, 0, 1188, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 1005, 158, 158,
  158, 158, 158, 0, 182, 0, 0, 0, 158, 0, 0, 0, 0, 0, 0, 182, 189, 0, 0, 0, 0, 184, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 193,
  0, 0, 0, 193, 193, 193, 193, 193, 0, 193, 237, 222, 237, 237, 237, 237, 237, 237, 237, 237, 237, 237, 237, 237, 237,
  259, 291, 6145, 41108, 3, 4, 0, 0, 0, 0, 0, 156, 157, 158, 0, 0, 0, 0, 320, 0, 0, 0, 0, 0, 0, 0, 173, 173, 173, 0,
  237, 237, 237, 237, 237, 237, 222, 271, 259, 259, 259, 291, 259, 259, 259, 259, 259, 291, 291, 291, 291, 291, 291,
  291, 259, 291, 0, 322, 0, 0, 0, 214, 214, 214, 214, 367, 214, 214, 214, 214, 214, 214, 0, 0, 0, 0, 0, 992, 158, 158,
  995, 158, 158, 158, 158, 158, 450, 158, 158, 158, 158, 158, 0, 283, 283, 283, 283, 470, 283, 158, 158, 283, 283, 1368,
  1369, 158, 283, 158, 283, 158, 283, 0, 0, 0, 0, 0, 158, 171, 0, 0, 0, 171, 0, 0, 0, 171, 0, 0, 171, 26624, 28672, 171,
  171, 0, 171, 0, 24576, 171, 171, 226, 158, 450, 158, 283, 283, 0, 283, 0, 0, 0, 0, 515, 519, 0, 521, 0, 0, 0, 690176,
  563519, 563519, 688447, 690495, 563519, 563519, 563519, 563519, 563519, 563519, 725311, 563519, 563519, 563519,
  563519, 727359, 735551, 563519, 563519, 563519, 563519, 563519, 563519, 809279, 563519, 563519, 563519, 563519,
  563519, 563519, 563519, 563519, 563519, 563519, 563519, 774463, 801087, 563519, 563519, 846143, 158, 158, 158, 158,
  606, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 913, 158, 158, 158, 158, 158, 158, 158, 619, 158,
  158, 158, 158, 158, 625, 158, 158, 0, 158, 596, 283, 646, 283, 283, 283, 283, 283, 283, 283, 283, 658, 283, 283, 283,
  283, 283, 283, 283, 283, 811, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 962, 283, 0, 0, 847, 0, 733, 214, 214,
  214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 577, 158, 158, 761, 762, 763, 158, 158, 158,
  158, 158, 158, 158, 158, 771, 158, 158, 158, 158, 158, 158, 1321, 283, 283, 283, 283, 283, 283, 283, 283, 1329, 283,
  283, 283, 283, 807, 808, 283, 810, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 1122, 283, 0, 0, 0, 283,
  819, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 0, 1229, 283, 283, 283, 956, 283, 283, 283,
  283, 283, 283, 283, 283, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 156, 158, 998, 158, 158, 158, 158, 158, 158,
  158, 158, 158, 158, 158, 158, 158, 158, 0, 0, 0, 214, 1066, 214, 214, 214, 214, 214, 214, 214, 214, 214, 0, 0, 0,
  1075, 158, 158, 1078, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 445, 0, 0, 283, 283, 1103, 283,
  283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 0, 0, 1125, 1316, 1317, 158, 158, 158, 158, 158, 283, 283,
  283, 283, 1325, 1326, 283, 283, 283, 283, 283, 283, 1029, 283, 283, 1032, 283, 1034, 283, 283, 283, 283, 283, 283,
  283, 283, 1109, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 1254, 283, 0, 0, 1188, 214, 0, 1330, 158, 158, 158,
  158, 158, 158, 158, 1336, 283, 283, 283, 283, 283, 283, 283, 283, 283, 841, 283, 843, 283, 845, 0, 158, 158, 158, 158,
  283, 1358, 283, 283, 283, 283, 158, 158, 158, 158, 283, 283, 283, 283, 283, 283, 283, 935, 283, 283, 938, 283, 940,
  283, 283, 242, 242, 242, 242, 242, 242, 223, 242, 260, 260, 260, 292, 260, 260, 260, 260, 260, 292, 292, 292, 292,
  292, 292, 292, 260, 292, 260, 292, 6145, 41108, 3, 4, 0, 0, 0, 0, 0, 156, 157, 158, 0, 0, 0, 0, 334, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 96452, 0, 96452, 0, 0, 194, 347, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 214, 214, 732, 0, 347, 0, 0,
  0, 214, 214, 214, 214, 368, 214, 214, 214, 214, 214, 214, 0, 0, 990, 0, 0, 0, 158, 158, 158, 158, 158, 158, 158, 1148,
  158, 158, 158, 158, 158, 158, 425, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 0, 0, 0, 0, 352, 214,
  362, 214, 214, 214, 214, 214, 376, 214, 214, 214, 877, 214, 214, 214, 214, 214, 214, 214, 214, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 397, 158, 158, 158, 451, 425, 158, 158, 158, 158, 0, 283, 283, 283, 283, 471, 283, 158, 158, 1344, 1345, 158, 158,
  283, 283, 1350, 1351, 283, 283, 158, 158, 158, 158, 158, 158, 283, 283, 283, 283, 283, 283, 158, 158, 1355, 283, 480,
  283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 0, 0, 0, 158, 252187, 283, 0, 158, 417, 158, 480, 283, 0,
  283, 0, 0, 0, 0, 0, 0, 0, 521, 0, 0, 166, 0, 0, 0, 0, 0, 0, 0, 0, 173, 158, 0, 158, 0, 0, 0, 1188, 214, 214, 214, 214,
  214, 0, 158, 158, 158, 158, 158, 1236, 283, 647, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283,
  675, 283, 0, 693, 0, 0, 0, 699, 0, 0, 521, 0, 0, 0, 0, 0, 0, 0, 0, 352256, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 158, 158,
  158, 158, 792, 158, 794, 158, 796, 158, 158, 158, 158, 158, 51839, 283, 158, 1343, 158, 158, 158, 1347, 283, 1349,
  283, 283, 283, 1353, 158, 158, 158, 158, 158, 158, 765, 158, 158, 158, 158, 158, 158, 158, 158, 158, 0, 283, 283, 283,
  283, 283, 283, 955, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1063,
  283, 283, 283, 283, 1274, 283, 0, 1188, 158, 158, 158, 158, 158, 158, 158, 158, 158, 611, 158, 612, 158, 158, 158,
  158, 238, 224, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 261, 238, 238, 238, 238, 238, 238,
  224, 238, 261, 278, 278, 293, 278, 278, 278, 278, 293, 278, 278, 278, 261, 278, 293, 293, 293, 293, 293, 293, 293,
  278, 293, 6145, 41108, 3, 4, 0, 0, 0, 0, 0, 156, 157, 158, 0, 0, 0, 0, 360, 214, 361, 214, 214, 214, 214, 214, 375,
  214, 214, 214, 748, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 158, 158, 158, 158, 596, 158, 158, 158, 158, 158, 426, 158, 158,
  158, 158, 158, 158, 158, 158, 442, 158, 158, 158, 0, 0, 0, 0, 523, 0, 0, 173, 173, 0, 0, 0, 0, 0, 0, 0, 0, 131072, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 157, 408, 158, 158, 158, 426, 158, 158, 158, 158, 0, 283, 461, 283, 283,
  283, 283, 283, 283, 283, 283, 1031, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 1121, 283, 283, 0, 0, 0, 283,
  481, 283, 283, 283, 283, 283, 283, 283, 283, 502, 283, 283, 283, 0, 0, 1183, 0, 0, 0, 0, 0, 0, 214, 214, 214, 214,
  214, 0, 0, 0, 0, 0, 0, 0, 0, 581, 0, 0, 0, 158, 158, 158, 481, 283, 0, 283, 0, 0, 0, 0, 0, 0, 0, 521, 0, 0, 169, 170,
  0, 158, 0, 0, 0, 0, 0, 0, 0, 0, 170, 0, 0, 303, 0, 0, 0, 303, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 862, 0, 0, 0, 0, 158,
  916, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 1009, 158, 158, 283, 930, 283, 283, 283,
  283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 0, 0, 178334, 0, 0, 976, 0, 0, 214, 214, 214, 214, 982, 214, 214,
  984, 214, 214, 986, 158, 158, 999, 158, 158, 158, 158, 158, 158, 1004, 158, 158, 158, 158, 158, 1010, 283, 1039, 283,
  283, 283, 283, 283, 283, 1046, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 1226, 283, 283, 283, 0, 0, 1217, 283,
  283, 283, 283, 283, 283, 1223, 283, 283, 283, 283, 283, 283, 0, 0, 0, 0, 535, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  110799, 0, 0, 0, 283, 1247, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 0, 0, 1188, 214, 214, 383, 214, 214,
  214, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 173, 0, 0, 0, 0, 158, 283, 283, 283, 1288, 283, 283, 283, 283, 283, 1294, 158,
  158, 158, 158, 158, 158, 158, 795, 158, 158, 158, 158, 800, 158, 51839, 283, 158, 1301, 158, 1303, 283, 283, 283, 283,
  283, 283, 1310, 283, 1312, 0, 158, 158, 158, 158, 158, 432, 434, 158, 158, 441, 158, 158, 158, 158, 0, 0, 0, 0, 548,
  0, 0, 0, 0, 214, 214, 214, 214, 214, 214, 214, 1071, 214, 214, 214, 0, 1073, 0, 0, 211, 211, 211, 211, 211, 211, 225,
  211, 262, 262, 262, 294, 262, 262, 262, 262, 262, 294, 294, 294, 294, 294, 294, 294, 262, 294, 262, 294, 6145, 41108,
  3, 4, 0, 0, 0, 0, 0, 156, 157, 158, 0, 0, 0, 0, 555, 0, 0, 0, 214, 214, 214, 214, 214, 214, 214, 214, 739, 214, 214,
  214, 214, 214, 214, 214, 0, 194, 0, 0, 0, 0, 0, 0, 0, 0, 0, 354, 0, 0, 0, 339, 0, 399, 0, 0, 0, 0, 396, 339, 339, 0,
  0, 158, 412, 415, 158, 421, 158, 158, 158, 430, 158, 158, 158, 158, 438, 440, 158, 158, 158, 158, 0, 0, 0, 0, 556, 0,
  806912, 0, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 0, 116736, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  65536, 0, 0, 0, 0, 0, 0, 0, 0, 65536, 158, 448, 449, 158, 158, 454, 158, 438, 440, 0, 283, 283, 466, 469, 283, 475,
  283, 283, 283, 486, 488, 283, 283, 283, 496, 499, 283, 283, 283, 283, 0, 0, 0, 0, 714, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 717, 863, 0, 0, 509, 158, 440, 283, 283, 0, 511, 0, 0, 0, 0, 0, 0, 0, 521, 0, 0, 332, 0, 0, 0, 0, 0, 0, 0, 0,
  332, 0, 341, 342, 0, 0, 359, 0, 0, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 0, 0, 0, 0, 214, 214, 747,
  214, 0, 0, 0, 750, 0, 0, 0, 0, 0, 0, 158, 158, 158, 158, 895, 158, 158, 158, 158, 158, 158, 158, 158, 158, 1211, 283,
  283, 283, 283, 283, 283, 773, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 786, 158, 158, 158,
  158, 158, 1238, 158, 158, 158, 158, 158, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283,
  283, 676, 283, 283, 283, 283, 821, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 504, 283, 0, 0, 158,
  158, 904, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 613, 158, 614, 283, 283, 944, 283, 283,
  283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 0, 1124, 0, 1076, 158, 158, 158, 158, 158, 158, 158, 158, 158,
  158, 158, 158, 158, 158, 158, 772, 158, 283, 1286, 283, 283, 283, 283, 283, 283, 283, 0, 158, 158, 158, 158, 158, 158,
  158, 1002, 158, 158, 158, 158, 158, 158, 158, 158, 158, 910, 158, 158, 158, 158, 158, 158, 0, 214, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 263, 279, 295, 6145, 41108, 3, 4, 0, 0, 0, 0, 0, 156, 157, 158, 0, 0, 0, 0, 855, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 567624, 567624, 173, 0, 603, 158, 158, 158, 158, 158, 158, 158, 609, 158, 158, 158, 158, 158,
  158, 158, 158, 158, 1242, 158, 283, 283, 283, 283, 283, 158, 158, 632, 158, 158, 158, 158, 158, 158, 638, 51839, 521,
  283, 283, 283, 283, 283, 283, 283, 824, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 1227, 283, 283, 0, 0,
  0, 694, 0, 0, 0, 700, 0, 0, 521, 0, 0, 0, 0, 0, 0, 0, 0, 563200, 0, 0, 0, 0, 0, 0, 0, 0, 324, 0, 0, 0, 173, 173, 173,
  0, 0, 548, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 214, 214, 214, 214, 214, 564, 214, 214, 214, 876, 214, 214, 214, 214, 214,
  214, 214, 214, 214, 214, 0, 0, 887, 0, 0, 533, 0, 0, 0, 0, 0, 541, 0, 0, 0, 0, 0, 0, 0, 0, 141312, 0, 0, 0, 0, 0, 0,
  0, 0, 96452, 0, 96452, 96452, 96452, 96452, 96452, 96452, 96452, 0, 0, 0, 0, 0, 0, 160, 0, 158, 903, 158, 158, 158,
  158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 51839, 283, 283, 943, 283, 283, 283, 283, 283, 283, 283, 283,
  283, 283, 283, 283, 283, 283, 1113, 283, 0, 194, 0, 0, 0, 351, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 175, 0, 0, 0, 0, 158,
  158, 158, 418, 158, 158, 158, 158, 158, 0, 283, 283, 283, 283, 472, 283, 283, 283, 283, 283, 822, 283, 283, 283, 283,
  283, 283, 283, 283, 283, 283, 283, 283, 1228, 283, 0, 0, 158, 418, 158, 283, 283, 0, 283, 0, 0, 0, 0, 516, 520, 0,
  521, 0, 0, 553, 0, 0, 0, 0, 0, 214, 214, 214, 214, 214, 214, 214, 214, 985, 214, 214, 283, 283, 1219, 283, 283, 283,
  283, 283, 283, 283, 283, 283, 283, 283, 0, 0, 0, 629, 283, 647, 0, 171, 0, 0, 0, 0, 0, 0, 0, 0, 171, 0, 0, 0, 0, 0, 0,
  0, 716, 0, 0, 0, 0, 0, 0, 0, 0, 172, 0, 0, 173, 158, 0, 158, 0, 171, 226, 171, 171, 171, 171, 171, 171, 171, 171, 171,
  171, 171, 171, 171, 264, 296, 6145, 41108, 3, 4, 0, 0, 0, 0, 0, 156, 157, 158, 0, 0, 0, 0, 892, 158, 158, 158, 158,
  158, 158, 158, 158, 158, 158, 158, 283, 283, 283, 283, 283, 283, 171, 171, 171, 171, 171, 171, 226, 171, 264, 264,
  264, 296, 264, 264, 264, 264, 264, 296, 296, 296, 296, 296, 296, 296, 264, 296, 381, 214, 214, 386, 214, 214, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 320, 0, 0, 0, 0, 158, 158, 441, 283, 283, 0, 283, 0, 0, 0, 0, 0, 0, 0, 521, 0, 0, 587, 0, 589,
  590, 587, 158, 158, 594, 158, 158, 599, 158, 158, 602, 158, 158, 158, 158, 158, 158, 158, 158, 51839, 521, 283, 283,
  283, 644, 0, 552, 0, 0, 0, 0, 0, 0, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 158, 158, 158, 158, 607,
  158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 1020, 158, 158, 158, 615, 158, 158, 158, 158, 158, 158,
  158, 158, 158, 158, 158, 158, 535, 158, 158, 158, 158, 158, 620, 158, 158, 158, 158, 158, 158, 158, 0, 158, 629, 158,
  789, 158, 791, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 51839, 283, 283, 283, 283, 283, 837, 283, 283, 283,
  283, 283, 283, 283, 0, 0, 158, 158, 158, 158, 158, 1261, 158, 158, 158, 158, 158, 283, 283, 283, 1268, 283, 158, 1366,
  283, 1367, 158, 283, 158, 283, 158, 283, 158, 283, 0, 0, 0, 0, 0, 214, 214, 214, 366, 214, 214, 214, 214, 214, 214,
  214, 570, 214, 214, 214, 214, 214, 214, 214, 214, 214, 571, 214, 572, 214, 214, 214, 214, 575, 576, 214, 283, 283,
  804, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 817, 852, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 194, 158, 158, 158, 158, 905, 158, 907, 158, 909, 158, 158, 912, 158, 158, 158, 158, 158, 158, 158, 1209, 158, 158,
  283, 283, 283, 283, 283, 283, 283, 283, 283, 0, 158, 1296, 158, 158, 158, 283, 283, 283, 283, 945, 283, 947, 283, 283,
  283, 949, 283, 283, 283, 953, 283, 283, 283, 283, 283, 946, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283,
  283, 951, 952, 283, 283, 997, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 787, 158,
  158, 158, 158, 1090, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 283, 1213, 283, 283, 283, 283, 1257, 158, 158,
  158, 158, 158, 158, 158, 1264, 158, 158, 1266, 283, 283, 283, 283, 283, 283, 283, 959, 283, 283, 283, 283, 0, 0, 0, 0,
  0, 0, 0, 1060, 0, 0, 0, 0, 0, 283, 283, 283, 1273, 283, 283, 0, 1188, 158, 158, 158, 158, 158, 158, 158, 158, 158,
  624, 158, 158, 158, 0, 158, 158, 212, 212, 212, 212, 212, 212, 227, 272, 265, 280, 280, 297, 280, 280, 280, 280, 297,
  280, 280, 280, 265, 280, 297, 297, 297, 297, 297, 297, 297, 280, 297, 6145, 41108, 3, 4, 0, 0, 0, 0, 0, 156, 157, 158,
  0, 0, 0, 0, 977, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 885, 0, 0, 0, 0, 0, 194, 0, 0, 0, 0, 0, 0, 0,
  352, 0, 0, 0, 0, 0, 0, 0, 1131, 214, 214, 214, 214, 214, 214, 214, 214, 882, 214, 214, 214, 0, 0, 0, 0, 392, 0, 0, 0,
  392, 392, 0, 0, 0, 352, 392, 409, 158, 158, 158, 158, 158, 158, 158, 1240, 158, 158, 158, 283, 283, 283, 283, 283,
  283, 1362, 158, 158, 158, 1364, 283, 283, 158, 427, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 0, 0,
  0, 0, 1128, 0, 0, 0, 214, 214, 1134, 214, 214, 214, 214, 214, 569, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
  884, 214, 0, 886, 0, 0, 409, 158, 158, 158, 427, 158, 158, 158, 158, 0, 283, 462, 283, 283, 283, 283, 283, 283, 283,
  1030, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 659, 283, 283, 283, 283, 283, 283, 482, 283, 283, 283, 283,
  283, 283, 283, 283, 283, 283, 283, 283, 0, 0, 555, 158, 283, 283, 0, 158, 158, 158, 482, 283, 0, 283, 0, 0, 512, 0, 0,
  0, 0, 521, 0, 0, 695, 0, 0, 0, 701, 0, 521, 0, 0, 0, 0, 0, 0, 0, 173, 173, 0, 0, 0, 0, 0, 530, 0, 0, 522, 0, 0, 0, 0,
  0, 173, 173, 0, 0, 0, 0, 0, 0, 0, 171, 0, 0, 0, 173, 158, 0, 158, 0, 551, 0, 0, 0, 0, 551, 0, 0, 214, 214, 560, 214,
  563, 214, 565, 214, 214, 384, 214, 214, 214, 0, 0, 0, 0, 391, 0, 394, 0, 0, 0, 0, 0, 214, 214, 214, 214, 370, 214,
  214, 214, 214, 214, 214, 0, 749, 0, 0, 0, 0, 0, 0, 0, 0, 158, 158, 158, 595, 158, 158, 158, 158, 158, 283, 283, 650,
  283, 283, 654, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 1035, 283, 283, 283, 662, 283, 283, 283,
  283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 954, 0, 711, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  303, 0, 0, 928, 929, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 505, 0, 0, 283, 283, 1040,
  283, 283, 283, 283, 1045, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 671, 283, 283, 283, 283, 283, 283, 283,
  283, 283, 1117, 283, 283, 283, 283, 283, 283, 283, 283, 0, 0, 0, 0, 0, 0, 0, 0, 0, 214, 214, 214, 214, 214, 214, 214,
  214, 214, 1193, 0, 0, 0, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 283, 283, 283, 283, 1167, 1203, 158,
  158, 158, 158, 158, 158, 158, 158, 158, 283, 283, 283, 283, 283, 283, 283, 283, 283, 1313, 158, 158, 158, 158, 158,
  1259, 1260, 158, 158, 158, 158, 158, 158, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 941,
  1270, 1271, 283, 283, 283, 283, 0, 1188, 158, 158, 158, 158, 158, 158, 158, 158, 158, 781, 158, 158, 158, 158, 158,
  158, 158, 158, 158, 158, 1304, 283, 283, 283, 283, 283, 283, 283, 283, 0, 158, 158, 158, 158, 158, 764, 158, 158, 158,
  158, 158, 158, 158, 158, 158, 158, 158, 769, 158, 158, 158, 158, 158, 158, 158, 158, 1319, 158, 158, 283, 283, 283,
  283, 283, 283, 1327, 283, 283, 283, 283, 283, 681, 283, 283, 283, 0, 0, 0, 158, 283, 283, 0, 0, 176, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 548, 0, 0, 239, 247, 247, 247, 247, 247, 228, 247, 266, 281, 281, 298, 281, 281, 281, 281,
  298, 281, 281, 281, 307, 281, 298, 298, 298, 298, 298, 298, 298, 281, 298, 6145, 41108, 3, 4, 0, 0, 0, 0, 0, 156, 157,
  158, 0, 0, 0, 0, 75776, 0, 0, 75776, 0, 0, 0, 75776, 0, 0, 75776, 75776, 6145, 0, 0, 4, 59392, 0, 0, 0, 0, 156, 157,
  563200, 0, 0, 0, 0, 0, 26624, 28672, 0, 0, 0, 0, 0, 24576, 0, 0, 0, 0, 0, 0, 86016, 0, 0, 86016, 86016, 0, 0, 0, 0, 0,
  0, 0, 75776, 75776, 75776, 0, 0, 0, 0, 0, 0, 0, 423, 158, 429, 158, 158, 158, 158, 158, 439, 158, 158, 158, 158, 158,
  394, 446, 447, 158, 158, 158, 453, 158, 158, 439, 158, 0, 283, 463, 283, 283, 283, 283, 283, 283, 283, 1108, 283, 283,
  283, 283, 283, 283, 283, 283, 283, 283, 283, 963, 964, 0, 0, 0, 477, 483, 485, 283, 283, 283, 283, 283, 497, 283, 283,
  283, 283, 283, 0, 0, 0, 0, 77824, 77824, 77824, 77824, 77824, 77824, 77824, 77824, 77824, 79872, 77824, 0, 158, 158,
  158, 483, 283, 0, 283, 0, 0, 0, 0, 0, 0, 0, 521, 0, 0, 712, 0, 0, 0, 0, 0, 0, 0, 0, 719, 0, 0, 0, 0, 0, 0, 322, 0, 0,
  0, 0, 0, 173, 173, 173, 0, 0, 586, 586, 0, 0, 0, 586, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 925, 158, 158,
  158, 158, 158, 158, 158, 617, 618, 158, 158, 158, 158, 158, 158, 158, 158, 158, 0, 628, 158, 158, 158, 158, 158, 1320,
  158, 283, 283, 283, 283, 283, 283, 283, 1328, 283, 283, 283, 283, 283, 957, 283, 283, 283, 283, 283, 283, 0, 0, 0, 0,
  0, 1058, 0, 0, 0, 0, 0, 0, 0, 173, 173, 0, 0, 0, 0, 0, 0, 0, 0, 521, 703, 704, 0, 0, 0, 0, 0, 663, 283, 283, 665, 283,
  283, 283, 283, 283, 283, 283, 672, 673, 283, 283, 283, 283, 283, 283, 1044, 283, 283, 283, 283, 283, 283, 283, 283,
  283, 283, 283, 950, 283, 283, 283, 283, 158, 760, 158, 158, 158, 158, 158, 158, 158, 158, 768, 158, 158, 158, 158,
  158, 158, 158, 1015, 158, 158, 158, 158, 158, 158, 158, 158, 158, 1017, 158, 1019, 158, 158, 158, 158, 158, 774, 158,
  158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 785, 158, 158, 283, 283, 283, 806, 283, 283, 283,
  283, 283, 283, 283, 283, 283, 283, 816, 283, 283, 283, 283, 283, 1106, 283, 283, 283, 283, 283, 283, 283, 283, 283,
  1114, 0, 890, 0, 0, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 627, 0, 158, 158, 915, 158, 158, 158,
  158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 1023, 1024, 283, 283, 283, 283, 1028, 283, 283, 283, 283,
  283, 283, 283, 283, 1036, 283, 283, 283, 283, 283, 1221, 283, 283, 283, 1225, 283, 283, 283, 283, 0, 0, 0, 0, 329728,
  0, 968, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 718, 0, 0, 0, 0, 0, 1038, 283, 283, 283, 283, 1043, 283, 283, 283, 283, 283,
  283, 283, 283, 283, 283, 283, 283, 1255, 0, 1188, 214, 0, 214, 214, 214, 1068, 214, 214, 214, 214, 214, 214, 214, 0,
  0, 0, 0, 0, 0, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 901, 283, 283, 283, 283, 1105, 283, 1107, 283,
  283, 1110, 283, 283, 283, 283, 283, 283, 283, 283, 283, 1174, 283, 283, 283, 283, 283, 283, 0, 1188, 158, 1277, 158,
  158, 158, 158, 158, 158, 158, 158, 766, 158, 158, 158, 158, 158, 158, 158, 158, 158, 1265, 158, 283, 283, 283, 283,
  283, 0, 1126, 0, 0, 0, 0, 0, 0, 214, 214, 214, 214, 214, 214, 214, 214, 0, 0, 0, 0, 553, 0, 0, 0, 0, 0, 0, 0, 173,
  173, 0, 0, 0, 0, 0, 0, 336, 184, 0, 0, 0, 0, 0, 0, 0, 343, 538, 0, 0, 0, 544, 0, 0, 0, 0, 158, 158, 158, 1156, 158,
  1157, 158, 158, 158, 158, 1162, 283, 283, 1165, 283, 283, 283, 283, 283, 682, 283, 283, 283, 0, 0, 0, 158, 283, 283,
  0, 283, 283, 283, 283, 1170, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 1180, 283, 283, 61440, 63488, 0, 0, 0,
  0, 0, 0, 0, 214, 214, 214, 214, 214, 0, 0, 0, 0, 751, 752, 0, 0, 690, 690, 757, 158, 1192, 214, 1194, 0, 0, 158, 158,
  158, 158, 158, 158, 158, 158, 158, 1201, 158, 158, 158, 158, 283, 1305, 283, 283, 283, 283, 283, 283, 283, 0, 158,
  158, 158, 158, 158, 634, 158, 158, 158, 158, 51839, 521, 641, 283, 283, 283, 283, 283, 283, 283, 1172, 283, 283, 283,
  1175, 283, 283, 283, 283, 283, 283, 283, 283, 1224, 283, 283, 283, 283, 283, 0, 0, 243, 243, 243, 243, 243, 243, 229,
  243, 267, 267, 267, 299, 267, 267, 267, 267, 267, 299, 299, 299, 299, 299, 299, 299, 267, 299, 267, 299, 6145, 41108,
  3, 4, 0, 0, 0, 0, 0, 156, 157, 158, 0, 0, 0, 0, 348160, 348359, 348359, 0, 0, 0, 0, 0, 348359, 0, 0, 348160, 348160,
  0, 0, 348160, 0, 0, 0, 0, 0, 348160, 348160, 0, 0, 348160, 0, 0, 0, 0, 0, 0, 0, 0, 348160, 0, 348160, 0, 158, 158,
  158, 158, 776, 158, 158, 158, 780, 158, 158, 158, 158, 158, 158, 158, 158, 458, 0, 283, 283, 283, 283, 283, 283, 283,
  1102, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 674, 283, 283, 283, 283, 1248, 283, 283,
  283, 283, 283, 283, 283, 283, 283, 0, 0, 1188, 214, 214, 568, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
  214, 214, 737, 214, 214, 214, 740, 214, 214, 214, 214, 214, 214, 158, 1357, 158, 283, 283, 283, 283, 1361, 283, 158,
  158, 158, 158, 283, 283, 283, 283, 283, 933, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 813, 283, 283,
  283, 283, 0, 214, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 268, 300, 6145, 41108, 3, 4, 0, 0, 0, 0, 0, 156, 157, 158, 0,
  0, 0, 158, 158, 158, 158, 158, 158, 1146, 158, 158, 158, 158, 158, 158, 158, 158, 637, 158, 51839, 521, 283, 283, 283,
  283, 158, 158, 158, 419, 158, 158, 158, 158, 158, 0, 283, 283, 283, 283, 473, 283, 283, 283, 283, 680, 283, 283, 283,
  283, 0, 0, 0, 688, 283, 689, 0, 0, 400, 0, 402, 403, 0, 0, 0, 360, 407, 408, 158, 158, 158, 158, 158, 158, 158, 1092,
  158, 158, 158, 158, 158, 158, 158, 283, 1323, 283, 283, 283, 283, 283, 283, 283, 158, 419, 158, 283, 283, 0, 283, 0,
  0, 0, 0, 0, 0, 0, 521, 0, 0, 725, 0, 350, 0, 0, 0, 0, 0, 0, 0, 0, 214, 214, 214, 214, 214, 214, 1137, 214, 283, 283,
  283, 651, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 1050, 283, 283, 283, 283, 283, 820, 283,
  283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 1123, 0, 0, 206, 206, 206, 206, 206, 206, 230, 206, 269,
  269, 269, 301, 269, 269, 269, 269, 269, 301, 301, 301, 301, 301, 301, 301, 269, 301, 269, 301, 6145, 41108, 3, 4, 0,
  0, 0, 0, 0, 156, 157, 158, 0, 0, 0, 158, 158, 158, 158, 158, 158, 1147, 158, 158, 158, 158, 158, 158, 158, 158, 1016,
  158, 158, 158, 158, 158, 158, 158, 158, 158, 1160, 158, 283, 283, 283, 283, 283, 0, 214, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 270, 302, 6145, 41108, 3, 4, 0, 0, 0, 0, 0, 156, 157, 158, 0, 0, 0, 158, 158, 158, 1145, 158, 158, 158, 158,
  158, 158, 158, 158, 158, 158, 911, 158, 158, 158, 158, 158, 158, 420, 158, 283, 283, 0, 283, 0, 0, 0, 0, 0, 0, 0, 521,
  0, 0, 853, 0, 0, 0, 0, 858, 0, 0, 0, 0, 0, 863, 0, 0, 0, 0, 158, 893, 158, 158, 158, 158, 158, 158, 158, 158, 158,
  158, 158, 1096, 1097, 158, 158, 283, 283, 678, 283, 283, 283, 283, 283, 283, 283, 0, 0, 0, 158, 283, 283, 0, 0, 865,
  0, 0, 0, 0, 0, 0, 214, 214, 214, 214, 214, 214, 214, 387, 214, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 173, 158, 0, 158, 0,
  692, 0, 0, 0, 698, 0, 0, 0, 521, 0, 0, 0, 0, 0, 0, 0, 173, 173, 0, 0, 0, 528, 0, 0, 0, 178459, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 550, 875, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 0, 0, 0, 0, 0, 0, 158, 994, 158,
  158, 158, 902, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 1100, 942, 283, 283, 283,
  283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 1037, 283, 283, 1053, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 722, 0, 0, 0, 0, 348160, 348160, 0, 348160, 0, 0, 0, 0, 0, 0, 0, 348160, 0, 348160, 0, 6145, 0, 3, 4, 0, 0, 0, 0,
  0, 156, 157, 563200, 0, 0, 0, 158, 1143, 158, 158, 158, 158, 158, 158, 1149, 158, 158, 158, 1152, 532480, 194, 0, 0,
  0, 0, 350208, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 81920, 81920, 81920, 81920, 81920, 81920, 81920, 81920, 81920, 81920,
  83968, 81920, 0, 352256, 352256, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 156, 157, 563200, 0, 0, 0, 160, 0, 0, 0, 160, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 338, 0, 0, 0, 0, 0, 0, 0, 0, 354304, 0, 0, 200, 200, 0, 0, 0, 0, 0, 200, 354304, 354304, 0, 354304,
  354304, 354304, 354304, 354304, 354304, 354304, 354304, 354304, 354304, 354304, 354304, 354304, 0, 0, 0, 0, 0, 0, 0,
  0, 354304, 354304, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 156, 157, 563200, 0, 0, 0, 167, 0, 0, 0, 0, 0, 0, 0, 173, 158, 0,
  158, 0, 532480, 194, 0, 0, 0, 0, 0, 356352, 0, 0, 0, 0, 0, 0, 0, 0, 214, 559, 214, 214, 214, 214, 214, 214, 0, 0,
  6145, 41108, 3, 4, 0, 0, 0, 0, 0, 156, 157, 158, 0, 0, 0, 331, 0, 214, 214, 363, 214, 214, 214, 214, 214, 214, 214,
  214, 0, 0, 0, 322, 0, 0, 0, 0, 0, 0, 0, 158, 158, 158, 416, 158, 686080, 0, 763904, 802816, 0, 0, 0, 0, 0, 0, 0,
  677888, 0, 0, 0, 534528, 696320, 675840, 0, 0, 675840, 696320, 561152, 770048, 827392, 770048, 563200, 675840, 696320,
  563200, 563200, 741376, 563200, 563200, 563200, 741376, 770048, 817152, 563200, 827392, 563200, 563200, 563200,
  860160, 0, 714752, 0, 714752
);

(:~
 : The DFA-state to expected-token-set mapping.
 :)
declare variable $p:EXPECTED as xs:integer+ :=
(
  33, 96, 65, 128, 160, 192, 224, 812, 829, 829, 837, 285, 317, 349, 662, 441, 473, 536, 409, 568, 600, 694, 726, 758,
  504, 869, 901, 933, 253, 631, 379, 789, 837, 965, 1246, 984, 988, 989, 994, 998, 989, 1000, 990, 1004, 1008, 1012,
  1013, 1017, 1021, 1025, 1029, 1033, 1043, 1694, 1415, 2130, 1403, 1047, 1991, 1253, 1928, 1929, 1695, 1695, 1257,
  1065, 975, 1695, 1070, 1079, 1086, 1928, 1928, 1130, 1573, 2190, 2190, 2190, 2190, 2190, 1096, 1164, 1164, 1164, 1164,
  1164, 1104, 1064, 1066, 1695, 1336, 1072, 1927, 1928, 1130, 1574, 2190, 1259, 2190, 1055, 1164, 1165, 1157, 2072,
  1312, 1418, 2009, 1039, 1992, 1928, 1928, 1928, 1130, 1695, 1625, 2190, 2190, 2190, 2190, 1143, 2190, 1098, 1164,
  1164, 1164, 1164, 1164, 1061, 2190, 2190, 2190, 2190, 1163, 1164, 1164, 1164, 1164, 1108, 1111, 1335, 1925, 1928,
  1089, 1257, 2190, 2190, 2190, 2190, 1164, 1164, 1164, 1164, 1118, 1695, 1927, 1130, 2190, 2190, 2190, 2191, 1164,
  1164, 1164, 1117, 1787, 1928, 1257, 2190, 2190, 1162, 1164, 1164, 1122, 1926, 1256, 2190, 2190, 1148, 1164, 1056,
  1128, 2189, 2190, 1162, 1164, 1057, 2190, 1162, 1149, 2190, 1163, 1141, 1147, 1100, 2191, 1164, 1258, 1163, 1155,
  1153, 1162, 1161, 1169, 1171, 1967, 1266, 1175, 1195, 1188, 1179, 1183, 1187, 1192, 1224, 1199, 1203, 1207, 1211,
  1215, 1222, 1228, 1232, 1281, 1218, 2125, 1236, 1695, 1695, 1694, 1244, 1695, 1695, 2145, 1695, 1695, 1695, 1695,
  1695, 1695, 1695, 1695, 2161, 1250, 1695, 1695, 1695, 1695, 1695, 2020, 1695, 1695, 1695, 1695, 1695, 1695, 1695,
  1833, 1695, 1695, 2250, 1695, 1695, 1695, 1780, 1695, 1356, 1695, 1695, 1695, 1695, 1936, 1695, 1917, 1695, 1695,
  1695, 1695, 1380, 2263, 1695, 1696, 1695, 1695, 1695, 2251, 1842, 1276, 1285, 1289, 1292, 1296, 1299, 1302, 1306,
  1310, 1692, 1543, 1695, 1347, 1842, 1695, 1318, 1323, 1327, 1695, 1695, 1334, 1340, 1695, 1695, 1344, 1082, 1695,
  1695, 1361, 1368, 1378, 1330, 1408, 1695, 1319, 1384, 1695, 1695, 1695, 1979, 1675, 1388, 1432, 1695, 1695, 1695,
  1392, 1806, 1398, 1695, 1695, 1695, 1695, 2034, 1402, 1695, 1407, 1695, 1579, 1036, 1412, 1695, 1979, 1675, 1422,
  1431, 1695, 1695, 2081, 1695, 1437, 1446, 1695, 1695, 1695, 1695, 1456, 1695, 1075, 2117, 1579, 1469, 2008, 1695,
  1705, 1462, 1695, 1695, 1695, 1480, 1720, 1440, 1695, 1695, 1695, 976, 1713, 1363, 1695, 2250, 1695, 1353, 1695, 1695,
  1695, 1711, 1074, 1918, 1695, 1695, 2021, 2262, 1695, 1695, 1695, 1695, 1695, 1560, 976, 1695, 1695, 1695, 2268, 1695,
  1695, 1350, 1695, 1728, 1734, 2127, 2253, 1695, 1852, 971, 1427, 1756, 1695, 1739, 971, 1695, 1374, 1695, 1695, 1764,
  1741, 1695, 1695, 1695, 1695, 977, 1944, 1695, 2129, 2021, 1745, 1719, 1500, 1695, 1695, 2057, 1513, 1525, 2099, 1858,
  1532, 1695, 1506, 1538, 1970, 1521, 1541, 1092, 1547, 1567, 2048, 1136, 1551, 1586, 1134, 2048, 1137, 1552, 1587,
  1587, 1587, 1588, 1589, 1556, 1564, 1695, 1695, 1695, 1695, 1695, 1571, 1695, 1695, 1314, 1578, 1583, 1960, 1593,
  1596, 1599, 1603, 1607, 1609, 1607, 1613, 1695, 1458, 1695, 1730, 1558, 2129, 1618, 1624, 1630, 1695, 1113, 1636,
  2047, 1695, 1695, 2054, 2119, 1695, 1695, 1695, 2062, 1132, 1695, 1695, 1881, 2069, 1695, 2079, 1695, 1695, 1449,
  2089, 1542, 1620, 2118, 2026, 1695, 2093, 1132, 1695, 976, 1642, 1646, 1657, 1661, 1124, 1667, 1770, 1674, 1695, 1679,
  1695, 1572, 2050, 1735, 2129, 1619, 1394, 1685, 2048, 2168, 2043, 1689, 2021, 1700, 1709, 1695, 1695, 1717, 1695,
  1475, 1724, 1425, 1753, 1695, 2085, 1761, 1695, 1695, 1768, 1695, 1681, 1774, 1695, 1695, 1695, 2049, 1778, 1695,
  1784, 1748, 1695, 1939, 1746, 1695, 1791, 1695, 1797, 1746, 1695, 1357, 1834, 968, 1749, 1747, 1942, 1695, 1372, 1695,
  1801, 1695, 1695, 1805, 1663, 1817, 1810, 1370, 1695, 1819, 1786, 1272, 1662, 1816, 1823, 1669, 1695, 1830, 1695,
  2027, 1812, 1534, 1695, 1840, 1695, 1051, 1614, 1695, 1695, 1780, 1356, 1695, 1695, 1695, 2126, 2262, 980, 1695, 1695,
  1695, 1695, 1695, 2261, 1695, 1695, 1364, 1695, 1695, 2252, 1695, 1957, 1695, 1695, 1695, 1695, 1712, 1695, 979, 1695,
  1695, 2116, 1467, 1473, 1695, 1514, 1463, 1695, 1695, 1479, 1859, 1441, 1695, 1695, 1695, 1484, 2058, 1695, 1489,
  1493, 1695, 2083, 1498, 1442, 1695, 1695, 1504, 1510, 1514, 1518, 2081, 1865, 1986, 1050, 1614, 1329, 1670, 1987,
  1846, 1856, 1990, 1988, 1989, 1863, 1695, 1695, 1695, 1695, 1695, 1695, 1869, 973, 1626, 1835, 1874, 1878, 2075, 1887,
  1891, 1898, 1894, 1903, 1902, 1904, 1695, 1695, 1836, 1910, 2002, 1908, 1695, 1919, 1695, 2152, 1695, 1914, 1923,
  1112, 1933, 1948, 1954, 1112, 1964, 1494, 1695, 1747, 1870, 2002, 2026, 1695, 1974, 1695, 1818, 1983, 2264, 1826,
  1695, 1695, 1695, 1996, 2041, 2000, 2006, 1695, 1695, 1695, 2013, 1638, 1695, 1695, 1620, 2017, 2025, 1695, 1695,
  1695, 1695, 2031, 1826, 1695, 1695, 1695, 2038, 2033, 1528, 2008, 1695, 1695, 2159, 978, 1695, 1695, 1651, 1695, 1695,
  1695, 2159, 1917, 1695, 1649, 1695, 1695, 1669, 978, 1695, 1849, 1695, 978, 980, 1695, 1695, 1695, 1695, 1695, 1695,
  1695, 1695, 1695, 1695, 1695, 1817, 1695, 1695, 1695, 1695, 2001, 1695, 1695, 1695, 1695, 1695, 1695, 1695, 1695,
  1695, 1695, 1695, 1695, 1695, 1695, 1695, 1695, 1695, 1695, 1695, 1695, 1695, 1695, 1695, 1695, 1695, 1695, 1695,
  1695, 1695, 1695, 1695, 1695, 1653, 1364, 1695, 1263, 1695, 1695, 1793, 1270, 1883, 1695, 2097, 1695, 976, 1452, 2048,
  2103, 2026, 1950, 1695, 1695, 2110, 1695, 1978, 1695, 1633, 2114, 1485, 1695, 2117, 1695, 2123, 1976, 1695, 1757,
  1703, 1279, 1910, 1695, 1240, 2134, 1695, 2139, 2143, 1408, 1239, 2149, 1695, 2156, 1817, 2176, 2243, 2106, 2134,
  2271, 2175, 2243, 2165, 2135, 2272, 2172, 2245, 2180, 2181, 2182, 2186, 1928, 1091, 1695, 1695, 1695, 1695, 2195,
  2202, 1433, 2198, 2206, 2210, 2214, 2218, 2221, 2225, 2229, 2233, 2237, 2241, 1695, 1695, 1695, 1834, 1695, 1329,
  2249, 1695, 1695, 1779, 1695, 2128, 1695, 1695, 2065, 1695, 979, 1695, 2257, 2276, 2424, 2668, 2286, 2286, 2554, 2457,
  2641, 2286, 2286, 2360, 2286, 2286, 2286, 2289, 2286, 2286, 2286, 2290, 2316, 2800, 2349, 2315, 2332, 2348, 2348,
  2348, 2348, 2809, 2348, 2551, 2342, 2345, 2333, 2334, 2348, 2348, 2344, 2334, 2348, 2348, 2628, 2347, 2348, 2348,
  2351, 2538, 2372, 2356, 2356, 2356, 2359, 2356, 2357, 2356, 2371, 2374, 2379, 2387, 2389, 2391, 2395, 2397, 2399,
  2392, 2393, 2393, 2401, 2403, 2276, 2424, 2816, 2286, 2286, 2321, 2642, 2366, 2323, 2286, 2801, 2737, 2285, 2494,
  2286, 2542, 2286, 2286, 2556, 2297, 2286, 2650, 2461, 2461, 2461, 2286, 2443, 2405, 2641, 2448, 2380, 2301, 2301,
  2301, 2301, 2286, 2325, 2321, 2321, 2642, 2323, 2286, 2286, 2286, 2787, 2410, 2366, 2323, 2286, 2286, 2594, 2596,
  2286, 2592, 2648, 2509, 2509, 2353, 2286, 2286, 2286, 2661, 2375, 2375, 2375, 2460, 2461, 2461, 2380, 2375, 2461,
  2461, 2405, 2635, 2461, 2461, 2617, 2301, 2286, 2286, 2286, 2291, 2802, 2461, 2461, 2405, 2641, 2286, 2461, 2617,
  2286, 2286, 2280, 2286, 2286, 2592, 2509, 2509, 2286, 2286, 2278, 2286, 2286, 2799, 2286, 2279, 2286, 2461, 2447,
  2375, 2375, 2360, 2375, 2375, 2375, 2461, 2461, 2461, 2592, 2461, 2461, 2462, 2375, 2375, 2448, 2449, 2380, 2462,
  2375, 2448, 2461, 2461, 2461, 2461, 2536, 2462, 2448, 2462, 2462, 2380, 2286, 2492, 2307, 2492, 2312, 2436, 2311,
  2306, 2311, 2313, 2408, 2529, 2467, 2429, 2311, 2311, 2311, 2311, 2845, 2451, 2528, 2419, 2428, 2432, 2311, 2466,
  2287, 2420, 2471, 2473, 2469, 2475, 2477, 2479, 2482, 2482, 2480, 2483, 2485, 2426, 2487, 2489, 2518, 2519, 2286,
  2286, 2643, 2520, 2297, 2491, 2311, 2311, 2527, 2468, 2493, 2512, 2514, 2516, 2522, 2517, 2524, 2526, 2286, 2452,
  2299, 2286, 2286, 2644, 2277, 2286, 2286, 2721, 2286, 2286, 2282, 2284, 2286, 2804, 2547, 2286, 2286, 2648, 2509,
  2286, 2447, 2375, 2375, 2375, 2286, 2286, 2430, 2285, 2286, 2286, 2667, 2287, 2792, 2561, 2286, 2286, 2285, 2286,
  2286, 2411, 2298, 2277, 2425, 2286, 2286, 2531, 2286, 2564, 2295, 2295, 2566, 2569, 2569, 2568, 2571, 2572, 2573,
  2574, 2577, 2575, 2576, 2576, 2579, 2580, 2580, 2581, 2580, 2585, 2581, 2582, 2583, 2583, 2587, 2589, 2286, 2286,
  2286, 2788, 2788, 2286, 2286, 2381, 2816, 2286, 2612, 2545, 2613, 2286, 2591, 2600, 2604, 2286, 2286, 2286, 2791,
  2787, 2603, 2286, 2286, 2286, 2321, 2321, 2562, 2601, 2817, 2607, 2286, 2595, 2597, 2286, 2286, 2786, 2286, 2286,
  2707, 2286, 2286, 2728, 2296, 2286, 2286, 2286, 2708, 2286, 2609, 2286, 2286, 2287, 2286, 2286, 2609, 2537, 2286,
  2286, 2287, 2298, 2286, 2286, 2287, 2732, 2365, 2285, 2286, 2286, 2289, 2293, 2554, 2338, 2540, 2616, 2557, 2385,
  2376, 2620, 2622, 2553, 2286, 2286, 2289, 2726, 2812, 2738, 2620, 2553, 2627, 2286, 2286, 2286, 2329, 2673, 2286,
  2286, 2277, 2286, 2385, 2630, 2659, 2286, 2286, 2789, 2790, 2286, 2286, 2304, 2337, 2385, 2376, 2639, 2655, 2286,
  2286, 2353, 2554, 2632, 2641, 2286, 2286, 2286, 2328, 2336, 2338, 2812, 2376, 2638, 2631, 2553, 2286, 2286, 2638,
  2631, 2369, 2286, 2286, 2798, 2803, 2508, 2376, 2781, 2614, 2413, 2286, 2286, 2289, 2790, 2414, 2376, 2639, 2634,
  2286, 2286, 2381, 2816, 2381, 2414, 2630, 2444, 2674, 2286, 2286, 2292, 2326, 2286, 2637, 2553, 2286, 2286, 2673,
  2286, 2441, 2286, 2614, 2648, 2384, 2444, 2639, 2634, 2286, 2286, 2286, 2364, 2336, 2339, 2444, 2638, 2631, 2553,
  2286, 2787, 2286, 2541, 2816, 2502, 2816, 2382, 2630, 2816, 2286, 2286, 2383, 2382, 2653, 2631, 2641, 2286, 2286,
  2801, 2339, 2382, 2657, 2662, 2286, 2286, 2801, 2453, 2657, 2675, 2286, 2286, 2297, 2286, 2816, 2286, 2327, 2657,
  2668, 2286, 2286, 2286, 2367, 2661, 2664, 2816, 2278, 2286, 2801, 2417, 2286, 2286, 2286, 2666, 2286, 2666, 2286,
  2286, 2297, 2842, 2286, 2666, 2666, 2286, 2286, 2801, 2658, 2286, 2670, 2286, 2286, 2286, 2375, 2375, 2672, 2286,
  2286, 2286, 2381, 2288, 2671, 2800, 2286, 2286, 2801, 2800, 2286, 2801, 2800, 2679, 2286, 2681, 2687, 2688, 2689,
  2686, 2686, 2685, 2684, 2686, 2686, 2686, 2683, 2692, 2692, 2692, 2692, 2691, 2693, 2695, 2286, 2286, 2286, 2433,
  2286, 2703, 2286, 2286, 2286, 2434, 2705, 2286, 2286, 2286, 2447, 2277, 2710, 2439, 2364, 2286, 2286, 2811, 2507,
  2649, 2445, 2748, 2674, 2618, 2714, 2651, 2286, 2610, 2286, 2716, 2440, 2286, 2286, 2844, 2294, 2286, 2286, 2550,
  2286, 2625, 2286, 2354, 2438, 2718, 2286, 2286, 2286, 2457, 2592, 2286, 2362, 2286, 2286, 2298, 2286, 2286, 2363,
  2286, 2286, 2286, 2539, 2720, 2723, 2286, 2286, 2308, 2300, 2500, 2808, 2712, 2654, 2458, 2286, 2605, 2286, 2287,
  2335, 2286, 2286, 2286, 2286, 2288, 2326, 2729, 2808, 2444, 2446, 2286, 2286, 2510, 2384, 2459, 2655, 2286, 2286,
  2310, 2320, 2323, 2286, 2292, 2463, 2286, 2286, 2336, 2339, 2414, 2729, 2808, 2649, 2743, 2290, 2286, 2286, 2708,
  2647, 2287, 2406, 2286, 2800, 2286, 2286, 2309, 2302, 2498, 2444, 2457, 2640, 2734, 2457, 2286, 2286, 2286, 2554,
  2455, 2286, 2286, 2648, 2554, 2455, 2286, 2286, 2286, 2548, 2495, 2444, 2457, 2286, 2287, 2731, 2302, 2407, 2787,
  2286, 2286, 2361, 2438, 2495, 2444, 2457, 2787, 2288, 2286, 2286, 2295, 2303, 2286, 2295, 2740, 2593, 2286, 2286,
  2286, 2592, 2286, 2407, 2286, 2286, 2365, 2366, 2286, 2407, 2302, 2742, 2318, 2495, 2412, 2593, 2317, 2286, 2286,
  2286, 2558, 2286, 2745, 2593, 2286, 2286, 2747, 2592, 2425, 2286, 2286, 2286, 2318, 2745, 2286, 2497, 2457, 2286,
  2288, 2286, 2278, 2297, 2745, 2593, 2286, 2288, 2286, 2286, 2286, 2555, 2646, 2297, 2747, 2286, 2286, 2377, 2286,
  2286, 2556, 2298, 2286, 2289, 2298, 2286, 2289, 2728, 2711, 2286, 2433, 2286, 2286, 2384, 2711, 2376, 2791, 2286,
  2791, 2286, 2298, 2286, 2554, 2434, 2647, 2286, 2277, 2286, 2360, 2614, 2360, 2706, 2750, 2447, 2286, 2289, 2803,
  2645, 2630, 2279, 2696, 2697, 2753, 2756, 2758, 2758, 2698, 2698, 2754, 2700, 2762, 2760, 2699, 2759, 2698, 2701,
  2762, 2762, 2762, 2762, 2286, 2706, 2787, 2286, 2286, 2441, 2286, 2297, 2641, 2287, 2286, 2290, 2286, 2286, 2286,
  2764, 2286, 2553, 2286, 2286, 2443, 2509, 2509, 2509, 2509, 2707, 2437, 2769, 2771, 2286, 2293, 2322, 2286, 2295,
  2302, 2742, 2457, 2286, 2286, 2368, 2288, 2286, 2840, 2286, 2286, 2447, 2630, 2805, 2773, 2364, 2286, 2295, 2303,
  2296, 2295, 2286, 2677, 2806, 2776, 2774, 2286, 2295, 2416, 2816, 2286, 2286, 2340, 2286, 2496, 2286, 2286, 2453,
  2286, 2286, 2286, 2647, 2767, 2630, 2618, 2286, 2297, 2556, 2286, 2286, 2556, 2286, 2286, 2593, 2286, 2291, 2437,
  2507, 2376, 2751, 2286, 2286, 2286, 2614, 2286, 2801, 2780, 2816, 2286, 2286, 2286, 2330, 2291, 2421, 2807, 2783,
  2647, 2277, 2286, 2614, 2286, 2286, 2286, 2309, 2286, 2724, 2286, 2286, 2286, 2593, 2785, 2376, 2464, 2286, 2286,
  2286, 2624, 2794, 2507, 2376, 2748, 2640, 2279, 2286, 2353, 2554, 2674, 2279, 2286, 2286, 2286, 2368, 2287, 2286,
  2791, 2646, 2441, 2815, 2381, 2444, 2674, 2791, 2376, 2464, 2286, 2299, 2320, 2323, 2442, 2639, 2279, 2286, 2301,
  2301, 2360, 2447, 2750, 2750, 2422, 2796, 2286, 2286, 2505, 2552, 2286, 2286, 2289, 2736, 2508, 2376, 2454, 2639,
  2286, 2434, 2630, 2279, 2648, 2446, 2286, 2286, 2505, 2553, 2447, 2277, 2286, 2425, 2425, 2286, 2537, 2289, 2506,
  2645, 2630, 2649, 2445, 2787, 2286, 2441, 2286, 2286, 2425, 2724, 2286, 2548, 2277, 2286, 2286, 2286, 2295, 2286,
  2286, 2286, 2305, 2286, 2423, 2425, 2286, 2286, 2286, 2508, 2503, 2425, 2286, 2412, 2286, 2286, 2535, 2286, 2286,
  2648, 2424, 2286, 2318, 2767, 2765, 2644, 2444, 2424, 2286, 2319, 2286, 2286, 2544, 2286, 2456, 2286, 2537, 2286,
  2324, 2808, 2654, 2335, 2423, 2425, 2286, 2335, 2648, 2424, 2286, 2352, 2504, 2286, 2352, 2504, 2537, 2353, 2537,
  2353, 2353, 2375, 2375, 2375, 2375, 2448, 2286, 2559, 2286, 2328, 2381, 2328, 2381, 2286, 2814, 2339, 2328, 2505,
  2286, 2381, 2328, 2286, 2598, 2501, 2533, 2554, 2499, 2532, 2820, 2819, 2822, 2820, 2825, 2825, 2825, 2825, 2824,
  2825, 2825, 2827, 2828, 2830, 2830, 2830, 2831, 2830, 2832, 2829, 2835, 2830, 2831, 2837, 2833, 2839, 2286, 2286,
  2537, 2423, 2425, 2286, 2804, 2286, 2286, 2303, 2286, 2286, 2286, 2703, 2286, 2731, 2320, 2323, 2309, 2319, 2322,
  2286, 2286, 2286, 2778, 2286, 2844, 2842, 2286, 2352, 2424, 2425, 2286, 4, 524288, 0, -2147483648, 0, -671088640,
  262208, -2147483584, 268451840, 16384, 0, 0, 1, 0, 2, 0, 3, 12, 16, 0, 4, 0, 8, 0, 12, 64, 64, 128, 0, 16, 24, 8, 1,
  2, 4, 8, 8, 10, 10, 134234112, 16384, 16384, 1, 8, 16, 128, 128, 256, 0, 32, 32, 64, 512, 0, 48, 32, 33587200,
  -2147450880, -2147450880, 32768, 0, 96, 128, 512, 2048, -2147483648, 294976, 32832, 32792, 33849344, -2147450880,
  75008, 32768, 32768, 32832, 8456448, 32768, 131072, 0, 230, 67141632, 67141632, -2080342016, 67141632, 262144, 0, 239,
  63832064, -805306368, 0, 256, 256, 16384, 536870912, -1073741824, 67272704, 67141632, 163904, -2113634304, 262144,
  262144, 524288, 1280, 278528, 17039360, 0, 512, 131072, 96, 512, 229376, 294912, 1610874880, 278528, -2147188736,
  294912, 17072128, -2130411272, -2130411272, 1610907648, -2147188736, 294912, -2147221256, 1610907648, 17072128,
  67403776, -2130411272, 67403776, -2063302408, 17039360, 536870912, 1, 12, 536, 65536, 256, 524288, 4194304, 32768,
  196608, 2048, 134217728, -2147483648, 24, 520, 8, 64, 131072, 2097152, 4194304, 0, -80214182, 262152, 524296, 8, 256,
  1048584, 8, 1024, 262144, 131080, 8, 3584, 40960, 29491200, 0, 524288, 8388608, 131072, 524288, 6291456, 0, 262144,
  17039360, 48, 134217736, 8, 131072, 6291456, 8388608, 4194304, 4194304, 8388608, 12582912, 16777216, 17039360,
  17039360, 262144, 33554432, -2147483648, 1097752, 520, 520, 1049112, 1049112, 1359896, 520, 1359898, 81788928, 8,
  2066743832, 24, 2066743832, 2066744984, 2066745016, -80738632, 2066745016, 2066745016, 2066794168, -80214184,
  2066794168, 2066794170, 2067056312, 2066794170, 2067056314, 0, 268500992, 8, 56, 128, 1536, 0, 1536, 2048, 128, 2048,
  512, 524288, 2097152, 0, 2048, 8192, 49152, 131072, 131072, 196608, 73404418, 10, 1048600, 49160, 73412618, 73462926,
  2066794170, 2066794170, 8, 262144, 73462942, 73462926, 74511518, 2067056314, 2138060442, 0, 524824, 1048600,
  -2147483624, 4, 2048, 9728, 9728, 50331648, 1610612736, 0, 32768, 163840, 229376, 524288, 512, 65792, 71303168, 0,
  557056, 121634816, 2048, 49152, 1, 32768, 1048576, -1073741824, 0, 128, 1024, 0, 224, 512, 4096, 33587200, 0, 688128,
  0, 268960256, 0, 302547464, 302547592, 302547592, 839615104, 839418504, 839418504, 839549576, 839615112, 839419528,
  839615116, 839615116, 2131722976, 2131722992, -14710048, -14710048, -14710046, -10515726, -10515726, -14710048,
  2136967920, -14710036, -10515726, -14710036, -10515718, 640, 0, 8388608, 0, 2784, 2064384, -16777216, 0, 4096, 640,
  753664, 1664, 0, 838860800, 0, 13631488, 1015808, 2130706432, 6258688, 0, 16908288, 0, 301989888, 0, 4194304,
  301989888, 536870912, 1073741824, -2147483648, 520093696, 536870912, 2048, 1572864, 5767168, 0, 30539776, 5767168,
  32768, 134288128, 524288, 33554432, 469762048, 536870912, 469762048, 1073741824, 262144, 2048, 1048576, 16777216,
  33554432, 1073741824, 0, 65536, 0, 49152, 262144, 536870912, 0, 131072, 262144, 16777216, -805306368, 524288,
  16777216, 1342177280, -2147483648, 524288, 201326592, 268435456, 536870912, 0, 268435456, 1073741824, 64, 201326592,
  0, 134217728, 268435456, -2147483648, 2, 1048576, 536887296, 0, 33554432, 268435456, -1073741824, 4, 1073743872, 0,
  1073743872, 1073743878, 1073743878, -641554266, -775246106, -774723418, -775771994, -775771994, -788486106,
  -788355034, -779966298, -775246105, -741429521, -741429521, -674255121, -741429521, 0, 34342400, -1039399415,
  -1039399415, -1014174197, -739316149, -745607669, 2048, 1073741824, 6, 0, 67108864, 0, 16384, 166, 2048, 131072,
  12582912, 38, 40960, 166, 25296896, 30015488, -805306368, 231, 0, 79691776, 63897600, 67108864, 33554432, 4, 32, 4,
  128, 3584, 2, 12, 33554432, 128, 131072, 4, 64, 262144, 1572864, 128, 4194304, 1536, 524288, 12582912, 1536, 4194304,
  1536, 8388608, 16777216, 33817600, 0, 100663296, 34342408, -1039399415, -972290551, 1108084232, 1108084232,
  1108084233, 1108084233, -1039399415, 1108084233, -739316149, -739316149, 1536, 34078720, -1073741824, 1536, 262144,
  57344, 262144, 59244544, -1073741824, 188416, 65536000, -805306368, 188416, 262144, 8, 1073741824, 180224, 6291456,
  33554432, 180224, 262144, 1, 1024, 33554432, 0, 1048576, 1048576, 0, 1024, 16384, 3, 3072, 6291456, 268435456, 2, 64,
  134217728, 0, 64, 3072, 8192, 0, 72, 3584, 8192, 32768, -2147483400, 2, 2048, 229376, 1, 512, 268435456, 0, 736, 644,
  4224, 4224, 132, 4224, 412, 6276, 6276, 6788, 6788, 412, 414, 414, 926, 414, 7070, 2462, 414, 4510, 7070, 6558, 0,
  101187584, 16, 256, 2, 8, 524296
);

(:~
 : The token-string table.
 :)
declare variable $p:TOKEN as xs:string+ :=
(
  "EPSILON",
  "END",
  "DirCommentContents",
  "IntegerLiteral",
  "DecimalLiteral",
  "DoubleLiteral",
  "StringLiteral",
  "TextNodeLiteral",
  "PredefinedEntityRef",
  "'""""'",
  "EscapeApos",
  "ElementContentChar",
  "QuotAttrContentChar",
  "AposAttrContentChar",
  "S",
  "S",
  "CharRef",
  "NCName",
  "QName",
  "PITarget",
  "CommentContents",
  "PragmaContents",
  "DirPIContents",
  "CDataSection",
  "Wildcard",
  "EOF",
  "'!='",
  "'""'",
  "'#)'",
  "'#current'",
  "'#default'",
  "'$'",
  "''''",
  "'('",
  "'(#'",
  "'(:'",
  "')'",
  "'*'",
  "'*'",
  "'+'",
  "'+'",
  "','",
  "'-'",
  "'-->'",
  "'.'",
  "'..'",
  "'/'",
  "'//'",
  "'/>'",
  "':)'",
  "'::'",
  "':='",
  "';'",
  "'<'",
  "'<!--'",
  "'</'",
  "'<<'",
  "'<='",
  "'<?'",
  "'='",
  "'>'",
  "'>='",
  "'>>'",
  "'?'",
  "'?>'",
  "'@'",
  "'['",
  "']'",
  "'^'",
  "'ancestor'",
  "'ancestor-or-self'",
  "'and'",
  "'as'",
  "'ascending'",
  "'at'",
  "'attribute'",
  "'base-uri'",
  "'boundary-space'",
  "'by'",
  "'case'",
  "'cast'",
  "'castable'",
  "'child'",
  "'collation'",
  "'comment'",
  "'construction'",
  "'copy'",
  "'copy-namespaces'",
  "'declare'",
  "'default'",
  "'descendant'",
  "'descendant-or-self'",
  "'descending'",
  "'div'",
  "'document'",
  "'document-node'",
  "'element'",
  "'else'",
  "'empty'",
  "'empty-sequence'",
  "'encoding'",
  "'eq'",
  "'every'",
  "'except'",
  "'external'",
  "'following'",
  "'following-sibling'",
  "'for'",
  "'function'",
  "'ge'",
  "'greatest'",
  "'gt'",
  "'id'",
  "'idiv'",
  "'if'",
  "'import'",
  "'in'",
  "'inherit'",
  "'instance'",
  "'intersect'",
  "'is'",
  "'item'",
  "'key'",
  "'lax'",
  "'le'",
  "'least'",
  "'let'",
  "'lt'",
  "'mod'",
  "'module'",
  "'namespace'",
  "'ne'",
  "'no-inherit'",
  "'no-preserve'",
  "'node'",
  "'of'",
  "'option'",
  "'or'",
  "'order'",
  "'ordered'",
  "'ordering'",
  "'parent'",
  "'preceding'",
  "'preceding-sibling'",
  "'preserve'",
  "'processing-instruction'",
  "'return'",
  "'satisfies'",
  "'schema'",
  "'schema-attribute'",
  "'schema-element'",
  "'self'",
  "'some'",
  "'stable'",
  "'strict'",
  "'strip'",
  "'text'",
  "'then'",
  "'to'",
  "'treat'",
  "'tunnel'",
  "'typeswitch'",
  "'union'",
  "'unordered'",
  "'validate'",
  "'variable'",
  "'version'",
  "'where'",
  "'xquery'",
  "'{'",
  "'{{'",
  "'|'",
  "'}'",
  "'}}'"
);

(:~
 : Match next token in input string, starting at given index, using
 : the DFA entry state for the set of tokens that are expected in
 : the current context.
 :
 : @param $input the input string.
 : @param $begin the index where to start in input string.
 : @param $token-set the expected token set id.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:match($input as xs:string,
                         $begin as xs:integer,
                         $token-set as xs:integer) as xs:integer+
{
  let $result := $p:INITIAL[1 + $token-set]
  return p:transition($input,
                      $begin,
                      $begin,
                      $begin,
                      $result,
                      $result mod 2048,
                      0)
};

(:~
 : The DFA state transition function. If we are in a valid DFA state, save
 : it's result annotation, consume one input codepoint, calculate the next
 : state, and use tail recursion to do the same again. Otherwise, return
 : any valid result or a negative DFA state id in case of an error.
 :
 : @param $input the input string.
 : @param $begin the begin index of the current token in the input string.
 : @param $current the index of the current position in the input string.
 : @param $end the end index of the result in the input string.
 : @param $result the result code.
 : @param $current-state the current DFA state.
 : @param $previous-state the  previous DFA state.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:transition($input as xs:string,
                              $begin as xs:integer,
                              $current as xs:integer,
                              $end as xs:integer,
                              $result as xs:integer,
                              $current-state as xs:integer,
                              $previous-state as xs:integer) as xs:integer+
{
  if ($current-state = 0) then
    let $result := $result idiv 2048
    return
      if ($result != 0) then
      (
        $result mod 256 - 1,
        $begin,
        $end - $result idiv 256
      )
      else
      (
        - $previous-state,
        $begin,
        $current - 1
      )
  else
    let $c0 := (string-to-codepoints(substring($input, $current, 1)), 0)[1]
    let $c1 :=
      if ($c0 < 128) then
        $p:MAP0[1 + $c0]
      else if ($c0 < 55296) then
        let $c1 := $c0 idiv 8
        let $c2 := $c1 idiv 32
        return $p:MAP1[1 + $c0 mod 8 + $p:MAP1[1 + $c1 mod 32 + $p:MAP1[1 + $c2]]]
      else
        p:map2($c0, 1, 2)
    let $current := $current + 1
    let $i0 := 2048 * $c1 + $current-state - 1
    let $i1 := $i0 idiv 16
    let $next-state := $p:TRANSITION[$i0 mod 16 + $p:TRANSITION[$i1 + 1] + 1]
    return
      if ($next-state > 2047) then
        p:transition($input, $begin, $current, $current, $next-state, $next-state mod 2048, $current-state)
      else
        p:transition($input, $begin, $current, $end, $result, $next-state, $current-state)
};

(:~
 : Recursively translate one 32-bit chunk of an expected token bitset
 : to the corresponding sequence of token strings.
 :
 : @param $result the result of previous recursion levels.
 : @param $chunk the 32-bit chunk of the expected token bitset.
 : @param $base-token-code the token code of bit 0 in the current chunk.
 : @return the set of token strings.
 :)
declare function p:token($result as xs:string*,
                         $chunk as xs:integer,
                         $base-token-code as xs:integer) as xs:string*
{
  if ($chunk = 0) then
    $result
  else
    p:token
    (
      ($result, if ($chunk mod 2 != 0) then $p:TOKEN[$base-token-code] else ()),
      if ($chunk < 0) then $chunk idiv 2 + 2147483648 else $chunk idiv 2,
      $base-token-code + 1
    )
};

(:~
 : Calculate expected token set for a given DFA state as a sequence
 : of strings.
 :
 : @param $state the DFA state.
 : @return the set of token strings
 :)
declare function p:expected-token-set($state as xs:integer) as xs:string*
{
  if ($state > 0) then
    for $t in 0 to 5
    let $i0 := $t * 1373 + $state - 1
    let $i1 := $i0 idiv 2
    let $i2 := $i1 idiv 4
    let $i3 := $i2 idiv 32
    return p:token((), $p:EXPECTED[$i0 mod 2 + $p:EXPECTED[$i1 mod 4 + $p:EXPECTED[$i2 mod 32 + $p:EXPECTED[$i3 + 1] + 1] + 1] + 1], $t * 32 + 1)
  else
    ()
};

(:~
 : Classify codepoint by doing a tail recursive binary search for a
 : matching codepoint range entry in MAP2, the codepoint to charclass
 : map for codepoints above the surrogate block.
 :
 : @param $c the codepoint.
 : @param $lo the binary search lower bound map index.
 : @param $hi the binary search upper bound map index.
 : @return the character class.
 :)
declare function p:map2($c as xs:integer, $lo as xs:integer, $hi as xs:integer) as xs:integer
{
  if ($lo > $hi) then
    0
  else
    let $m := ($hi + $lo) idiv 2
    return
      if ($p:MAP2[$m] > $c) then
        p:map2($c, $lo, $m - 1)
      else if ($p:MAP2[2 + $m] < $c) then
        p:map2($c, $m + 1, $hi)
      else
        $p:MAP2[4 + $m]
};

(:~
 : The index of the parser state for accessing the combined
 : (i.e. level > 1) lookahead code.
 :)
declare variable $p:lk := 1;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the token that has been shifted.
 :)
declare variable $p:b0 := 2;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the token that has been shifted.
 :)
declare variable $p:e0 := 3;

(:~
 : The index of the parser state for accessing the code of the
 : level-1-lookahead token.
 :)
declare variable $p:l1 := 4;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-1-lookahead token.
 :)
declare variable $p:b1 := 5;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-1-lookahead token.
 :)
declare variable $p:e1 := 6;

(:~
 : The index of the parser state for accessing the code of the
 : level-2-lookahead token.
 :)
declare variable $p:l2 := 7;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-2-lookahead token.
 :)
declare variable $p:b2 := 8;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-2-lookahead token.
 :)
declare variable $p:e2 := 9;

(:~
 : The index of the parser state for accessing the code of the
 : level-3-lookahead token.
 :)
declare variable $p:l3 := 10;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-3-lookahead token.
 :)
declare variable $p:b3 := 11;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-3-lookahead token.
 :)
declare variable $p:e3 := 12;

(:~
 : The index of the parser state for accessing the token code that
 : was expected when an error was found.
 :)
declare variable $p:error := 13;

(:~
 : The index of the parser state that points to the first entry
 : used for collecting action results.
 :)
declare variable $p:result := 14;

(:~
 : Create a textual error message from a parsing error.
 :
 : @param $input the input string.
 : @param $error the parsing error descriptor.
 : @return the error message.
 :)
declare function p:error-message($input as xs:string, $error as element(error)) as xs:string
{
  let $begin := xs:integer($error/@b)
  let $context := string-to-codepoints(substring($input, 1, $begin - 1))
  let $linefeeds := index-of($context, 10)
  let $line := count($linefeeds) + 1
  let $column := ($begin - $linefeeds[last()], $begin)[1]
  return
    if ($error/@o) then
      concat
      (
        "syntax error, found ", $p:TOKEN[$error/@o + 1], "&#10;",
        "while expecting ", $p:TOKEN[$error/@x + 1], "&#10;",
        "after scanning ", string($error/@e - $begin), " characters at line ",
        string($line), ", column ", string($column), "&#10;",
        "...", substring($input, $begin, 32), "..."
      )
    else
      let $expected := p:expected-token-set($error/@s)
      return
        concat
        (
          "lexical analysis failed&#10;",
          "while expecting ",
          "["[exists($expected[2])],
          string-join($expected, ", "),
          "]"[exists($expected[2])],
          "&#10;",
          "after scanning ", string($error/@e - $begin), " characters at line ",
          string($line), ", column ", string($column), "&#10;",
          "...", substring($input, $begin, 32), "..."
        )
};

(:~
 : Shift one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : parser state.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:shift($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] = $code) then
  (
    $state[position() >= $p:l1 and position() <= $p:e3],
    0,
    $state[$p:e3],
    $state[position() >= $p:e3],
    if ($state[$p:e0] != $state[$p:b1]) then
      text {substring($input, $state[$p:e0], $state[$p:b1] - $state[$p:e0])}
    else
      (),
    let $name := $p:TOKEN[1 + $state[$p:l1]]
    let $content := substring($input, $state[$p:b1], $state[$p:e1] - $state[$p:b1])
    return
      if (starts-with($name, "'")) then
		    element TOKEN {$content}
	    else
	      element {$name} {$content}
  )
  else
  (
    $state[position() < $p:error],
    element error
    {
      attribute b {$state[$p:b1]},
      attribute e {$state[$p:e1]},
      if ($state[$p:l1] < 0) then
        attribute s {- $state[$p:l1]}
      else
        (attribute o {$state[$p:l1]}, attribute x {$code})
    },
    $state[position() > $p:error]
  )
};

(:~
 : Use p:match to fetch the next token, but skip any leading
 : whitespace.
 :
 : @param $input the input string.
 : @param $begin the index where to start.
 : @param $token-set the valid token set id.
 : @return a sequence of three values: the token code of the result
 : token, with input string positions of token begin and end.
 :)
declare function p:matchW($input as xs:string,
                          $begin as xs:integer,
                          $token-set as xs:integer) as xs:integer+
{
  let $match := p:match($input, $begin, $token-set)
  return
    if ($match[1] = 15) then                                (: S^WS :)
      p:matchW($input, $match[3], $token-set)
    else if ($match[1] = 35) then                           (: '(.' :)
      let $state := p:parse-Whitespace($input, (0, 0, 0, $match, 0, $match[3], 0, 0, 0, 0, false()))
      return p:matchW($input, $state[$p:e0], $token-set)
    else
      $match
};

(:~
 : Lookahead one token on level 1 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead1W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] != 0) then
    $state
  else
    let $match := p:matchW($input, $state[$p:b1], $set)
    return
    (
      $match[1],
      $state[position() > $p:lk and position() < $p:l1],
      $match,
      0, $match[3], 0,
      $state[position() > $p:e2]
    )
};

(:~
 : Lookahead one token on level 2 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead2W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l2] != 0) then
      $state[position() >= $p:l2 and position() <= $p:e2]
    else
      p:matchW($input, $state[$p:b2], $set)
  return
  (
    $match[1] * 256 + $state[$p:l1],
    $state[position() > $p:lk and position() < $p:l2],
    $match,
    0, $match[3], 0,
    $state[position() > $p:e3]
  )
};

(:~
 : Lookahead one token on level 3 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead3W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l3] != 0) then
      $state[position() >= $p:l3 and position() <= $p:e3]
    else
      p:matchW($input, $state[$p:b3], $set)
  return
  (
    $match[1] * 65536 + $state[$p:lk],
    $state[position() > $p:lk and position() < $p:l3],
    $match,
    $state[position() > $p:e3]
  )
};

(:~
 : Lookahead one token on level 1.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead1($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] != 0) then
    $state
  else
    let $match := p:match($input, $state[$p:b1], $set)
    return
    (
      $match[1],
      $state[position() > $p:lk and position() < $p:l1],
      $match,
      0, $match[3], 0,
      $state[position() > $p:e2]
    )
};

(:~
 : Reduce the result stack. Pop $count element, wrap them in a
 : new element named $name, and push the new element.
 :
 : @param $state the parser state.
 : @param $name the name of the result node.
 : @param $count the number of child nodes.
 : @return the updated parser state.
 :)
declare function p:reduce($state as item()+, $name as xs:string, $count as xs:integer) as item()+
{
  $state[position() <= $count],
  element {$name}
  {
    $state[position() > $count]
  }
};

(:~
 : Parse the 1st loop of production Comment (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Comment-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(44, $input, $state)          (: CommentContents | '(.' | '.)' :)
    return
      if ($state[$p:l1] = 49) then                          (: '.)' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 20) then                      (: CommentContents :)
            let $state := p:shift(20, $input, $state)       (: CommentContents :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-Comment($input, $state)
            return $state
        return p:parse-Comment-1($input, $state)
};

(:~
 : Parse Comment.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Comment($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(35, $input, $state)                 (: '(.' :)
  let $state := p:parse-Comment-1($input, $state)
  let $state := p:shift(49, $input, $state)                 (: '.)' :)
  return p:reduce($state, "Comment", $count)
};

(:~
 : Parse the 1st loop of production Whitespace (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Whitespace-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(21, $input, $state)          (: END | S^WS | '(.' :)
    return
      if ($state[$p:l1] = 1) then                           (: END :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 15) then                      (: S^WS :)
            let $state := p:shift(15, $input, $state)       (: S^WS :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-Comment($input, $state)
            return $state
        return p:parse-Whitespace-1($input, $state)
};

(:~
 : Parse Whitespace.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Whitespace($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-Whitespace-1($input, $state)
  return p:reduce($state, "Whitespace", $count)
};

(:~
 : Parse Value.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Value($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(12, $input, $state)            (: StringLiteral | QName^Token :)
  let $state :=
    if ($state[$p:l1] = 6) then                             (: StringLiteral :)
      let $state := p:shift(6, $input, $state)              (: StringLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(18, $input, $state)             (: QName^Token :)
      return $state
  return p:reduce($state, "Value", $count)
};

(:~
 : Parse Key.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Key($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(18, $input, $state)                 (: QName^Token :)
  return p:reduce($state, "Key", $count)
};

(:~
 : Parse the 1st loop of production KeyValuePairs (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-KeyValuePairs-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(47, $input, $state)         (: S^WS | QName^Token | EOF | '(.' :)
    return
      if ($state[$p:l1] != 18) then                         (: QName^Token :)
        $state
      else
        let $state := p:parse-Key($input, $state)
        let $state := p:lookahead1W(70, $input, $state)     (: S^WS | QName^Token | EOF | '(.' | '=' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 59) then                 (: '=' :)
            let $state := p:shift(59, $input, $state)       (: '=' :)
            let $state := p:lookahead1W(45, $input, $state) (: StringLiteral | S^WS | QName^Token | '(.' :)
            let $state := p:parse-Value($input, $state)
            return $state
          else
            $state
        return p:parse-KeyValuePairs-1($input, $state)
};

(:~
 : Parse KeyValuePairs.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-KeyValuePairs($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-KeyValuePairs-1($input, $state)
  let $state := p:shift(25, $input, $state)                 (: EOF :)
  return p:reduce($state, "KeyValuePairs", $count)
};

(:~
 : Parse Separator.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Separator($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(52, $input, $state)                 (: ';' :)
  return p:reduce($state, "Separator", $count)
};

(:~
 : Parse ParamWithDefault.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParamWithDefault($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(50, $input, $state)           (: S^WS | '$' | '(.' | 'tunnel' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 160) then                      (: 'tunnel' :)
      let $state := p:shift(160, $input, $state)            (: 'tunnel' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-Param($input, $state)
  let $state := p:lookahead1W(72, $input, $state)           (: S^WS | '(.' | ')' | ',' | ':=' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 51) then                       (: ':=' :)
      let $state := p:shift(51, $input, $state)             (: ':=' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-ExprSingle($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "ParamWithDefault", $count)
};

(:~
 : Parse the 1st loop of production RuleParamList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RuleParamList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(55, $input, $state)         (: S^WS | '(.' | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | '(.' :)
        let $state := p:parse-ParamWithDefault($input, $state)
        return p:parse-RuleParamList-1($input, $state)
};

(:~
 : Parse RuleParamList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RuleParamList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ParamWithDefault($input, $state)
  let $state := p:parse-RuleParamList-1($input, $state)
  return p:reduce($state, "RuleParamList", $count)
};

(:~
 : Parse NextPathPatternOpt.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NextPathPatternOpt($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(73, $input, $state)           (: S^WS | '(.' | ')' | ';' | '|' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 171) then                      (: '|' :)
      let $state := p:shift(171, $input, $state)            (: '|' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-PathPattern($input, $state)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-NextPathPatternOpt($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "NextPathPatternOpt", $count)
};

(:~
 : Parse KeyValue.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-KeyValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(80, $input, $state)            (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | '$' :)
  let $state :=
    if ($state[$p:l1] = 31) then                            (: '$' :)
      let $state := p:parse-VarRef($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-Literal($input, $state)
      return $state
  return p:reduce($state, "KeyValue", $count)
};

(:~
 : Parse IdValue.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IdValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(13, $input, $state)            (: StringLiteral | '$' :)
  let $state :=
    if ($state[$p:l1] = 6) then                             (: StringLiteral :)
      let $state := p:shift(6, $input, $state)              (: StringLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-VarRef($input, $state)
      return $state
  return p:reduce($state, "IdValue", $count)
};

(:~
 : Parse IdKeyPattern.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IdKeyPattern($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 112) then                           (: 'id' :)
      let $state := p:shift(112, $input, $state)            (: 'id' :)
      let $state := p:lookahead1W(27, $input, $state)       (: S^WS | '(' | '(.' :)
      let $state := p:shift(33, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-IdValue($input, $state)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | '(.' | ')' :)
      let $state := p:shift(36, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(122, $input, $state)            (: 'key' :)
      let $state := p:lookahead1W(27, $input, $state)       (: S^WS | '(' | '(.' :)
      let $state := p:shift(33, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(22, $input, $state)       (: StringLiteral | S^WS | '(.' :)
      let $state := p:shift(6, $input, $state)              (: StringLiteral :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | '(.' | ',' :)
      let $state := p:shift(41, $input, $state)             (: ',' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-KeyValue($input, $state)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | '(.' | ')' :)
      let $state := p:shift(36, $input, $state)             (: ')' :)
      return $state
  return p:reduce($state, "IdKeyPattern", $count)
};

(:~
 : Parse PatternAxis.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PatternAxis($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 82) then                            (: 'child' :)
      let $state := p:shift(82, $input, $state)             (: 'child' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | '(.' | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 75) then                       (: 'attribute' :)
      let $state := p:shift(75, $input, $state)             (: 'attribute' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | '(.' | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(65, $input, $state)             (: '@' :)
      return $state
  return p:reduce($state, "PatternAxis", $count)
};

(:~
 : Parse PatternStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PatternStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(130, $input, $state)          (: S^WS | QName^Token | Wildcard | '(.' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 75) then                            (: 'attribute' :)
      let $state := p:lookahead2W(92, $input, $state)       (: S^WS | '(' | '(.' | ')' | '/' | '//' | '::' | ';' | '[' |
                                                               '|' :)
      return $state
    else if ($state[$p:l1] = 82) then                       (: 'child' :)
      let $state := p:lookahead2W(90, $input, $state)       (: S^WS | '(.' | ')' | '/' | '//' | '::' | ';' | '[' | '|' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 65                             (: '@' :)
          or $state[$p:lk] = 12875                          (: 'attribute' '::' :)
          or $state[$p:lk] = 12882) then                    (: 'child' '::' :)
      let $state := p:parse-PatternAxis($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-NodeTest($input, $state)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-PredicateList($input, $state)
  return p:reduce($state, "PatternStep", $count)
};

(:~
 : Parse RelativePathPattern.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RelativePathPattern($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-PatternStep($input, $state)
  let $state := p:lookahead1W(84, $input, $state)           (: S^WS | '(.' | ')' | '/' | '//' | ';' | '|' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 46                             (: '/' :)
          or $state[$p:l1] = 47) then                       (: '//' :)
      let $state :=
        if ($state[$p:l1] = 46) then                        (: '/' :)
          let $state := p:shift(46, $input, $state)         (: '/' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(47, $input, $state)         (: '//' :)
          return $state
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-RelativePathPattern($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "RelativePathPattern", $count)
};

(:~
 : Parse PathPattern.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PathPattern($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(137, $input, $state)          (: S^WS | QName^Token | Wildcard | '(.' | '/' | '//' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'id' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'key' | 'le' |
                                                               'let' | 'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 46) then                            (: '/' :)
      let $state := p:shift(46, $input, $state)             (: '/' :)
      let $state := p:lookahead1W(136, $input, $state)      (: S^WS | QName^Token | Wildcard | '(.' | ')' | ';' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'ne' | 'node' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' | '|' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] != 36                        (: ')' :)
             and $state[$p:l1] != 52                        (: ';' :)
             and $state[$p:l1] != 171) then                 (: '|' :)
          let $state := p:parse-RelativePathPattern($input, $state)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 47) then                       (: '//' :)
      let $state := p:shift(47, $input, $state)             (: '//' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-RelativePathPattern($input, $state)
      return $state
    else if ($state[$p:l1] = 112                            (: 'id' :)
          or $state[$p:l1] = 122) then                      (: 'key' :)
      let $state := p:parse-IdKeyPattern($input, $state)
      let $state := p:lookahead1W(84, $input, $state)       (: S^WS | '(.' | ')' | '/' | '//' | ';' | '|' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 46                         (: '/' :)
              or $state[$p:l1] = 47) then                   (: '//' :)
          let $state :=
            if ($state[$p:l1] = 46) then                    (: '/' :)
              let $state := p:shift(46, $input, $state)     (: '/' :)
              return $state
            else if ($state[$p:error]) then
              $state
            else
              let $state := p:shift(47, $input, $state)     (: '//' :)
              return $state
          let $state := p:lookahead1W(20, $input, $state)   (: EPSILON | S^WS | '(.' :)
          let $state := p:parse-RelativePathPattern($input, $state)
          return $state
        else
          $state
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-RelativePathPattern($input, $state)
      return $state
  return p:reduce($state, "PathPattern", $count)
};

(:~
 : Parse Pattern.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Pattern($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-PathPattern($input, $state)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-NextPathPatternOpt($input, $state)
  return p:reduce($state, "Pattern", $count)
};

(:~
 : Parse the 1st loop of production RuleDecl (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RuleDecl-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(53, $input, $state)         (: S^WS | '(' | '(.' | '|' :)
    return
      if ($state[$p:l1] != 171) then                        (: '|' :)
        $state
      else
        let $state := p:shift(171, $input, $state)          (: '|' :)
        let $state := p:lookahead1W(131, $input, $state)    (: S^WS | QName^Token | '#current' | '#default' | '(.' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'ne' | 'node' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
        let $state := p:parse-ModeName($input, $state)
        return p:parse-RuleDecl-1($input, $state)
};

(:~
 : Parse RuleDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RuleDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(68, $input, $state)                 (: '^' :)
  let $state := p:lookahead1W(135, $input, $state)          (: S^WS | QName^Token | '#current' | '#default' | '(' |
                                                               '(.' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 33) then                      (: '(' :)
      let $state := p:parse-ModeName($input, $state)
      let $state := p:parse-RuleDecl-1($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | '(.' :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-Pattern($input, $state)
  let $state := p:lookahead1W(56, $input, $state)           (: S^WS | '(.' | ')' | ';' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 52) then                       (: ';' :)
      let $state := p:shift(52, $input, $state)             (: ';' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-RuleParamList($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | '(.' | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(69, $input, $state)           (: IntegerLiteral | DecimalLiteral | S^WS | '(.' | ':=' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 51) then                      (: ':=' :)
      let $state :=
        if ($state[$p:l1] = 3) then                         (: IntegerLiteral :)
          let $state := p:shift(3, $input, $state)          (: IntegerLiteral :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(4, $input, $state)          (: DecimalLiteral :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(31, $input, $state)           (: S^WS | '(.' | ':=' :)
  let $state := p:shift(51, $input, $state)                 (: ':=' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-Expr($input, $state)
  return p:reduce($state, "RuleDecl", $count)
};

(:~
 : Parse the 1st loop of production ParamList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParamList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(55, $input, $state)         (: S^WS | '(.' | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | '(.' :)
        let $state := p:parse-Param($input, $state)
        return p:parse-ParamList-1($input, $state)
};

(:~
 : Parse ParamList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParamList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-Param($input, $state)
  let $state := p:parse-ParamList-1($input, $state)
  return p:reduce($state, "ParamList", $count)
};

(:~
 : Parse FunctionDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-FunctionName($input, $state)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | '(.' :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(48, $input, $state)           (: S^WS | '$' | '(.' | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:parse-ParamList($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | '(.' | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(60, $input, $state)           (: S^WS | '(.' | ':=' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 72) then                       (: 'as' :)
      let $state := p:shift(72, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(31, $input, $state)           (: S^WS | '(.' | ':=' :)
  let $state := p:shift(51, $input, $state)                 (: ':=' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-Expr($input, $state)
  return p:reduce($state, "FunctionDecl", $count)
};

(:~
 : Parse NodeComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NodeComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 120) then                           (: 'is' :)
      let $state := p:shift(120, $input, $state)            (: 'is' :)
      return $state
    else if ($state[$p:l1] = 56) then                       (: '<<' :)
      let $state := p:shift(56, $input, $state)             (: '<<' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(62, $input, $state)             (: '>>' :)
      return $state
  return p:reduce($state, "NodeComp", $count)
};

(:~
 : Parse GeneralComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-GeneralComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 59) then                            (: '=' :)
      let $state := p:shift(59, $input, $state)             (: '=' :)
      return $state
    else if ($state[$p:l1] = 26) then                       (: '!=' :)
      let $state := p:shift(26, $input, $state)             (: '!=' :)
      return $state
    else if ($state[$p:l1] = 53) then                       (: '<' :)
      let $state := p:shift(53, $input, $state)             (: '<' :)
      return $state
    else if ($state[$p:l1] = 57) then                       (: '<=' :)
      let $state := p:shift(57, $input, $state)             (: '<=' :)
      return $state
    else if ($state[$p:l1] = 60) then                       (: '>' :)
      let $state := p:shift(60, $input, $state)             (: '>' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(61, $input, $state)             (: '>=' :)
      return $state
  return p:reduce($state, "GeneralComp", $count)
};

(:~
 : Parse ValueComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValueComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 101) then                           (: 'eq' :)
      let $state := p:shift(101, $input, $state)            (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 131) then                      (: 'ne' :)
      let $state := p:shift(131, $input, $state)            (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 127) then                      (: 'lt' :)
      let $state := p:shift(127, $input, $state)            (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 124) then                      (: 'le' :)
      let $state := p:shift(124, $input, $state)            (: 'le' :)
      return $state
    else if ($state[$p:l1] = 111) then                      (: 'gt' :)
      let $state := p:shift(111, $input, $state)            (: 'gt' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(109, $input, $state)            (: 'ge' :)
      return $state
  return p:reduce($state, "ValueComp", $count)
};

(:~
 : Parse SingleType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SingleType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(122, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-AtomicType($input, $state)
  let $state := p:lookahead1W(107, $input, $state)          (: S^WS | '!=' | '(.' | ')' | '*' | '+' | ',' | '-' | ';' |
                                                               '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | '?' | ']' |
                                                               'and' | 'ascending' | 'case' | 'castable' | 'collation' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'eq' | 'except' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 63) then                       (: '?' :)
      let $state := p:shift(63, $input, $state)             (: '?' :)
      return $state
    else
      $state
  return p:reduce($state, "SingleType", $count)
};

(:~
 : Parse Pragma.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Pragma($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(6, $input, $state)             (: '(#' :)
  let $state := p:shift(34, $input, $state)                 (: '(#' :)
  let $state := p:lookahead1(123, $input, $state)           (: S | QName^Token | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 14) then                       (: S :)
      let $state := p:shift(14, $input, $state)             (: S :)
      return $state
    else
      $state
  let $state := p:lookahead1(122, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-QName($input, $state)
  let $state := p:lookahead1(14, $input, $state)            (: S | '#)' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 14) then                       (: S :)
      let $state := p:shift(14, $input, $state)             (: S :)
      let $state := p:lookahead1(2, $input, $state)         (: PragmaContents :)
      let $state := p:shift(21, $input, $state)             (: PragmaContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(4, $input, $state)             (: '#)' :)
  let $state := p:shift(28, $input, $state)                 (: '#)' :)
  return p:reduce($state, "Pragma", $count)
};

(:~
 : Parse the 1st loop of production ExtensionExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ExtensionExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:parse-Pragma($input, $state)
    let $state := p:lookahead1W(54, $input, $state)         (: S^WS | '(#' | '(.' | '{' :)
    return
      if ($state[$p:l1] != 34) then                         (: '(#' :)
        $state
      else
        p:parse-ExtensionExpr-1($input, $state)
};

(:~
 : Parse ExtensionExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ExtensionExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ExtensionExpr-1($input, $state)
  let $state := p:shift(169, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(142, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | '(.' | '+' | '-' | '.' |
                                                               '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' | '^' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'copy' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 172) then                     (: '}' :)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | '(.' | '}' :)
  let $state := p:shift(172, $input, $state)                (: '}' :)
  return p:reduce($state, "ExtensionExpr", $count)
};

(:~
 : Parse AbbrevForwardStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AbbrevForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 65) then                       (: '@' :)
      let $state := p:shift(65, $input, $state)             (: '@' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-NodeTest($input, $state)
  return p:reduce($state, "AbbrevForwardStep", $count)
};

(:~
 : Parse ForwardAxis.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForwardAxis($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 82) then                            (: 'child' :)
      let $state := p:shift(82, $input, $state)             (: 'child' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | '(.' | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 90) then                       (: 'descendant' :)
      let $state := p:shift(90, $input, $state)             (: 'descendant' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | '(.' | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 75) then                       (: 'attribute' :)
      let $state := p:shift(75, $input, $state)             (: 'attribute' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | '(.' | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 151) then                      (: 'self' :)
      let $state := p:shift(151, $input, $state)            (: 'self' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | '(.' | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 91) then                       (: 'descendant-or-self' :)
      let $state := p:shift(91, $input, $state)             (: 'descendant-or-self' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | '(.' | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 106) then                      (: 'following-sibling' :)
      let $state := p:shift(106, $input, $state)            (: 'following-sibling' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | '(.' | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(105, $input, $state)            (: 'following' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | '(.' | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
  return p:reduce($state, "ForwardAxis", $count)
};

(:~
 : Parse ForwardStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 75) then                            (: 'attribute' :)
      let $state := p:lookahead2W(117, $input, $state)      (: S^WS | '!=' | '(' | '(.' | ')' | '*' | '+' | ',' | '-' |
                                                               '/' | '//' | '::' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 82                             (: 'descendant' :)
          or $state[$p:l1] = 90                             (: 'descendant-or-self' :)
          or $state[$p:l1] = 91                             (: 'following' :)
          or $state[$p:l1] = 105                            (: 'following-sibling' :)
          or $state[$p:l1] = 106                            (: 'self' :)
          or $state[$p:l1] = 151) then                      (: 'self' :)
      let $state := p:lookahead2W(115, $input, $state)      (: S^WS | '!=' | '(.' | ')' | '*' | '+' | ',' | '-' | '/' |
                                                               '//' | '::' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 12875                               (: 'attribute' '::' :)
     or $state[$p:lk] = 12882                               (: 'child' '::' :)
     or $state[$p:lk] = 12890                               (: 'descendant' '::' :)
     or $state[$p:lk] = 12891                               (: 'descendant-or-self' '::' :)
     or $state[$p:lk] = 12905                               (: 'following' '::' :)
     or $state[$p:lk] = 12906                               (: 'following-sibling' '::' :)
     or $state[$p:lk] = 12951) then                         (: 'self' '::' :)
      let $state := p:parse-ForwardAxis($input, $state)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-NodeTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AbbrevForwardStep($input, $state)
      return $state
  return p:reduce($state, "ForwardStep", $count)
};

(:~
 : Parse AbbrevReverseStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AbbrevReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(45, $input, $state)                 (: '..' :)
  return p:reduce($state, "AbbrevReverseStep", $count)
};

(:~
 : Parse NameTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NameTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 24) then                            (: Wildcard :)
      let $state := p:shift(24, $input, $state)             (: Wildcard :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-QName($input, $state)
      return $state
  return p:reduce($state, "NameTest", $count)
};

(:~
 : Parse NodeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NodeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(124, $input, $state)           (: QName^Token | Wildcard | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 75                                  (: 'comment' :)
     or $state[$p:l1] = 84                                  (: 'document-node' :)
     or $state[$p:l1] = 95                                  (: 'element' :)
     or $state[$p:l1] = 96                                  (: 'node' :)
     or $state[$p:l1] = 134                                 (: 'processing-instruction' :)
     or $state[$p:l1] = 145                                 (: 'schema-attribute' :)
     or $state[$p:l1] = 149                                 (: 'schema-element' :)
     or $state[$p:l1] = 150                                 (: 'text' :)
     or $state[$p:l1] = 156) then                           (: 'text' :)
      let $state := p:lookahead2W(114, $input, $state)      (: S^WS | '!=' | '(' | '(.' | ')' | '*' | '+' | ',' | '-' |
                                                               '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 8523                                (: 'attribute' '(' :)
     or $state[$p:lk] = 8532                                (: 'comment' '(' :)
     or $state[$p:lk] = 8543                                (: 'document-node' '(' :)
     or $state[$p:lk] = 8544                                (: 'element' '(' :)
     or $state[$p:lk] = 8582                                (: 'node' '(' :)
     or $state[$p:lk] = 8593                                (: 'processing-instruction' '(' :)
     or $state[$p:lk] = 8597                                (: 'schema-attribute' '(' :)
     or $state[$p:lk] = 8598                                (: 'schema-element' '(' :)
     or $state[$p:lk] = 8604) then                          (: 'text' '(' :)
      let $state := p:parse-KindTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NameTest($input, $state)
      return $state
  return p:reduce($state, "NodeTest", $count)
};

(:~
 : Parse ReverseAxis.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ReverseAxis($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 141) then                           (: 'parent' :)
      let $state := p:shift(141, $input, $state)            (: 'parent' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | '(.' | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 69) then                       (: 'ancestor' :)
      let $state := p:shift(69, $input, $state)             (: 'ancestor' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | '(.' | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'preceding-sibling' :)
      let $state := p:shift(143, $input, $state)            (: 'preceding-sibling' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | '(.' | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 142) then                      (: 'preceding' :)
      let $state := p:shift(142, $input, $state)            (: 'preceding' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | '(.' | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(70, $input, $state)             (: 'ancestor-or-self' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | '(.' | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
  return p:reduce($state, "ReverseAxis", $count)
};

(:~
 : Parse ReverseStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 45) then                            (: '..' :)
      let $state := p:parse-AbbrevReverseStep($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ReverseAxis($input, $state)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-NodeTest($input, $state)
      return $state
  return p:reduce($state, "ReverseStep", $count)
};

(:~
 : Parse AxisStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AxisStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 69                                  (: 'ancestor-or-self' :)
     or $state[$p:l1] = 70                                  (: 'parent' :)
     or $state[$p:l1] = 141                                 (: 'preceding' :)
     or $state[$p:l1] = 142                                 (: 'preceding-sibling' :)
     or $state[$p:l1] = 143) then                           (: 'preceding-sibling' :)
      let $state := p:lookahead2W(115, $input, $state)      (: S^WS | '!=' | '(.' | ')' | '*' | '+' | ',' | '-' | '/' |
                                                               '//' | '::' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 45                                  (: '..' :)
     or $state[$p:lk] = 12869                               (: 'ancestor' '::' :)
     or $state[$p:lk] = 12870                               (: 'ancestor-or-self' '::' :)
     or $state[$p:lk] = 12941                               (: 'parent' '::' :)
     or $state[$p:lk] = 12942                               (: 'preceding' '::' :)
     or $state[$p:lk] = 12943) then                         (: 'preceding-sibling' '::' :)
      let $state := p:parse-ReverseStep($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ForwardStep($input, $state)
      return $state
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-PredicateList($input, $state)
  return p:reduce($state, "AxisStep", $count)
};

(:~
 : Parse Predicate.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Predicate($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(66, $input, $state)                 (: '[' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(33, $input, $state)           (: S^WS | '(.' | ']' :)
  let $state := p:shift(67, $input, $state)                 (: ']' :)
  return p:reduce($state, "Predicate", $count)
};

(:~
 : Parse the 1st loop of production PredicateList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PredicateList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(111, $input, $state)        (: S^WS | '!=' | '(.' | ')' | '*' | '+' | ',' | '-' | '/' |
                                                               '//' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
    return
      if ($state[$p:l1] != 66) then                         (: '[' :)
        $state
      else
        let $state := p:parse-Predicate($input, $state)
        return p:parse-PredicateList-1($input, $state)
};

(:~
 : Parse PredicateList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PredicateList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-PredicateList-1($input, $state)
  return p:reduce($state, "PredicateList", $count)
};

(:~
 : Parse Param.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Param($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(5, $input, $state)             (: '$' :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(125, $input, $state)          (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-QName($input, $state)
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | '(.' | ')' | ',' | ':=' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 72) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "Param", $count)
};

(:~
 : Parse InitializedParam.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InitializedParam($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(50, $input, $state)           (: S^WS | '$' | '(.' | 'tunnel' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 160) then                      (: 'tunnel' :)
      let $state := p:shift(160, $input, $state)            (: 'tunnel' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-Param($input, $state)
  let $state := p:lookahead1W(31, $input, $state)           (: S^WS | '(.' | ':=' :)
  let $state := p:shift(51, $input, $state)                 (: ':=' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "InitializedParam", $count)
};

(:~
 : Parse the 1st loop of production RulesetCallParamList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RulesetCallParamList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(55, $input, $state)         (: S^WS | '(.' | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | '(.' :)
        let $state := p:parse-InitializedParam($input, $state)
        return p:parse-RulesetCallParamList-1($input, $state)
};

(:~
 : Parse RulesetCallParamList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RulesetCallParamList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-InitializedParam($input, $state)
  let $state := p:parse-RulesetCallParamList-1($input, $state)
  return p:reduce($state, "RulesetCallParamList", $count)
};

(:~
 : Parse ModeName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ModeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(126, $input, $state)           (: QName^Token | '#current' | '#default' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 29) then                            (: '#current' :)
      let $state := p:shift(29, $input, $state)             (: '#current' :)
      return $state
    else if ($state[$p:l1] = 30) then                       (: '#default' :)
      let $state := p:shift(30, $input, $state)             (: '#default' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-QName($input, $state)
      return $state
  return p:reduce($state, "ModeName", $count)
};

(:~
 : Parse RulesetCall.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RulesetCall($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(68, $input, $state)                 (: '^' :)
  let $state := p:lookahead1W(135, $input, $state)          (: S^WS | QName^Token | '#current' | '#default' | '(' |
                                                               '(.' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 33) then                      (: '(' :)
      let $state := p:parse-ModeName($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | '(.' :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(144, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | '(.' | ')' | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | ';' | '<' | '<!--' | '<?' |
                                                               '@' | '^' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36                            (: ')' :)
         and $state[$p:l1] != 52) then                      (: ';' :)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(56, $input, $state)           (: S^WS | '(.' | ')' | ';' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 52) then                       (: ';' :)
      let $state := p:shift(52, $input, $state)             (: ';' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-RulesetCallParamList($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | '(.' | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "RulesetCall", $count)
};

(:~
 : Parse CompCopyConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompCopyConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(86, $input, $state)                 (: 'copy' :)
  let $state := p:lookahead1W(42, $input, $state)           (: S^WS | '(.' | '{' :)
  let $state := p:shift(169, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | '(.' | '}' :)
  let $state := p:shift(172, $input, $state)                (: '}' :)
  return p:reduce($state, "CompCopyConstructor", $count)
};

(:~
 : Parse CompPIConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(145, $input, $state)                (: 'processing-instruction' :)
  let $state := p:lookahead1W(96, $input, $state)           (: S^WS | NCName^Token | '(.' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '{' :)
  let $state :=
    if ($state[$p:l1] = 169) then                           (: '{' :)
      let $state := p:shift(169, $input, $state)            (: '{' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-Expr($input, $state)
      let $state := p:lookahead1W(43, $input, $state)       (: S^WS | '(.' | '}' :)
      let $state := p:shift(172, $input, $state)            (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NCName($input, $state)
      return $state
  let $state := p:lookahead1W(42, $input, $state)           (: S^WS | '(.' | '{' :)
  let $state := p:shift(169, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(142, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | '(.' | '+' | '-' | '.' |
                                                               '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' | '^' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'copy' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 172) then                     (: '}' :)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | '(.' | '}' :)
  let $state := p:shift(172, $input, $state)                (: '}' :)
  return p:reduce($state, "CompPIConstructor", $count)
};

(:~
 : Parse CompCommentConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(84, $input, $state)                 (: 'comment' :)
  let $state := p:lookahead1W(42, $input, $state)           (: S^WS | '(.' | '{' :)
  let $state := p:shift(169, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | '(.' | '}' :)
  let $state := p:shift(172, $input, $state)                (: '}' :)
  return p:reduce($state, "CompCommentConstructor", $count)
};

(:~
 : Parse CompTextConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompTextConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(156, $input, $state)                (: 'text' :)
  let $state := p:lookahead1W(42, $input, $state)           (: S^WS | '(.' | '{' :)
  let $state := p:shift(169, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | '(.' | '}' :)
  let $state := p:shift(172, $input, $state)                (: '}' :)
  return p:reduce($state, "CompTextConstructor", $count)
};

(:~
 : Parse CompAttrConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompAttrConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(75, $input, $state)                 (: 'attribute' :)
  let $state := p:lookahead1W(129, $input, $state)          (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
  let $state :=
    if ($state[$p:l1] = 169) then                           (: '{' :)
      let $state := p:shift(169, $input, $state)            (: '{' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-Expr($input, $state)
      let $state := p:lookahead1W(43, $input, $state)       (: S^WS | '(.' | '}' :)
      let $state := p:shift(172, $input, $state)            (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-QName($input, $state)
      return $state
  let $state := p:lookahead1W(42, $input, $state)           (: S^WS | '(.' | '{' :)
  let $state := p:shift(169, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(142, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | '(.' | '+' | '-' | '.' |
                                                               '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' | '^' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'copy' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 172) then                     (: '}' :)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | '(.' | '}' :)
  let $state := p:shift(172, $input, $state)                (: '}' :)
  return p:reduce($state, "CompAttrConstructor", $count)
};

(:~
 : Parse ContentExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ContentExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-Expr($input, $state)
  return p:reduce($state, "ContentExpr", $count)
};

(:~
 : Parse CompElemConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(96, $input, $state)                 (: 'element' :)
  let $state := p:lookahead1W(129, $input, $state)          (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
  let $state :=
    if ($state[$p:l1] = 169) then                           (: '{' :)
      let $state := p:shift(169, $input, $state)            (: '{' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-Expr($input, $state)
      let $state := p:lookahead1W(43, $input, $state)       (: S^WS | '(.' | '}' :)
      let $state := p:shift(172, $input, $state)            (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-QName($input, $state)
      return $state
  let $state := p:lookahead1W(42, $input, $state)           (: S^WS | '(.' | '{' :)
  let $state := p:shift(169, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(142, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | '(.' | '+' | '-' | '.' |
                                                               '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' | '^' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'copy' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 172) then                     (: '}' :)
      let $state := p:parse-ContentExpr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | '(.' | '}' :)
  let $state := p:shift(172, $input, $state)                (: '}' :)
  return p:reduce($state, "CompElemConstructor", $count)
};

(:~
 : Parse CompDocConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompDocConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(94, $input, $state)                 (: 'document' :)
  let $state := p:lookahead1W(42, $input, $state)           (: S^WS | '(.' | '{' :)
  let $state := p:shift(169, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | '(.' | '}' :)
  let $state := p:shift(172, $input, $state)                (: '}' :)
  return p:reduce($state, "CompDocConstructor", $count)
};

(:~
 : Parse ComputedConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ComputedConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 94) then                            (: 'document' :)
      let $state := p:parse-CompDocConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 96) then                       (: 'element' :)
      let $state := p:parse-CompElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 75) then                       (: 'attribute' :)
      let $state := p:parse-CompAttrConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 156) then                      (: 'text' :)
      let $state := p:parse-CompTextConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'comment' :)
      let $state := p:parse-CompCommentConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'processing-instruction' :)
      let $state := p:parse-CompPIConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CompCopyConstructor($input, $state)
      return $state
  return p:reduce($state, "ComputedConstructor", $count)
};

(:~
 : Parse DirPIConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(58, $input, $state)                 (: '<?' :)
  let $state := p:lookahead1(1, $input, $state)             (: PITarget :)
  let $state := p:shift(19, $input, $state)                 (: PITarget :)
  let $state := p:lookahead1(17, $input, $state)            (: S | '?>' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 14) then                       (: S :)
      let $state := p:shift(14, $input, $state)             (: S :)
      let $state := p:lookahead1(3, $input, $state)         (: DirPIContents :)
      let $state := p:shift(22, $input, $state)             (: DirPIContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(10, $input, $state)            (: '?>' :)
  let $state := p:shift(64, $input, $state)                 (: '?>' :)
  return p:reduce($state, "DirPIConstructor", $count)
};

(:~
 : Parse DirCommentConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(54, $input, $state)                 (: '<!--' :)
  let $state := p:lookahead1(0, $input, $state)             (: DirCommentContents :)
  let $state := p:shift(2, $input, $state)                  (: DirCommentContents :)
  let $state := p:lookahead1(7, $input, $state)             (: '-->' :)
  let $state := p:shift(43, $input, $state)                 (: '-->' :)
  return p:reduce($state, "DirCommentConstructor", $count)
};

(:~
 : Parse DirElemContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirElemContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 53                                  (: '<' :)
     or $state[$p:l1] = 54                                  (: '<!--' :)
     or $state[$p:l1] = 58) then                            (: '<?' :)
      let $state := p:parse-DirectConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 23) then                       (: CDataSection :)
      let $state := p:shift(23, $input, $state)             (: CDataSection :)
      return $state
    else if ($state[$p:l1] = 11) then                       (: ElementContentChar :)
      let $state := p:shift(11, $input, $state)             (: ElementContentChar :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CommonContent($input, $state)
      return $state
  return p:reduce($state, "DirElemContent", $count)
};

(:~
 : Parse AposAttrValueContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AposAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 13) then                            (: AposAttrContentChar :)
      let $state := p:shift(13, $input, $state)             (: AposAttrContentChar :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CommonContent($input, $state)
      return $state
  return p:reduce($state, "AposAttrValueContent", $count)
};

(:~
 : Parse EnclosedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EnclosedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(169, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | '(.' | '}' :)
  let $state := p:shift(172, $input, $state)                (: '}' :)
  return p:reduce($state, "EnclosedExpr", $count)
};

(:~
 : Parse CommonContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CommonContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 8) then                             (: PredefinedEntityRef :)
      let $state := p:shift(8, $input, $state)              (: PredefinedEntityRef :)
      return $state
    else if ($state[$p:l1] = 16) then                       (: CharRef :)
      let $state := p:shift(16, $input, $state)             (: CharRef :)
      return $state
    else if ($state[$p:l1] = 170) then                      (: '{{' :)
      let $state := p:shift(170, $input, $state)            (: '{{' :)
      return $state
    else if ($state[$p:l1] = 173) then                      (: '}}' :)
      let $state := p:shift(173, $input, $state)            (: '}}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-EnclosedExpr($input, $state)
      return $state
  return p:reduce($state, "CommonContent", $count)
};

(:~
 : Parse QuotAttrValueContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QuotAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 12) then                            (: QuotAttrContentChar :)
      let $state := p:shift(12, $input, $state)             (: QuotAttrContentChar :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CommonContent($input, $state)
      return $state
  return p:reduce($state, "QuotAttrValueContent", $count)
};

(:~
 : Parse the 1st loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeValue-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(86, $input, $state)          (: PredefinedEntityRef | EscapeQuot | QuotAttrContentChar |
                                                               CharRef | '"' | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 27) then                          (: '"' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 9) then                       (: EscapeQuot :)
            let $state := p:shift(9, $input, $state)        (: EscapeQuot :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-QuotAttrValueContent($input, $state)
            return $state
        return p:parse-DirAttributeValue-1($input, $state)
};

(:~
 : Parse the 2nd loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeValue-2($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(87, $input, $state)          (: PredefinedEntityRef | EscapeApos | AposAttrContentChar |
                                                               CharRef | "'" | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 32) then                          (: "'" :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 10) then                      (: EscapeApos :)
            let $state := p:shift(10, $input, $state)       (: EscapeApos :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-AposAttrValueContent($input, $state)
            return $state
        return p:parse-DirAttributeValue-2($input, $state)
};

(:~
 : Parse DirAttributeValue.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(18, $input, $state)            (: '"' | "'" :)
  let $state :=
    if ($state[$p:l1] = 27) then                            (: '"' :)
      let $state := p:shift(27, $input, $state)             (: '"' :)
      let $state := p:parse-DirAttributeValue-1($input, $state)
      let $state := p:shift(27, $input, $state)             (: '"' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(32, $input, $state)             (: "'" :)
      let $state := p:parse-DirAttributeValue-2($input, $state)
      let $state := p:shift(32, $input, $state)             (: "'" :)
      return $state
  return p:reduce($state, "DirAttributeValue", $count)
};

(:~
 : Parse the 1st loop of production DirAttributeList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(24, $input, $state)          (: S | '/>' | '>' :)
    return
      if ($state[$p:l1] != 14) then                         (: S :)
        $state
      else
        let $state := p:shift(14, $input, $state)           (: S :)
        let $state := p:lookahead1(127, $input, $state)     (: S | QName^Token | '/>' | '>' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] != 14                      (: S :)
               and $state[$p:l1] != 48                      (: '/>' :)
               and $state[$p:l1] != 60) then                (: '>' :)
            let $state := p:parse-QName($input, $state)
            let $state := p:lookahead1(15, $input, $state)  (: S | '=' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 14) then             (: S :)
                let $state := p:shift(14, $input, $state)   (: S :)
                return $state
              else
                $state
            let $state := p:lookahead1(8, $input, $state)   (: '=' :)
            let $state := p:shift(59, $input, $state)       (: '=' :)
            let $state := p:lookahead1(23, $input, $state)  (: S | '"' | "'" :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 14) then             (: S :)
                let $state := p:shift(14, $input, $state)   (: S :)
                return $state
              else
                $state
            let $state := p:parse-DirAttributeValue($input, $state)
            return $state
          else
            $state
        return p:parse-DirAttributeList-1($input, $state)
};

(:~
 : Parse DirAttributeList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-DirAttributeList-1($input, $state)
  return p:reduce($state, "DirAttributeList", $count)
};

(:~
 : Parse the 1st loop of production DirElemConstructor (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirElemConstructor-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(93, $input, $state)          (: PredefinedEntityRef | ElementContentChar | CharRef |
                                                               CDataSection | '<' | '<!--' | '</' | '<?' | '{' | '{{' |
                                                               '}}' :)
    return
      if ($state[$p:l1] = 55) then                          (: '</' :)
        $state
      else
        let $state := p:parse-DirElemContent($input, $state)
        return p:parse-DirElemConstructor-1($input, $state)
};

(:~
 : Parse DirElemConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(53, $input, $state)                 (: '<' :)
  let $state := p:lookahead1(122, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-QName($input, $state)
  let $state := p:parse-DirAttributeList($input, $state)
  let $state := p:lookahead1(19, $input, $state)            (: '/>' | '>' :)
  let $state :=
    if ($state[$p:l1] = 48) then                            (: '/>' :)
      let $state := p:shift(48, $input, $state)             (: '/>' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(60, $input, $state)             (: '>' :)
      let $state := p:parse-DirElemConstructor-1($input, $state)
      let $state := p:shift(55, $input, $state)             (: '</' :)
      let $state := p:lookahead1(122, $input, $state)       (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
      let $state := p:parse-QName($input, $state)
      let $state := p:lookahead1(16, $input, $state)        (: S | '>' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 14) then                   (: S :)
          let $state := p:shift(14, $input, $state)         (: S :)
          return $state
        else
          $state
      let $state := p:lookahead1(9, $input, $state)         (: '>' :)
      let $state := p:shift(60, $input, $state)             (: '>' :)
      return $state
  return p:reduce($state, "DirElemConstructor", $count)
};

(:~
 : Parse DirectConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirectConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 53) then                            (: '<' :)
      let $state := p:parse-DirElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 54) then                       (: '<!--' :)
      let $state := p:parse-DirCommentConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-DirPIConstructor($input, $state)
      return $state
  return p:reduce($state, "DirectConstructor", $count)
};

(:~
 : Parse Constructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Constructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 53                                  (: '<' :)
     or $state[$p:l1] = 54                                  (: '<!--' :)
     or $state[$p:l1] = 58) then                            (: '<?' :)
      let $state := p:parse-DirectConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ComputedConstructor($input, $state)
      return $state
  return p:reduce($state, "Constructor", $count)
};

(:~
 : Parse UnorderedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnorderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(163, $input, $state)                (: 'unordered' :)
  let $state := p:lookahead1W(42, $input, $state)           (: S^WS | '(.' | '{' :)
  let $state := p:shift(169, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | '(.' | '}' :)
  let $state := p:shift(172, $input, $state)                (: '}' :)
  return p:reduce($state, "UnorderedExpr", $count)
};

(:~
 : Parse OrderedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(139, $input, $state)                (: 'ordered' :)
  let $state := p:lookahead1W(42, $input, $state)           (: S^WS | '(.' | '{' :)
  let $state := p:shift(169, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | '(.' | '}' :)
  let $state := p:shift(172, $input, $state)                (: '}' :)
  return p:reduce($state, "OrderedExpr", $count)
};

(:~
 : Parse the 1st loop of production FunctionCall (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionCall-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(55, $input, $state)         (: S^WS | '(.' | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | '(.' :)
        let $state := p:parse-ExprSingle($input, $state)
        return p:parse-FunctionCall-1($input, $state)
};

(:~
 : Parse FunctionCall.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionCall($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-FunctionName($input, $state)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | '(.' :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(140, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | '(.' | ')' | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               '^' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36) then                      (: ')' :)
      let $state := p:parse-ExprSingle($input, $state)
      let $state := p:parse-FunctionCall-1($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | '(.' | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "FunctionCall", $count)
};

(:~
 : Parse ContextItemExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ContextItemExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(44, $input, $state)                 (: '.' :)
  return p:reduce($state, "ContextItemExpr", $count)
};

(:~
 : Parse ParenthesizedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParenthesizedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(140, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | '(.' | ')' | '+' | '-' |
                                                               '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               '^' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36) then                      (: ')' :)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | '(.' | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "ParenthesizedExpr", $count)
};

(:~
 : Parse VarRef.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarRef($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(125, $input, $state)          (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  return p:reduce($state, "VarRef", $count)
};

(:~
 : Parse NumericLiteral.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NumericLiteral($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 3) then                             (: IntegerLiteral :)
      let $state := p:shift(3, $input, $state)              (: IntegerLiteral :)
      return $state
    else if ($state[$p:l1] = 4) then                        (: DecimalLiteral :)
      let $state := p:shift(4, $input, $state)              (: DecimalLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(5, $input, $state)              (: DoubleLiteral :)
      return $state
  return p:reduce($state, "NumericLiteral", $count)
};

(:~
 : Parse Literal.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Literal($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 6) then                             (: StringLiteral :)
      let $state := p:shift(6, $input, $state)              (: StringLiteral :)
      return $state
    else if ($state[$p:l1] = 7) then                        (: TextNodeLiteral :)
      let $state := p:shift(7, $input, $state)              (: TextNodeLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NumericLiteral($input, $state)
      return $state
  return p:reduce($state, "Literal", $count)
};

(:~
 : Parse PrimaryExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PrimaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(134, $input, $state)           (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | QName^Token | '$' |
                                                               '(' | '.' | '<' | '<!--' | '<?' | '^' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'copy' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'element' | 'else' | 'empty' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'le' |
                                                               'let' | 'lt' | 'mod' | 'module' | 'ne' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'self' | 'some' | 'stable' |
                                                               'text' | 'to' | 'treat' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 94                                  (: 'ordered' :)
     or $state[$p:l1] = 139                                 (: 'unordered' :)
     or $state[$p:l1] = 163) then                           (: 'unordered' :)
      let $state := p:lookahead2W(52, $input, $state)       (: S^WS | '(' | '(.' | '{' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 3                                   (: IntegerLiteral :)
     or $state[$p:lk] = 4                                   (: DecimalLiteral :)
     or $state[$p:lk] = 5                                   (: DoubleLiteral :)
     or $state[$p:lk] = 6                                   (: StringLiteral :)
     or $state[$p:lk] = 7) then                             (: TextNodeLiteral :)
      let $state := p:parse-Literal($input, $state)
      return $state
    else if ($state[$p:lk] = 31) then                       (: '$' :)
      let $state := p:parse-VarRef($input, $state)
      return $state
    else if ($state[$p:lk] = 33) then                       (: '(' :)
      let $state := p:parse-ParenthesizedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 44) then                       (: '.' :)
      let $state := p:parse-ContextItemExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 43403) then                    (: 'ordered' '{' :)
      let $state := p:parse-OrderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 43427) then                    (: 'unordered' '{' :)
      let $state := p:parse-UnorderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 53                             (: '<' :)
          or $state[$p:lk] = 54                             (: '<!--' :)
          or $state[$p:lk] = 58                             (: '<?' :)
          or $state[$p:lk] = 75                             (: 'attribute' :)
          or $state[$p:lk] = 84                             (: 'comment' :)
          or $state[$p:lk] = 86                             (: 'copy' :)
          or $state[$p:lk] = 96                             (: 'element' :)
          or $state[$p:lk] = 145                            (: 'processing-instruction' :)
          or $state[$p:lk] = 156                            (: 'text' :)
          or $state[$p:lk] = 43358) then                    (: 'document' '{' :)
      let $state := p:parse-Constructor($input, $state)
      return $state
    else if ($state[$p:lk] = 68) then                       (: '^' :)
      let $state := p:parse-RulesetCall($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-FunctionCall($input, $state)
      return $state
  return p:reduce($state, "PrimaryExpr", $count)
};

(:~
 : Parse FilterExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FilterExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-PrimaryExpr($input, $state)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-PredicateList($input, $state)
  return p:reduce($state, "FilterExpr", $count)
};

(:~
 : Parse StepExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-StepExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(138, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(.' | '.' | '..' | '<' | '<!--' |
                                                               '<?' | '@' | '^' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' | 'copy' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 75) then                            (: 'attribute' :)
      let $state := p:lookahead2W(145, $input, $state)      (: S^WS | QName^Token | '!=' | '(' | '(.' | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | '::' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' | '|' | '}' :)
      let $state :=
        if ($state[$p:lk] = 20299) then                     (: 'attribute' 'case' :)
          let $state := p:lookahead3W(132, $input, $state)  (: S^WS | QName^Token | '$' | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
          return $state
        else if ($state[$p:lk] = 21323) then                (: 'attribute' 'collation' :)
          let $state := p:lookahead3W(46, $input, $state)   (: StringLiteral | S^WS | '(.' | '{' :)
          return $state
        else if ($state[$p:lk] = 22859) then                (: 'attribute' 'default' :)
          let $state := p:lookahead3W(71, $input, $state)   (: S^WS | '$' | '(.' | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 25163) then                (: 'attribute' 'empty' :)
          let $state := p:lookahead3W(77, $input, $state)   (: S^WS | '(.' | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] = 30283) then                (: 'attribute' 'instance' :)
          let $state := p:lookahead3W(67, $input, $state)   (: S^WS | '(.' | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] = 35403) then                (: 'attribute' 'order' :)
          let $state := p:lookahead3W(64, $input, $state)   (: S^WS | '(.' | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = 39243) then                (: 'attribute' 'stable' :)
          let $state := p:lookahead3W(68, $input, $state)   (: S^WS | '(.' | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = 18763                      (: 'attribute' 'descending' :)
              or $state[$p:lk] = 23627) then                (: 'attribute' 'descending' :)
          let $state := p:lookahead3W(85, $input, $state)   (: S^WS | '(.' | ',' | 'collation' | 'empty' | 'return' |
                                                               '{' :)
          return $state
        else if ($state[$p:lk] = 27467                      (: 'attribute' 'let' :)
              or $state[$p:lk] = 32331) then                (: 'attribute' 'let' :)
          let $state := p:lookahead3W(51, $input, $state)   (: S^WS | '$' | '(.' | '{' :)
          return $state
        else if ($state[$p:lk] = 20555                      (: 'attribute' 'castable' :)
              or $state[$p:lk] = 20811                      (: 'attribute' 'treat' :)
              or $state[$p:lk] = 40779) then                (: 'attribute' 'treat' :)
          let $state := p:lookahead3W(62, $input, $state)   (: S^WS | '(.' | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 18251                      (: 'attribute' 'div' :)
              or $state[$p:lk] = 23883                      (: 'attribute' 'else' :)
              or $state[$p:lk] = 24907                      (: 'attribute' 'eq' :)
              or $state[$p:lk] = 25931                      (: 'attribute' 'except' :)
              or $state[$p:lk] = 26443                      (: 'attribute' 'ge' :)
              or $state[$p:lk] = 27979                      (: 'attribute' 'gt' :)
              or $state[$p:lk] = 28491                      (: 'attribute' 'idiv' :)
              or $state[$p:lk] = 29003                      (: 'attribute' 'intersect' :)
              or $state[$p:lk] = 30539                      (: 'attribute' 'is' :)
              or $state[$p:lk] = 30795                      (: 'attribute' 'le' :)
              or $state[$p:lk] = 31819                      (: 'attribute' 'lt' :)
              or $state[$p:lk] = 32587                      (: 'attribute' 'mod' :)
              or $state[$p:lk] = 32843                      (: 'attribute' 'ne' :)
              or $state[$p:lk] = 33611                      (: 'attribute' 'or' :)
              or $state[$p:lk] = 35147                      (: 'attribute' 'return' :)
              or $state[$p:lk] = 37451                      (: 'attribute' 'satisfies' :)
              or $state[$p:lk] = 37707                      (: 'attribute' 'to' :)
              or $state[$p:lk] = 40523                      (: 'attribute' 'union' :)
              or $state[$p:lk] = 41547                      (: 'attribute' 'where' :)
              or $state[$p:lk] = 42827) then                (: 'attribute' 'where' :)
          let $state := p:lookahead3W(141, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | '(.' | '+' | '-' | '.' |
                                                               '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' | '^' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'copy' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 96) then                       (: 'element' :)
      let $state := p:lookahead2W(143, $input, $state)      (: S^WS | QName^Token | '!=' | '(' | '(.' | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' | '|' | '}' :)
      let $state :=
        if ($state[$p:lk] = 20320) then                     (: 'element' 'case' :)
          let $state := p:lookahead3W(132, $input, $state)  (: S^WS | QName^Token | '$' | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
          return $state
        else if ($state[$p:lk] = 21344) then                (: 'element' 'collation' :)
          let $state := p:lookahead3W(46, $input, $state)   (: StringLiteral | S^WS | '(.' | '{' :)
          return $state
        else if ($state[$p:lk] = 22880) then                (: 'element' 'default' :)
          let $state := p:lookahead3W(71, $input, $state)   (: S^WS | '$' | '(.' | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 25184) then                (: 'element' 'empty' :)
          let $state := p:lookahead3W(77, $input, $state)   (: S^WS | '(.' | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] = 30304) then                (: 'element' 'instance' :)
          let $state := p:lookahead3W(67, $input, $state)   (: S^WS | '(.' | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] = 35424) then                (: 'element' 'order' :)
          let $state := p:lookahead3W(64, $input, $state)   (: S^WS | '(.' | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = 39264) then                (: 'element' 'stable' :)
          let $state := p:lookahead3W(68, $input, $state)   (: S^WS | '(.' | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = 18784                      (: 'element' 'descending' :)
              or $state[$p:lk] = 23648) then                (: 'element' 'descending' :)
          let $state := p:lookahead3W(85, $input, $state)   (: S^WS | '(.' | ',' | 'collation' | 'empty' | 'return' |
                                                               '{' :)
          return $state
        else if ($state[$p:lk] = 27488                      (: 'element' 'let' :)
              or $state[$p:lk] = 32352) then                (: 'element' 'let' :)
          let $state := p:lookahead3W(51, $input, $state)   (: S^WS | '$' | '(.' | '{' :)
          return $state
        else if ($state[$p:lk] = 20576                      (: 'element' 'castable' :)
              or $state[$p:lk] = 20832                      (: 'element' 'treat' :)
              or $state[$p:lk] = 40800) then                (: 'element' 'treat' :)
          let $state := p:lookahead3W(62, $input, $state)   (: S^WS | '(.' | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 18272                      (: 'element' 'div' :)
              or $state[$p:lk] = 23904                      (: 'element' 'else' :)
              or $state[$p:lk] = 24928                      (: 'element' 'eq' :)
              or $state[$p:lk] = 25952                      (: 'element' 'except' :)
              or $state[$p:lk] = 26464                      (: 'element' 'ge' :)
              or $state[$p:lk] = 28000                      (: 'element' 'gt' :)
              or $state[$p:lk] = 28512                      (: 'element' 'idiv' :)
              or $state[$p:lk] = 29024                      (: 'element' 'intersect' :)
              or $state[$p:lk] = 30560                      (: 'element' 'is' :)
              or $state[$p:lk] = 30816                      (: 'element' 'le' :)
              or $state[$p:lk] = 31840                      (: 'element' 'lt' :)
              or $state[$p:lk] = 32608                      (: 'element' 'mod' :)
              or $state[$p:lk] = 32864                      (: 'element' 'ne' :)
              or $state[$p:lk] = 33632                      (: 'element' 'or' :)
              or $state[$p:lk] = 35168                      (: 'element' 'return' :)
              or $state[$p:lk] = 37472                      (: 'element' 'satisfies' :)
              or $state[$p:lk] = 37728                      (: 'element' 'to' :)
              or $state[$p:lk] = 40544                      (: 'element' 'union' :)
              or $state[$p:lk] = 41568                      (: 'element' 'where' :)
              or $state[$p:lk] = 42848) then                (: 'element' 'where' :)
          let $state := p:lookahead3W(141, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | '(.' | '+' | '-' | '.' |
                                                               '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' | '^' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'copy' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'processing-instruction' :)
      let $state := p:lookahead2W(119, $input, $state)      (: S^WS | NCName^Token | '!=' | '(' | '(.' | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'eq' | 'except' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'to' | 'treat' | 'union' |
                                                               'where' | '{' | '|' | '}' :)
      let $state :=
        if ($state[$p:lk] = 20369) then                     (: 'processing-instruction' 'case' :)
          let $state := p:lookahead3W(132, $input, $state)  (: S^WS | QName^Token | '$' | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
          return $state
        else if ($state[$p:lk] = 21393) then                (: 'processing-instruction' 'collation' :)
          let $state := p:lookahead3W(46, $input, $state)   (: StringLiteral | S^WS | '(.' | '{' :)
          return $state
        else if ($state[$p:lk] = 22929) then                (: 'processing-instruction' 'default' :)
          let $state := p:lookahead3W(71, $input, $state)   (: S^WS | '$' | '(.' | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 25233) then                (: 'processing-instruction' 'empty' :)
          let $state := p:lookahead3W(77, $input, $state)   (: S^WS | '(.' | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] = 30353) then                (: 'processing-instruction' 'instance' :)
          let $state := p:lookahead3W(67, $input, $state)   (: S^WS | '(.' | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] = 35473) then                (: 'processing-instruction' 'order' :)
          let $state := p:lookahead3W(64, $input, $state)   (: S^WS | '(.' | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = 39313) then                (: 'processing-instruction' 'stable' :)
          let $state := p:lookahead3W(68, $input, $state)   (: S^WS | '(.' | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = 18833                      (: 'processing-instruction' 'descending' :)
              or $state[$p:lk] = 23697) then                (: 'processing-instruction' 'descending' :)
          let $state := p:lookahead3W(85, $input, $state)   (: S^WS | '(.' | ',' | 'collation' | 'empty' | 'return' |
                                                               '{' :)
          return $state
        else if ($state[$p:lk] = 27537                      (: 'processing-instruction' 'let' :)
              or $state[$p:lk] = 32401) then                (: 'processing-instruction' 'let' :)
          let $state := p:lookahead3W(51, $input, $state)   (: S^WS | '$' | '(.' | '{' :)
          return $state
        else if ($state[$p:lk] = 20625                      (: 'processing-instruction' 'castable' :)
              or $state[$p:lk] = 20881                      (: 'processing-instruction' 'treat' :)
              or $state[$p:lk] = 40849) then                (: 'processing-instruction' 'treat' :)
          let $state := p:lookahead3W(62, $input, $state)   (: S^WS | '(.' | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 18321                      (: 'processing-instruction' 'div' :)
              or $state[$p:lk] = 23953                      (: 'processing-instruction' 'else' :)
              or $state[$p:lk] = 24977                      (: 'processing-instruction' 'eq' :)
              or $state[$p:lk] = 26001                      (: 'processing-instruction' 'except' :)
              or $state[$p:lk] = 26513                      (: 'processing-instruction' 'ge' :)
              or $state[$p:lk] = 28049                      (: 'processing-instruction' 'gt' :)
              or $state[$p:lk] = 28561                      (: 'processing-instruction' 'idiv' :)
              or $state[$p:lk] = 29073                      (: 'processing-instruction' 'intersect' :)
              or $state[$p:lk] = 30609                      (: 'processing-instruction' 'is' :)
              or $state[$p:lk] = 30865                      (: 'processing-instruction' 'le' :)
              or $state[$p:lk] = 31889                      (: 'processing-instruction' 'lt' :)
              or $state[$p:lk] = 32657                      (: 'processing-instruction' 'mod' :)
              or $state[$p:lk] = 32913                      (: 'processing-instruction' 'ne' :)
              or $state[$p:lk] = 33681                      (: 'processing-instruction' 'or' :)
              or $state[$p:lk] = 35217                      (: 'processing-instruction' 'return' :)
              or $state[$p:lk] = 37521                      (: 'processing-instruction' 'satisfies' :)
              or $state[$p:lk] = 37777                      (: 'processing-instruction' 'to' :)
              or $state[$p:lk] = 40593                      (: 'processing-instruction' 'union' :)
              or $state[$p:lk] = 41617                      (: 'processing-instruction' 'where' :)
              or $state[$p:lk] = 42897) then                (: 'processing-instruction' 'where' :)
          let $state := p:lookahead3W(141, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | '(.' | '+' | '-' | '.' |
                                                               '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' | '^' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'copy' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 84                             (: 'document' :)
          or $state[$p:l1] = 94                             (: 'ordered' :)
          or $state[$p:l1] = 139                            (: 'text' :)
          or $state[$p:l1] = 156                            (: 'unordered' :)
          or $state[$p:l1] = 163) then                      (: 'unordered' :)
      let $state := p:lookahead2W(118, $input, $state)      (: S^WS | '!=' | '(' | '(.' | ')' | '*' | '+' | ',' | '-' |
                                                               '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '{' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 69                             (: 'ancestor-or-self' :)
          or $state[$p:l1] = 70                             (: 'child' :)
          or $state[$p:l1] = 82                             (: 'descendant' :)
          or $state[$p:l1] = 90                             (: 'descendant-or-self' :)
          or $state[$p:l1] = 91                             (: 'following' :)
          or $state[$p:l1] = 105                            (: 'following-sibling' :)
          or $state[$p:l1] = 106                            (: 'parent' :)
          or $state[$p:l1] = 141                            (: 'preceding' :)
          or $state[$p:l1] = 142                            (: 'preceding-sibling' :)
          or $state[$p:l1] = 143                            (: 'self' :)
          or $state[$p:l1] = 151) then                      (: 'self' :)
      let $state := p:lookahead2W(117, $input, $state)      (: S^WS | '!=' | '(' | '(.' | ')' | '*' | '+' | ',' | '-' |
                                                               '/' | '//' | '::' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 18                             (: 'and' :)
          or $state[$p:l1] = 71                             (: 'ascending' :)
          or $state[$p:l1] = 73                             (: 'case' :)
          or $state[$p:l1] = 79                             (: 'cast' :)
          or $state[$p:l1] = 80                             (: 'castable' :)
          or $state[$p:l1] = 81                             (: 'collation' :)
          or $state[$p:l1] = 83                             (: 'declare' :)
          or $state[$p:l1] = 88                             (: 'default' :)
          or $state[$p:l1] = 89                             (: 'descending' :)
          or $state[$p:l1] = 92                             (: 'div' :)
          or $state[$p:l1] = 93                             (: 'else' :)
          or $state[$p:l1] = 97                             (: 'empty' :)
          or $state[$p:l1] = 98                             (: 'eq' :)
          or $state[$p:l1] = 101                            (: 'every' :)
          or $state[$p:l1] = 102                            (: 'except' :)
          or $state[$p:l1] = 103                            (: 'for' :)
          or $state[$p:l1] = 107                            (: 'ge' :)
          or $state[$p:l1] = 109                            (: 'gt' :)
          or $state[$p:l1] = 111                            (: 'idiv' :)
          or $state[$p:l1] = 113                            (: 'import' :)
          or $state[$p:l1] = 115                            (: 'instance' :)
          or $state[$p:l1] = 118                            (: 'intersect' :)
          or $state[$p:l1] = 119                            (: 'is' :)
          or $state[$p:l1] = 120                            (: 'le' :)
          or $state[$p:l1] = 124                            (: 'let' :)
          or $state[$p:l1] = 126                            (: 'lt' :)
          or $state[$p:l1] = 127                            (: 'mod' :)
          or $state[$p:l1] = 128                            (: 'module' :)
          or $state[$p:l1] = 129                            (: 'ne' :)
          or $state[$p:l1] = 131                            (: 'or' :)
          or $state[$p:l1] = 137                            (: 'order' :)
          or $state[$p:l1] = 138                            (: 'return' :)
          or $state[$p:l1] = 146                            (: 'satisfies' :)
          or $state[$p:l1] = 147                            (: 'some' :)
          or $state[$p:l1] = 152                            (: 'stable' :)
          or $state[$p:l1] = 153                            (: 'to' :)
          or $state[$p:l1] = 158                            (: 'treat' :)
          or $state[$p:l1] = 159                            (: 'union' :)
          or $state[$p:l1] = 162                            (: 'validate' :)
          or $state[$p:l1] = 164                            (: 'where' :)
          or $state[$p:l1] = 167                            (: 'xquery' :)
          or $state[$p:l1] = 168) then                      (: 'xquery' :)
      let $state := p:lookahead2W(114, $input, $state)      (: S^WS | '!=' | '(' | '(.' | ')' | '*' | '+' | ',' | '-' |
                                                               '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 3                                   (: IntegerLiteral :)
     or $state[$p:lk] = 4                                   (: DecimalLiteral :)
     or $state[$p:lk] = 5                                   (: DoubleLiteral :)
     or $state[$p:lk] = 6                                   (: StringLiteral :)
     or $state[$p:lk] = 7                                   (: TextNodeLiteral :)
     or $state[$p:lk] = 31                                  (: '$' :)
     or $state[$p:lk] = 33                                  (: '(' :)
     or $state[$p:lk] = 44                                  (: '.' :)
     or $state[$p:lk] = 53                                  (: '<' :)
     or $state[$p:lk] = 54                                  (: '<!--' :)
     or $state[$p:lk] = 58                                  (: '<?' :)
     or $state[$p:lk] = 68                                  (: '^' :)
     or $state[$p:lk] = 86                                  (: 'copy' :)
     or $state[$p:lk] = 4497                                (: 'processing-instruction' NCName^Token :)
     or $state[$p:lk] = 4683                                (: 'attribute' QName^Token :)
     or $state[$p:lk] = 4704                                (: 'element' QName^Token :)
     or $state[$p:lk] = 8466                                (: QName^Token '(' :)
     or $state[$p:lk] = 8517                                (: 'ancestor' '(' :)
     or $state[$p:lk] = 8518                                (: 'ancestor-or-self' '(' :)
     or $state[$p:lk] = 8519                                (: 'and' '(' :)
     or $state[$p:lk] = 8521                                (: 'ascending' '(' :)
     or $state[$p:lk] = 8527                                (: 'case' '(' :)
     or $state[$p:lk] = 8528                                (: 'cast' '(' :)
     or $state[$p:lk] = 8529                                (: 'castable' '(' :)
     or $state[$p:lk] = 8530                                (: 'child' '(' :)
     or $state[$p:lk] = 8531                                (: 'collation' '(' :)
     or $state[$p:lk] = 8536                                (: 'declare' '(' :)
     or $state[$p:lk] = 8537                                (: 'default' '(' :)
     or $state[$p:lk] = 8538                                (: 'descendant' '(' :)
     or $state[$p:lk] = 8539                                (: 'descendant-or-self' '(' :)
     or $state[$p:lk] = 8540                                (: 'descending' '(' :)
     or $state[$p:lk] = 8541                                (: 'div' '(' :)
     or $state[$p:lk] = 8542                                (: 'document' '(' :)
     or $state[$p:lk] = 8545                                (: 'else' '(' :)
     or $state[$p:lk] = 8546                                (: 'empty' '(' :)
     or $state[$p:lk] = 8549                                (: 'eq' '(' :)
     or $state[$p:lk] = 8550                                (: 'every' '(' :)
     or $state[$p:lk] = 8551                                (: 'except' '(' :)
     or $state[$p:lk] = 8553                                (: 'following' '(' :)
     or $state[$p:lk] = 8554                                (: 'following-sibling' '(' :)
     or $state[$p:lk] = 8555                                (: 'for' '(' :)
     or $state[$p:lk] = 8557                                (: 'ge' '(' :)
     or $state[$p:lk] = 8559                                (: 'gt' '(' :)
     or $state[$p:lk] = 8561                                (: 'idiv' '(' :)
     or $state[$p:lk] = 8563                                (: 'import' '(' :)
     or $state[$p:lk] = 8566                                (: 'instance' '(' :)
     or $state[$p:lk] = 8567                                (: 'intersect' '(' :)
     or $state[$p:lk] = 8568                                (: 'is' '(' :)
     or $state[$p:lk] = 8572                                (: 'le' '(' :)
     or $state[$p:lk] = 8574                                (: 'let' '(' :)
     or $state[$p:lk] = 8575                                (: 'lt' '(' :)
     or $state[$p:lk] = 8576                                (: 'mod' '(' :)
     or $state[$p:lk] = 8577                                (: 'module' '(' :)
     or $state[$p:lk] = 8579                                (: 'ne' '(' :)
     or $state[$p:lk] = 8585                                (: 'or' '(' :)
     or $state[$p:lk] = 8586                                (: 'order' '(' :)
     or $state[$p:lk] = 8587                                (: 'ordered' '(' :)
     or $state[$p:lk] = 8589                                (: 'parent' '(' :)
     or $state[$p:lk] = 8590                                (: 'preceding' '(' :)
     or $state[$p:lk] = 8591                                (: 'preceding-sibling' '(' :)
     or $state[$p:lk] = 8594                                (: 'return' '(' :)
     or $state[$p:lk] = 8595                                (: 'satisfies' '(' :)
     or $state[$p:lk] = 8599                                (: 'self' '(' :)
     or $state[$p:lk] = 8600                                (: 'some' '(' :)
     or $state[$p:lk] = 8601                                (: 'stable' '(' :)
     or $state[$p:lk] = 8606                                (: 'to' '(' :)
     or $state[$p:lk] = 8607                                (: 'treat' '(' :)
     or $state[$p:lk] = 8610                                (: 'union' '(' :)
     or $state[$p:lk] = 8611                                (: 'unordered' '(' :)
     or $state[$p:lk] = 8612                                (: 'validate' '(' :)
     or $state[$p:lk] = 8615                                (: 'where' '(' :)
     or $state[$p:lk] = 8616                                (: 'xquery' '(' :)
     or $state[$p:lk] = 17739                               (: 'attribute' 'ancestor' :)
     or $state[$p:lk] = 17760                               (: 'element' 'ancestor' :)
     or $state[$p:lk] = 17995                               (: 'attribute' 'ancestor-or-self' :)
     or $state[$p:lk] = 18016                               (: 'element' 'ancestor-or-self' :)
     or $state[$p:lk] = 19275                               (: 'attribute' 'attribute' :)
     or $state[$p:lk] = 19296                               (: 'element' 'attribute' :)
     or $state[$p:lk] = 21067                               (: 'attribute' 'child' :)
     or $state[$p:lk] = 21088                               (: 'element' 'child' :)
     or $state[$p:lk] = 21579                               (: 'attribute' 'comment' :)
     or $state[$p:lk] = 21600                               (: 'element' 'comment' :)
     or $state[$p:lk] = 22603                               (: 'attribute' 'declare' :)
     or $state[$p:lk] = 22624                               (: 'element' 'declare' :)
     or $state[$p:lk] = 23115                               (: 'attribute' 'descendant' :)
     or $state[$p:lk] = 23136                               (: 'element' 'descendant' :)
     or $state[$p:lk] = 23371                               (: 'attribute' 'descendant-or-self' :)
     or $state[$p:lk] = 23392                               (: 'element' 'descendant-or-self' :)
     or $state[$p:lk] = 24139                               (: 'attribute' 'document' :)
     or $state[$p:lk] = 24160                               (: 'element' 'document' :)
     or $state[$p:lk] = 24395                               (: 'attribute' 'document-node' :)
     or $state[$p:lk] = 24416                               (: 'element' 'document-node' :)
     or $state[$p:lk] = 24651                               (: 'attribute' 'element' :)
     or $state[$p:lk] = 24672                               (: 'element' 'element' :)
     or $state[$p:lk] = 25419                               (: 'attribute' 'empty-sequence' :)
     or $state[$p:lk] = 25440                               (: 'element' 'empty-sequence' :)
     or $state[$p:lk] = 26187                               (: 'attribute' 'every' :)
     or $state[$p:lk] = 26208                               (: 'element' 'every' :)
     or $state[$p:lk] = 26955                               (: 'attribute' 'following' :)
     or $state[$p:lk] = 26976                               (: 'element' 'following' :)
     or $state[$p:lk] = 27211                               (: 'attribute' 'following-sibling' :)
     or $state[$p:lk] = 27232                               (: 'element' 'following-sibling' :)
     or $state[$p:lk] = 29259                               (: 'attribute' 'if' :)
     or $state[$p:lk] = 29280                               (: 'element' 'if' :)
     or $state[$p:lk] = 29515                               (: 'attribute' 'import' :)
     or $state[$p:lk] = 29536                               (: 'element' 'import' :)
     or $state[$p:lk] = 31051                               (: 'attribute' 'item' :)
     or $state[$p:lk] = 31072                               (: 'element' 'item' :)
     or $state[$p:lk] = 33099                               (: 'attribute' 'module' :)
     or $state[$p:lk] = 33120                               (: 'element' 'module' :)
     or $state[$p:lk] = 34379                               (: 'attribute' 'node' :)
     or $state[$p:lk] = 34400                               (: 'element' 'node' :)
     or $state[$p:lk] = 35659                               (: 'attribute' 'ordered' :)
     or $state[$p:lk] = 35680                               (: 'element' 'ordered' :)
     or $state[$p:lk] = 36171                               (: 'attribute' 'parent' :)
     or $state[$p:lk] = 36192                               (: 'element' 'parent' :)
     or $state[$p:lk] = 36427                               (: 'attribute' 'preceding' :)
     or $state[$p:lk] = 36448                               (: 'element' 'preceding' :)
     or $state[$p:lk] = 36683                               (: 'attribute' 'preceding-sibling' :)
     or $state[$p:lk] = 36704                               (: 'element' 'preceding-sibling' :)
     or $state[$p:lk] = 37195                               (: 'attribute' 'processing-instruction' :)
     or $state[$p:lk] = 37216                               (: 'element' 'processing-instruction' :)
     or $state[$p:lk] = 38219                               (: 'attribute' 'schema-attribute' :)
     or $state[$p:lk] = 38240                               (: 'element' 'schema-attribute' :)
     or $state[$p:lk] = 38475                               (: 'attribute' 'schema-element' :)
     or $state[$p:lk] = 38496                               (: 'element' 'schema-element' :)
     or $state[$p:lk] = 38731                               (: 'attribute' 'self' :)
     or $state[$p:lk] = 38752                               (: 'element' 'self' :)
     or $state[$p:lk] = 38987                               (: 'attribute' 'some' :)
     or $state[$p:lk] = 39008                               (: 'element' 'some' :)
     or $state[$p:lk] = 40011                               (: 'attribute' 'text' :)
     or $state[$p:lk] = 40032                               (: 'element' 'text' :)
     or $state[$p:lk] = 41291                               (: 'attribute' 'typeswitch' :)
     or $state[$p:lk] = 41312                               (: 'element' 'typeswitch' :)
     or $state[$p:lk] = 41803                               (: 'attribute' 'unordered' :)
     or $state[$p:lk] = 41824                               (: 'element' 'unordered' :)
     or $state[$p:lk] = 42059                               (: 'attribute' 'validate' :)
     or $state[$p:lk] = 42080                               (: 'element' 'validate' :)
     or $state[$p:lk] = 43083                               (: 'attribute' 'xquery' :)
     or $state[$p:lk] = 43104                               (: 'element' 'xquery' :)
     or $state[$p:lk] = 43339                               (: 'attribute' '{' :)
     or $state[$p:lk] = 43348                               (: 'comment' '{' :)
     or $state[$p:lk] = 43358                               (: 'document' '{' :)
     or $state[$p:lk] = 43360                               (: 'element' '{' :)
     or $state[$p:lk] = 43403                               (: 'ordered' '{' :)
     or $state[$p:lk] = 43409                               (: 'processing-instruction' '{' :)
     or $state[$p:lk] = 43420                               (: 'text' '{' :)
     or $state[$p:lk] = 43427                               (: 'unordered' '{' :)
     or $state[$p:lk] = 11093835                            (: 'attribute' 'and' '{' :)
     or $state[$p:lk] = 11093856                            (: 'element' 'and' '{' :)
     or $state[$p:lk] = 11093905                            (: 'processing-instruction' 'and' '{' :)
     or $state[$p:lk] = 11094347                            (: 'attribute' 'ascending' '{' :)
     or $state[$p:lk] = 11094368                            (: 'element' 'ascending' '{' :)
     or $state[$p:lk] = 11094417                            (: 'processing-instruction' 'ascending' '{' :)
     or $state[$p:lk] = 11095883                            (: 'attribute' 'case' '{' :)
     or $state[$p:lk] = 11095904                            (: 'element' 'case' '{' :)
     or $state[$p:lk] = 11095953                            (: 'processing-instruction' 'case' '{' :)
     or $state[$p:lk] = 11096139                            (: 'attribute' 'cast' '{' :)
     or $state[$p:lk] = 11096160                            (: 'element' 'cast' '{' :)
     or $state[$p:lk] = 11096209                            (: 'processing-instruction' 'cast' '{' :)
     or $state[$p:lk] = 11096395                            (: 'attribute' 'castable' '{' :)
     or $state[$p:lk] = 11096416                            (: 'element' 'castable' '{' :)
     or $state[$p:lk] = 11096465                            (: 'processing-instruction' 'castable' '{' :)
     or $state[$p:lk] = 11096907                            (: 'attribute' 'collation' '{' :)
     or $state[$p:lk] = 11096928                            (: 'element' 'collation' '{' :)
     or $state[$p:lk] = 11096977                            (: 'processing-instruction' 'collation' '{' :)
     or $state[$p:lk] = 11098443                            (: 'attribute' 'default' '{' :)
     or $state[$p:lk] = 11098464                            (: 'element' 'default' '{' :)
     or $state[$p:lk] = 11098513                            (: 'processing-instruction' 'default' '{' :)
     or $state[$p:lk] = 11099211                            (: 'attribute' 'descending' '{' :)
     or $state[$p:lk] = 11099232                            (: 'element' 'descending' '{' :)
     or $state[$p:lk] = 11099281                            (: 'processing-instruction' 'descending' '{' :)
     or $state[$p:lk] = 11099467                            (: 'attribute' 'div' '{' :)
     or $state[$p:lk] = 11099488                            (: 'element' 'div' '{' :)
     or $state[$p:lk] = 11099537                            (: 'processing-instruction' 'div' '{' :)
     or $state[$p:lk] = 11100491                            (: 'attribute' 'else' '{' :)
     or $state[$p:lk] = 11100512                            (: 'element' 'else' '{' :)
     or $state[$p:lk] = 11100561                            (: 'processing-instruction' 'else' '{' :)
     or $state[$p:lk] = 11100747                            (: 'attribute' 'empty' '{' :)
     or $state[$p:lk] = 11100768                            (: 'element' 'empty' '{' :)
     or $state[$p:lk] = 11100817                            (: 'processing-instruction' 'empty' '{' :)
     or $state[$p:lk] = 11101515                            (: 'attribute' 'eq' '{' :)
     or $state[$p:lk] = 11101536                            (: 'element' 'eq' '{' :)
     or $state[$p:lk] = 11101585                            (: 'processing-instruction' 'eq' '{' :)
     or $state[$p:lk] = 11102027                            (: 'attribute' 'except' '{' :)
     or $state[$p:lk] = 11102048                            (: 'element' 'except' '{' :)
     or $state[$p:lk] = 11102097                            (: 'processing-instruction' 'except' '{' :)
     or $state[$p:lk] = 11103051                            (: 'attribute' 'for' '{' :)
     or $state[$p:lk] = 11103072                            (: 'element' 'for' '{' :)
     or $state[$p:lk] = 11103121                            (: 'processing-instruction' 'for' '{' :)
     or $state[$p:lk] = 11103563                            (: 'attribute' 'ge' '{' :)
     or $state[$p:lk] = 11103584                            (: 'element' 'ge' '{' :)
     or $state[$p:lk] = 11103633                            (: 'processing-instruction' 'ge' '{' :)
     or $state[$p:lk] = 11104075                            (: 'attribute' 'gt' '{' :)
     or $state[$p:lk] = 11104096                            (: 'element' 'gt' '{' :)
     or $state[$p:lk] = 11104145                            (: 'processing-instruction' 'gt' '{' :)
     or $state[$p:lk] = 11104587                            (: 'attribute' 'idiv' '{' :)
     or $state[$p:lk] = 11104608                            (: 'element' 'idiv' '{' :)
     or $state[$p:lk] = 11104657                            (: 'processing-instruction' 'idiv' '{' :)
     or $state[$p:lk] = 11105867                            (: 'attribute' 'instance' '{' :)
     or $state[$p:lk] = 11105888                            (: 'element' 'instance' '{' :)
     or $state[$p:lk] = 11105937                            (: 'processing-instruction' 'instance' '{' :)
     or $state[$p:lk] = 11106123                            (: 'attribute' 'intersect' '{' :)
     or $state[$p:lk] = 11106144                            (: 'element' 'intersect' '{' :)
     or $state[$p:lk] = 11106193                            (: 'processing-instruction' 'intersect' '{' :)
     or $state[$p:lk] = 11106379                            (: 'attribute' 'is' '{' :)
     or $state[$p:lk] = 11106400                            (: 'element' 'is' '{' :)
     or $state[$p:lk] = 11106449                            (: 'processing-instruction' 'is' '{' :)
     or $state[$p:lk] = 11107403                            (: 'attribute' 'le' '{' :)
     or $state[$p:lk] = 11107424                            (: 'element' 'le' '{' :)
     or $state[$p:lk] = 11107473                            (: 'processing-instruction' 'le' '{' :)
     or $state[$p:lk] = 11107915                            (: 'attribute' 'let' '{' :)
     or $state[$p:lk] = 11107936                            (: 'element' 'let' '{' :)
     or $state[$p:lk] = 11107985                            (: 'processing-instruction' 'let' '{' :)
     or $state[$p:lk] = 11108171                            (: 'attribute' 'lt' '{' :)
     or $state[$p:lk] = 11108192                            (: 'element' 'lt' '{' :)
     or $state[$p:lk] = 11108241                            (: 'processing-instruction' 'lt' '{' :)
     or $state[$p:lk] = 11108427                            (: 'attribute' 'mod' '{' :)
     or $state[$p:lk] = 11108448                            (: 'element' 'mod' '{' :)
     or $state[$p:lk] = 11108497                            (: 'processing-instruction' 'mod' '{' :)
     or $state[$p:lk] = 11109195                            (: 'attribute' 'ne' '{' :)
     or $state[$p:lk] = 11109216                            (: 'element' 'ne' '{' :)
     or $state[$p:lk] = 11109265                            (: 'processing-instruction' 'ne' '{' :)
     or $state[$p:lk] = 11110731                            (: 'attribute' 'or' '{' :)
     or $state[$p:lk] = 11110752                            (: 'element' 'or' '{' :)
     or $state[$p:lk] = 11110801                            (: 'processing-instruction' 'or' '{' :)
     or $state[$p:lk] = 11110987                            (: 'attribute' 'order' '{' :)
     or $state[$p:lk] = 11111008                            (: 'element' 'order' '{' :)
     or $state[$p:lk] = 11111057                            (: 'processing-instruction' 'order' '{' :)
     or $state[$p:lk] = 11113035                            (: 'attribute' 'return' '{' :)
     or $state[$p:lk] = 11113056                            (: 'element' 'return' '{' :)
     or $state[$p:lk] = 11113105                            (: 'processing-instruction' 'return' '{' :)
     or $state[$p:lk] = 11113291                            (: 'attribute' 'satisfies' '{' :)
     or $state[$p:lk] = 11113312                            (: 'element' 'satisfies' '{' :)
     or $state[$p:lk] = 11113361                            (: 'processing-instruction' 'satisfies' '{' :)
     or $state[$p:lk] = 11114827                            (: 'attribute' 'stable' '{' :)
     or $state[$p:lk] = 11114848                            (: 'element' 'stable' '{' :)
     or $state[$p:lk] = 11114897                            (: 'processing-instruction' 'stable' '{' :)
     or $state[$p:lk] = 11116107                            (: 'attribute' 'to' '{' :)
     or $state[$p:lk] = 11116128                            (: 'element' 'to' '{' :)
     or $state[$p:lk] = 11116177                            (: 'processing-instruction' 'to' '{' :)
     or $state[$p:lk] = 11116363                            (: 'attribute' 'treat' '{' :)
     or $state[$p:lk] = 11116384                            (: 'element' 'treat' '{' :)
     or $state[$p:lk] = 11116433                            (: 'processing-instruction' 'treat' '{' :)
     or $state[$p:lk] = 11117131                            (: 'attribute' 'union' '{' :)
     or $state[$p:lk] = 11117152                            (: 'element' 'union' '{' :)
     or $state[$p:lk] = 11117201                            (: 'processing-instruction' 'union' '{' :)
     or $state[$p:lk] = 11118411                            (: 'attribute' 'where' '{' :)
     or $state[$p:lk] = 11118432                            (: 'element' 'where' '{' :)
     or $state[$p:lk] = 11118481) then                      (: 'processing-instruction' 'where' '{' :)
      let $state := p:parse-FilterExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AxisStep($input, $state)
      return $state
  return p:reduce($state, "StepExpr", $count)
};

(:~
 : Parse the 1st loop of production RelativePathExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RelativePathExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(109, $input, $state)        (: S^WS | '!=' | '(.' | ')' | '*' | '+' | ',' | '-' | '/' |
                                                               '//' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'and' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'ne' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'to' | 'treat' |
                                                               'union' | 'where' | '|' | '}' :)
    return
      if ($state[$p:l1] != 46                               (: '/' :)
      and $state[$p:l1] != 47) then                         (: '//' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 46) then                      (: '/' :)
            let $state := p:shift(46, $input, $state)       (: '/' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(47, $input, $state)       (: '//' :)
            return $state
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | '(.' :)
        let $state := p:parse-StepExpr($input, $state)
        return p:parse-RelativePathExpr-1($input, $state)
};

(:~
 : Parse RelativePathExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RelativePathExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-StepExpr($input, $state)
  let $state := p:parse-RelativePathExpr-1($input, $state)
  return p:reduce($state, "RelativePathExpr", $count)
};

(:~
 : Parse PathExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PathExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 46) then                            (: '/' :)
      let $state := p:shift(46, $input, $state)             (: '/' :)
      let $state := p:lookahead1W(146, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '!=' | '$' | '(' | '(.' | ')' | '*' | '+' |
                                                               ',' | '-' | '.' | '..' | ';' | '<' | '<!--' | '<<' |
                                                               '<=' | '<?' | '=' | '>' | '>=' | '>>' | '@' | ']' | '^' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'copy' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' | '|' | '}' :)
      let $state :=
        if ($state[$p:l1] = 26                              (: '!=' :)
         or $state[$p:l1] = 36                              (: ')' :)
         or $state[$p:l1] = 37                              (: '*' :)
         or $state[$p:l1] = 39                              (: '+' :)
         or $state[$p:l1] = 41                              (: ',' :)
         or $state[$p:l1] = 42                              (: '-' :)
         or $state[$p:l1] = 52                              (: ';' :)
         or $state[$p:l1] = 56                              (: '<<' :)
         or $state[$p:l1] = 57                              (: '<=' :)
         or $state[$p:l1] = 59                              (: '=' :)
         or $state[$p:l1] = 60                              (: '>' :)
         or $state[$p:l1] = 61                              (: '>=' :)
         or $state[$p:l1] = 62                              (: '>>' :)
         or $state[$p:l1] = 67                              (: ']' :)
         or $state[$p:l1] = 171                             (: '|' :)
         or $state[$p:l1] = 172) then                       (: '}' :)
          $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:parse-RelativePathExpr($input, $state)
          return $state
      return $state
    else if ($state[$p:l1] = 47) then                       (: '//' :)
      let $state := p:shift(47, $input, $state)             (: '//' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-RelativePathExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-RelativePathExpr($input, $state)
      return $state
  return p:reduce($state, "PathExpr", $count)
};

(:~
 : Parse ValidationMode.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValidationMode($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 123) then                           (: 'lax' :)
      let $state := p:shift(123, $input, $state)            (: 'lax' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(154, $input, $state)            (: 'strict' :)
      return $state
  return p:reduce($state, "ValidationMode", $count)
};

(:~
 : Parse ValidateExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValidateExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(164, $input, $state)                (: 'validate' :)
  let $state := p:lookahead1W(78, $input, $state)           (: S^WS | '(.' | 'lax' | 'strict' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 169) then                     (: '{' :)
      let $state := p:parse-ValidationMode($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(42, $input, $state)           (: S^WS | '(.' | '{' :)
  let $state := p:shift(169, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | '(.' | '}' :)
  let $state := p:shift(172, $input, $state)                (: '}' :)
  return p:reduce($state, "ValidateExpr", $count)
};

(:~
 : Parse ValueExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValueExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 164) then                           (: 'validate' :)
      let $state := p:lookahead2W(120, $input, $state)      (: S^WS | '!=' | '(' | '(.' | ')' | '*' | '+' | ',' | '-' |
                                                               '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'lax' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'strict' | 'to' | 'treat' | 'union' |
                                                               'where' | '{' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 31652                               (: 'validate' 'lax' :)
     or $state[$p:lk] = 39588                               (: 'validate' 'strict' :)
     or $state[$p:lk] = 43428) then                         (: 'validate' '{' :)
      let $state := p:parse-ValidateExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 34) then                       (: '(#' :)
      let $state := p:parse-ExtensionExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-PathExpr($input, $state)
      return $state
  return p:reduce($state, "ValueExpr", $count)
};

(:~
 : Parse the 1st loop of production UnaryExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnaryExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(139, $input, $state)        (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | '(.' | '+' | '-' | '.' |
                                                               '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' | '^' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'copy' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
    return
      if ($state[$p:l1] != 39                               (: '+' :)
      and $state[$p:l1] != 42) then                         (: '-' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 42) then                      (: '-' :)
            let $state := p:shift(42, $input, $state)       (: '-' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(39, $input, $state)       (: '+' :)
            return $state
        return p:parse-UnaryExpr-1($input, $state)
};

(:~
 : Parse UnaryExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-UnaryExpr-1($input, $state)
  let $state := p:parse-ValueExpr($input, $state)
  return p:reduce($state, "UnaryExpr", $count)
};

(:~
 : Parse CastExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CastExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-UnaryExpr($input, $state)
  let $state := p:lookahead1W(108, $input, $state)          (: S^WS | '!=' | '(.' | ')' | '*' | '+' | ',' | '-' | ';' |
                                                               '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'eq' | 'except' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'to' | 'treat' | 'union' |
                                                               'where' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 80) then                       (: 'cast' :)
      let $state := p:shift(80, $input, $state)             (: 'cast' :)
      let $state := p:lookahead1W(34, $input, $state)       (: S^WS | '(.' | 'as' :)
      let $state := p:shift(72, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-SingleType($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "CastExpr", $count)
};

(:~
 : Parse CastableExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CastableExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-CastExpr($input, $state)
  let $state := p:lookahead1W(106, $input, $state)          (: S^WS | '!=' | '(.' | ')' | '*' | '+' | ',' | '-' | ';' |
                                                               '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'castable' | 'collation' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'eq' | 'except' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 81) then                       (: 'castable' :)
      let $state := p:shift(81, $input, $state)             (: 'castable' :)
      let $state := p:lookahead1W(34, $input, $state)       (: S^WS | '(.' | 'as' :)
      let $state := p:shift(72, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-SingleType($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "CastableExpr", $count)
};

(:~
 : Parse TreatExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TreatExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-CastableExpr($input, $state)
  let $state := p:lookahead1W(105, $input, $state)          (: S^WS | '!=' | '(.' | ')' | '*' | '+' | ',' | '-' | ';' |
                                                               '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 159) then                      (: 'treat' :)
      let $state := p:shift(159, $input, $state)            (: 'treat' :)
      let $state := p:lookahead1W(34, $input, $state)       (: S^WS | '(.' | 'as' :)
      let $state := p:shift(72, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "TreatExpr", $count)
};

(:~
 : Parse InstanceofExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InstanceofExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-TreatExpr($input, $state)
  let $state := p:lookahead1W(104, $input, $state)          (: S^WS | '!=' | '(.' | ')' | '*' | '+' | ',' | '-' | ';' |
                                                               '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'union' | 'where' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 118) then                      (: 'instance' :)
      let $state := p:shift(118, $input, $state)            (: 'instance' :)
      let $state := p:lookahead1W(38, $input, $state)       (: S^WS | '(.' | 'of' :)
      let $state := p:shift(135, $input, $state)            (: 'of' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "InstanceofExpr", $count)
};

(:~
 : Parse the 1st loop of production IntersectExceptExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IntersectExceptExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(103, $input, $state)        (: S^WS | '!=' | '(.' | ')' | '*' | '+' | ',' | '-' | ';' |
                                                               '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'intersect' |
                                                               'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'to' |
                                                               'union' | 'where' | '|' | '}' :)
    return
      if ($state[$p:l1] != 103                              (: 'except' :)
      and $state[$p:l1] != 119) then                        (: 'intersect' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 119) then                     (: 'intersect' :)
            let $state := p:shift(119, $input, $state)      (: 'intersect' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(103, $input, $state)      (: 'except' :)
            return $state
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | '(.' :)
        let $state := p:parse-InstanceofExpr($input, $state)
        return p:parse-IntersectExceptExpr-1($input, $state)
};

(:~
 : Parse IntersectExceptExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IntersectExceptExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-InstanceofExpr($input, $state)
  let $state := p:parse-IntersectExceptExpr-1($input, $state)
  return p:reduce($state, "IntersectExceptExpr", $count)
};

(:~
 : Parse the 1st loop of production UnionExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnionExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(102, $input, $state)        (: S^WS | '!=' | '(.' | ')' | '*' | '+' | ',' | '-' | ';' |
                                                               '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'to' | 'union' | 'where' | '|' | '}' :)
    return
      if ($state[$p:l1] != 162                              (: 'union' :)
      and $state[$p:l1] != 171) then                        (: '|' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 162) then                     (: 'union' :)
            let $state := p:shift(162, $input, $state)      (: 'union' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(171, $input, $state)      (: '|' :)
            return $state
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | '(.' :)
        let $state := p:parse-IntersectExceptExpr($input, $state)
        return p:parse-UnionExpr-1($input, $state)
};

(:~
 : Parse UnionExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnionExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-IntersectExceptExpr($input, $state)
  let $state := p:parse-UnionExpr-1($input, $state)
  return p:reduce($state, "UnionExpr", $count)
};

(:~
 : Parse the 1st loop of production MultiplicativeExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MultiplicativeExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(101, $input, $state)        (: S^WS | '!=' | '(.' | ')' | '*' | '+' | ',' | '-' | ';' |
                                                               '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'to' | 'where' | '}' :)
    return
      if ($state[$p:l1] != 37                               (: '*' :)
      and $state[$p:l1] != 93                               (: 'div' :)
      and $state[$p:l1] != 113                              (: 'idiv' :)
      and $state[$p:l1] != 128) then                        (: 'mod' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 37) then                      (: '*' :)
            let $state := p:shift(37, $input, $state)       (: '*' :)
            return $state
          else if ($state[$p:l1] = 93) then                 (: 'div' :)
            let $state := p:shift(93, $input, $state)       (: 'div' :)
            return $state
          else if ($state[$p:l1] = 113) then                (: 'idiv' :)
            let $state := p:shift(113, $input, $state)      (: 'idiv' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(128, $input, $state)      (: 'mod' :)
            return $state
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | '(.' :)
        let $state := p:parse-UnionExpr($input, $state)
        return p:parse-MultiplicativeExpr-1($input, $state)
};

(:~
 : Parse MultiplicativeExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MultiplicativeExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-UnionExpr($input, $state)
  let $state := p:parse-MultiplicativeExpr-1($input, $state)
  return p:reduce($state, "MultiplicativeExpr", $count)
};

(:~
 : Parse the 1st loop of production AdditiveExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AdditiveExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(100, $input, $state)        (: S^WS | '!=' | '(.' | ')' | '+' | ',' | '-' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' |
                                                               'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'else' | 'empty' | 'eq' | 'for' | 'ge' |
                                                               'gt' | 'is' | 'le' | 'let' | 'lt' | 'ne' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'to' |
                                                               'where' | '}' :)
    return
      if ($state[$p:l1] != 39                               (: '+' :)
      and $state[$p:l1] != 42) then                         (: '-' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 39) then                      (: '+' :)
            let $state := p:shift(39, $input, $state)       (: '+' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(42, $input, $state)       (: '-' :)
            return $state
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | '(.' :)
        let $state := p:parse-MultiplicativeExpr($input, $state)
        return p:parse-AdditiveExpr-1($input, $state)
};

(:~
 : Parse AdditiveExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AdditiveExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-MultiplicativeExpr($input, $state)
  let $state := p:parse-AdditiveExpr-1($input, $state)
  return p:reduce($state, "AdditiveExpr", $count)
};

(:~
 : Parse RangeExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RangeExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-AdditiveExpr($input, $state)
  let $state := p:lookahead1W(99, $input, $state)           (: S^WS | '!=' | '(.' | ')' | ',' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' |
                                                               'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'else' | 'empty' | 'eq' | 'for' | 'ge' |
                                                               'gt' | 'is' | 'le' | 'let' | 'lt' | 'ne' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'to' |
                                                               'where' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 158) then                      (: 'to' :)
      let $state := p:shift(158, $input, $state)            (: 'to' :)
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-AdditiveExpr($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "RangeExpr", $count)
};

(:~
 : Parse ComparisonExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ComparisonExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-RangeExpr($input, $state)
  let $state := p:lookahead1W(97, $input, $state)           (: S^WS | '!=' | '(.' | ')' | ',' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' |
                                                               'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'else' | 'empty' | 'eq' | 'for' | 'ge' |
                                                               'gt' | 'is' | 'le' | 'let' | 'lt' | 'ne' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'where' |
                                                               '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 26                             (: '!=' :)
          or $state[$p:l1] = 53                             (: '<' :)
          or $state[$p:l1] = 56                             (: '<<' :)
          or $state[$p:l1] = 57                             (: '<=' :)
          or $state[$p:l1] = 59                             (: '=' :)
          or $state[$p:l1] = 60                             (: '>' :)
          or $state[$p:l1] = 61                             (: '>=' :)
          or $state[$p:l1] = 62                             (: '>>' :)
          or $state[$p:l1] = 101                            (: 'eq' :)
          or $state[$p:l1] = 109                            (: 'ge' :)
          or $state[$p:l1] = 111                            (: 'gt' :)
          or $state[$p:l1] = 120                            (: 'is' :)
          or $state[$p:l1] = 124                            (: 'le' :)
          or $state[$p:l1] = 127                            (: 'lt' :)
          or $state[$p:l1] = 131) then                      (: 'ne' :)
      let $state :=
        if ($state[$p:l1] = 101                             (: 'eq' :)
         or $state[$p:l1] = 109                             (: 'ge' :)
         or $state[$p:l1] = 111                             (: 'gt' :)
         or $state[$p:l1] = 124                             (: 'le' :)
         or $state[$p:l1] = 127                             (: 'lt' :)
         or $state[$p:l1] = 131) then                       (: 'ne' :)
          let $state := p:parse-ValueComp($input, $state)
          return $state
        else if ($state[$p:l1] = 56                         (: '<<' :)
              or $state[$p:l1] = 62                         (: '>>' :)
              or $state[$p:l1] = 120) then                  (: 'is' :)
          let $state := p:parse-NodeComp($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:parse-GeneralComp($input, $state)
          return $state
      let $state := p:lookahead1W(20, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-RangeExpr($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "ComparisonExpr", $count)
};

(:~
 : Parse the 1st loop of production AndExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AndExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(95, $input, $state)         (: S^WS | '(.' | ')' | ',' | ';' | ']' | 'and' |
                                                               'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'else' | 'empty' | 'for' | 'let' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'where' |
                                                               '}' :)
    return
      if ($state[$p:l1] != 71) then                         (: 'and' :)
        $state
      else
        let $state := p:shift(71, $input, $state)           (: 'and' :)
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | '(.' :)
        let $state := p:parse-ComparisonExpr($input, $state)
        return p:parse-AndExpr-1($input, $state)
};

(:~
 : Parse AndExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AndExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ComparisonExpr($input, $state)
  let $state := p:parse-AndExpr-1($input, $state)
  return p:reduce($state, "AndExpr", $count)
};

(:~
 : Parse the 1st loop of production OrExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(94, $input, $state)         (: S^WS | '(.' | ')' | ',' | ';' | ']' | 'ascending' |
                                                               'case' | 'collation' | 'default' | 'descending' |
                                                               'else' | 'empty' | 'for' | 'let' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'where' | '}' :)
    return
      if ($state[$p:l1] != 137) then                        (: 'or' :)
        $state
      else
        let $state := p:shift(137, $input, $state)          (: 'or' :)
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | '(.' :)
        let $state := p:parse-AndExpr($input, $state)
        return p:parse-OrExpr-1($input, $state)
};

(:~
 : Parse OrExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-AndExpr($input, $state)
  let $state := p:parse-OrExpr-1($input, $state)
  return p:reduce($state, "OrExpr", $count)
};

(:~
 : Parse IfExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IfExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(114, $input, $state)                (: 'if' :)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | '(.' :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | '(.' | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | '(.' | 'then' :)
  let $state := p:shift(157, $input, $state)                (: 'then' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:lookahead1W(36, $input, $state)           (: S^WS | '(.' | 'else' :)
  let $state := p:shift(97, $input, $state)                 (: 'else' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "IfExpr", $count)
};

(:~
 : Parse CaseClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CaseClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(11, $input, $state)            (: 'case' :)
  let $state := p:shift(79, $input, $state)                 (: 'case' :)
  let $state := p:lookahead1W(128, $input, $state)          (: S^WS | QName^Token | '$' | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:shift(31, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(125, $input, $state)      (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
      let $state := p:parse-VarName($input, $state)
      let $state := p:lookahead1W(34, $input, $state)       (: S^WS | '(.' | 'as' :)
      let $state := p:shift(72, $input, $state)             (: 'as' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-SequenceType($input, $state)
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | '(.' | 'return' :)
  let $state := p:shift(146, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "CaseClause", $count)
};

(:~
 : Parse the 1st loop of production TypeswitchExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeswitchExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(20, $input, $state)         (: EPSILON | S^WS | '(.' :)
    let $state := p:parse-CaseClause($input, $state)
    let $state := p:lookahead1W(65, $input, $state)         (: S^WS | '(.' | 'case' | 'default' :)
    return
      if ($state[$p:l1] != 79) then                         (: 'case' :)
        $state
      else
        p:parse-TypeswitchExpr-1($input, $state)
};

(:~
 : Parse TypeswitchExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeswitchExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(161, $input, $state)                (: 'typeswitch' :)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | '(.' :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | '(.' | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-TypeswitchExpr-1($input, $state)
  let $state := p:shift(89, $input, $state)                 (: 'default' :)
  let $state := p:lookahead1W(49, $input, $state)           (: S^WS | '$' | '(.' | 'return' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:shift(31, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(125, $input, $state)      (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
      let $state := p:parse-VarName($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | '(.' | 'return' :)
  let $state := p:shift(146, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "TypeswitchExpr", $count)
};

(:~
 : Parse the 1st loop of production QuantifiedExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QuantifiedExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(59, $input, $state)         (: S^WS | '(.' | ',' | 'satisfies' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(26, $input, $state)     (: S^WS | '$' | '(.' :)
        let $state := p:shift(31, $input, $state)           (: '$' :)
        let $state := p:lookahead1W(125, $input, $state)    (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
        let $state := p:parse-VarName($input, $state)
        let $state := p:lookahead1W(61, $input, $state)     (: S^WS | '(.' | 'as' | 'in' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 72) then                 (: 'as' :)
            let $state := p:parse-TypeDeclaration($input, $state)
            return $state
          else
            $state
        let $state := p:lookahead1W(37, $input, $state)     (: S^WS | '(.' | 'in' :)
        let $state := p:shift(116, $input, $state)          (: 'in' :)
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | '(.' :)
        let $state := p:parse-ExprSingle($input, $state)
        return p:parse-QuantifiedExpr-1($input, $state)
};

(:~
 : Parse QuantifiedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QuantifiedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 152) then                           (: 'some' :)
      let $state := p:shift(152, $input, $state)            (: 'some' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(102, $input, $state)            (: 'every' :)
      return $state
  let $state := p:lookahead1W(26, $input, $state)           (: S^WS | '$' | '(.' :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(125, $input, $state)          (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(61, $input, $state)           (: S^WS | '(.' | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 72) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(37, $input, $state)           (: S^WS | '(.' | 'in' :)
  let $state := p:shift(116, $input, $state)                (: 'in' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:parse-QuantifiedExpr-1($input, $state)
  let $state := p:shift(147, $input, $state)                (: 'satisfies' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "QuantifiedExpr", $count)
};

(:~
 : Parse URILiteral.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-URILiteral($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(6, $input, $state)                  (: StringLiteral :)
  return p:reduce($state, "URILiteral", $count)
};

(:~
 : Parse OrderModifier.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderModifier($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(88, $input, $state)           (: S^WS | '(.' | ',' | 'ascending' | 'collation' |
                                                               'descending' | 'empty' | 'return' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 73                             (: 'ascending' :)
          or $state[$p:l1] = 92) then                       (: 'descending' :)
      let $state :=
        if ($state[$p:l1] = 73) then                        (: 'ascending' :)
          let $state := p:shift(73, $input, $state)         (: 'ascending' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(92, $input, $state)         (: 'descending' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(82, $input, $state)           (: S^WS | '(.' | ',' | 'collation' | 'empty' | 'return' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 98) then                       (: 'empty' :)
      let $state := p:shift(98, $input, $state)             (: 'empty' :)
      let $state := p:lookahead1W(66, $input, $state)       (: S^WS | '(.' | 'greatest' | 'least' :)
      let $state :=
        if ($state[$p:l1] = 110) then                       (: 'greatest' :)
          let $state := p:shift(110, $input, $state)        (: 'greatest' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(125, $input, $state)        (: 'least' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(75, $input, $state)           (: S^WS | '(.' | ',' | 'collation' | 'return' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 83) then                       (: 'collation' :)
      let $state := p:shift(83, $input, $state)             (: 'collation' :)
      let $state := p:lookahead1W(22, $input, $state)       (: StringLiteral | S^WS | '(.' :)
      let $state := p:parse-URILiteral($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "OrderModifier", $count)
};

(:~
 : Parse OrderSpec.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderSpec($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-OrderModifier($input, $state)
  return p:reduce($state, "OrderSpec", $count)
};

(:~
 : Parse the 1st loop of production OrderSpecList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderSpecList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(58, $input, $state)         (: S^WS | '(.' | ',' | 'return' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | '(.' :)
        let $state := p:parse-OrderSpec($input, $state)
        return p:parse-OrderSpecList-1($input, $state)
};

(:~
 : Parse OrderSpecList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderSpecList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-OrderSpec($input, $state)
  let $state := p:parse-OrderSpecList-1($input, $state)
  return p:reduce($state, "OrderSpecList", $count)
};

(:~
 : Parse OrderByClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderByClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 138) then                           (: 'order' :)
      let $state := p:shift(138, $input, $state)            (: 'order' :)
      let $state := p:lookahead1W(35, $input, $state)       (: S^WS | '(.' | 'by' :)
      let $state := p:shift(78, $input, $state)             (: 'by' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(153, $input, $state)            (: 'stable' :)
      let $state := p:lookahead1W(39, $input, $state)       (: S^WS | '(.' | 'order' :)
      let $state := p:shift(138, $input, $state)            (: 'order' :)
      let $state := p:lookahead1W(35, $input, $state)       (: S^WS | '(.' | 'by' :)
      let $state := p:shift(78, $input, $state)             (: 'by' :)
      return $state
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-OrderSpecList($input, $state)
  return p:reduce($state, "OrderByClause", $count)
};

(:~
 : Parse WhereClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-WhereClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(167, $input, $state)                (: 'where' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "WhereClause", $count)
};

(:~
 : Parse the 1st loop of production LetClause (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LetClause-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(91, $input, $state)         (: S^WS | '(.' | ',' | 'for' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(26, $input, $state)     (: S^WS | '$' | '(.' :)
        let $state := p:shift(31, $input, $state)           (: '$' :)
        let $state := p:lookahead1W(125, $input, $state)    (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
        let $state := p:parse-VarName($input, $state)
        let $state := p:lookahead1W(60, $input, $state)     (: S^WS | '(.' | ':=' | 'as' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 72) then                 (: 'as' :)
            let $state := p:parse-TypeDeclaration($input, $state)
            return $state
          else
            $state
        let $state := p:lookahead1W(31, $input, $state)     (: S^WS | '(.' | ':=' :)
        let $state := p:shift(51, $input, $state)           (: ':=' :)
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | '(.' :)
        let $state := p:parse-ExprSingle($input, $state)
        return p:parse-LetClause-1($input, $state)
};

(:~
 : Parse LetClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LetClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(126, $input, $state)                (: 'let' :)
  let $state := p:lookahead1W(26, $input, $state)           (: S^WS | '$' | '(.' :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(125, $input, $state)          (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(60, $input, $state)           (: S^WS | '(.' | ':=' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 72) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(31, $input, $state)           (: S^WS | '(.' | ':=' :)
  let $state := p:shift(51, $input, $state)                 (: ':=' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:parse-LetClause-1($input, $state)
  return p:reduce($state, "LetClause", $count)
};

(:~
 : Parse PositionalVar.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PositionalVar($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(74, $input, $state)                 (: 'at' :)
  let $state := p:lookahead1W(26, $input, $state)           (: S^WS | '$' | '(.' :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(125, $input, $state)          (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  return p:reduce($state, "PositionalVar", $count)
};

(:~
 : Parse VarName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-QName($input, $state)
  return p:reduce($state, "VarName", $count)
};

(:~
 : Parse the 1st loop of production ForClause (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForClause-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(91, $input, $state)         (: S^WS | '(.' | ',' | 'for' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(26, $input, $state)     (: S^WS | '$' | '(.' :)
        let $state := p:shift(31, $input, $state)           (: '$' :)
        let $state := p:lookahead1W(125, $input, $state)    (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
        let $state := p:parse-VarName($input, $state)
        let $state := p:lookahead1W(76, $input, $state)     (: S^WS | '(.' | 'as' | 'at' | 'in' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 72) then                 (: 'as' :)
            let $state := p:parse-TypeDeclaration($input, $state)
            return $state
          else
            $state
        let $state := p:lookahead1W(63, $input, $state)     (: S^WS | '(.' | 'at' | 'in' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 74) then                 (: 'at' :)
            let $state := p:parse-PositionalVar($input, $state)
            return $state
          else
            $state
        let $state := p:lookahead1W(37, $input, $state)     (: S^WS | '(.' | 'in' :)
        let $state := p:shift(116, $input, $state)          (: 'in' :)
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | '(.' :)
        let $state := p:parse-ExprSingle($input, $state)
        return p:parse-ForClause-1($input, $state)
};

(:~
 : Parse ForClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(107, $input, $state)                (: 'for' :)
  let $state := p:lookahead1W(26, $input, $state)           (: S^WS | '$' | '(.' :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(125, $input, $state)          (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(76, $input, $state)           (: S^WS | '(.' | 'as' | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 72) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(63, $input, $state)           (: S^WS | '(.' | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 74) then                       (: 'at' :)
      let $state := p:parse-PositionalVar($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(37, $input, $state)           (: S^WS | '(.' | 'in' :)
  let $state := p:shift(116, $input, $state)                (: 'in' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:parse-ForClause-1($input, $state)
  return p:reduce($state, "ForClause", $count)
};

(:~
 : Parse the 1st loop of production FLWORExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FLWORExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:l1] = 107) then                         (: 'for' :)
        let $state := p:parse-ForClause($input, $state)
        return $state
      else if ($state[$p:error]) then
        $state
      else
        let $state := p:parse-LetClause($input, $state)
        return $state
    let $state := p:lookahead1W(89, $input, $state)         (: S^WS | '(.' | 'for' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' :)
    return
      if ($state[$p:l1] != 107                              (: 'for' :)
      and $state[$p:l1] != 126) then                        (: 'let' :)
        $state
      else
        p:parse-FLWORExpr-1($input, $state)
};

(:~
 : Parse FLWORExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FLWORExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-FLWORExpr-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 167) then                      (: 'where' :)
      let $state := p:parse-WhereClause($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(79, $input, $state)           (: S^WS | '(.' | 'order' | 'return' | 'stable' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 146) then                     (: 'return' :)
      let $state := p:parse-OrderByClause($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | '(.' | 'return' :)
  let $state := p:shift(146, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "FLWORExpr", $count)
};

(:~
 : Parse ExprSingle.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ExprSingle($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(139, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | TextNodeLiteral | S^WS | QName^Token |
                                                               Wildcard | '$' | '(' | '(#' | '(.' | '+' | '-' | '.' |
                                                               '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' | '^' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'copy' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'ne' | 'node' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 114                                 (: 'typeswitch' :)
     or $state[$p:l1] = 161) then                           (: 'typeswitch' :)
      let $state := p:lookahead2W(114, $input, $state)      (: S^WS | '!=' | '(' | '(.' | ')' | '*' | '+' | ',' | '-' |
                                                               '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 102                            (: 'for' :)
          or $state[$p:l1] = 107                            (: 'let' :)
          or $state[$p:l1] = 126                            (: 'some' :)
          or $state[$p:l1] = 152) then                      (: 'some' :)
      let $state := p:lookahead2W(116, $input, $state)      (: S^WS | '!=' | '$' | '(' | '(.' | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 8043                                (: 'for' '$' :)
     or $state[$p:lk] = 8062) then                          (: 'let' '$' :)
      let $state := p:parse-FLWORExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 8038                           (: 'every' '$' :)
          or $state[$p:lk] = 8088) then                     (: 'some' '$' :)
      let $state := p:parse-QuantifiedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 8609) then                     (: 'typeswitch' '(' :)
      let $state := p:parse-TypeswitchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 8562) then                     (: 'if' '(' :)
      let $state := p:parse-IfExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-OrExpr($input, $state)
      return $state
  return p:reduce($state, "ExprSingle", $count)
};

(:~
 : Parse the 1st loop of production Expr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Expr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(83, $input, $state)         (: S^WS | '(.' | ')' | ',' | ';' | ']' | '}' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(20, $input, $state)     (: EPSILON | S^WS | '(.' :)
        let $state := p:parse-ExprSingle($input, $state)
        return p:parse-Expr-1($input, $state)
};

(:~
 : Parse Expr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Expr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:parse-Expr-1($input, $state)
  return p:reduce($state, "Expr", $count)
};

(:~
 : Parse OccurrenceIndicator.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OccurrenceIndicator($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 63) then                            (: '?' :)
      let $state := p:shift(63, $input, $state)             (: '?' :)
      return $state
    else if ($state[$p:l1] = 38) then                       (: '*' :)
      let $state := p:shift(38, $input, $state)             (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(40, $input, $state)             (: '+' :)
      return $state
  return p:reduce($state, "OccurrenceIndicator", $count)
};

(:~
 : Parse AtomicType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AtomicType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-QName($input, $state)
  return p:reduce($state, "AtomicType", $count)
};

(:~
 : Parse AnyKindTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AnyKindTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(134, $input, $state)                (: 'node' :)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | '(.' :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | '(.' | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "AnyKindTest", $count)
};

(:~
 : Parse TextTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TextTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(156, $input, $state)                (: 'text' :)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | '(.' :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | '(.' | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "TextTest", $count)
};

(:~
 : Parse CommentTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CommentTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(84, $input, $state)                 (: 'comment' :)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | '(.' :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | '(.' | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "CommentTest", $count)
};

(:~
 : Parse NCName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NCName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 71) then                            (: 'and' :)
      let $state := p:shift(71, $input, $state)             (: 'and' :)
      return $state
    else if ($state[$p:l1] = 73) then                       (: 'ascending' :)
      let $state := p:shift(73, $input, $state)             (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 79) then                       (: 'case' :)
      let $state := p:shift(79, $input, $state)             (: 'case' :)
      return $state
    else if ($state[$p:l1] = 80) then                       (: 'cast' :)
      let $state := p:shift(80, $input, $state)             (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 81) then                       (: 'castable' :)
      let $state := p:shift(81, $input, $state)             (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'collation' :)
      let $state := p:shift(83, $input, $state)             (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 89) then                       (: 'default' :)
      let $state := p:shift(89, $input, $state)             (: 'default' :)
      return $state
    else if ($state[$p:l1] = 92) then                       (: 'descending' :)
      let $state := p:shift(92, $input, $state)             (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'div' :)
      let $state := p:shift(93, $input, $state)             (: 'div' :)
      return $state
    else if ($state[$p:l1] = 97) then                       (: 'else' :)
      let $state := p:shift(97, $input, $state)             (: 'else' :)
      return $state
    else if ($state[$p:l1] = 98) then                       (: 'empty' :)
      let $state := p:shift(98, $input, $state)             (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 101) then                      (: 'eq' :)
      let $state := p:shift(101, $input, $state)            (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 103) then                      (: 'except' :)
      let $state := p:shift(103, $input, $state)            (: 'except' :)
      return $state
    else if ($state[$p:l1] = 107) then                      (: 'for' :)
      let $state := p:shift(107, $input, $state)            (: 'for' :)
      return $state
    else if ($state[$p:l1] = 109) then                      (: 'ge' :)
      let $state := p:shift(109, $input, $state)            (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 111) then                      (: 'gt' :)
      let $state := p:shift(111, $input, $state)            (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 113) then                      (: 'idiv' :)
      let $state := p:shift(113, $input, $state)            (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 118) then                      (: 'instance' :)
      let $state := p:shift(118, $input, $state)            (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 119) then                      (: 'intersect' :)
      let $state := p:shift(119, $input, $state)            (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 120) then                      (: 'is' :)
      let $state := p:shift(120, $input, $state)            (: 'is' :)
      return $state
    else if ($state[$p:l1] = 124) then                      (: 'le' :)
      let $state := p:shift(124, $input, $state)            (: 'le' :)
      return $state
    else if ($state[$p:l1] = 126) then                      (: 'let' :)
      let $state := p:shift(126, $input, $state)            (: 'let' :)
      return $state
    else if ($state[$p:l1] = 127) then                      (: 'lt' :)
      let $state := p:shift(127, $input, $state)            (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 128) then                      (: 'mod' :)
      let $state := p:shift(128, $input, $state)            (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 131) then                      (: 'ne' :)
      let $state := p:shift(131, $input, $state)            (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 137) then                      (: 'or' :)
      let $state := p:shift(137, $input, $state)            (: 'or' :)
      return $state
    else if ($state[$p:l1] = 138) then                      (: 'order' :)
      let $state := p:shift(138, $input, $state)            (: 'order' :)
      return $state
    else if ($state[$p:l1] = 146) then                      (: 'return' :)
      let $state := p:shift(146, $input, $state)            (: 'return' :)
      return $state
    else if ($state[$p:l1] = 147) then                      (: 'satisfies' :)
      let $state := p:shift(147, $input, $state)            (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 153) then                      (: 'stable' :)
      let $state := p:shift(153, $input, $state)            (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 158) then                      (: 'to' :)
      let $state := p:shift(158, $input, $state)            (: 'to' :)
      return $state
    else if ($state[$p:l1] = 159) then                      (: 'treat' :)
      let $state := p:shift(159, $input, $state)            (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 162) then                      (: 'union' :)
      let $state := p:shift(162, $input, $state)            (: 'union' :)
      return $state
    else if ($state[$p:l1] = 167) then                      (: 'where' :)
      let $state := p:shift(167, $input, $state)            (: 'where' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(17, $input, $state)             (: NCName^Token :)
      return $state
  return p:reduce($state, "NCName", $count)
};

(:~
 : Parse PITest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PITest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(145, $input, $state)                (: 'processing-instruction' :)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | '(.' :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(98, $input, $state)           (: StringLiteral | S^WS | NCName^Token | '(.' | ')' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'eq' | 'except' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'to' | 'treat' | 'union' |
                                                               'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36) then                      (: ')' :)
      let $state :=
        if ($state[$p:l1] = 6) then                         (: StringLiteral :)
          let $state := p:shift(6, $input, $state)          (: StringLiteral :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:parse-NCName($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | '(.' | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "PITest", $count)
};

(:~
 : Parse AttributeDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttributeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-AttributeName($input, $state)
  return p:reduce($state, "AttributeDeclaration", $count)
};

(:~
 : Parse SchemaAttributeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaAttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(149, $input, $state)                (: 'schema-attribute' :)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | '(.' :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(125, $input, $state)          (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-AttributeDeclaration($input, $state)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | '(.' | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "SchemaAttributeTest", $count)
};

(:~
 : Parse AttributeName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttributeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-QName($input, $state)
  return p:reduce($state, "AttributeName", $count)
};

(:~
 : Parse AttribNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttribNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 37) then                            (: '*' :)
      let $state := p:shift(37, $input, $state)             (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AttributeName($input, $state)
      return $state
  return p:reduce($state, "AttribNameOrWildcard", $count)
};

(:~
 : Parse AttributeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(75, $input, $state)                 (: 'attribute' :)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | '(.' :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(133, $input, $state)          (: S^WS | QName^Token | '(.' | ')' | '*' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36) then                      (: ')' :)
      let $state := p:parse-AttribNameOrWildcard($input, $state)
      let $state := p:lookahead1W(55, $input, $state)       (: S^WS | '(.' | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 41) then                   (: ',' :)
          let $state := p:shift(41, $input, $state)         (: ',' :)
          let $state := p:lookahead1W(125, $input, $state)  (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
          let $state := p:parse-TypeName($input, $state)
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | '(.' | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "AttributeTest", $count)
};

(:~
 : Parse ElementDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ElementName($input, $state)
  return p:reduce($state, "ElementDeclaration", $count)
};

(:~
 : Parse SchemaElementTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaElementTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(150, $input, $state)                (: 'schema-element' :)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | '(.' :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(125, $input, $state)          (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-ElementDeclaration($input, $state)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | '(.' | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "SchemaElementTest", $count)
};

(:~
 : Parse TypeName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-QName($input, $state)
  return p:reduce($state, "TypeName", $count)
};

(:~
 : Parse ElementName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-QName($input, $state)
  return p:reduce($state, "ElementName", $count)
};

(:~
 : Parse ElementNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 37) then                            (: '*' :)
      let $state := p:shift(37, $input, $state)             (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ElementName($input, $state)
      return $state
  return p:reduce($state, "ElementNameOrWildcard", $count)
};

(:~
 : Parse ElementTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(96, $input, $state)                 (: 'element' :)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | '(.' :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(133, $input, $state)          (: S^WS | QName^Token | '(.' | ')' | '*' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36) then                      (: ')' :)
      let $state := p:parse-ElementNameOrWildcard($input, $state)
      let $state := p:lookahead1W(55, $input, $state)       (: S^WS | '(.' | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 41) then                   (: ',' :)
          let $state := p:shift(41, $input, $state)         (: ',' :)
          let $state := p:lookahead1W(125, $input, $state)  (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
          let $state := p:parse-TypeName($input, $state)
          let $state := p:lookahead1W(57, $input, $state)   (: S^WS | '(.' | ')' | '?' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 63) then               (: '?' :)
              let $state := p:shift(63, $input, $state)     (: '?' :)
              return $state
            else
              $state
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | '(.' | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "ElementTest", $count)
};

(:~
 : Parse DocumentTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DocumentTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(95, $input, $state)                 (: 'document-node' :)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | '(' | '(.' :)
  let $state := p:shift(33, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(74, $input, $state)           (: S^WS | '(.' | ')' | 'element' | 'schema-element' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 36) then                      (: ')' :)
      let $state :=
        if ($state[$p:l1] = 96) then                        (: 'element' :)
          let $state := p:parse-ElementTest($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:parse-SchemaElementTest($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | '(.' | ')' :)
  let $state := p:shift(36, $input, $state)                 (: ')' :)
  return p:reduce($state, "DocumentTest", $count)
};

(:~
 : Parse KindTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-KindTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 95) then                            (: 'document-node' :)
      let $state := p:parse-DocumentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 96) then                       (: 'element' :)
      let $state := p:parse-ElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 75) then                       (: 'attribute' :)
      let $state := p:parse-AttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 150) then                      (: 'schema-element' :)
      let $state := p:parse-SchemaElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 149) then                      (: 'schema-attribute' :)
      let $state := p:parse-SchemaAttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'processing-instruction' :)
      let $state := p:parse-PITest($input, $state)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'comment' :)
      let $state := p:parse-CommentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 156) then                      (: 'text' :)
      let $state := p:parse-TextTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AnyKindTest($input, $state)
      return $state
  return p:reduce($state, "KindTest", $count)
};

(:~
 : Parse ItemType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ItemType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 75                                  (: 'comment' :)
     or $state[$p:l1] = 84                                  (: 'document-node' :)
     or $state[$p:l1] = 95                                  (: 'element' :)
     or $state[$p:l1] = 96                                  (: 'item' :)
     or $state[$p:l1] = 121                                 (: 'node' :)
     or $state[$p:l1] = 134                                 (: 'processing-instruction' :)
     or $state[$p:l1] = 145                                 (: 'schema-attribute' :)
     or $state[$p:l1] = 149                                 (: 'schema-element' :)
     or $state[$p:l1] = 150                                 (: 'text' :)
     or $state[$p:l1] = 156) then                           (: 'text' :)
      let $state := p:lookahead2W(113, $input, $state)      (: S^WS | '!=' | '(' | '(.' | ')' | '*' | '*' | '+' | '+' |
                                                               ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '?' | ']' | 'and' | 'ascending' | 'at' |
                                                               'case' | 'collation' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'gt' | 'idiv' | 'in' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'ne' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'to' | 'union' |
                                                               'where' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 8523                                (: 'attribute' '(' :)
     or $state[$p:lk] = 8532                                (: 'comment' '(' :)
     or $state[$p:lk] = 8543                                (: 'document-node' '(' :)
     or $state[$p:lk] = 8544                                (: 'element' '(' :)
     or $state[$p:lk] = 8582                                (: 'node' '(' :)
     or $state[$p:lk] = 8593                                (: 'processing-instruction' '(' :)
     or $state[$p:lk] = 8597                                (: 'schema-attribute' '(' :)
     or $state[$p:lk] = 8598                                (: 'schema-element' '(' :)
     or $state[$p:lk] = 8604) then                          (: 'text' '(' :)
      let $state := p:parse-KindTest($input, $state)
      return $state
    else if ($state[$p:lk] = 8569) then                     (: 'item' '(' :)
      let $state := p:shift(121, $input, $state)            (: 'item' :)
      let $state := p:lookahead1W(27, $input, $state)       (: S^WS | '(' | '(.' :)
      let $state := p:shift(33, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | '(.' | ')' :)
      let $state := p:shift(36, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AtomicType($input, $state)
      return $state
  return p:reduce($state, "ItemType", $count)
};

(:~
 : Parse SequenceType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SequenceType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(122, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 99) then                            (: 'empty-sequence' :)
      let $state := p:lookahead2W(113, $input, $state)      (: S^WS | '!=' | '(' | '(.' | ')' | '*' | '*' | '+' | '+' |
                                                               ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '?' | ']' | 'and' | 'ascending' | 'at' |
                                                               'case' | 'collation' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'gt' | 'idiv' | 'in' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'ne' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'to' | 'union' |
                                                               'where' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 8547) then                          (: 'empty-sequence' '(' :)
      let $state := p:shift(99, $input, $state)             (: 'empty-sequence' :)
      let $state := p:lookahead1W(27, $input, $state)       (: S^WS | '(' | '(.' :)
      let $state := p:shift(33, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(28, $input, $state)       (: S^WS | '(.' | ')' :)
      let $state := p:shift(36, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ItemType($input, $state)
      let $state := p:lookahead1W(110, $input, $state)      (: S^WS | '!=' | '(.' | ')' | '*' | '*' | '+' | '+' | ',' |
                                                               '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '?' | ']' | 'and' | 'ascending' | 'at' | 'case' |
                                                               'collation' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'eq' | 'except' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'in' | 'instance' | 'intersect' | 'is' | 'le' |
                                                               'let' | 'lt' | 'mod' | 'ne' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'to' | 'union' | 'where' | '|' |
                                                               '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 38                         (: '*' :)
              or $state[$p:l1] = 40                         (: '+' :)
              or $state[$p:l1] = 63) then                   (: '?' :)
          let $state := p:parse-OccurrenceIndicator($input, $state)
          return $state
        else
          $state
      return $state
  return p:reduce($state, "SequenceType", $count)
};

(:~
 : Parse TypeDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(72, $input, $state)                 (: 'as' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-SequenceType($input, $state)
  return p:reduce($state, "TypeDeclaration", $count)
};

(:~
 : Parse FunctionName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(112, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'else' | 'empty' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'module' | 'ne' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'return' |
                                                               'satisfies' | 'self' | 'some' | 'stable' | 'to' |
                                                               'treat' | 'union' | 'unordered' | 'validate' | 'where' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:l1] = 69) then                            (: 'ancestor' :)
      let $state := p:shift(69, $input, $state)             (: 'ancestor' :)
      return $state
    else if ($state[$p:l1] = 70) then                       (: 'ancestor-or-self' :)
      let $state := p:shift(70, $input, $state)             (: 'ancestor-or-self' :)
      return $state
    else if ($state[$p:l1] = 71) then                       (: 'and' :)
      let $state := p:shift(71, $input, $state)             (: 'and' :)
      return $state
    else if ($state[$p:l1] = 73) then                       (: 'ascending' :)
      let $state := p:shift(73, $input, $state)             (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 79) then                       (: 'case' :)
      let $state := p:shift(79, $input, $state)             (: 'case' :)
      return $state
    else if ($state[$p:l1] = 80) then                       (: 'cast' :)
      let $state := p:shift(80, $input, $state)             (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 81) then                       (: 'castable' :)
      let $state := p:shift(81, $input, $state)             (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 82) then                       (: 'child' :)
      let $state := p:shift(82, $input, $state)             (: 'child' :)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'collation' :)
      let $state := p:shift(83, $input, $state)             (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 88) then                       (: 'declare' :)
      let $state := p:shift(88, $input, $state)             (: 'declare' :)
      return $state
    else if ($state[$p:l1] = 89) then                       (: 'default' :)
      let $state := p:shift(89, $input, $state)             (: 'default' :)
      return $state
    else if ($state[$p:l1] = 90) then                       (: 'descendant' :)
      let $state := p:shift(90, $input, $state)             (: 'descendant' :)
      return $state
    else if ($state[$p:l1] = 91) then                       (: 'descendant-or-self' :)
      let $state := p:shift(91, $input, $state)             (: 'descendant-or-self' :)
      return $state
    else if ($state[$p:l1] = 92) then                       (: 'descending' :)
      let $state := p:shift(92, $input, $state)             (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'div' :)
      let $state := p:shift(93, $input, $state)             (: 'div' :)
      return $state
    else if ($state[$p:l1] = 94) then                       (: 'document' :)
      let $state := p:shift(94, $input, $state)             (: 'document' :)
      return $state
    else if ($state[$p:l1] = 97) then                       (: 'else' :)
      let $state := p:shift(97, $input, $state)             (: 'else' :)
      return $state
    else if ($state[$p:l1] = 98) then                       (: 'empty' :)
      let $state := p:shift(98, $input, $state)             (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 101) then                      (: 'eq' :)
      let $state := p:shift(101, $input, $state)            (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 102) then                      (: 'every' :)
      let $state := p:shift(102, $input, $state)            (: 'every' :)
      return $state
    else if ($state[$p:l1] = 103) then                      (: 'except' :)
      let $state := p:shift(103, $input, $state)            (: 'except' :)
      return $state
    else if ($state[$p:l1] = 105) then                      (: 'following' :)
      let $state := p:shift(105, $input, $state)            (: 'following' :)
      return $state
    else if ($state[$p:l1] = 106) then                      (: 'following-sibling' :)
      let $state := p:shift(106, $input, $state)            (: 'following-sibling' :)
      return $state
    else if ($state[$p:l1] = 107) then                      (: 'for' :)
      let $state := p:shift(107, $input, $state)            (: 'for' :)
      return $state
    else if ($state[$p:l1] = 109) then                      (: 'ge' :)
      let $state := p:shift(109, $input, $state)            (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 111) then                      (: 'gt' :)
      let $state := p:shift(111, $input, $state)            (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 113) then                      (: 'idiv' :)
      let $state := p:shift(113, $input, $state)            (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 115) then                      (: 'import' :)
      let $state := p:shift(115, $input, $state)            (: 'import' :)
      return $state
    else if ($state[$p:l1] = 118) then                      (: 'instance' :)
      let $state := p:shift(118, $input, $state)            (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 119) then                      (: 'intersect' :)
      let $state := p:shift(119, $input, $state)            (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 120) then                      (: 'is' :)
      let $state := p:shift(120, $input, $state)            (: 'is' :)
      return $state
    else if ($state[$p:l1] = 124) then                      (: 'le' :)
      let $state := p:shift(124, $input, $state)            (: 'le' :)
      return $state
    else if ($state[$p:l1] = 126) then                      (: 'let' :)
      let $state := p:shift(126, $input, $state)            (: 'let' :)
      return $state
    else if ($state[$p:l1] = 127) then                      (: 'lt' :)
      let $state := p:shift(127, $input, $state)            (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 128) then                      (: 'mod' :)
      let $state := p:shift(128, $input, $state)            (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 129) then                      (: 'module' :)
      let $state := p:shift(129, $input, $state)            (: 'module' :)
      return $state
    else if ($state[$p:l1] = 131) then                      (: 'ne' :)
      let $state := p:shift(131, $input, $state)            (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 137) then                      (: 'or' :)
      let $state := p:shift(137, $input, $state)            (: 'or' :)
      return $state
    else if ($state[$p:l1] = 138) then                      (: 'order' :)
      let $state := p:shift(138, $input, $state)            (: 'order' :)
      return $state
    else if ($state[$p:l1] = 139) then                      (: 'ordered' :)
      let $state := p:shift(139, $input, $state)            (: 'ordered' :)
      return $state
    else if ($state[$p:l1] = 141) then                      (: 'parent' :)
      let $state := p:shift(141, $input, $state)            (: 'parent' :)
      return $state
    else if ($state[$p:l1] = 142) then                      (: 'preceding' :)
      let $state := p:shift(142, $input, $state)            (: 'preceding' :)
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'preceding-sibling' :)
      let $state := p:shift(143, $input, $state)            (: 'preceding-sibling' :)
      return $state
    else if ($state[$p:l1] = 146) then                      (: 'return' :)
      let $state := p:shift(146, $input, $state)            (: 'return' :)
      return $state
    else if ($state[$p:l1] = 147) then                      (: 'satisfies' :)
      let $state := p:shift(147, $input, $state)            (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 151) then                      (: 'self' :)
      let $state := p:shift(151, $input, $state)            (: 'self' :)
      return $state
    else if ($state[$p:l1] = 152) then                      (: 'some' :)
      let $state := p:shift(152, $input, $state)            (: 'some' :)
      return $state
    else if ($state[$p:l1] = 153) then                      (: 'stable' :)
      let $state := p:shift(153, $input, $state)            (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 158) then                      (: 'to' :)
      let $state := p:shift(158, $input, $state)            (: 'to' :)
      return $state
    else if ($state[$p:l1] = 159) then                      (: 'treat' :)
      let $state := p:shift(159, $input, $state)            (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 162) then                      (: 'union' :)
      let $state := p:shift(162, $input, $state)            (: 'union' :)
      return $state
    else if ($state[$p:l1] = 163) then                      (: 'unordered' :)
      let $state := p:shift(163, $input, $state)            (: 'unordered' :)
      return $state
    else if ($state[$p:l1] = 164) then                      (: 'validate' :)
      let $state := p:shift(164, $input, $state)            (: 'validate' :)
      return $state
    else if ($state[$p:l1] = 167) then                      (: 'where' :)
      let $state := p:shift(167, $input, $state)            (: 'where' :)
      return $state
    else if ($state[$p:l1] = 168) then                      (: 'xquery' :)
      let $state := p:shift(168, $input, $state)            (: 'xquery' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(18, $input, $state)             (: QName^Token :)
      return $state
  return p:reduce($state, "FunctionName", $count)
};

(:~
 : Parse QName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(122, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 75) then                            (: 'attribute' :)
      let $state := p:shift(75, $input, $state)             (: 'attribute' :)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'comment' :)
      let $state := p:shift(84, $input, $state)             (: 'comment' :)
      return $state
    else if ($state[$p:l1] = 95) then                       (: 'document-node' :)
      let $state := p:shift(95, $input, $state)             (: 'document-node' :)
      return $state
    else if ($state[$p:l1] = 96) then                       (: 'element' :)
      let $state := p:shift(96, $input, $state)             (: 'element' :)
      return $state
    else if ($state[$p:l1] = 99) then                       (: 'empty-sequence' :)
      let $state := p:shift(99, $input, $state)             (: 'empty-sequence' :)
      return $state
    else if ($state[$p:l1] = 114) then                      (: 'if' :)
      let $state := p:shift(114, $input, $state)            (: 'if' :)
      return $state
    else if ($state[$p:l1] = 121) then                      (: 'item' :)
      let $state := p:shift(121, $input, $state)            (: 'item' :)
      return $state
    else if ($state[$p:l1] = 134) then                      (: 'node' :)
      let $state := p:shift(134, $input, $state)            (: 'node' :)
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'processing-instruction' :)
      let $state := p:shift(145, $input, $state)            (: 'processing-instruction' :)
      return $state
    else if ($state[$p:l1] = 149) then                      (: 'schema-attribute' :)
      let $state := p:shift(149, $input, $state)            (: 'schema-attribute' :)
      return $state
    else if ($state[$p:l1] = 150) then                      (: 'schema-element' :)
      let $state := p:shift(150, $input, $state)            (: 'schema-element' :)
      return $state
    else if ($state[$p:l1] = 156) then                      (: 'text' :)
      let $state := p:shift(156, $input, $state)            (: 'text' :)
      return $state
    else if ($state[$p:l1] = 161) then                      (: 'typeswitch' :)
      let $state := p:shift(161, $input, $state)            (: 'typeswitch' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-FunctionName($input, $state)
      return $state
  return p:reduce($state, "QName", $count)
};

(:~
 : Parse VarDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(125, $input, $state)          (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-QName($input, $state)
  let $state := p:lookahead1W(60, $input, $state)           (: S^WS | '(.' | ':=' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 72) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(31, $input, $state)           (: S^WS | '(.' | ':=' :)
  let $state := p:shift(51, $input, $state)                 (: ':=' :)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-Expr($input, $state)
  return p:reduce($state, "VarDecl", $count)
};

(:~
 : Parse the 1st loop of production CarrotModule (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CarrotModule-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(121, $input, $state)        (: S^WS | QName^Token | EOF | '$' | '(.' | '^' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'else' | 'empty' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'module' | 'ne' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'return' |
                                                               'satisfies' | 'self' | 'some' | 'stable' | 'to' |
                                                               'treat' | 'union' | 'unordered' | 'validate' | 'where' |
                                                               'xquery' :)
    return
      if ($state[$p:l1] = 25) then                          (: EOF :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 31) then                      (: '$' :)
            let $state := p:parse-VarDecl($input, $state)
            return $state
          else if ($state[$p:l1] = 68) then                 (: '^' :)
            let $state := p:parse-RuleDecl($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-FunctionDecl($input, $state)
            return $state
        let $state := p:lookahead1W(32, $input, $state)     (: S^WS | '(.' | ';' :)
        let $state := p:parse-Separator($input, $state)
        return p:parse-CarrotModule-1($input, $state)
};

(:~
 : Parse CarrotModule.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CarrotModule($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-CarrotModule-1($input, $state)
  return p:reduce($state, "CarrotModule", $count)
};

(:~
 : Parse Carrot.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Carrot($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(20, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-CarrotModule($input, $state)
  let $state := p:lookahead1W(25, $input, $state)           (: S^WS | EOF | '(.' :)
  let $state := p:shift(25, $input, $state)                 (: EOF :)
  return p:reduce($state, "Carrot", $count)
};

(:~
 : Parse start symbol Carrot from given string.
 :
 : @param $s the string to be parsed.
 : @return the result as generated by parser actions.
 :)
declare function p:parse-Carrot($s as xs:string) as item()*
{
  let $state := p:parse-Carrot($s, (0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, false()))
  let $error := $state[$p:error]
  return
    if ($error) then
      element ERROR {$error/@*, p:error-message($s, $error)}
    else
      $state[position() >= $p:result]
};

(:~
 : Parse start symbol KeyValuePairs from given string.
 :
 : @param $s the string to be parsed.
 : @return the result as generated by parser actions.
 :)
declare function p:parse-KeyValuePairs($s as xs:string) as item()*
{
  let $state := p:parse-KeyValuePairs($s, (0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, false()))
  let $error := $state[$p:error]
  return
    if ($error) then
      element ERROR {$error/@*, p:error-message($s, $error)}
    else
      $state[position() >= $p:result]
};

(:~
 : The input filename, or string, if surrounded by curly braces.
 :)
declare variable $input external;

let $result :=
  (: EDL: Manual change so regex is processed in "dot-all" mode :)
  if (matches($input, "^\{.*\}$", "s")) then
  (:
  if (matches($input, "^\{.*\}$")) then
  :)
    p:parse-Carrot(substring($input, 2, string-length($input) - 2))
  else
    p:parse-Carrot(collection(concat(".?select=", $input, ";unparsed=yes")))
return
  if (empty($result/self::ERROR)) then
    $result
  else
    error(xs:QName("p:parse-Carrot"), concat("&#10;    ", replace($result, "&#10;", "&#10;    ")))

(: End :)
